<!DOCTYPE html>
<html lang="it">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vox Populi - Giornale Scolastico</title>

    <!-- Libraries -->
    <script>
      /**
       * @license
       * Copyright 2010-2021 Three.js Authors
       * SPDX-License-Identifier: MIT
       */
      !(function (t, e) {
        "object" == typeof exports && "undefined" != typeof module
          ? e(exports)
          : "function" == typeof define && define.amd
          ? define(["exports"], e)
          : e(
              ((t =
                "undefined" != typeof globalThis
                  ? globalThis
                  : t || self).THREE = {})
            );
      })(this, function (t) {
        "use strict";
        const e = "128",
          n = 100,
          i = 300,
          r = 301,
          s = 302,
          a = 303,
          o = 304,
          l = 306,
          c = 307,
          h = 1e3,
          u = 1001,
          d = 1002,
          p = 1003,
          m = 1004,
          f = 1005,
          g = 1006,
          v = 1007,
          y = 1008,
          x = 1009,
          _ = 1012,
          w = 1014,
          b = 1015,
          M = 1016,
          S = 1020,
          T = 1022,
          E = 1023,
          A = 1026,
          L = 1027,
          R = 33776,
          C = 33777,
          P = 33778,
          D = 33779,
          I = 35840,
          N = 35841,
          B = 35842,
          z = 35843,
          F = 37492,
          O = 37496,
          H = 2300,
          G = 2301,
          U = 2302,
          k = 2400,
          V = 2401,
          W = 2402,
          j = 2500,
          q = 2501,
          X = 3e3,
          Y = 3001,
          Z = 3007,
          J = 3002,
          Q = 3004,
          K = 3005,
          $ = 3006,
          tt = 7680,
          et = 35044,
          nt = 35048,
          it = "300 es";
        class rt {
          addEventListener(t, e) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[t] && (n[t] = []),
              -1 === n[t].indexOf(e) && n[t].push(e);
          }
          hasEventListener(t, e) {
            if (void 0 === this._listeners) return !1;
            const n = this._listeners;
            return void 0 !== n[t] && -1 !== n[t].indexOf(e);
          }
          removeEventListener(t, e) {
            if (void 0 === this._listeners) return;
            const n = this._listeners[t];
            if (void 0 !== n) {
              const t = n.indexOf(e);
              -1 !== t && n.splice(t, 1);
            }
          }
          dispatchEvent(t) {
            if (void 0 === this._listeners) return;
            const e = this._listeners[t.type];
            if (void 0 !== e) {
              t.target = this;
              const n = e.slice(0);
              for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
              t.target = null;
            }
          }
        }
        const st = [];
        for (let t = 0; t < 256; t++)
          st[t] = (t < 16 ? "0" : "") + t.toString(16);
        let at = 1234567;
        const ot = Math.PI / 180,
          lt = 180 / Math.PI;
        function ct() {
          const t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0;
          return (
            st[255 & t] +
            st[(t >> 8) & 255] +
            st[(t >> 16) & 255] +
            st[(t >> 24) & 255] +
            "-" +
            st[255 & e] +
            st[(e >> 8) & 255] +
            "-" +
            st[((e >> 16) & 15) | 64] +
            st[(e >> 24) & 255] +
            "-" +
            st[(63 & n) | 128] +
            st[(n >> 8) & 255] +
            "-" +
            st[(n >> 16) & 255] +
            st[(n >> 24) & 255] +
            st[255 & i] +
            st[(i >> 8) & 255] +
            st[(i >> 16) & 255] +
            st[(i >> 24) & 255]
          ).toUpperCase();
        }
        function ht(t, e, n) {
          return Math.max(e, Math.min(n, t));
        }
        function ut(t, e) {
          return ((t % e) + e) % e;
        }
        function dt(t, e, n) {
          return (1 - n) * t + n * e;
        }
        function pt(t) {
          return 0 == (t & (t - 1)) && 0 !== t;
        }
        function mt(t) {
          return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
        }
        function ft(t) {
          return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
        }
        var gt = Object.freeze({
          __proto__: null,
          DEG2RAD: ot,
          RAD2DEG: lt,
          generateUUID: ct,
          clamp: ht,
          euclideanModulo: ut,
          mapLinear: function (t, e, n, i, r) {
            return i + ((t - e) * (r - i)) / (n - e);
          },
          inverseLerp: function (t, e, n) {
            return t !== e ? (n - t) / (e - t) : 0;
          },
          lerp: dt,
          damp: function (t, e, n, i) {
            return dt(t, e, 1 - Math.exp(-n * i));
          },
          pingpong: function (t, e = 1) {
            return e - Math.abs(ut(t, 2 * e) - e);
          },
          smoothstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * (3 - 2 * t);
          },
          smootherstep: function (t, e, n) {
            return t <= e
              ? 0
              : t >= n
              ? 1
              : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10);
          },
          randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1));
          },
          randFloat: function (t, e) {
            return t + Math.random() * (e - t);
          },
          randFloatSpread: function (t) {
            return t * (0.5 - Math.random());
          },
          seededRandom: function (t) {
            return (
              void 0 !== t && (at = t % 2147483647),
              (at = (16807 * at) % 2147483647),
              (at - 1) / 2147483646
            );
          },
          degToRad: function (t) {
            return t * ot;
          },
          radToDeg: function (t) {
            return t * lt;
          },
          isPowerOfTwo: pt,
          ceilPowerOfTwo: mt,
          floorPowerOfTwo: ft,
          setQuaternionFromProperEuler: function (t, e, n, i, r) {
            const s = Math.cos,
              a = Math.sin,
              o = s(n / 2),
              l = a(n / 2),
              c = s((e + i) / 2),
              h = a((e + i) / 2),
              u = s((e - i) / 2),
              d = a((e - i) / 2),
              p = s((i - e) / 2),
              m = a((i - e) / 2);
            switch (r) {
              case "XYX":
                t.set(o * h, l * u, l * d, o * c);
                break;
              case "YZY":
                t.set(l * d, o * h, l * u, o * c);
                break;
              case "ZXZ":
                t.set(l * u, l * d, o * h, o * c);
                break;
              case "XZX":
                t.set(o * h, l * m, l * p, o * c);
                break;
              case "YXY":
                t.set(l * p, o * h, l * m, o * c);
                break;
              case "ZYZ":
                t.set(l * m, l * p, o * h, o * c);
                break;
              default:
                console.warn(
                  "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                    r
                );
            }
          },
        });
        class vt {
          constructor(t = 0, e = 0) {
            (this.x = t), (this.y = e);
          }
          get width() {
            return this.x;
          }
          set width(t) {
            this.x = t;
          }
          get height() {
            return this.y;
          }
          set height(t) {
            this.y = t;
          }
          set(t, e) {
            return (this.x = t), (this.y = e), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), this;
          }
          addVectors(t, e) {
            return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
          }
          addScaledVector(t, e) {
            return (this.x += t.x * e), (this.y += t.y * e), this;
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), this;
          }
          subVectors(t, e) {
            return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
          }
          multiply(t) {
            return (this.x *= t.x), (this.y *= t.y), this;
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), this;
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = t.elements;
            return (
              (this.x = i[0] * e + i[3] * n + i[6]),
              (this.y = i[1] * e + i[4] * n + i[7]),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              this
            );
          }
          negate() {
            return (this.x = -this.x), (this.y = -this.y), this;
          }
          dot(t) {
            return this.x * t.x + this.y * t.y;
          }
          cross(t) {
            return this.x * t.y - this.y * t.x;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y;
          }
          length() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI;
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y;
            return e * e + n * n;
          }
          manhattanDistanceTo(t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              this
            );
          }
          equals(t) {
            return t.x === this.x && t.y === this.y;
          }
          fromArray(t, e = 0) {
            return (this.x = t[e]), (this.y = t[e + 1]), this;
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector2: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              this
            );
          }
          rotateAround(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = this.x - t.x,
              s = this.y - t.y;
            return (
              (this.x = r * n - s * i + t.x),
              (this.y = r * i + s * n + t.y),
              this
            );
          }
          random() {
            return (this.x = Math.random()), (this.y = Math.random()), this;
          }
        }
        vt.prototype.isVector2 = !0;
        class yt {
          constructor() {
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error(
                  "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead."
                );
          }
          set(t, e, n, i, r, s, a, o, l) {
            const c = this.elements;
            return (
              (c[0] = t),
              (c[1] = i),
              (c[2] = a),
              (c[3] = e),
              (c[4] = r),
              (c[5] = o),
              (c[6] = n),
              (c[7] = s),
              (c[8] = l),
              this
            );
          }
          identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrix3Column(this, 0),
              e.setFromMatrix3Column(this, 1),
              n.setFromMatrix3Column(this, 2),
              this
            );
          }
          setFromMatrix4(t) {
            const e = t.elements;
            return (
              this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
              this
            );
          }
          multiply(t) {
            return this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              a = n[3],
              o = n[6],
              l = n[1],
              c = n[4],
              h = n[7],
              u = n[2],
              d = n[5],
              p = n[8],
              m = i[0],
              f = i[3],
              g = i[6],
              v = i[1],
              y = i[4],
              x = i[7],
              _ = i[2],
              w = i[5],
              b = i[8];
            return (
              (r[0] = s * m + a * v + o * _),
              (r[3] = s * f + a * y + o * w),
              (r[6] = s * g + a * x + o * b),
              (r[1] = l * m + c * v + h * _),
              (r[4] = l * f + c * y + h * w),
              (r[7] = l * g + c * x + h * b),
              (r[2] = u * m + d * v + p * _),
              (r[5] = u * f + d * y + p * w),
              (r[8] = u * g + d * x + p * b),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[3] *= t),
              (e[6] *= t),
              (e[1] *= t),
              (e[4] *= t),
              (e[7] *= t),
              (e[2] *= t),
              (e[5] *= t),
              (e[8] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8];
            return (
              e * s * c -
              e * a * l -
              n * r * c +
              n * a * o +
              i * r * l -
              i * s * o
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8],
              h = c * s - a * l,
              u = a * o - c * r,
              d = l * r - s * o,
              p = e * h + n * u + i * d;
            if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const m = 1 / p;
            return (
              (t[0] = h * m),
              (t[1] = (i * l - c * n) * m),
              (t[2] = (a * n - i * s) * m),
              (t[3] = u * m),
              (t[4] = (c * e - i * o) * m),
              (t[5] = (i * r - a * e) * m),
              (t[6] = d * m),
              (t[7] = (n * o - l * e) * m),
              (t[8] = (s * e - n * r) * m),
              this
            );
          }
          transpose() {
            let t;
            const e = this.elements;
            return (
              (t = e[1]),
              (e[1] = e[3]),
              (e[3] = t),
              (t = e[2]),
              (e[2] = e[6]),
              (e[6] = t),
              (t = e[5]),
              (e[5] = e[7]),
              (e[7] = t),
              this
            );
          }
          getNormalMatrix(t) {
            return this.setFromMatrix4(t).invert().transpose();
          }
          transposeIntoArray(t) {
            const e = this.elements;
            return (
              (t[0] = e[0]),
              (t[1] = e[3]),
              (t[2] = e[6]),
              (t[3] = e[1]),
              (t[4] = e[4]),
              (t[5] = e[7]),
              (t[6] = e[2]),
              (t[7] = e[5]),
              (t[8] = e[8]),
              this
            );
          }
          setUvTransform(t, e, n, i, r, s, a) {
            const o = Math.cos(r),
              l = Math.sin(r);
            return (
              this.set(
                n * o,
                n * l,
                -n * (o * s + l * a) + s + t,
                -i * l,
                i * o,
                -i * (-l * s + o * a) + a + e,
                0,
                0,
                1
              ),
              this
            );
          }
          scale(t, e) {
            const n = this.elements;
            return (
              (n[0] *= t),
              (n[3] *= t),
              (n[6] *= t),
              (n[1] *= e),
              (n[4] *= e),
              (n[7] *= e),
              this
            );
          }
          rotate(t) {
            const e = Math.cos(t),
              n = Math.sin(t),
              i = this.elements,
              r = i[0],
              s = i[3],
              a = i[6],
              o = i[1],
              l = i[4],
              c = i[7];
            return (
              (i[0] = e * r + n * o),
              (i[3] = e * s + n * l),
              (i[6] = e * a + n * c),
              (i[1] = -n * r + e * o),
              (i[4] = -n * s + e * l),
              (i[7] = -n * a + e * c),
              this
            );
          }
          translate(t, e) {
            const n = this.elements;
            return (
              (n[0] += t * n[2]),
              (n[3] += t * n[5]),
              (n[6] += t * n[8]),
              (n[1] += e * n[2]),
              (n[4] += e * n[5]),
              (n[7] += e * n[8]),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              t
            );
          }
          clone() {
            return new this.constructor().fromArray(this.elements);
          }
        }
        let xt;
        yt.prototype.isMatrix3 = !0;
        class _t {
          static getDataURL(t) {
            if (/^data:/i.test(t.src)) return t.src;
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            let e;
            if (t instanceof HTMLCanvasElement) e = t;
            else {
              void 0 === xt &&
                (xt = document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                )),
                (xt.width = t.width),
                (xt.height = t.height);
              const n = xt.getContext("2d");
              t instanceof ImageData
                ? n.putImageData(t, 0, 0)
                : n.drawImage(t, 0, 0, t.width, t.height),
                (e = xt);
            }
            return e.width > 2048 || e.height > 2048
              ? (console.warn(
                  "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                  t
                ),
                e.toDataURL("image/jpeg", 0.6))
              : e.toDataURL("image/png");
          }
        }
        let wt = 0;
        class bt extends rt {
          constructor(
            t = bt.DEFAULT_IMAGE,
            e = bt.DEFAULT_MAPPING,
            n = 1001,
            i = 1001,
            r = 1006,
            s = 1008,
            a = 1023,
            o = 1009,
            l = 1,
            c = 3e3
          ) {
            super(),
              Object.defineProperty(this, "id", { value: wt++ }),
              (this.uuid = ct()),
              (this.name = ""),
              (this.image = t),
              (this.mipmaps = []),
              (this.mapping = e),
              (this.wrapS = n),
              (this.wrapT = i),
              (this.magFilter = r),
              (this.minFilter = s),
              (this.anisotropy = l),
              (this.format = a),
              (this.internalFormat = null),
              (this.type = o),
              (this.offset = new vt(0, 0)),
              (this.repeat = new vt(1, 1)),
              (this.center = new vt(0, 0)),
              (this.rotation = 0),
              (this.matrixAutoUpdate = !0),
              (this.matrix = new yt()),
              (this.generateMipmaps = !0),
              (this.premultiplyAlpha = !1),
              (this.flipY = !0),
              (this.unpackAlignment = 4),
              (this.encoding = c),
              (this.version = 0),
              (this.onUpdate = null);
          }
          updateMatrix() {
            this.matrix.setUvTransform(
              this.offset.x,
              this.offset.y,
              this.repeat.x,
              this.repeat.y,
              this.rotation,
              this.center.x,
              this.center.y
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.image = t.image),
              (this.mipmaps = t.mipmaps.slice(0)),
              (this.mapping = t.mapping),
              (this.wrapS = t.wrapS),
              (this.wrapT = t.wrapT),
              (this.magFilter = t.magFilter),
              (this.minFilter = t.minFilter),
              (this.anisotropy = t.anisotropy),
              (this.format = t.format),
              (this.internalFormat = t.internalFormat),
              (this.type = t.type),
              this.offset.copy(t.offset),
              this.repeat.copy(t.repeat),
              this.center.copy(t.center),
              (this.rotation = t.rotation),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this.matrix.copy(t.matrix),
              (this.generateMipmaps = t.generateMipmaps),
              (this.premultiplyAlpha = t.premultiplyAlpha),
              (this.flipY = t.flipY),
              (this.unpackAlignment = t.unpackAlignment),
              (this.encoding = t.encoding),
              this
            );
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid])
              return t.textures[this.uuid];
            const n = {
              metadata: {
                version: 4.5,
                type: "Texture",
                generator: "Texture.toJSON",
              },
              uuid: this.uuid,
              name: this.name,
              mapping: this.mapping,
              repeat: [this.repeat.x, this.repeat.y],
              offset: [this.offset.x, this.offset.y],
              center: [this.center.x, this.center.y],
              rotation: this.rotation,
              wrap: [this.wrapS, this.wrapT],
              format: this.format,
              type: this.type,
              encoding: this.encoding,
              minFilter: this.minFilter,
              magFilter: this.magFilter,
              anisotropy: this.anisotropy,
              flipY: this.flipY,
              premultiplyAlpha: this.premultiplyAlpha,
              unpackAlignment: this.unpackAlignment,
            };
            if (void 0 !== this.image) {
              const i = this.image;
              if (
                (void 0 === i.uuid && (i.uuid = ct()),
                !e && void 0 === t.images[i.uuid])
              ) {
                let e;
                if (Array.isArray(i)) {
                  e = [];
                  for (let t = 0, n = i.length; t < n; t++)
                    i[t].isDataTexture
                      ? e.push(Mt(i[t].image))
                      : e.push(Mt(i[t]));
                } else e = Mt(i);
                t.images[i.uuid] = { uuid: i.uuid, url: e };
              }
              n.image = i.uuid;
            }
            return e || (t.textures[this.uuid] = n), n;
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
          transformUv(t) {
            if (this.mapping !== i) return t;
            if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
              switch (this.wrapS) {
                case h:
                  t.x = t.x - Math.floor(t.x);
                  break;
                case u:
                  t.x = t.x < 0 ? 0 : 1;
                  break;
                case d:
                  1 === Math.abs(Math.floor(t.x) % 2)
                    ? (t.x = Math.ceil(t.x) - t.x)
                    : (t.x = t.x - Math.floor(t.x));
              }
            if (t.y < 0 || t.y > 1)
              switch (this.wrapT) {
                case h:
                  t.y = t.y - Math.floor(t.y);
                  break;
                case u:
                  t.y = t.y < 0 ? 0 : 1;
                  break;
                case d:
                  1 === Math.abs(Math.floor(t.y) % 2)
                    ? (t.y = Math.ceil(t.y) - t.y)
                    : (t.y = t.y - Math.floor(t.y));
              }
            return this.flipY && (t.y = 1 - t.y), t;
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
        }
        function Mt(t) {
          return ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
            ? _t.getDataURL(t)
            : t.data
            ? {
                data: Array.prototype.slice.call(t.data),
                width: t.width,
                height: t.height,
                type: t.data.constructor.name,
              }
            : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
        }
        (bt.DEFAULT_IMAGE = void 0),
          (bt.DEFAULT_MAPPING = i),
          (bt.prototype.isTexture = !0);
        class St {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this.x = t), (this.y = e), (this.z = n), (this.w = i);
          }
          get width() {
            return this.z;
          }
          set width(t) {
            this.z = t;
          }
          get height() {
            return this.w;
          }
          set height(t) {
            this.w = t;
          }
          set(t, e, n, i) {
            return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setW(t) {
            return (this.w = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              case 3:
                this.w = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              case 3:
                return this.w;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z, this.w);
          }
          copy(t) {
            return (
              (this.x = t.x),
              (this.y = t.y),
              (this.z = t.z),
              (this.w = void 0 !== t.w ? t.w : 1),
              this
            );
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x),
                (this.y += t.y),
                (this.z += t.z),
                (this.w += t.w),
                this);
          }
          addScalar(t) {
            return (
              (this.x += t), (this.y += t), (this.z += t), (this.w += t), this
            );
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              (this.w = t.w + e.w),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              (this.w += t.w * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x),
                (this.y -= t.y),
                (this.z -= t.z),
                (this.w -= t.w),
                this);
          }
          subScalar(t) {
            return (
              (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this
            );
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              (this.w = t.w - e.w),
              this
            );
          }
          multiply(t) {
            return (
              (this.x *= t.x),
              (this.y *= t.y),
              (this.z *= t.z),
              (this.w *= t.w),
              this
            );
          }
          multiplyScalar(t) {
            return (
              (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this
            );
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = this.w,
              s = t.elements;
            return (
              (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
              (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
              (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
              (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
              this
            );
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          setAxisAngleFromQuaternion(t) {
            this.w = 2 * Math.acos(t.w);
            const e = Math.sqrt(1 - t.w * t.w);
            return (
              e < 1e-4
                ? ((this.x = 1), (this.y = 0), (this.z = 0))
                : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
              this
            );
          }
          setAxisAngleFromRotationMatrix(t) {
            let e, n, i, r;
            const s = 0.01,
              a = 0.1,
              o = t.elements,
              l = o[0],
              c = o[4],
              h = o[8],
              u = o[1],
              d = o[5],
              p = o[9],
              m = o[2],
              f = o[6],
              g = o[10];
            if (
              Math.abs(c - u) < s &&
              Math.abs(h - m) < s &&
              Math.abs(p - f) < s
            ) {
              if (
                Math.abs(c + u) < a &&
                Math.abs(h + m) < a &&
                Math.abs(p + f) < a &&
                Math.abs(l + d + g - 3) < a
              )
                return this.set(1, 0, 0, 0), this;
              e = Math.PI;
              const t = (l + 1) / 2,
                o = (d + 1) / 2,
                v = (g + 1) / 2,
                y = (c + u) / 4,
                x = (h + m) / 4,
                _ = (p + f) / 4;
              return (
                t > o && t > v
                  ? t < s
                    ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                    : ((n = Math.sqrt(t)), (i = y / n), (r = x / n))
                  : o > v
                  ? o < s
                    ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                    : ((i = Math.sqrt(o)), (n = y / i), (r = _ / i))
                  : v < s
                  ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                  : ((r = Math.sqrt(v)), (n = x / r), (i = _ / r)),
                this.set(n, i, r, e),
                this
              );
            }
            let v = Math.sqrt(
              (f - p) * (f - p) + (h - m) * (h - m) + (u - c) * (u - c)
            );
            return (
              Math.abs(v) < 0.001 && (v = 1),
              (this.x = (f - p) / v),
              (this.y = (h - m) / v),
              (this.z = (u - c) / v),
              (this.w = Math.acos((l + d + g - 1) / 2)),
              this
            );
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              (this.w = Math.min(this.w, t.w)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              (this.w = Math.max(this.w, t.w)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              (this.w = Math.max(t.w, Math.min(e.w, this.w))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              (this.w = Math.max(t, Math.min(e, this.w))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              (this.w = Math.floor(this.w)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              (this.w = Math.ceil(this.w)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              (this.w = Math.round(this.w)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x),
              (this.y = -this.y),
              (this.z = -this.z),
              (this.w = -this.w),
              this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
          }
          lengthSq() {
            return (
              this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
            );
          }
          length() {
            return Math.sqrt(
              this.x * this.x +
                this.y * this.y +
                this.z * this.z +
                this.w * this.w
            );
          }
          manhattanLength() {
            return (
              Math.abs(this.x) +
              Math.abs(this.y) +
              Math.abs(this.z) +
              Math.abs(this.w)
            );
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              (this.w += (t.w - this.w) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              (this.w = t.w + (e.w - t.w) * n),
              this
            );
          }
          equals(t) {
            return (
              t.x === this.x &&
              t.y === this.y &&
              t.z === this.z &&
              t.w === this.w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]),
              (this.y = t[e + 1]),
              (this.z = t[e + 2]),
              (this.w = t[e + 3]),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this.x),
              (t[e + 1] = this.y),
              (t[e + 2] = this.z),
              (t[e + 3] = this.w),
              t
            );
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector4: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              (this.w = t.getW(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              (this.w = Math.random()),
              this
            );
          }
        }
        St.prototype.isVector4 = !0;
        class Tt extends rt {
          constructor(t, e, n) {
            super(),
              (this.width = t),
              (this.height = e),
              (this.depth = 1),
              (this.scissor = new St(0, 0, t, e)),
              (this.scissorTest = !1),
              (this.viewport = new St(0, 0, t, e)),
              (n = n || {}),
              (this.texture = new bt(
                void 0,
                n.mapping,
                n.wrapS,
                n.wrapT,
                n.magFilter,
                n.minFilter,
                n.format,
                n.type,
                n.anisotropy,
                n.encoding
              )),
              (this.texture.image = {}),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = 1),
              (this.texture.generateMipmaps =
                void 0 !== n.generateMipmaps && n.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== n.minFilter ? n.minFilter : g),
              (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
              (this.stencilBuffer =
                void 0 !== n.stencilBuffer && n.stencilBuffer),
              (this.depthTexture =
                void 0 !== n.depthTexture ? n.depthTexture : null);
          }
          setTexture(t) {
            (t.image = {
              width: this.width,
              height: this.height,
              depth: this.depth,
            }),
              (this.texture = t);
          }
          setSize(t, e, n = 1) {
            (this.width === t && this.height === e && this.depth === n) ||
              ((this.width = t),
              (this.height = e),
              (this.depth = n),
              (this.texture.image.width = t),
              (this.texture.image.height = e),
              (this.texture.image.depth = n),
              this.dispose()),
              this.viewport.set(0, 0, t, e),
              this.scissor.set(0, 0, t, e);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (
              (this.width = t.width),
              (this.height = t.height),
              (this.depth = t.depth),
              this.viewport.copy(t.viewport),
              (this.texture = t.texture.clone()),
              (this.depthBuffer = t.depthBuffer),
              (this.stencilBuffer = t.stencilBuffer),
              (this.depthTexture = t.depthTexture),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        Tt.prototype.isWebGLRenderTarget = !0;
        class Et extends Tt {
          constructor(t, e, n) {
            super(t, e, n), (this.samples = 4);
          }
          copy(t) {
            return super.copy.call(this, t), (this.samples = t.samples), this;
          }
        }
        Et.prototype.isWebGLMultisampleRenderTarget = !0;
        class At {
          constructor(t = 0, e = 0, n = 0, i = 1) {
            (this._x = t), (this._y = e), (this._z = n), (this._w = i);
          }
          static slerp(t, e, n, i) {
            return (
              console.warn(
                "THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."
              ),
              n.slerpQuaternions(t, e, i)
            );
          }
          static slerpFlat(t, e, n, i, r, s, a) {
            let o = n[i + 0],
              l = n[i + 1],
              c = n[i + 2],
              h = n[i + 3];
            const u = r[s + 0],
              d = r[s + 1],
              p = r[s + 2],
              m = r[s + 3];
            if (0 === a)
              return (
                (t[e + 0] = o),
                (t[e + 1] = l),
                (t[e + 2] = c),
                void (t[e + 3] = h)
              );
            if (1 === a)
              return (
                (t[e + 0] = u),
                (t[e + 1] = d),
                (t[e + 2] = p),
                void (t[e + 3] = m)
              );
            if (h !== m || o !== u || l !== d || c !== p) {
              let t = 1 - a;
              const e = o * u + l * d + c * p + h * m,
                n = e >= 0 ? 1 : -1,
                i = 1 - e * e;
              if (i > Number.EPSILON) {
                const r = Math.sqrt(i),
                  s = Math.atan2(r, e * n);
                (t = Math.sin(t * s) / r), (a = Math.sin(a * s) / r);
              }
              const r = a * n;
              if (
                ((o = o * t + u * r),
                (l = l * t + d * r),
                (c = c * t + p * r),
                (h = h * t + m * r),
                t === 1 - a)
              ) {
                const t = 1 / Math.sqrt(o * o + l * l + c * c + h * h);
                (o *= t), (l *= t), (c *= t), (h *= t);
              }
            }
            (t[e] = o), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = h);
          }
          static multiplyQuaternionsFlat(t, e, n, i, r, s) {
            const a = n[i],
              o = n[i + 1],
              l = n[i + 2],
              c = n[i + 3],
              h = r[s],
              u = r[s + 1],
              d = r[s + 2],
              p = r[s + 3];
            return (
              (t[e] = a * p + c * h + o * d - l * u),
              (t[e + 1] = o * p + c * u + l * h - a * d),
              (t[e + 2] = l * p + c * d + a * u - o * h),
              (t[e + 3] = c * p - a * h - o * u - l * d),
              t
            );
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get w() {
            return this._w;
          }
          set w(t) {
            (this._w = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._w = i),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._w);
          }
          copy(t) {
            return (
              (this._x = t.x),
              (this._y = t.y),
              (this._z = t.z),
              (this._w = t.w),
              this._onChangeCallback(),
              this
            );
          }
          setFromEuler(t, e) {
            if (!t || !t.isEuler)
              throw new Error(
                "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."
              );
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._order,
              a = Math.cos,
              o = Math.sin,
              l = a(n / 2),
              c = a(i / 2),
              h = a(r / 2),
              u = o(n / 2),
              d = o(i / 2),
              p = o(r / 2);
            switch (s) {
              case "XYZ":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "YXZ":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              case "ZXY":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "ZYX":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              case "YZX":
                (this._x = u * c * h + l * d * p),
                  (this._y = l * d * h + u * c * p),
                  (this._z = l * c * p - u * d * h),
                  (this._w = l * c * h - u * d * p);
                break;
              case "XZY":
                (this._x = u * c * h - l * d * p),
                  (this._y = l * d * h - u * c * p),
                  (this._z = l * c * p + u * d * h),
                  (this._w = l * c * h + u * d * p);
                break;
              default:
                console.warn(
                  "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                    s
                );
            }
            return !1 !== e && this._onChangeCallback(), this;
          }
          setFromAxisAngle(t, e) {
            const n = e / 2,
              i = Math.sin(n);
            return (
              (this._x = t.x * i),
              (this._y = t.y * i),
              (this._z = t.z * i),
              (this._w = Math.cos(n)),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t) {
            const e = t.elements,
              n = e[0],
              i = e[4],
              r = e[8],
              s = e[1],
              a = e[5],
              o = e[9],
              l = e[2],
              c = e[6],
              h = e[10],
              u = n + a + h;
            if (u > 0) {
              const t = 0.5 / Math.sqrt(u + 1);
              (this._w = 0.25 / t),
                (this._x = (c - o) * t),
                (this._y = (r - l) * t),
                (this._z = (s - i) * t);
            } else if (n > a && n > h) {
              const t = 2 * Math.sqrt(1 + n - a - h);
              (this._w = (c - o) / t),
                (this._x = 0.25 * t),
                (this._y = (i + s) / t),
                (this._z = (r + l) / t);
            } else if (a > h) {
              const t = 2 * Math.sqrt(1 + a - n - h);
              (this._w = (r - l) / t),
                (this._x = (i + s) / t),
                (this._y = 0.25 * t),
                (this._z = (o + c) / t);
            } else {
              const t = 2 * Math.sqrt(1 + h - n - a);
              (this._w = (s - i) / t),
                (this._x = (r + l) / t),
                (this._y = (o + c) / t),
                (this._z = 0.25 * t);
            }
            return this._onChangeCallback(), this;
          }
          setFromUnitVectors(t, e) {
            let n = t.dot(e) + 1;
            return (
              n < Number.EPSILON
                ? ((n = 0),
                  Math.abs(t.x) > Math.abs(t.z)
                    ? ((this._x = -t.y),
                      (this._y = t.x),
                      (this._z = 0),
                      (this._w = n))
                    : ((this._x = 0),
                      (this._y = -t.z),
                      (this._z = t.y),
                      (this._w = n)))
                : ((this._x = t.y * e.z - t.z * e.y),
                  (this._y = t.z * e.x - t.x * e.z),
                  (this._z = t.x * e.y - t.y * e.x),
                  (this._w = n)),
              this.normalize()
            );
          }
          angleTo(t) {
            return 2 * Math.acos(Math.abs(ht(this.dot(t), -1, 1)));
          }
          rotateTowards(t, e) {
            const n = this.angleTo(t);
            if (0 === n) return this;
            const i = Math.min(1, e / n);
            return this.slerp(t, i), this;
          }
          identity() {
            return this.set(0, 0, 0, 1);
          }
          invert() {
            return this.conjugate();
          }
          conjugate() {
            return (
              (this._x *= -1),
              (this._y *= -1),
              (this._z *= -1),
              this._onChangeCallback(),
              this
            );
          }
          dot(t) {
            return (
              this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
            );
          }
          lengthSq() {
            return (
              this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
            );
          }
          length() {
            return Math.sqrt(
              this._x * this._x +
                this._y * this._y +
                this._z * this._z +
                this._w * this._w
            );
          }
          normalize() {
            let t = this.length();
            return (
              0 === t
                ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
                : ((t = 1 / t),
                  (this._x = this._x * t),
                  (this._y = this._y * t),
                  (this._z = this._z * t),
                  (this._w = this._w * t)),
              this._onChangeCallback(),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
                ),
                this.multiplyQuaternions(t, e))
              : this.multiplyQuaternions(this, t);
          }
          premultiply(t) {
            return this.multiplyQuaternions(t, this);
          }
          multiplyQuaternions(t, e) {
            const n = t._x,
              i = t._y,
              r = t._z,
              s = t._w,
              a = e._x,
              o = e._y,
              l = e._z,
              c = e._w;
            return (
              (this._x = n * c + s * a + i * l - r * o),
              (this._y = i * c + s * o + r * a - n * l),
              (this._z = r * c + s * l + n * o - i * a),
              (this._w = s * c - n * a - i * o - r * l),
              this._onChangeCallback(),
              this
            );
          }
          slerp(t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            const n = this._x,
              i = this._y,
              r = this._z,
              s = this._w;
            let a = s * t._w + n * t._x + i * t._y + r * t._z;
            if (
              (a < 0
                ? ((this._w = -t._w),
                  (this._x = -t._x),
                  (this._y = -t._y),
                  (this._z = -t._z),
                  (a = -a))
                : this.copy(t),
              a >= 1)
            )
              return (
                (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
              );
            const o = 1 - a * a;
            if (o <= Number.EPSILON) {
              const t = 1 - e;
              return (
                (this._w = t * s + e * this._w),
                (this._x = t * n + e * this._x),
                (this._y = t * i + e * this._y),
                (this._z = t * r + e * this._z),
                this.normalize(),
                this._onChangeCallback(),
                this
              );
            }
            const l = Math.sqrt(o),
              c = Math.atan2(l, a),
              h = Math.sin((1 - e) * c) / l,
              u = Math.sin(e * c) / l;
            return (
              (this._w = s * h + this._w * u),
              (this._x = n * h + this._x * u),
              (this._y = i * h + this._y * u),
              (this._z = r * h + this._z * u),
              this._onChangeCallback(),
              this
            );
          }
          slerpQuaternions(t, e, n) {
            this.copy(t).slerp(e, n);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._w === this._w
            );
          }
          fromArray(t, e = 0) {
            return (
              (this._x = t[e]),
              (this._y = t[e + 1]),
              (this._z = t[e + 2]),
              (this._w = t[e + 3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._w),
              t
            );
          }
          fromBufferAttribute(t, e) {
            return (
              (this._x = t.getX(e)),
              (this._y = t.getY(e)),
              (this._z = t.getZ(e)),
              (this._w = t.getW(e)),
              this
            );
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
        }
        At.prototype.isQuaternion = !0;
        class Lt {
          constructor(t = 0, e = 0, n = 0) {
            (this.x = t), (this.y = e), (this.z = n);
          }
          set(t, e, n) {
            return (
              void 0 === n && (n = this.z),
              (this.x = t),
              (this.y = e),
              (this.z = n),
              this
            );
          }
          setScalar(t) {
            return (this.x = t), (this.y = t), (this.z = t), this;
          }
          setX(t) {
            return (this.x = t), this;
          }
          setY(t) {
            return (this.y = t), this;
          }
          setZ(t) {
            return (this.z = t), this;
          }
          setComponent(t, e) {
            switch (t) {
              case 0:
                this.x = e;
                break;
              case 1:
                this.y = e;
                break;
              case 2:
                this.z = e;
                break;
              default:
                throw new Error("index is out of range: " + t);
            }
            return this;
          }
          getComponent(t) {
            switch (t) {
              case 0:
                return this.x;
              case 1:
                return this.y;
              case 2:
                return this.z;
              default:
                throw new Error("index is out of range: " + t);
            }
          }
          clone() {
            return new this.constructor(this.x, this.y, this.z);
          }
          copy(t) {
            return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
          }
          add(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."
                ),
                this.addVectors(t, e))
              : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
          }
          addScalar(t) {
            return (this.x += t), (this.y += t), (this.z += t), this;
          }
          addVectors(t, e) {
            return (
              (this.x = t.x + e.x),
              (this.y = t.y + e.y),
              (this.z = t.z + e.z),
              this
            );
          }
          addScaledVector(t, e) {
            return (
              (this.x += t.x * e),
              (this.y += t.y * e),
              (this.z += t.z * e),
              this
            );
          }
          sub(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."
                ),
                this.subVectors(t, e))
              : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
          }
          subScalar(t) {
            return (this.x -= t), (this.y -= t), (this.z -= t), this;
          }
          subVectors(t, e) {
            return (
              (this.x = t.x - e.x),
              (this.y = t.y - e.y),
              (this.z = t.z - e.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."
                ),
                this.multiplyVectors(t, e))
              : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
          }
          multiplyScalar(t) {
            return (this.x *= t), (this.y *= t), (this.z *= t), this;
          }
          multiplyVectors(t, e) {
            return (
              (this.x = t.x * e.x),
              (this.y = t.y * e.y),
              (this.z = t.z * e.z),
              this
            );
          }
          applyEuler(t) {
            return (
              (t && t.isEuler) ||
                console.error(
                  "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."
                ),
              this.applyQuaternion(Ct.setFromEuler(t))
            );
          }
          applyAxisAngle(t, e) {
            return this.applyQuaternion(Ct.setFromAxisAngle(t, e));
          }
          applyMatrix3(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[3] * n + r[6] * i),
              (this.y = r[1] * e + r[4] * n + r[7] * i),
              (this.z = r[2] * e + r[5] * n + r[8] * i),
              this
            );
          }
          applyNormalMatrix(t) {
            return this.applyMatrix3(t).normalize();
          }
          applyMatrix4(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements,
              s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
            return (
              (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
              (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
              (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
              this
            );
          }
          applyQuaternion(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.x,
              s = t.y,
              a = t.z,
              o = t.w,
              l = o * e + s * i - a * n,
              c = o * n + a * e - r * i,
              h = o * i + r * n - s * e,
              u = -r * e - s * n - a * i;
            return (
              (this.x = l * o + u * -r + c * -a - h * -s),
              (this.y = c * o + u * -s + h * -r - l * -a),
              (this.z = h * o + u * -a + l * -s - c * -r),
              this
            );
          }
          project(t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
              t.projectionMatrix
            );
          }
          unproject(t) {
            return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
              t.matrixWorld
            );
          }
          transformDirection(t) {
            const e = this.x,
              n = this.y,
              i = this.z,
              r = t.elements;
            return (
              (this.x = r[0] * e + r[4] * n + r[8] * i),
              (this.y = r[1] * e + r[5] * n + r[9] * i),
              (this.z = r[2] * e + r[6] * n + r[10] * i),
              this.normalize()
            );
          }
          divide(t) {
            return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
          }
          divideScalar(t) {
            return this.multiplyScalar(1 / t);
          }
          min(t) {
            return (
              (this.x = Math.min(this.x, t.x)),
              (this.y = Math.min(this.y, t.y)),
              (this.z = Math.min(this.z, t.z)),
              this
            );
          }
          max(t) {
            return (
              (this.x = Math.max(this.x, t.x)),
              (this.y = Math.max(this.y, t.y)),
              (this.z = Math.max(this.z, t.z)),
              this
            );
          }
          clamp(t, e) {
            return (
              (this.x = Math.max(t.x, Math.min(e.x, this.x))),
              (this.y = Math.max(t.y, Math.min(e.y, this.y))),
              (this.z = Math.max(t.z, Math.min(e.z, this.z))),
              this
            );
          }
          clampScalar(t, e) {
            return (
              (this.x = Math.max(t, Math.min(e, this.x))),
              (this.y = Math.max(t, Math.min(e, this.y))),
              (this.z = Math.max(t, Math.min(e, this.z))),
              this
            );
          }
          clampLength(t, e) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(
              Math.max(t, Math.min(e, n))
            );
          }
          floor() {
            return (
              (this.x = Math.floor(this.x)),
              (this.y = Math.floor(this.y)),
              (this.z = Math.floor(this.z)),
              this
            );
          }
          ceil() {
            return (
              (this.x = Math.ceil(this.x)),
              (this.y = Math.ceil(this.y)),
              (this.z = Math.ceil(this.z)),
              this
            );
          }
          round() {
            return (
              (this.x = Math.round(this.x)),
              (this.y = Math.round(this.y)),
              (this.z = Math.round(this.z)),
              this
            );
          }
          roundToZero() {
            return (
              (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
              (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
              (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
              this
            );
          }
          negate() {
            return (
              (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
            );
          }
          dot(t) {
            return this.x * t.x + this.y * t.y + this.z * t.z;
          }
          lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z;
          }
          length() {
            return Math.sqrt(
              this.x * this.x + this.y * this.y + this.z * this.z
            );
          }
          manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
          }
          normalize() {
            return this.divideScalar(this.length() || 1);
          }
          setLength(t) {
            return this.normalize().multiplyScalar(t);
          }
          lerp(t, e) {
            return (
              (this.x += (t.x - this.x) * e),
              (this.y += (t.y - this.y) * e),
              (this.z += (t.z - this.z) * e),
              this
            );
          }
          lerpVectors(t, e, n) {
            return (
              (this.x = t.x + (e.x - t.x) * n),
              (this.y = t.y + (e.y - t.y) * n),
              (this.z = t.z + (e.z - t.z) * n),
              this
            );
          }
          cross(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."
                ),
                this.crossVectors(t, e))
              : this.crossVectors(this, t);
          }
          crossVectors(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = e.x,
              a = e.y,
              o = e.z;
            return (
              (this.x = i * o - r * a),
              (this.y = r * s - n * o),
              (this.z = n * a - i * s),
              this
            );
          }
          projectOnVector(t) {
            const e = t.lengthSq();
            if (0 === e) return this.set(0, 0, 0);
            const n = t.dot(this) / e;
            return this.copy(t).multiplyScalar(n);
          }
          projectOnPlane(t) {
            return Rt.copy(this).projectOnVector(t), this.sub(Rt);
          }
          reflect(t) {
            return this.sub(Rt.copy(t).multiplyScalar(2 * this.dot(t)));
          }
          angleTo(t) {
            const e = Math.sqrt(this.lengthSq() * t.lengthSq());
            if (0 === e) return Math.PI / 2;
            const n = this.dot(t) / e;
            return Math.acos(ht(n, -1, 1));
          }
          distanceTo(t) {
            return Math.sqrt(this.distanceToSquared(t));
          }
          distanceToSquared(t) {
            const e = this.x - t.x,
              n = this.y - t.y,
              i = this.z - t.z;
            return e * e + n * n + i * i;
          }
          manhattanDistanceTo(t) {
            return (
              Math.abs(this.x - t.x) +
              Math.abs(this.y - t.y) +
              Math.abs(this.z - t.z)
            );
          }
          setFromSpherical(t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
          }
          setFromSphericalCoords(t, e, n) {
            const i = Math.sin(e) * t;
            return (
              (this.x = i * Math.sin(n)),
              (this.y = Math.cos(e) * t),
              (this.z = i * Math.cos(n)),
              this
            );
          }
          setFromCylindrical(t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
          }
          setFromCylindricalCoords(t, e, n) {
            return (
              (this.x = t * Math.sin(e)),
              (this.y = n),
              (this.z = t * Math.cos(e)),
              this
            );
          }
          setFromMatrixPosition(t) {
            const e = t.elements;
            return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
          }
          setFromMatrixScale(t) {
            const e = this.setFromMatrixColumn(t, 0).length(),
              n = this.setFromMatrixColumn(t, 1).length(),
              i = this.setFromMatrixColumn(t, 2).length();
            return (this.x = e), (this.y = n), (this.z = i), this;
          }
          setFromMatrixColumn(t, e) {
            return this.fromArray(t.elements, 4 * e);
          }
          setFromMatrix3Column(t, e) {
            return this.fromArray(t.elements, 3 * e);
          }
          equals(t) {
            return t.x === this.x && t.y === this.y && t.z === this.z;
          }
          fromArray(t, e = 0) {
            return (
              (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
          }
          fromBufferAttribute(t, e, n) {
            return (
              void 0 !== n &&
                console.warn(
                  "THREE.Vector3: offset has been removed from .fromBufferAttribute()."
                ),
              (this.x = t.getX(e)),
              (this.y = t.getY(e)),
              (this.z = t.getZ(e)),
              this
            );
          }
          random() {
            return (
              (this.x = Math.random()),
              (this.y = Math.random()),
              (this.z = Math.random()),
              this
            );
          }
        }
        Lt.prototype.isVector3 = !0;
        const Rt = new Lt(),
          Ct = new At();
        class Pt {
          constructor(
            t = new Lt(1 / 0, 1 / 0, 1 / 0),
            e = new Lt(-1 / 0, -1 / 0, -1 / 0)
          ) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromArray(t) {
            let e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              s = -1 / 0,
              a = -1 / 0;
            for (let o = 0, l = t.length; o < l; o += 3) {
              const l = t[o],
                c = t[o + 1],
                h = t[o + 2];
              l < e && (e = l),
                c < n && (n = c),
                h < i && (i = h),
                l > r && (r = l),
                c > s && (s = c),
                h > a && (a = h);
            }
            return this.min.set(e, n, i), this.max.set(r, s, a), this;
          }
          setFromBufferAttribute(t) {
            let e = 1 / 0,
              n = 1 / 0,
              i = 1 / 0,
              r = -1 / 0,
              s = -1 / 0,
              a = -1 / 0;
            for (let o = 0, l = t.count; o < l; o++) {
              const l = t.getX(o),
                c = t.getY(o),
                h = t.getZ(o);
              l < e && (e = l),
                c < n && (n = c),
                h < i && (i = h),
                l > r && (r = l),
                c > s && (s = c),
                h > a && (a = h);
            }
            return this.min.set(e, n, i), this.max.set(r, s, a), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = It.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          setFromObject(t) {
            return this.makeEmpty(), this.expandByObject(t);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = this.min.z = 1 / 0),
              (this.max.x = this.max.y = this.max.z = -1 / 0),
              this
            );
          }
          isEmpty() {
            return (
              this.max.x < this.min.x ||
              this.max.y < this.min.y ||
              this.max.z < this.min.z
            );
          }
          getCenter(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Box3: .getCenter() target is now required"
                ),
                (t = new Lt())),
              this.isEmpty()
                ? t.set(0, 0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          }
          getSize(t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Box3: .getSize() target is now required"),
                (t = new Lt())),
              this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
            );
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          expandByObject(t) {
            t.updateWorldMatrix(!1, !1);
            const e = t.geometry;
            void 0 !== e &&
              (null === e.boundingBox && e.computeBoundingBox(),
              Nt.copy(e.boundingBox),
              Nt.applyMatrix4(t.matrixWorld),
              this.union(Nt));
            const n = t.children;
            for (let t = 0, e = n.length; t < e; t++) this.expandByObject(n[t]);
            return this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y ||
              t.z < this.min.z ||
              t.z > this.max.z
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y &&
              this.min.z <= t.min.z &&
              t.max.z <= this.max.z
            );
          }
          getParameter(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box3: .getParameter() target is now required"
                ),
                (e = new Lt())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y),
                (t.z - this.min.z) / (this.max.z - this.min.z)
              )
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y ||
              t.max.z < this.min.z ||
              t.min.z > this.max.z
            );
          }
          intersectsSphere(t) {
            return (
              this.clampPoint(t.center, It),
              It.distanceToSquared(t.center) <= t.radius * t.radius
            );
          }
          intersectsPlane(t) {
            let e, n;
            return (
              t.normal.x > 0
                ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
                : ((e = t.normal.x * this.max.x),
                  (n = t.normal.x * this.min.x)),
              t.normal.y > 0
                ? ((e += t.normal.y * this.min.y),
                  (n += t.normal.y * this.max.y))
                : ((e += t.normal.y * this.max.y),
                  (n += t.normal.y * this.min.y)),
              t.normal.z > 0
                ? ((e += t.normal.z * this.min.z),
                  (n += t.normal.z * this.max.z))
                : ((e += t.normal.z * this.max.z),
                  (n += t.normal.z * this.min.z)),
              e <= -t.constant && n >= -t.constant
            );
          }
          intersectsTriangle(t) {
            if (this.isEmpty()) return !1;
            this.getCenter(Ut),
              kt.subVectors(this.max, Ut),
              Bt.subVectors(t.a, Ut),
              zt.subVectors(t.b, Ut),
              Ft.subVectors(t.c, Ut),
              Ot.subVectors(zt, Bt),
              Ht.subVectors(Ft, zt),
              Gt.subVectors(Bt, Ft);
            let e = [
              0,
              -Ot.z,
              Ot.y,
              0,
              -Ht.z,
              Ht.y,
              0,
              -Gt.z,
              Gt.y,
              Ot.z,
              0,
              -Ot.x,
              Ht.z,
              0,
              -Ht.x,
              Gt.z,
              0,
              -Gt.x,
              -Ot.y,
              Ot.x,
              0,
              -Ht.y,
              Ht.x,
              0,
              -Gt.y,
              Gt.x,
              0,
            ];
            return (
              !!jt(e, Bt, zt, Ft, kt) &&
              ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
              !!jt(e, Bt, zt, Ft, kt) &&
                (Vt.crossVectors(Ot, Ht),
                (e = [Vt.x, Vt.y, Vt.z]),
                jt(e, Bt, zt, Ft, kt)))
            );
          }
          clampPoint(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box3: .clampPoint() target is now required"
                ),
                (e = new Lt())),
              e.copy(t).clamp(this.min, this.max)
            );
          }
          distanceToPoint(t) {
            return It.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          getBoundingSphere(t) {
            return (
              void 0 === t &&
                console.error(
                  "THREE.Box3: .getBoundingSphere() target is now required"
                ),
              this.getCenter(t.center),
              (t.radius = 0.5 * this.getSize(It).length()),
              t
            );
          }
          intersect(t) {
            return (
              this.min.max(t.min),
              this.max.min(t.max),
              this.isEmpty() && this.makeEmpty(),
              this
            );
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          applyMatrix4(t) {
            return (
              this.isEmpty() ||
                (Dt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
                Dt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
                Dt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
                Dt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
                Dt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
                Dt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
                Dt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
                Dt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
                this.setFromPoints(Dt)),
              this
            );
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        Pt.prototype.isBox3 = !0;
        const Dt = [
            new Lt(),
            new Lt(),
            new Lt(),
            new Lt(),
            new Lt(),
            new Lt(),
            new Lt(),
            new Lt(),
          ],
          It = new Lt(),
          Nt = new Pt(),
          Bt = new Lt(),
          zt = new Lt(),
          Ft = new Lt(),
          Ot = new Lt(),
          Ht = new Lt(),
          Gt = new Lt(),
          Ut = new Lt(),
          kt = new Lt(),
          Vt = new Lt(),
          Wt = new Lt();
        function jt(t, e, n, i, r) {
          for (let s = 0, a = t.length - 3; s <= a; s += 3) {
            Wt.fromArray(t, s);
            const a =
                r.x * Math.abs(Wt.x) +
                r.y * Math.abs(Wt.y) +
                r.z * Math.abs(Wt.z),
              o = e.dot(Wt),
              l = n.dot(Wt),
              c = i.dot(Wt);
            if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
          }
          return !0;
        }
        const qt = new Pt(),
          Xt = new Lt(),
          Yt = new Lt(),
          Zt = new Lt();
        class Jt {
          constructor(t = new Lt(), e = -1) {
            (this.center = t), (this.radius = e);
          }
          set(t, e) {
            return this.center.copy(t), (this.radius = e), this;
          }
          setFromPoints(t, e) {
            const n = this.center;
            void 0 !== e ? n.copy(e) : qt.setFromPoints(t).getCenter(n);
            let i = 0;
            for (let e = 0, r = t.length; e < r; e++)
              i = Math.max(i, n.distanceToSquared(t[e]));
            return (this.radius = Math.sqrt(i)), this;
          }
          copy(t) {
            return this.center.copy(t.center), (this.radius = t.radius), this;
          }
          isEmpty() {
            return this.radius < 0;
          }
          makeEmpty() {
            return this.center.set(0, 0, 0), (this.radius = -1), this;
          }
          containsPoint(t) {
            return (
              t.distanceToSquared(this.center) <= this.radius * this.radius
            );
          }
          distanceToPoint(t) {
            return t.distanceTo(this.center) - this.radius;
          }
          intersectsSphere(t) {
            const e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e;
          }
          intersectsBox(t) {
            return t.intersectsSphere(this);
          }
          intersectsPlane(t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
          }
          clampPoint(t, e) {
            const n = this.center.distanceToSquared(t);
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Sphere: .clampPoint() target is now required"
                ),
                (e = new Lt())),
              e.copy(t),
              n > this.radius * this.radius &&
                (e.sub(this.center).normalize(),
                e.multiplyScalar(this.radius).add(this.center)),
              e
            );
          }
          getBoundingBox(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Sphere: .getBoundingBox() target is now required"
                ),
                (t = new Pt())),
              this.isEmpty()
                ? (t.makeEmpty(), t)
                : (t.set(this.center, this.center),
                  t.expandByScalar(this.radius),
                  t)
            );
          }
          applyMatrix4(t) {
            return (
              this.center.applyMatrix4(t),
              (this.radius = this.radius * t.getMaxScaleOnAxis()),
              this
            );
          }
          translate(t) {
            return this.center.add(t), this;
          }
          expandByPoint(t) {
            Zt.subVectors(t, this.center);
            const e = Zt.lengthSq();
            if (e > this.radius * this.radius) {
              const t = Math.sqrt(e),
                n = 0.5 * (t - this.radius);
              this.center.add(Zt.multiplyScalar(n / t)), (this.radius += n);
            }
            return this;
          }
          union(t) {
            return (
              Yt.subVectors(t.center, this.center)
                .normalize()
                .multiplyScalar(t.radius),
              this.expandByPoint(Xt.copy(t.center).add(Yt)),
              this.expandByPoint(Xt.copy(t.center).sub(Yt)),
              this
            );
          }
          equals(t) {
            return t.center.equals(this.center) && t.radius === this.radius;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        const Qt = new Lt(),
          Kt = new Lt(),
          $t = new Lt(),
          te = new Lt(),
          ee = new Lt(),
          ne = new Lt(),
          ie = new Lt();
        class re {
          constructor(t = new Lt(), e = new Lt(0, 0, -1)) {
            (this.origin = t), (this.direction = e);
          }
          set(t, e) {
            return this.origin.copy(t), this.direction.copy(e), this;
          }
          copy(t) {
            return (
              this.origin.copy(t.origin), this.direction.copy(t.direction), this
            );
          }
          at(t, e) {
            return (
              void 0 === e &&
                (console.warn("THREE.Ray: .at() target is now required"),
                (e = new Lt())),
              e.copy(this.direction).multiplyScalar(t).add(this.origin)
            );
          }
          lookAt(t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this;
          }
          recast(t) {
            return this.origin.copy(this.at(t, Qt)), this;
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Ray: .closestPointToPoint() target is now required"
              ),
              (e = new Lt())),
              e.subVectors(t, this.origin);
            const n = e.dot(this.direction);
            return n < 0
              ? e.copy(this.origin)
              : e.copy(this.direction).multiplyScalar(n).add(this.origin);
          }
          distanceToPoint(t) {
            return Math.sqrt(this.distanceSqToPoint(t));
          }
          distanceSqToPoint(t) {
            const e = Qt.subVectors(t, this.origin).dot(this.direction);
            return e < 0
              ? this.origin.distanceToSquared(t)
              : (Qt.copy(this.direction).multiplyScalar(e).add(this.origin),
                Qt.distanceToSquared(t));
          }
          distanceSqToSegment(t, e, n, i) {
            Kt.copy(t).add(e).multiplyScalar(0.5),
              $t.copy(e).sub(t).normalize(),
              te.copy(this.origin).sub(Kt);
            const r = 0.5 * t.distanceTo(e),
              s = -this.direction.dot($t),
              a = te.dot(this.direction),
              o = -te.dot($t),
              l = te.lengthSq(),
              c = Math.abs(1 - s * s);
            let h, u, d, p;
            if (c > 0)
              if (((h = s * o - a), (u = s * a - o), (p = r * c), h >= 0))
                if (u >= -p)
                  if (u <= p) {
                    const t = 1 / c;
                    (h *= t),
                      (u *= t),
                      (d =
                        h * (h + s * u + 2 * a) + u * (s * h + u + 2 * o) + l);
                  } else
                    (u = r),
                      (h = Math.max(0, -(s * u + a))),
                      (d = -h * h + u * (u + 2 * o) + l);
                else
                  (u = -r),
                    (h = Math.max(0, -(s * u + a))),
                    (d = -h * h + u * (u + 2 * o) + l);
              else
                u <= -p
                  ? ((h = Math.max(0, -(-s * r + a))),
                    (u = h > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                    (d = -h * h + u * (u + 2 * o) + l))
                  : u <= p
                  ? ((h = 0),
                    (u = Math.min(Math.max(-r, -o), r)),
                    (d = u * (u + 2 * o) + l))
                  : ((h = Math.max(0, -(s * r + a))),
                    (u = h > 0 ? r : Math.min(Math.max(-r, -o), r)),
                    (d = -h * h + u * (u + 2 * o) + l));
            else
              (u = s > 0 ? -r : r),
                (h = Math.max(0, -(s * u + a))),
                (d = -h * h + u * (u + 2 * o) + l);
            return (
              n && n.copy(this.direction).multiplyScalar(h).add(this.origin),
              i && i.copy($t).multiplyScalar(u).add(Kt),
              d
            );
          }
          intersectSphere(t, e) {
            Qt.subVectors(t.center, this.origin);
            const n = Qt.dot(this.direction),
              i = Qt.dot(Qt) - n * n,
              r = t.radius * t.radius;
            if (i > r) return null;
            const s = Math.sqrt(r - i),
              a = n - s,
              o = n + s;
            return a < 0 && o < 0
              ? null
              : a < 0
              ? this.at(o, e)
              : this.at(a, e);
          }
          intersectsSphere(t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
          }
          distanceToPlane(t) {
            const e = t.normal.dot(this.direction);
            if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(t.normal) + t.constant) / e;
            return n >= 0 ? n : null;
          }
          intersectPlane(t, e) {
            const n = this.distanceToPlane(t);
            return null === n ? null : this.at(n, e);
          }
          intersectsPlane(t) {
            const e = t.distanceToPoint(this.origin);
            if (0 === e) return !0;
            return t.normal.dot(this.direction) * e < 0;
          }
          intersectBox(t, e) {
            let n, i, r, s, a, o;
            const l = 1 / this.direction.x,
              c = 1 / this.direction.y,
              h = 1 / this.direction.z,
              u = this.origin;
            return (
              l >= 0
                ? ((n = (t.min.x - u.x) * l), (i = (t.max.x - u.x) * l))
                : ((n = (t.max.x - u.x) * l), (i = (t.min.x - u.x) * l)),
              c >= 0
                ? ((r = (t.min.y - u.y) * c), (s = (t.max.y - u.y) * c))
                : ((r = (t.max.y - u.y) * c), (s = (t.min.y - u.y) * c)),
              n > s || r > i
                ? null
                : ((r > n || n != n) && (n = r),
                  (s < i || i != i) && (i = s),
                  h >= 0
                    ? ((a = (t.min.z - u.z) * h), (o = (t.max.z - u.z) * h))
                    : ((a = (t.max.z - u.z) * h), (o = (t.min.z - u.z) * h)),
                  n > o || a > i
                    ? null
                    : ((a > n || n != n) && (n = a),
                      (o < i || i != i) && (i = o),
                      i < 0 ? null : this.at(n >= 0 ? n : i, e)))
            );
          }
          intersectsBox(t) {
            return null !== this.intersectBox(t, Qt);
          }
          intersectTriangle(t, e, n, i, r) {
            ee.subVectors(e, t), ne.subVectors(n, t), ie.crossVectors(ee, ne);
            let s,
              a = this.direction.dot(ie);
            if (a > 0) {
              if (i) return null;
              s = 1;
            } else {
              if (!(a < 0)) return null;
              (s = -1), (a = -a);
            }
            te.subVectors(this.origin, t);
            const o = s * this.direction.dot(ne.crossVectors(te, ne));
            if (o < 0) return null;
            const l = s * this.direction.dot(ee.cross(te));
            if (l < 0) return null;
            if (o + l > a) return null;
            const c = -s * te.dot(ie);
            return c < 0 ? null : this.at(c / a, r);
          }
          applyMatrix4(t) {
            return (
              this.origin.applyMatrix4(t),
              this.direction.transformDirection(t),
              this
            );
          }
          equals(t) {
            return (
              t.origin.equals(this.origin) && t.direction.equals(this.direction)
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class se {
          constructor() {
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
              arguments.length > 0 &&
                console.error(
                  "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead."
                );
          }
          set(t, e, n, i, r, s, a, o, l, c, h, u, d, p, m, f) {
            const g = this.elements;
            return (
              (g[0] = t),
              (g[4] = e),
              (g[8] = n),
              (g[12] = i),
              (g[1] = r),
              (g[5] = s),
              (g[9] = a),
              (g[13] = o),
              (g[2] = l),
              (g[6] = c),
              (g[10] = h),
              (g[14] = u),
              (g[3] = d),
              (g[7] = p),
              (g[11] = m),
              (g[15] = f),
              this
            );
          }
          identity() {
            return (
              this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          clone() {
            return new se().fromArray(this.elements);
          }
          copy(t) {
            const e = this.elements,
              n = t.elements;
            return (
              (e[0] = n[0]),
              (e[1] = n[1]),
              (e[2] = n[2]),
              (e[3] = n[3]),
              (e[4] = n[4]),
              (e[5] = n[5]),
              (e[6] = n[6]),
              (e[7] = n[7]),
              (e[8] = n[8]),
              (e[9] = n[9]),
              (e[10] = n[10]),
              (e[11] = n[11]),
              (e[12] = n[12]),
              (e[13] = n[13]),
              (e[14] = n[14]),
              (e[15] = n[15]),
              this
            );
          }
          copyPosition(t) {
            const e = this.elements,
              n = t.elements;
            return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
          }
          setFromMatrix3(t) {
            const e = t.elements;
            return (
              this.set(
                e[0],
                e[3],
                e[6],
                0,
                e[1],
                e[4],
                e[7],
                0,
                e[2],
                e[5],
                e[8],
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractBasis(t, e, n) {
            return (
              t.setFromMatrixColumn(this, 0),
              e.setFromMatrixColumn(this, 1),
              n.setFromMatrixColumn(this, 2),
              this
            );
          }
          makeBasis(t, e, n) {
            return (
              this.set(
                t.x,
                e.x,
                n.x,
                0,
                t.y,
                e.y,
                n.y,
                0,
                t.z,
                e.z,
                n.z,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          extractRotation(t) {
            const e = this.elements,
              n = t.elements,
              i = 1 / ae.setFromMatrixColumn(t, 0).length(),
              r = 1 / ae.setFromMatrixColumn(t, 1).length(),
              s = 1 / ae.setFromMatrixColumn(t, 2).length();
            return (
              (e[0] = n[0] * i),
              (e[1] = n[1] * i),
              (e[2] = n[2] * i),
              (e[3] = 0),
              (e[4] = n[4] * r),
              (e[5] = n[5] * r),
              (e[6] = n[6] * r),
              (e[7] = 0),
              (e[8] = n[8] * s),
              (e[9] = n[9] * s),
              (e[10] = n[10] * s),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromEuler(t) {
            (t && t.isEuler) ||
              console.error(
                "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."
              );
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z,
              s = Math.cos(n),
              a = Math.sin(n),
              o = Math.cos(i),
              l = Math.sin(i),
              c = Math.cos(r),
              h = Math.sin(r);
            if ("XYZ" === t.order) {
              const t = s * c,
                n = s * h,
                i = a * c,
                r = a * h;
              (e[0] = o * c),
                (e[4] = -o * h),
                (e[8] = l),
                (e[1] = n + i * l),
                (e[5] = t - r * l),
                (e[9] = -a * o),
                (e[2] = r - t * l),
                (e[6] = i + n * l),
                (e[10] = s * o);
            } else if ("YXZ" === t.order) {
              const t = o * c,
                n = o * h,
                i = l * c,
                r = l * h;
              (e[0] = t + r * a),
                (e[4] = i * a - n),
                (e[8] = s * l),
                (e[1] = s * h),
                (e[5] = s * c),
                (e[9] = -a),
                (e[2] = n * a - i),
                (e[6] = r + t * a),
                (e[10] = s * o);
            } else if ("ZXY" === t.order) {
              const t = o * c,
                n = o * h,
                i = l * c,
                r = l * h;
              (e[0] = t - r * a),
                (e[4] = -s * h),
                (e[8] = i + n * a),
                (e[1] = n + i * a),
                (e[5] = s * c),
                (e[9] = r - t * a),
                (e[2] = -s * l),
                (e[6] = a),
                (e[10] = s * o);
            } else if ("ZYX" === t.order) {
              const t = s * c,
                n = s * h,
                i = a * c,
                r = a * h;
              (e[0] = o * c),
                (e[4] = i * l - n),
                (e[8] = t * l + r),
                (e[1] = o * h),
                (e[5] = r * l + t),
                (e[9] = n * l - i),
                (e[2] = -l),
                (e[6] = a * o),
                (e[10] = s * o);
            } else if ("YZX" === t.order) {
              const t = s * o,
                n = s * l,
                i = a * o,
                r = a * l;
              (e[0] = o * c),
                (e[4] = r - t * h),
                (e[8] = i * h + n),
                (e[1] = h),
                (e[5] = s * c),
                (e[9] = -a * c),
                (e[2] = -l * c),
                (e[6] = n * h + i),
                (e[10] = t - r * h);
            } else if ("XZY" === t.order) {
              const t = s * o,
                n = s * l,
                i = a * o,
                r = a * l;
              (e[0] = o * c),
                (e[4] = -h),
                (e[8] = l * c),
                (e[1] = t * h + r),
                (e[5] = s * c),
                (e[9] = n * h - i),
                (e[2] = i * h - n),
                (e[6] = a * c),
                (e[10] = r * h + t);
            }
            return (
              (e[3] = 0),
              (e[7] = 0),
              (e[11] = 0),
              (e[12] = 0),
              (e[13] = 0),
              (e[14] = 0),
              (e[15] = 1),
              this
            );
          }
          makeRotationFromQuaternion(t) {
            return this.compose(le, t, ce);
          }
          lookAt(t, e, n) {
            const i = this.elements;
            return (
              de.subVectors(t, e),
              0 === de.lengthSq() && (de.z = 1),
              de.normalize(),
              he.crossVectors(n, de),
              0 === he.lengthSq() &&
                (1 === Math.abs(n.z) ? (de.x += 1e-4) : (de.z += 1e-4),
                de.normalize(),
                he.crossVectors(n, de)),
              he.normalize(),
              ue.crossVectors(de, he),
              (i[0] = he.x),
              (i[4] = ue.x),
              (i[8] = de.x),
              (i[1] = he.y),
              (i[5] = ue.y),
              (i[9] = de.y),
              (i[2] = he.z),
              (i[6] = ue.z),
              (i[10] = de.z),
              this
            );
          }
          multiply(t, e) {
            return void 0 !== e
              ? (console.warn(
                  "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."
                ),
                this.multiplyMatrices(t, e))
              : this.multiplyMatrices(this, t);
          }
          premultiply(t) {
            return this.multiplyMatrices(t, this);
          }
          multiplyMatrices(t, e) {
            const n = t.elements,
              i = e.elements,
              r = this.elements,
              s = n[0],
              a = n[4],
              o = n[8],
              l = n[12],
              c = n[1],
              h = n[5],
              u = n[9],
              d = n[13],
              p = n[2],
              m = n[6],
              f = n[10],
              g = n[14],
              v = n[3],
              y = n[7],
              x = n[11],
              _ = n[15],
              w = i[0],
              b = i[4],
              M = i[8],
              S = i[12],
              T = i[1],
              E = i[5],
              A = i[9],
              L = i[13],
              R = i[2],
              C = i[6],
              P = i[10],
              D = i[14],
              I = i[3],
              N = i[7],
              B = i[11],
              z = i[15];
            return (
              (r[0] = s * w + a * T + o * R + l * I),
              (r[4] = s * b + a * E + o * C + l * N),
              (r[8] = s * M + a * A + o * P + l * B),
              (r[12] = s * S + a * L + o * D + l * z),
              (r[1] = c * w + h * T + u * R + d * I),
              (r[5] = c * b + h * E + u * C + d * N),
              (r[9] = c * M + h * A + u * P + d * B),
              (r[13] = c * S + h * L + u * D + d * z),
              (r[2] = p * w + m * T + f * R + g * I),
              (r[6] = p * b + m * E + f * C + g * N),
              (r[10] = p * M + m * A + f * P + g * B),
              (r[14] = p * S + m * L + f * D + g * z),
              (r[3] = v * w + y * T + x * R + _ * I),
              (r[7] = v * b + y * E + x * C + _ * N),
              (r[11] = v * M + y * A + x * P + _ * B),
              (r[15] = v * S + y * L + x * D + _ * z),
              this
            );
          }
          multiplyScalar(t) {
            const e = this.elements;
            return (
              (e[0] *= t),
              (e[4] *= t),
              (e[8] *= t),
              (e[12] *= t),
              (e[1] *= t),
              (e[5] *= t),
              (e[9] *= t),
              (e[13] *= t),
              (e[2] *= t),
              (e[6] *= t),
              (e[10] *= t),
              (e[14] *= t),
              (e[3] *= t),
              (e[7] *= t),
              (e[11] *= t),
              (e[15] *= t),
              this
            );
          }
          determinant() {
            const t = this.elements,
              e = t[0],
              n = t[4],
              i = t[8],
              r = t[12],
              s = t[1],
              a = t[5],
              o = t[9],
              l = t[13],
              c = t[2],
              h = t[6],
              u = t[10],
              d = t[14];
            return (
              t[3] *
                (+r * o * h -
                  i * l * h -
                  r * a * u +
                  n * l * u +
                  i * a * d -
                  n * o * d) +
              t[7] *
                (+e * o * d -
                  e * l * u +
                  r * s * u -
                  i * s * d +
                  i * l * c -
                  r * o * c) +
              t[11] *
                (+e * l * h -
                  e * a * d -
                  r * s * h +
                  n * s * d +
                  r * a * c -
                  n * l * c) +
              t[15] *
                (-i * a * c -
                  e * o * h +
                  e * a * u +
                  i * s * h -
                  n * s * u +
                  n * o * c)
            );
          }
          transpose() {
            const t = this.elements;
            let e;
            return (
              (e = t[1]),
              (t[1] = t[4]),
              (t[4] = e),
              (e = t[2]),
              (t[2] = t[8]),
              (t[8] = e),
              (e = t[6]),
              (t[6] = t[9]),
              (t[9] = e),
              (e = t[3]),
              (t[3] = t[12]),
              (t[12] = e),
              (e = t[7]),
              (t[7] = t[13]),
              (t[13] = e),
              (e = t[11]),
              (t[11] = t[14]),
              (t[14] = e),
              this
            );
          }
          setPosition(t, e, n) {
            const i = this.elements;
            return (
              t.isVector3
                ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
                : ((i[12] = t), (i[13] = e), (i[14] = n)),
              this
            );
          }
          invert() {
            const t = this.elements,
              e = t[0],
              n = t[1],
              i = t[2],
              r = t[3],
              s = t[4],
              a = t[5],
              o = t[6],
              l = t[7],
              c = t[8],
              h = t[9],
              u = t[10],
              d = t[11],
              p = t[12],
              m = t[13],
              f = t[14],
              g = t[15],
              v =
                h * f * l -
                m * u * l +
                m * o * d -
                a * f * d -
                h * o * g +
                a * u * g,
              y =
                p * u * l -
                c * f * l -
                p * o * d +
                s * f * d +
                c * o * g -
                s * u * g,
              x =
                c * m * l -
                p * h * l +
                p * a * d -
                s * m * d -
                c * a * g +
                s * h * g,
              _ =
                p * h * o -
                c * m * o -
                p * a * u +
                s * m * u +
                c * a * f -
                s * h * f,
              w = e * v + n * y + i * x + r * _;
            if (0 === w)
              return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const b = 1 / w;
            return (
              (t[0] = v * b),
              (t[1] =
                (m * u * r -
                  h * f * r -
                  m * i * d +
                  n * f * d +
                  h * i * g -
                  n * u * g) *
                b),
              (t[2] =
                (a * f * r -
                  m * o * r +
                  m * i * l -
                  n * f * l -
                  a * i * g +
                  n * o * g) *
                b),
              (t[3] =
                (h * o * r -
                  a * u * r -
                  h * i * l +
                  n * u * l +
                  a * i * d -
                  n * o * d) *
                b),
              (t[4] = y * b),
              (t[5] =
                (c * f * r -
                  p * u * r +
                  p * i * d -
                  e * f * d -
                  c * i * g +
                  e * u * g) *
                b),
              (t[6] =
                (p * o * r -
                  s * f * r -
                  p * i * l +
                  e * f * l +
                  s * i * g -
                  e * o * g) *
                b),
              (t[7] =
                (s * u * r -
                  c * o * r +
                  c * i * l -
                  e * u * l -
                  s * i * d +
                  e * o * d) *
                b),
              (t[8] = x * b),
              (t[9] =
                (p * h * r -
                  c * m * r -
                  p * n * d +
                  e * m * d +
                  c * n * g -
                  e * h * g) *
                b),
              (t[10] =
                (s * m * r -
                  p * a * r +
                  p * n * l -
                  e * m * l -
                  s * n * g +
                  e * a * g) *
                b),
              (t[11] =
                (c * a * r -
                  s * h * r -
                  c * n * l +
                  e * h * l +
                  s * n * d -
                  e * a * d) *
                b),
              (t[12] = _ * b),
              (t[13] =
                (c * m * i -
                  p * h * i +
                  p * n * u -
                  e * m * u -
                  c * n * f +
                  e * h * f) *
                b),
              (t[14] =
                (p * a * i -
                  s * m * i -
                  p * n * o +
                  e * m * o +
                  s * n * f -
                  e * a * f) *
                b),
              (t[15] =
                (s * h * i -
                  c * a * i +
                  c * n * o -
                  e * h * o -
                  s * n * u +
                  e * a * u) *
                b),
              this
            );
          }
          scale(t) {
            const e = this.elements,
              n = t.x,
              i = t.y,
              r = t.z;
            return (
              (e[0] *= n),
              (e[4] *= i),
              (e[8] *= r),
              (e[1] *= n),
              (e[5] *= i),
              (e[9] *= r),
              (e[2] *= n),
              (e[6] *= i),
              (e[10] *= r),
              (e[3] *= n),
              (e[7] *= i),
              (e[11] *= r),
              this
            );
          }
          getMaxScaleOnAxis() {
            const t = this.elements,
              e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
              n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
              i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
            return Math.sqrt(Math.max(e, n, i));
          }
          makeTranslation(t, e, n) {
            return (
              this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
            );
          }
          makeRotationX(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationY(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationZ(t) {
            const e = Math.cos(t),
              n = Math.sin(t);
            return (
              this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            );
          }
          makeRotationAxis(t, e) {
            const n = Math.cos(e),
              i = Math.sin(e),
              r = 1 - n,
              s = t.x,
              a = t.y,
              o = t.z,
              l = r * s,
              c = r * a;
            return (
              this.set(
                l * s + n,
                l * a - i * o,
                l * o + i * a,
                0,
                l * a + i * o,
                c * a + n,
                c * o - i * s,
                0,
                l * o - i * a,
                c * o + i * s,
                r * o * o + n,
                0,
                0,
                0,
                0,
                1
              ),
              this
            );
          }
          makeScale(t, e, n) {
            return (
              this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
            );
          }
          makeShear(t, e, n) {
            return (
              this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
            );
          }
          compose(t, e, n) {
            const i = this.elements,
              r = e._x,
              s = e._y,
              a = e._z,
              o = e._w,
              l = r + r,
              c = s + s,
              h = a + a,
              u = r * l,
              d = r * c,
              p = r * h,
              m = s * c,
              f = s * h,
              g = a * h,
              v = o * l,
              y = o * c,
              x = o * h,
              _ = n.x,
              w = n.y,
              b = n.z;
            return (
              (i[0] = (1 - (m + g)) * _),
              (i[1] = (d + x) * _),
              (i[2] = (p - y) * _),
              (i[3] = 0),
              (i[4] = (d - x) * w),
              (i[5] = (1 - (u + g)) * w),
              (i[6] = (f + v) * w),
              (i[7] = 0),
              (i[8] = (p + y) * b),
              (i[9] = (f - v) * b),
              (i[10] = (1 - (u + m)) * b),
              (i[11] = 0),
              (i[12] = t.x),
              (i[13] = t.y),
              (i[14] = t.z),
              (i[15] = 1),
              this
            );
          }
          decompose(t, e, n) {
            const i = this.elements;
            let r = ae.set(i[0], i[1], i[2]).length();
            const s = ae.set(i[4], i[5], i[6]).length(),
              a = ae.set(i[8], i[9], i[10]).length();
            this.determinant() < 0 && (r = -r),
              (t.x = i[12]),
              (t.y = i[13]),
              (t.z = i[14]),
              oe.copy(this);
            const o = 1 / r,
              l = 1 / s,
              c = 1 / a;
            return (
              (oe.elements[0] *= o),
              (oe.elements[1] *= o),
              (oe.elements[2] *= o),
              (oe.elements[4] *= l),
              (oe.elements[5] *= l),
              (oe.elements[6] *= l),
              (oe.elements[8] *= c),
              (oe.elements[9] *= c),
              (oe.elements[10] *= c),
              e.setFromRotationMatrix(oe),
              (n.x = r),
              (n.y = s),
              (n.z = a),
              this
            );
          }
          makePerspective(t, e, n, i, r, s) {
            void 0 === s &&
              console.warn(
                "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."
              );
            const a = this.elements,
              o = (2 * r) / (e - t),
              l = (2 * r) / (n - i),
              c = (e + t) / (e - t),
              h = (n + i) / (n - i),
              u = -(s + r) / (s - r),
              d = (-2 * s * r) / (s - r);
            return (
              (a[0] = o),
              (a[4] = 0),
              (a[8] = c),
              (a[12] = 0),
              (a[1] = 0),
              (a[5] = l),
              (a[9] = h),
              (a[13] = 0),
              (a[2] = 0),
              (a[6] = 0),
              (a[10] = u),
              (a[14] = d),
              (a[3] = 0),
              (a[7] = 0),
              (a[11] = -1),
              (a[15] = 0),
              this
            );
          }
          makeOrthographic(t, e, n, i, r, s) {
            const a = this.elements,
              o = 1 / (e - t),
              l = 1 / (n - i),
              c = 1 / (s - r),
              h = (e + t) * o,
              u = (n + i) * l,
              d = (s + r) * c;
            return (
              (a[0] = 2 * o),
              (a[4] = 0),
              (a[8] = 0),
              (a[12] = -h),
              (a[1] = 0),
              (a[5] = 2 * l),
              (a[9] = 0),
              (a[13] = -u),
              (a[2] = 0),
              (a[6] = 0),
              (a[10] = -2 * c),
              (a[14] = -d),
              (a[3] = 0),
              (a[7] = 0),
              (a[11] = 0),
              (a[15] = 1),
              this
            );
          }
          equals(t) {
            const e = this.elements,
              n = t.elements;
            for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
            return !0;
          }
          fromArray(t, e = 0) {
            for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.elements;
            return (
              (t[e] = n[0]),
              (t[e + 1] = n[1]),
              (t[e + 2] = n[2]),
              (t[e + 3] = n[3]),
              (t[e + 4] = n[4]),
              (t[e + 5] = n[5]),
              (t[e + 6] = n[6]),
              (t[e + 7] = n[7]),
              (t[e + 8] = n[8]),
              (t[e + 9] = n[9]),
              (t[e + 10] = n[10]),
              (t[e + 11] = n[11]),
              (t[e + 12] = n[12]),
              (t[e + 13] = n[13]),
              (t[e + 14] = n[14]),
              (t[e + 15] = n[15]),
              t
            );
          }
        }
        se.prototype.isMatrix4 = !0;
        const ae = new Lt(),
          oe = new se(),
          le = new Lt(0, 0, 0),
          ce = new Lt(1, 1, 1),
          he = new Lt(),
          ue = new Lt(),
          de = new Lt(),
          pe = new se(),
          me = new At();
        class fe {
          constructor(t = 0, e = 0, n = 0, i = fe.DefaultOrder) {
            (this._x = t), (this._y = e), (this._z = n), (this._order = i);
          }
          get x() {
            return this._x;
          }
          set x(t) {
            (this._x = t), this._onChangeCallback();
          }
          get y() {
            return this._y;
          }
          set y(t) {
            (this._y = t), this._onChangeCallback();
          }
          get z() {
            return this._z;
          }
          set z(t) {
            (this._z = t), this._onChangeCallback();
          }
          get order() {
            return this._order;
          }
          set order(t) {
            (this._order = t), this._onChangeCallback();
          }
          set(t, e, n, i) {
            return (
              (this._x = t),
              (this._y = e),
              (this._z = n),
              (this._order = i || this._order),
              this._onChangeCallback(),
              this
            );
          }
          clone() {
            return new this.constructor(this._x, this._y, this._z, this._order);
          }
          copy(t) {
            return (
              (this._x = t._x),
              (this._y = t._y),
              (this._z = t._z),
              (this._order = t._order),
              this._onChangeCallback(),
              this
            );
          }
          setFromRotationMatrix(t, e, n) {
            const i = t.elements,
              r = i[0],
              s = i[4],
              a = i[8],
              o = i[1],
              l = i[5],
              c = i[9],
              h = i[2],
              u = i[6],
              d = i[10];
            switch ((e = e || this._order)) {
              case "XYZ":
                (this._y = Math.asin(ht(a, -1, 1))),
                  Math.abs(a) < 0.9999999
                    ? ((this._x = Math.atan2(-c, d)),
                      (this._z = Math.atan2(-s, r)))
                    : ((this._x = Math.atan2(u, l)), (this._z = 0));
                break;
              case "YXZ":
                (this._x = Math.asin(-ht(c, -1, 1))),
                  Math.abs(c) < 0.9999999
                    ? ((this._y = Math.atan2(a, d)),
                      (this._z = Math.atan2(o, l)))
                    : ((this._y = Math.atan2(-h, r)), (this._z = 0));
                break;
              case "ZXY":
                (this._x = Math.asin(ht(u, -1, 1))),
                  Math.abs(u) < 0.9999999
                    ? ((this._y = Math.atan2(-h, d)),
                      (this._z = Math.atan2(-s, l)))
                    : ((this._y = 0), (this._z = Math.atan2(o, r)));
                break;
              case "ZYX":
                (this._y = Math.asin(-ht(h, -1, 1))),
                  Math.abs(h) < 0.9999999
                    ? ((this._x = Math.atan2(u, d)),
                      (this._z = Math.atan2(o, r)))
                    : ((this._x = 0), (this._z = Math.atan2(-s, l)));
                break;
              case "YZX":
                (this._z = Math.asin(ht(o, -1, 1))),
                  Math.abs(o) < 0.9999999
                    ? ((this._x = Math.atan2(-c, l)),
                      (this._y = Math.atan2(-h, r)))
                    : ((this._x = 0), (this._y = Math.atan2(a, d)));
                break;
              case "XZY":
                (this._z = Math.asin(-ht(s, -1, 1))),
                  Math.abs(s) < 0.9999999
                    ? ((this._x = Math.atan2(u, l)),
                      (this._y = Math.atan2(a, r)))
                    : ((this._x = Math.atan2(-c, d)), (this._y = 0));
                break;
              default:
                console.warn(
                  "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                    e
                );
            }
            return (
              (this._order = e), !1 !== n && this._onChangeCallback(), this
            );
          }
          setFromQuaternion(t, e, n) {
            return (
              pe.makeRotationFromQuaternion(t),
              this.setFromRotationMatrix(pe, e, n)
            );
          }
          setFromVector3(t, e) {
            return this.set(t.x, t.y, t.z, e || this._order);
          }
          reorder(t) {
            return me.setFromEuler(this), this.setFromQuaternion(me, t);
          }
          equals(t) {
            return (
              t._x === this._x &&
              t._y === this._y &&
              t._z === this._z &&
              t._order === this._order
            );
          }
          fromArray(t) {
            return (
              (this._x = t[0]),
              (this._y = t[1]),
              (this._z = t[2]),
              void 0 !== t[3] && (this._order = t[3]),
              this._onChangeCallback(),
              this
            );
          }
          toArray(t = [], e = 0) {
            return (
              (t[e] = this._x),
              (t[e + 1] = this._y),
              (t[e + 2] = this._z),
              (t[e + 3] = this._order),
              t
            );
          }
          toVector3(t) {
            return t
              ? t.set(this._x, this._y, this._z)
              : new Lt(this._x, this._y, this._z);
          }
          _onChange(t) {
            return (this._onChangeCallback = t), this;
          }
          _onChangeCallback() {}
        }
        (fe.prototype.isEuler = !0),
          (fe.DefaultOrder = "XYZ"),
          (fe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]);
        class ge {
          constructor() {
            this.mask = 1;
          }
          set(t) {
            this.mask = (1 << t) | 0;
          }
          enable(t) {
            this.mask |= (1 << t) | 0;
          }
          enableAll() {
            this.mask = -1;
          }
          toggle(t) {
            this.mask ^= (1 << t) | 0;
          }
          disable(t) {
            this.mask &= ~((1 << t) | 0);
          }
          disableAll() {
            this.mask = 0;
          }
          test(t) {
            return 0 != (this.mask & t.mask);
          }
        }
        let ve = 0;
        const ye = new Lt(),
          xe = new At(),
          _e = new se(),
          we = new Lt(),
          be = new Lt(),
          Me = new Lt(),
          Se = new At(),
          Te = new Lt(1, 0, 0),
          Ee = new Lt(0, 1, 0),
          Ae = new Lt(0, 0, 1),
          Le = { type: "added" },
          Re = { type: "removed" };
        class Ce extends rt {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: ve++ }),
              (this.uuid = ct()),
              (this.name = ""),
              (this.type = "Object3D"),
              (this.parent = null),
              (this.children = []),
              (this.up = Ce.DefaultUp.clone());
            const t = new Lt(),
              e = new fe(),
              n = new At(),
              i = new Lt(1, 1, 1);
            e._onChange(function () {
              n.setFromEuler(e, !1);
            }),
              n._onChange(function () {
                e.setFromQuaternion(n, void 0, !1);
              }),
              Object.defineProperties(this, {
                position: { configurable: !0, enumerable: !0, value: t },
                rotation: { configurable: !0, enumerable: !0, value: e },
                quaternion: { configurable: !0, enumerable: !0, value: n },
                scale: { configurable: !0, enumerable: !0, value: i },
                modelViewMatrix: { value: new se() },
                normalMatrix: { value: new yt() },
              }),
              (this.matrix = new se()),
              (this.matrixWorld = new se()),
              (this.matrixAutoUpdate = Ce.DefaultMatrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = !1),
              (this.layers = new ge()),
              (this.visible = !0),
              (this.castShadow = !1),
              (this.receiveShadow = !1),
              (this.frustumCulled = !0),
              (this.renderOrder = 0),
              (this.animations = []),
              (this.userData = {});
          }
          onBeforeRender() {}
          onAfterRender() {}
          applyMatrix4(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              this.matrix.premultiply(t),
              this.matrix.decompose(this.position, this.quaternion, this.scale);
          }
          applyQuaternion(t) {
            return this.quaternion.premultiply(t), this;
          }
          setRotationFromAxisAngle(t, e) {
            this.quaternion.setFromAxisAngle(t, e);
          }
          setRotationFromEuler(t) {
            this.quaternion.setFromEuler(t, !0);
          }
          setRotationFromMatrix(t) {
            this.quaternion.setFromRotationMatrix(t);
          }
          setRotationFromQuaternion(t) {
            this.quaternion.copy(t);
          }
          rotateOnAxis(t, e) {
            return (
              xe.setFromAxisAngle(t, e), this.quaternion.multiply(xe), this
            );
          }
          rotateOnWorldAxis(t, e) {
            return (
              xe.setFromAxisAngle(t, e), this.quaternion.premultiply(xe), this
            );
          }
          rotateX(t) {
            return this.rotateOnAxis(Te, t);
          }
          rotateY(t) {
            return this.rotateOnAxis(Ee, t);
          }
          rotateZ(t) {
            return this.rotateOnAxis(Ae, t);
          }
          translateOnAxis(t, e) {
            return (
              ye.copy(t).applyQuaternion(this.quaternion),
              this.position.add(ye.multiplyScalar(e)),
              this
            );
          }
          translateX(t) {
            return this.translateOnAxis(Te, t);
          }
          translateY(t) {
            return this.translateOnAxis(Ee, t);
          }
          translateZ(t) {
            return this.translateOnAxis(Ae, t);
          }
          localToWorld(t) {
            return t.applyMatrix4(this.matrixWorld);
          }
          worldToLocal(t) {
            return t.applyMatrix4(_e.copy(this.matrixWorld).invert());
          }
          lookAt(t, e, n) {
            t.isVector3 ? we.copy(t) : we.set(t, e, n);
            const i = this.parent;
            this.updateWorldMatrix(!0, !1),
              be.setFromMatrixPosition(this.matrixWorld),
              this.isCamera || this.isLight
                ? _e.lookAt(be, we, this.up)
                : _e.lookAt(we, be, this.up),
              this.quaternion.setFromRotationMatrix(_e),
              i &&
                (_e.extractRotation(i.matrixWorld),
                xe.setFromRotationMatrix(_e),
                this.quaternion.premultiply(xe.invert()));
          }
          add(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
              return this;
            }
            return t === this
              ? (console.error(
                  "THREE.Object3D.add: object can't be added as a child of itself.",
                  t
                ),
                this)
              : (t && t.isObject3D
                  ? (null !== t.parent && t.parent.remove(t),
                    (t.parent = this),
                    this.children.push(t),
                    t.dispatchEvent(Le))
                  : console.error(
                      "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                      t
                    ),
                this);
          }
          remove(t) {
            if (arguments.length > 1) {
              for (let t = 0; t < arguments.length; t++)
                this.remove(arguments[t]);
              return this;
            }
            const e = this.children.indexOf(t);
            return (
              -1 !== e &&
                ((t.parent = null),
                this.children.splice(e, 1),
                t.dispatchEvent(Re)),
              this
            );
          }
          clear() {
            for (let t = 0; t < this.children.length; t++) {
              const e = this.children[t];
              (e.parent = null), e.dispatchEvent(Re);
            }
            return (this.children.length = 0), this;
          }
          attach(t) {
            return (
              this.updateWorldMatrix(!0, !1),
              _e.copy(this.matrixWorld).invert(),
              null !== t.parent &&
                (t.parent.updateWorldMatrix(!0, !1),
                _e.multiply(t.parent.matrixWorld)),
              t.applyMatrix4(_e),
              this.add(t),
              t.updateWorldMatrix(!1, !0),
              this
            );
          }
          getObjectById(t) {
            return this.getObjectByProperty("id", t);
          }
          getObjectByName(t) {
            return this.getObjectByProperty("name", t);
          }
          getObjectByProperty(t, e) {
            if (this[t] === e) return this;
            for (let n = 0, i = this.children.length; n < i; n++) {
              const i = this.children[n].getObjectByProperty(t, e);
              if (void 0 !== i) return i;
            }
          }
          getWorldPosition(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Object3D: .getWorldPosition() target is now required"
                ),
                (t = new Lt())),
              this.updateWorldMatrix(!0, !1),
              t.setFromMatrixPosition(this.matrixWorld)
            );
          }
          getWorldQuaternion(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Object3D: .getWorldQuaternion() target is now required"
                ),
                (t = new At())),
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(be, t, Me),
              t
            );
          }
          getWorldScale(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Object3D: .getWorldScale() target is now required"
                ),
                (t = new Lt())),
              this.updateWorldMatrix(!0, !1),
              this.matrixWorld.decompose(be, Se, t),
              t
            );
          }
          getWorldDirection(t) {
            void 0 === t &&
              (console.warn(
                "THREE.Object3D: .getWorldDirection() target is now required"
              ),
              (t = new Lt())),
              this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize();
          }
          raycast() {}
          traverse(t) {
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
          }
          traverseVisible(t) {
            if (!1 === this.visible) return;
            t(this);
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
          }
          traverseAncestors(t) {
            const e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t));
          }
          updateMatrix() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
              (this.matrixWorldNeedsUpdate = !0);
          }
          updateMatrixWorld(t) {
            this.matrixAutoUpdate && this.updateMatrix(),
              (this.matrixWorldNeedsUpdate || t) &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    ),
                (this.matrixWorldNeedsUpdate = !1),
                (t = !0));
            const e = this.children;
            for (let n = 0, i = e.length; n < i; n++) e[n].updateMatrixWorld(t);
          }
          updateWorldMatrix(t, e) {
            const n = this.parent;
            if (
              (!0 === t && null !== n && n.updateWorldMatrix(!0, !1),
              this.matrixAutoUpdate && this.updateMatrix(),
              null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  ),
              !0 === e)
            ) {
              const t = this.children;
              for (let e = 0, n = t.length; e < n; e++)
                t[e].updateWorldMatrix(!1, !0);
            }
          }
          toJSON(t) {
            const e = void 0 === t || "string" == typeof t,
              n = {};
            e &&
              ((t = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {},
              }),
              (n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON",
              }));
            const i = {};
            function r(e, n) {
              return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
            }
            if (
              ((i.uuid = this.uuid),
              (i.type = this.type),
              "" !== this.name && (i.name = this.name),
              !0 === this.castShadow && (i.castShadow = !0),
              !0 === this.receiveShadow && (i.receiveShadow = !0),
              !1 === this.visible && (i.visible = !1),
              !1 === this.frustumCulled && (i.frustumCulled = !1),
              0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
              "{}" !== JSON.stringify(this.userData) &&
                (i.userData = this.userData),
              (i.layers = this.layers.mask),
              (i.matrix = this.matrix.toArray()),
              !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
              this.isInstancedMesh &&
                ((i.type = "InstancedMesh"),
                (i.count = this.count),
                (i.instanceMatrix = this.instanceMatrix.toJSON()),
                null !== this.instanceColor &&
                  (i.instanceColor = this.instanceColor.toJSON())),
              this.isMesh || this.isLine || this.isPoints)
            ) {
              i.geometry = r(t.geometries, this.geometry);
              const e = this.geometry.parameters;
              if (void 0 !== e && void 0 !== e.shapes) {
                const n = e.shapes;
                if (Array.isArray(n))
                  for (let e = 0, i = n.length; e < i; e++) {
                    const i = n[e];
                    r(t.shapes, i);
                  }
                else r(t.shapes, n);
              }
            }
            if (
              (this.isSkinnedMesh &&
                ((i.bindMode = this.bindMode),
                (i.bindMatrix = this.bindMatrix.toArray()),
                void 0 !== this.skeleton &&
                  (r(t.skeletons, this.skeleton),
                  (i.skeleton = this.skeleton.uuid))),
              void 0 !== this.material)
            )
              if (Array.isArray(this.material)) {
                const e = [];
                for (let n = 0, i = this.material.length; n < i; n++)
                  e.push(r(t.materials, this.material[n]));
                i.material = e;
              } else i.material = r(t.materials, this.material);
            if (this.children.length > 0) {
              i.children = [];
              for (let e = 0; e < this.children.length; e++)
                i.children.push(this.children[e].toJSON(t).object);
            }
            if (this.animations.length > 0) {
              i.animations = [];
              for (let e = 0; e < this.animations.length; e++) {
                const n = this.animations[e];
                i.animations.push(r(t.animations, n));
              }
            }
            if (e) {
              const e = s(t.geometries),
                i = s(t.materials),
                r = s(t.textures),
                a = s(t.images),
                o = s(t.shapes),
                l = s(t.skeletons),
                c = s(t.animations);
              e.length > 0 && (n.geometries = e),
                i.length > 0 && (n.materials = i),
                r.length > 0 && (n.textures = r),
                a.length > 0 && (n.images = a),
                o.length > 0 && (n.shapes = o),
                l.length > 0 && (n.skeletons = l),
                c.length > 0 && (n.animations = c);
            }
            return (n.object = i), n;
            function s(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
          }
          clone(t) {
            return new this.constructor().copy(this, t);
          }
          copy(t, e = !0) {
            if (
              ((this.name = t.name),
              this.up.copy(t.up),
              this.position.copy(t.position),
              (this.rotation.order = t.rotation.order),
              this.quaternion.copy(t.quaternion),
              this.scale.copy(t.scale),
              this.matrix.copy(t.matrix),
              this.matrixWorld.copy(t.matrixWorld),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
              (this.layers.mask = t.layers.mask),
              (this.visible = t.visible),
              (this.castShadow = t.castShadow),
              (this.receiveShadow = t.receiveShadow),
              (this.frustumCulled = t.frustumCulled),
              (this.renderOrder = t.renderOrder),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              !0 === e)
            )
              for (let e = 0; e < t.children.length; e++) {
                const n = t.children[e];
                this.add(n.clone());
              }
            return this;
          }
        }
        (Ce.DefaultUp = new Lt(0, 1, 0)),
          (Ce.DefaultMatrixAutoUpdate = !0),
          (Ce.prototype.isObject3D = !0);
        const Pe = new Lt(),
          De = new Lt(),
          Ie = new yt();
        class Ne {
          constructor(t = new Lt(1, 0, 0), e = 0) {
            (this.normal = t), (this.constant = e);
          }
          set(t, e) {
            return this.normal.copy(t), (this.constant = e), this;
          }
          setComponents(t, e, n, i) {
            return this.normal.set(t, e, n), (this.constant = i), this;
          }
          setFromNormalAndCoplanarPoint(t, e) {
            return (
              this.normal.copy(t), (this.constant = -e.dot(this.normal)), this
            );
          }
          setFromCoplanarPoints(t, e, n) {
            const i = Pe.subVectors(n, e)
              .cross(De.subVectors(t, e))
              .normalize();
            return this.setFromNormalAndCoplanarPoint(i, t), this;
          }
          copy(t) {
            return (
              this.normal.copy(t.normal), (this.constant = t.constant), this
            );
          }
          normalize() {
            const t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), (this.constant *= t), this;
          }
          negate() {
            return (this.constant *= -1), this.normal.negate(), this;
          }
          distanceToPoint(t) {
            return this.normal.dot(t) + this.constant;
          }
          distanceToSphere(t) {
            return this.distanceToPoint(t.center) - t.radius;
          }
          projectPoint(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Plane: .projectPoint() target is now required"
                ),
                (e = new Lt())),
              e
                .copy(this.normal)
                .multiplyScalar(-this.distanceToPoint(t))
                .add(t)
            );
          }
          intersectLine(t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Plane: .intersectLine() target is now required"
              ),
              (e = new Lt()));
            const n = t.delta(Pe),
              i = this.normal.dot(n);
            if (0 === i)
              return 0 === this.distanceToPoint(t.start)
                ? e.copy(t.start)
                : null;
            const r = -(t.start.dot(this.normal) + this.constant) / i;
            return r < 0 || r > 1
              ? null
              : e.copy(n).multiplyScalar(r).add(t.start);
          }
          intersectsLine(t) {
            const e = this.distanceToPoint(t.start),
              n = this.distanceToPoint(t.end);
            return (e < 0 && n > 0) || (n < 0 && e > 0);
          }
          intersectsBox(t) {
            return t.intersectsPlane(this);
          }
          intersectsSphere(t) {
            return t.intersectsPlane(this);
          }
          coplanarPoint(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Plane: .coplanarPoint() target is now required"
                ),
                (t = new Lt())),
              t.copy(this.normal).multiplyScalar(-this.constant)
            );
          }
          applyMatrix4(t, e) {
            const n = e || Ie.getNormalMatrix(t),
              i = this.coplanarPoint(Pe).applyMatrix4(t),
              r = this.normal.applyMatrix3(n).normalize();
            return (this.constant = -i.dot(r)), this;
          }
          translate(t) {
            return (this.constant -= t.dot(this.normal)), this;
          }
          equals(t) {
            return t.normal.equals(this.normal) && t.constant === this.constant;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        Ne.prototype.isPlane = !0;
        const Be = new Lt(),
          ze = new Lt(),
          Fe = new Lt(),
          Oe = new Lt(),
          He = new Lt(),
          Ge = new Lt(),
          Ue = new Lt(),
          ke = new Lt(),
          Ve = new Lt(),
          We = new Lt();
        class je {
          constructor(t = new Lt(), e = new Lt(), n = new Lt()) {
            (this.a = t), (this.b = e), (this.c = n);
          }
          static getNormal(t, e, n, i) {
            void 0 === i &&
              (console.warn(
                "THREE.Triangle: .getNormal() target is now required"
              ),
              (i = new Lt())),
              i.subVectors(n, e),
              Be.subVectors(t, e),
              i.cross(Be);
            const r = i.lengthSq();
            return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
          }
          static getBarycoord(t, e, n, i, r) {
            Be.subVectors(i, e), ze.subVectors(n, e), Fe.subVectors(t, e);
            const s = Be.dot(Be),
              a = Be.dot(ze),
              o = Be.dot(Fe),
              l = ze.dot(ze),
              c = ze.dot(Fe),
              h = s * l - a * a;
            if (
              (void 0 === r &&
                (console.warn(
                  "THREE.Triangle: .getBarycoord() target is now required"
                ),
                (r = new Lt())),
              0 === h)
            )
              return r.set(-2, -1, -1);
            const u = 1 / h,
              d = (l * o - a * c) * u,
              p = (s * c - a * o) * u;
            return r.set(1 - d - p, p, d);
          }
          static containsPoint(t, e, n, i) {
            return (
              this.getBarycoord(t, e, n, i, Oe),
              Oe.x >= 0 && Oe.y >= 0 && Oe.x + Oe.y <= 1
            );
          }
          static getUV(t, e, n, i, r, s, a, o) {
            return (
              this.getBarycoord(t, e, n, i, Oe),
              o.set(0, 0),
              o.addScaledVector(r, Oe.x),
              o.addScaledVector(s, Oe.y),
              o.addScaledVector(a, Oe.z),
              o
            );
          }
          static isFrontFacing(t, e, n, i) {
            return (
              Be.subVectors(n, e), ze.subVectors(t, e), Be.cross(ze).dot(i) < 0
            );
          }
          set(t, e, n) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
          }
          setFromPointsAndIndices(t, e, n, i) {
            return (
              this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
          }
          getArea() {
            return (
              Be.subVectors(this.c, this.b),
              ze.subVectors(this.a, this.b),
              0.5 * Be.cross(ze).length()
            );
          }
          getMidpoint(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Triangle: .getMidpoint() target is now required"
                ),
                (t = new Lt())),
              t
                .addVectors(this.a, this.b)
                .add(this.c)
                .multiplyScalar(1 / 3)
            );
          }
          getNormal(t) {
            return je.getNormal(this.a, this.b, this.c, t);
          }
          getPlane(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Triangle: .getPlane() target is now required"
                ),
                (t = new Ne())),
              t.setFromCoplanarPoints(this.a, this.b, this.c)
            );
          }
          getBarycoord(t, e) {
            return je.getBarycoord(t, this.a, this.b, this.c, e);
          }
          getUV(t, e, n, i, r) {
            return je.getUV(t, this.a, this.b, this.c, e, n, i, r);
          }
          containsPoint(t) {
            return je.containsPoint(t, this.a, this.b, this.c);
          }
          isFrontFacing(t) {
            return je.isFrontFacing(this.a, this.b, this.c, t);
          }
          intersectsBox(t) {
            return t.intersectsTriangle(this);
          }
          closestPointToPoint(t, e) {
            void 0 === e &&
              (console.warn(
                "THREE.Triangle: .closestPointToPoint() target is now required"
              ),
              (e = new Lt()));
            const n = this.a,
              i = this.b,
              r = this.c;
            let s, a;
            He.subVectors(i, n), Ge.subVectors(r, n), ke.subVectors(t, n);
            const o = He.dot(ke),
              l = Ge.dot(ke);
            if (o <= 0 && l <= 0) return e.copy(n);
            Ve.subVectors(t, i);
            const c = He.dot(Ve),
              h = Ge.dot(Ve);
            if (c >= 0 && h <= c) return e.copy(i);
            const u = o * h - c * l;
            if (u <= 0 && o >= 0 && c <= 0)
              return (s = o / (o - c)), e.copy(n).addScaledVector(He, s);
            We.subVectors(t, r);
            const d = He.dot(We),
              p = Ge.dot(We);
            if (p >= 0 && d <= p) return e.copy(r);
            const m = d * l - o * p;
            if (m <= 0 && l >= 0 && p <= 0)
              return (a = l / (l - p)), e.copy(n).addScaledVector(Ge, a);
            const f = c * p - d * h;
            if (f <= 0 && h - c >= 0 && d - p >= 0)
              return (
                Ue.subVectors(r, i),
                (a = (h - c) / (h - c + (d - p))),
                e.copy(i).addScaledVector(Ue, a)
              );
            const g = 1 / (f + m + u);
            return (
              (s = m * g),
              (a = u * g),
              e.copy(n).addScaledVector(He, s).addScaledVector(Ge, a)
            );
          }
          equals(t) {
            return (
              t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
            );
          }
        }
        let qe = 0;
        function Xe() {
          Object.defineProperty(this, "id", { value: qe++ }),
            (this.uuid = ct()),
            (this.name = ""),
            (this.type = "Material"),
            (this.fog = !0),
            (this.blending = 1),
            (this.side = 0),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = n),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.depthFunc = 3),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = tt),
            (this.stencilZFail = tt),
            (this.stencilZPass = tt),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaTest = 0),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0);
        }
        (Xe.prototype = Object.assign(Object.create(rt.prototype), {
          constructor: Xe,
          isMaterial: !0,
          onBuild: function () {},
          onBeforeCompile: function () {},
          customProgramCacheKey: function () {
            return this.onBeforeCompile.toString();
          },
          setValues: function (t) {
            if (void 0 !== t)
              for (const e in t) {
                const n = t[e];
                if (void 0 === n) {
                  console.warn(
                    "THREE.Material: '" + e + "' parameter is undefined."
                  );
                  continue;
                }
                if ("shading" === e) {
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .shading has been removed. Use the boolean .flatShading instead."
                  ),
                    (this.flatShading = 1 === n);
                  continue;
                }
                const i = this[e];
                void 0 !== i
                  ? i && i.isColor
                    ? i.set(n)
                    : i && i.isVector3 && n && n.isVector3
                    ? i.copy(n)
                    : (this[e] = n)
                  : console.warn(
                      "THREE." +
                        this.type +
                        ": '" +
                        e +
                        "' is not a property of this material."
                    );
              }
          },
          toJSON: function (t) {
            const e = void 0 === t || "string" == typeof t;
            e && (t = { textures: {}, images: {} });
            const n = {
              metadata: {
                version: 4.5,
                type: "Material",
                generator: "Material.toJSON",
              },
            };
            function i(t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                delete i.metadata, e.push(i);
              }
              return e;
            }
            if (
              ((n.uuid = this.uuid),
              (n.type = this.type),
              "" !== this.name && (n.name = this.name),
              this.color &&
                this.color.isColor &&
                (n.color = this.color.getHex()),
              void 0 !== this.roughness && (n.roughness = this.roughness),
              void 0 !== this.metalness && (n.metalness = this.metalness),
              this.sheen &&
                this.sheen.isColor &&
                (n.sheen = this.sheen.getHex()),
              this.emissive &&
                this.emissive.isColor &&
                (n.emissive = this.emissive.getHex()),
              this.emissiveIntensity &&
                1 !== this.emissiveIntensity &&
                (n.emissiveIntensity = this.emissiveIntensity),
              this.specular &&
                this.specular.isColor &&
                (n.specular = this.specular.getHex()),
              void 0 !== this.shininess && (n.shininess = this.shininess),
              void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
              void 0 !== this.clearcoatRoughness &&
                (n.clearcoatRoughness = this.clearcoatRoughness),
              this.clearcoatMap &&
                this.clearcoatMap.isTexture &&
                (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
              this.clearcoatRoughnessMap &&
                this.clearcoatRoughnessMap.isTexture &&
                (n.clearcoatRoughnessMap =
                  this.clearcoatRoughnessMap.toJSON(t).uuid),
              this.clearcoatNormalMap &&
                this.clearcoatNormalMap.isTexture &&
                ((n.clearcoatNormalMap =
                  this.clearcoatNormalMap.toJSON(t).uuid),
                (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
              this.map &&
                this.map.isTexture &&
                (n.map = this.map.toJSON(t).uuid),
              this.matcap &&
                this.matcap.isTexture &&
                (n.matcap = this.matcap.toJSON(t).uuid),
              this.alphaMap &&
                this.alphaMap.isTexture &&
                (n.alphaMap = this.alphaMap.toJSON(t).uuid),
              this.lightMap &&
                this.lightMap.isTexture &&
                ((n.lightMap = this.lightMap.toJSON(t).uuid),
                (n.lightMapIntensity = this.lightMapIntensity)),
              this.aoMap &&
                this.aoMap.isTexture &&
                ((n.aoMap = this.aoMap.toJSON(t).uuid),
                (n.aoMapIntensity = this.aoMapIntensity)),
              this.bumpMap &&
                this.bumpMap.isTexture &&
                ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
                (n.bumpScale = this.bumpScale)),
              this.normalMap &&
                this.normalMap.isTexture &&
                ((n.normalMap = this.normalMap.toJSON(t).uuid),
                (n.normalMapType = this.normalMapType),
                (n.normalScale = this.normalScale.toArray())),
              this.displacementMap &&
                this.displacementMap.isTexture &&
                ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
                (n.displacementScale = this.displacementScale),
                (n.displacementBias = this.displacementBias)),
              this.roughnessMap &&
                this.roughnessMap.isTexture &&
                (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
              this.metalnessMap &&
                this.metalnessMap.isTexture &&
                (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
              this.emissiveMap &&
                this.emissiveMap.isTexture &&
                (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
              this.specularMap &&
                this.specularMap.isTexture &&
                (n.specularMap = this.specularMap.toJSON(t).uuid),
              this.envMap &&
                this.envMap.isTexture &&
                ((n.envMap = this.envMap.toJSON(t).uuid),
                void 0 !== this.combine && (n.combine = this.combine)),
              void 0 !== this.envMapIntensity &&
                (n.envMapIntensity = this.envMapIntensity),
              void 0 !== this.reflectivity &&
                (n.reflectivity = this.reflectivity),
              void 0 !== this.refractionRatio &&
                (n.refractionRatio = this.refractionRatio),
              this.gradientMap &&
                this.gradientMap.isTexture &&
                (n.gradientMap = this.gradientMap.toJSON(t).uuid),
              void 0 !== this.size && (n.size = this.size),
              null !== this.shadowSide && (n.shadowSide = this.shadowSide),
              void 0 !== this.sizeAttenuation &&
                (n.sizeAttenuation = this.sizeAttenuation),
              1 !== this.blending && (n.blending = this.blending),
              0 !== this.side && (n.side = this.side),
              this.vertexColors && (n.vertexColors = !0),
              this.opacity < 1 && (n.opacity = this.opacity),
              !0 === this.transparent && (n.transparent = this.transparent),
              (n.depthFunc = this.depthFunc),
              (n.depthTest = this.depthTest),
              (n.depthWrite = this.depthWrite),
              (n.colorWrite = this.colorWrite),
              (n.stencilWrite = this.stencilWrite),
              (n.stencilWriteMask = this.stencilWriteMask),
              (n.stencilFunc = this.stencilFunc),
              (n.stencilRef = this.stencilRef),
              (n.stencilFuncMask = this.stencilFuncMask),
              (n.stencilFail = this.stencilFail),
              (n.stencilZFail = this.stencilZFail),
              (n.stencilZPass = this.stencilZPass),
              this.rotation &&
                0 !== this.rotation &&
                (n.rotation = this.rotation),
              !0 === this.polygonOffset && (n.polygonOffset = !0),
              0 !== this.polygonOffsetFactor &&
                (n.polygonOffsetFactor = this.polygonOffsetFactor),
              0 !== this.polygonOffsetUnits &&
                (n.polygonOffsetUnits = this.polygonOffsetUnits),
              this.linewidth &&
                1 !== this.linewidth &&
                (n.linewidth = this.linewidth),
              void 0 !== this.dashSize && (n.dashSize = this.dashSize),
              void 0 !== this.gapSize && (n.gapSize = this.gapSize),
              void 0 !== this.scale && (n.scale = this.scale),
              !0 === this.dithering && (n.dithering = !0),
              this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
              !0 === this.alphaToCoverage &&
                (n.alphaToCoverage = this.alphaToCoverage),
              !0 === this.premultipliedAlpha &&
                (n.premultipliedAlpha = this.premultipliedAlpha),
              !0 === this.wireframe && (n.wireframe = this.wireframe),
              this.wireframeLinewidth > 1 &&
                (n.wireframeLinewidth = this.wireframeLinewidth),
              "round" !== this.wireframeLinecap &&
                (n.wireframeLinecap = this.wireframeLinecap),
              "round" !== this.wireframeLinejoin &&
                (n.wireframeLinejoin = this.wireframeLinejoin),
              !0 === this.morphTargets && (n.morphTargets = !0),
              !0 === this.morphNormals && (n.morphNormals = !0),
              !0 === this.skinning && (n.skinning = !0),
              !0 === this.flatShading && (n.flatShading = this.flatShading),
              !1 === this.visible && (n.visible = !1),
              !1 === this.toneMapped && (n.toneMapped = !1),
              "{}" !== JSON.stringify(this.userData) &&
                (n.userData = this.userData),
              e)
            ) {
              const e = i(t.textures),
                r = i(t.images);
              e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
            }
            return n;
          },
          clone: function () {
            return new this.constructor().copy(this);
          },
          copy: function (t) {
            (this.name = t.name),
              (this.fog = t.fog),
              (this.blending = t.blending),
              (this.side = t.side),
              (this.vertexColors = t.vertexColors),
              (this.opacity = t.opacity),
              (this.transparent = t.transparent),
              (this.blendSrc = t.blendSrc),
              (this.blendDst = t.blendDst),
              (this.blendEquation = t.blendEquation),
              (this.blendSrcAlpha = t.blendSrcAlpha),
              (this.blendDstAlpha = t.blendDstAlpha),
              (this.blendEquationAlpha = t.blendEquationAlpha),
              (this.depthFunc = t.depthFunc),
              (this.depthTest = t.depthTest),
              (this.depthWrite = t.depthWrite),
              (this.stencilWriteMask = t.stencilWriteMask),
              (this.stencilFunc = t.stencilFunc),
              (this.stencilRef = t.stencilRef),
              (this.stencilFuncMask = t.stencilFuncMask),
              (this.stencilFail = t.stencilFail),
              (this.stencilZFail = t.stencilZFail),
              (this.stencilZPass = t.stencilZPass),
              (this.stencilWrite = t.stencilWrite);
            const e = t.clippingPlanes;
            let n = null;
            if (null !== e) {
              const t = e.length;
              n = new Array(t);
              for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
            }
            return (
              (this.clippingPlanes = n),
              (this.clipIntersection = t.clipIntersection),
              (this.clipShadows = t.clipShadows),
              (this.shadowSide = t.shadowSide),
              (this.colorWrite = t.colorWrite),
              (this.precision = t.precision),
              (this.polygonOffset = t.polygonOffset),
              (this.polygonOffsetFactor = t.polygonOffsetFactor),
              (this.polygonOffsetUnits = t.polygonOffsetUnits),
              (this.dithering = t.dithering),
              (this.alphaTest = t.alphaTest),
              (this.alphaToCoverage = t.alphaToCoverage),
              (this.premultipliedAlpha = t.premultipliedAlpha),
              (this.visible = t.visible),
              (this.toneMapped = t.toneMapped),
              (this.userData = JSON.parse(JSON.stringify(t.userData))),
              this
            );
          },
          dispose: function () {
            this.dispatchEvent({ type: "dispose" });
          },
        })),
          Object.defineProperty(Xe.prototype, "needsUpdate", {
            set: function (t) {
              !0 === t && this.version++;
            },
          });
        const Ye = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074,
          },
          Ze = { h: 0, s: 0, l: 0 },
          Je = { h: 0, s: 0, l: 0 };
        function Qe(t, e, n) {
          return (
            n < 0 && (n += 1),
            n > 1 && (n -= 1),
            n < 1 / 6
              ? t + 6 * (e - t) * n
              : n < 0.5
              ? e
              : n < 2 / 3
              ? t + 6 * (e - t) * (2 / 3 - n)
              : t
          );
        }
        function Ke(t) {
          return t < 0.04045
            ? 0.0773993808 * t
            : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
        }
        function $e(t) {
          return t < 0.0031308
            ? 12.92 * t
            : 1.055 * Math.pow(t, 0.41666) - 0.055;
        }
        class tn {
          constructor(t, e, n) {
            return void 0 === e && void 0 === n
              ? this.set(t)
              : this.setRGB(t, e, n);
          }
          set(t) {
            return (
              t && t.isColor
                ? this.copy(t)
                : "number" == typeof t
                ? this.setHex(t)
                : "string" == typeof t && this.setStyle(t),
              this
            );
          }
          setScalar(t) {
            return (this.r = t), (this.g = t), (this.b = t), this;
          }
          setHex(t) {
            return (
              (t = Math.floor(t)),
              (this.r = ((t >> 16) & 255) / 255),
              (this.g = ((t >> 8) & 255) / 255),
              (this.b = (255 & t) / 255),
              this
            );
          }
          setRGB(t, e, n) {
            return (this.r = t), (this.g = e), (this.b = n), this;
          }
          setHSL(t, e, n) {
            if (((t = ut(t, 1)), (e = ht(e, 0, 1)), (n = ht(n, 0, 1)), 0 === e))
              this.r = this.g = this.b = n;
            else {
              const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
                r = 2 * n - i;
              (this.r = Qe(r, i, t + 1 / 3)),
                (this.g = Qe(r, i, t)),
                (this.b = Qe(r, i, t - 1 / 3));
            }
            return this;
          }
          setStyle(t) {
            function e(e) {
              void 0 !== e &&
                parseFloat(e) < 1 &&
                console.warn(
                  "THREE.Color: Alpha component of " + t + " will be ignored."
                );
            }
            let n;
            if ((n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t))) {
              let t;
              const i = n[1],
                r = n[2];
              switch (i) {
                case "rgb":
                case "rgba":
                  if (
                    (t =
                      /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        r
                      ))
                  )
                    return (
                      (this.r = Math.min(255, parseInt(t[1], 10)) / 255),
                      (this.g = Math.min(255, parseInt(t[2], 10)) / 255),
                      (this.b = Math.min(255, parseInt(t[3], 10)) / 255),
                      e(t[4]),
                      this
                    );
                  if (
                    (t =
                      /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        r
                      ))
                  )
                    return (
                      (this.r = Math.min(100, parseInt(t[1], 10)) / 100),
                      (this.g = Math.min(100, parseInt(t[2], 10)) / 100),
                      (this.b = Math.min(100, parseInt(t[3], 10)) / 100),
                      e(t[4]),
                      this
                    );
                  break;
                case "hsl":
                case "hsla":
                  if (
                    (t =
                      /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                        r
                      ))
                  ) {
                    const n = parseFloat(t[1]) / 360,
                      i = parseInt(t[2], 10) / 100,
                      r = parseInt(t[3], 10) / 100;
                    return e(t[4]), this.setHSL(n, i, r);
                  }
              }
            } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(t))) {
              const t = n[1],
                e = t.length;
              if (3 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255),
                  (this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255),
                  (this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255),
                  this
                );
              if (6 === e)
                return (
                  (this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255),
                  (this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255),
                  (this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255),
                  this
                );
            }
            return t && t.length > 0 ? this.setColorName(t) : this;
          }
          setColorName(t) {
            const e = Ye[t.toLowerCase()];
            return (
              void 0 !== e
                ? this.setHex(e)
                : console.warn("THREE.Color: Unknown color " + t),
              this
            );
          }
          clone() {
            return new this.constructor(this.r, this.g, this.b);
          }
          copy(t) {
            return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
          }
          copyGammaToLinear(t, e = 2) {
            return (
              (this.r = Math.pow(t.r, e)),
              (this.g = Math.pow(t.g, e)),
              (this.b = Math.pow(t.b, e)),
              this
            );
          }
          copyLinearToGamma(t, e = 2) {
            const n = e > 0 ? 1 / e : 1;
            return (
              (this.r = Math.pow(t.r, n)),
              (this.g = Math.pow(t.g, n)),
              (this.b = Math.pow(t.b, n)),
              this
            );
          }
          convertGammaToLinear(t) {
            return this.copyGammaToLinear(this, t), this;
          }
          convertLinearToGamma(t) {
            return this.copyLinearToGamma(this, t), this;
          }
          copySRGBToLinear(t) {
            return (
              (this.r = Ke(t.r)), (this.g = Ke(t.g)), (this.b = Ke(t.b)), this
            );
          }
          copyLinearToSRGB(t) {
            return (
              (this.r = $e(t.r)), (this.g = $e(t.g)), (this.b = $e(t.b)), this
            );
          }
          convertSRGBToLinear() {
            return this.copySRGBToLinear(this), this;
          }
          convertLinearToSRGB() {
            return this.copyLinearToSRGB(this), this;
          }
          getHex() {
            return (
              ((255 * this.r) << 16) ^
              ((255 * this.g) << 8) ^
              ((255 * this.b) << 0)
            );
          }
          getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6);
          }
          getHSL(t) {
            void 0 === t &&
              (console.warn("THREE.Color: .getHSL() target is now required"),
              (t = { h: 0, s: 0, l: 0 }));
            const e = this.r,
              n = this.g,
              i = this.b,
              r = Math.max(e, n, i),
              s = Math.min(e, n, i);
            let a, o;
            const l = (s + r) / 2;
            if (s === r) (a = 0), (o = 0);
            else {
              const t = r - s;
              switch (((o = l <= 0.5 ? t / (r + s) : t / (2 - r - s)), r)) {
                case e:
                  a = (n - i) / t + (n < i ? 6 : 0);
                  break;
                case n:
                  a = (i - e) / t + 2;
                  break;
                case i:
                  a = (e - n) / t + 4;
              }
              a /= 6;
            }
            return (t.h = a), (t.s = o), (t.l = l), t;
          }
          getStyle() {
            return (
              "rgb(" +
              ((255 * this.r) | 0) +
              "," +
              ((255 * this.g) | 0) +
              "," +
              ((255 * this.b) | 0) +
              ")"
            );
          }
          offsetHSL(t, e, n) {
            return (
              this.getHSL(Ze),
              (Ze.h += t),
              (Ze.s += e),
              (Ze.l += n),
              this.setHSL(Ze.h, Ze.s, Ze.l),
              this
            );
          }
          add(t) {
            return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
          }
          addColors(t, e) {
            return (
              (this.r = t.r + e.r),
              (this.g = t.g + e.g),
              (this.b = t.b + e.b),
              this
            );
          }
          addScalar(t) {
            return (this.r += t), (this.g += t), (this.b += t), this;
          }
          sub(t) {
            return (
              (this.r = Math.max(0, this.r - t.r)),
              (this.g = Math.max(0, this.g - t.g)),
              (this.b = Math.max(0, this.b - t.b)),
              this
            );
          }
          multiply(t) {
            return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
          }
          multiplyScalar(t) {
            return (this.r *= t), (this.g *= t), (this.b *= t), this;
          }
          lerp(t, e) {
            return (
              (this.r += (t.r - this.r) * e),
              (this.g += (t.g - this.g) * e),
              (this.b += (t.b - this.b) * e),
              this
            );
          }
          lerpColors(t, e, n) {
            return (
              (this.r = t.r + (e.r - t.r) * n),
              (this.g = t.g + (e.g - t.g) * n),
              (this.b = t.b + (e.b - t.b) * n),
              this
            );
          }
          lerpHSL(t, e) {
            this.getHSL(Ze), t.getHSL(Je);
            const n = dt(Ze.h, Je.h, e),
              i = dt(Ze.s, Je.s, e),
              r = dt(Ze.l, Je.l, e);
            return this.setHSL(n, i, r), this;
          }
          equals(t) {
            return t.r === this.r && t.g === this.g && t.b === this.b;
          }
          fromArray(t, e = 0) {
            return (
              (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this
            );
          }
          toArray(t = [], e = 0) {
            return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
          }
          fromBufferAttribute(t, e) {
            return (
              (this.r = t.getX(e)),
              (this.g = t.getY(e)),
              (this.b = t.getZ(e)),
              !0 === t.normalized &&
                ((this.r /= 255), (this.g /= 255), (this.b /= 255)),
              this
            );
          }
          toJSON() {
            return this.getHex();
          }
        }
        (tn.NAMES = Ye),
          (tn.prototype.isColor = !0),
          (tn.prototype.r = 1),
          (tn.prototype.g = 1),
          (tn.prototype.b = 1);
        class en extends Xe {
          constructor(t) {
            super(),
              (this.type = "MeshBasicMaterial"),
              (this.color = new tn(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.skinning = !1),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        en.prototype.isMeshBasicMaterial = !0;
        const nn = new Lt(),
          rn = new vt();
        class sn {
          constructor(t, e, n) {
            if (Array.isArray(t))
              throw new TypeError(
                "THREE.BufferAttribute: array should be a Typed Array."
              );
            (this.name = ""),
              (this.array = t),
              (this.itemSize = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.normalized = !0 === n),
              (this.usage = et),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.onUploadCallback = function () {});
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.name = t.name),
              (this.array = new t.array.constructor(t.array)),
              (this.itemSize = t.itemSize),
              (this.count = t.count),
              (this.normalized = t.normalized),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.itemSize), (n *= e.itemSize);
            for (let i = 0, r = this.itemSize; i < r; i++)
              this.array[t + i] = e.array[n + i];
            return this;
          }
          copyArray(t) {
            return this.array.set(t), this;
          }
          copyColorsArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
              let r = t[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyColorsArray(): color is undefined",
                  i
                ),
                (r = new tn())),
                (e[n++] = r.r),
                (e[n++] = r.g),
                (e[n++] = r.b);
            }
            return this;
          }
          copyVector2sArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
              let r = t[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
                  i
                ),
                (r = new vt())),
                (e[n++] = r.x),
                (e[n++] = r.y);
            }
            return this;
          }
          copyVector3sArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
              let r = t[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
                  i
                ),
                (r = new Lt())),
                (e[n++] = r.x),
                (e[n++] = r.y),
                (e[n++] = r.z);
            }
            return this;
          }
          copyVector4sArray(t) {
            const e = this.array;
            let n = 0;
            for (let i = 0, r = t.length; i < r; i++) {
              let r = t[i];
              void 0 === r &&
                (console.warn(
                  "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
                  i
                ),
                (r = new St())),
                (e[n++] = r.x),
                (e[n++] = r.y),
                (e[n++] = r.z),
                (e[n++] = r.w);
            }
            return this;
          }
          applyMatrix3(t) {
            if (2 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                rn.fromBufferAttribute(this, e),
                  rn.applyMatrix3(t),
                  this.setXY(e, rn.x, rn.y);
            else if (3 === this.itemSize)
              for (let e = 0, n = this.count; e < n; e++)
                nn.fromBufferAttribute(this, e),
                  nn.applyMatrix3(t),
                  this.setXYZ(e, nn.x, nn.y, nn.z);
            return this;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (nn.x = this.getX(e)),
                (nn.y = this.getY(e)),
                (nn.z = this.getZ(e)),
                nn.applyMatrix4(t),
                this.setXYZ(e, nn.x, nn.y, nn.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (nn.x = this.getX(e)),
                (nn.y = this.getY(e)),
                (nn.z = this.getZ(e)),
                nn.applyNormalMatrix(t),
                this.setXYZ(e, nn.x, nn.y, nn.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (nn.x = this.getX(e)),
                (nn.y = this.getY(e)),
                (nn.z = this.getZ(e)),
                nn.transformDirection(t),
                this.setXYZ(e, nn.x, nn.y, nn.z);
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          getX(t) {
            return this.array[t * this.itemSize];
          }
          setX(t, e) {
            return (this.array[t * this.itemSize] = e), this;
          }
          getY(t) {
            return this.array[t * this.itemSize + 1];
          }
          setY(t, e) {
            return (this.array[t * this.itemSize + 1] = e), this;
          }
          getZ(t) {
            return this.array[t * this.itemSize + 2];
          }
          setZ(t, e) {
            return (this.array[t * this.itemSize + 2] = e), this;
          }
          getW(t) {
            return this.array[t * this.itemSize + 3];
          }
          setW(t, e) {
            return (this.array[t * this.itemSize + 3] = e), this;
          }
          setXY(t, e, n) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t *= this.itemSize),
              (this.array[t + 0] = e),
              (this.array[t + 1] = n),
              (this.array[t + 2] = i),
              (this.array[t + 3] = r),
              this
            );
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          clone() {
            return new this.constructor(this.array, this.itemSize).copy(this);
          }
          toJSON() {
            const t = {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: Array.prototype.slice.call(this.array),
              normalized: this.normalized,
            };
            return (
              "" !== this.name && (t.name = this.name),
              this.usage !== et && (t.usage = this.usage),
              (0 === this.updateRange.offset &&
                -1 === this.updateRange.count) ||
                (t.updateRange = this.updateRange),
              t
            );
          }
        }
        sn.prototype.isBufferAttribute = !0;
        class an extends sn {
          constructor(t, e, n) {
            super(new Int8Array(t), e, n);
          }
        }
        class on extends sn {
          constructor(t, e, n) {
            super(new Uint8Array(t), e, n);
          }
        }
        class ln extends sn {
          constructor(t, e, n) {
            super(new Uint8ClampedArray(t), e, n);
          }
        }
        class cn extends sn {
          constructor(t, e, n) {
            super(new Int16Array(t), e, n);
          }
        }
        class hn extends sn {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        class un extends sn {
          constructor(t, e, n) {
            super(new Int32Array(t), e, n);
          }
        }
        class dn extends sn {
          constructor(t, e, n) {
            super(new Uint32Array(t), e, n);
          }
        }
        class pn extends sn {
          constructor(t, e, n) {
            super(new Uint16Array(t), e, n);
          }
        }
        pn.prototype.isFloat16BufferAttribute = !0;
        class mn extends sn {
          constructor(t, e, n) {
            super(new Float32Array(t), e, n);
          }
        }
        class fn extends sn {
          constructor(t, e, n) {
            super(new Float64Array(t), e, n);
          }
        }
        function gn(t) {
          if (0 === t.length) return -1 / 0;
          let e = t[0];
          for (let n = 1, i = t.length; n < i; ++n) t[n] > e && (e = t[n]);
          return e;
        }
        const vn = {
          Int8Array: Int8Array,
          Uint8Array: Uint8Array,
          Uint8ClampedArray: Uint8ClampedArray,
          Int16Array: Int16Array,
          Uint16Array: Uint16Array,
          Int32Array: Int32Array,
          Uint32Array: Uint32Array,
          Float32Array: Float32Array,
          Float64Array: Float64Array,
        };
        function yn(t, e) {
          return new vn[t](e);
        }
        let xn = 0;
        const _n = new se(),
          wn = new Ce(),
          bn = new Lt(),
          Mn = new Pt(),
          Sn = new Pt(),
          Tn = new Lt();
        class En extends rt {
          constructor() {
            super(),
              Object.defineProperty(this, "id", { value: xn++ }),
              (this.uuid = ct()),
              (this.name = ""),
              (this.type = "BufferGeometry"),
              (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.morphTargetsRelative = !1),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null),
              (this.drawRange = { start: 0, count: 1 / 0 }),
              (this.userData = {});
          }
          getIndex() {
            return this.index;
          }
          setIndex(t) {
            return (
              Array.isArray(t)
                ? (this.index = new (gn(t) > 65535 ? dn : hn)(t, 1))
                : (this.index = t),
              this
            );
          }
          getAttribute(t) {
            return this.attributes[t];
          }
          setAttribute(t, e) {
            return (this.attributes[t] = e), this;
          }
          deleteAttribute(t) {
            return delete this.attributes[t], this;
          }
          hasAttribute(t) {
            return void 0 !== this.attributes[t];
          }
          addGroup(t, e, n = 0) {
            this.groups.push({ start: t, count: e, materialIndex: n });
          }
          clearGroups() {
            this.groups = [];
          }
          setDrawRange(t, e) {
            (this.drawRange.start = t), (this.drawRange.count = e);
          }
          applyMatrix4(t) {
            const e = this.attributes.position;
            void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
            const n = this.attributes.normal;
            if (void 0 !== n) {
              const e = new yt().getNormalMatrix(t);
              n.applyNormalMatrix(e), (n.needsUpdate = !0);
            }
            const i = this.attributes.tangent;
            return (
              void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
              null !== this.boundingBox && this.computeBoundingBox(),
              null !== this.boundingSphere && this.computeBoundingSphere(),
              this
            );
          }
          rotateX(t) {
            return _n.makeRotationX(t), this.applyMatrix4(_n), this;
          }
          rotateY(t) {
            return _n.makeRotationY(t), this.applyMatrix4(_n), this;
          }
          rotateZ(t) {
            return _n.makeRotationZ(t), this.applyMatrix4(_n), this;
          }
          translate(t, e, n) {
            return _n.makeTranslation(t, e, n), this.applyMatrix4(_n), this;
          }
          scale(t, e, n) {
            return _n.makeScale(t, e, n), this.applyMatrix4(_n), this;
          }
          lookAt(t) {
            return (
              wn.lookAt(t),
              wn.updateMatrix(),
              this.applyMatrix4(wn.matrix),
              this
            );
          }
          center() {
            return (
              this.computeBoundingBox(),
              this.boundingBox.getCenter(bn).negate(),
              this.translate(bn.x, bn.y, bn.z),
              this
            );
          }
          setFromPoints(t) {
            const e = [];
            for (let n = 0, i = t.length; n < i; n++) {
              const i = t[n];
              e.push(i.x, i.y, i.z || 0);
            }
            return this.setAttribute("position", new mn(e, 3)), this;
          }
          computeBoundingBox() {
            null === this.boundingBox && (this.boundingBox = new Pt());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingBox.set(
                  new Lt(-1 / 0, -1 / 0, -1 / 0),
                  new Lt(1 / 0, 1 / 0, 1 / 0)
                )
              );
            if (void 0 !== t) {
              if ((this.boundingBox.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Mn.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Tn.addVectors(this.boundingBox.min, Mn.min),
                        this.boundingBox.expandByPoint(Tn),
                        Tn.addVectors(this.boundingBox.max, Mn.max),
                        this.boundingBox.expandByPoint(Tn))
                      : (this.boundingBox.expandByPoint(Mn.min),
                        this.boundingBox.expandByPoint(Mn.max));
                }
            } else this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) ||
              isNaN(this.boundingBox.min.y) ||
              isNaN(this.boundingBox.min.z)) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
                this
              );
          }
          computeBoundingSphere() {
            null === this.boundingSphere && (this.boundingSphere = new Jt());
            const t = this.attributes.position,
              e = this.morphAttributes.position;
            if (t && t.isGLBufferAttribute)
              return (
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
                  this
                ),
                void this.boundingSphere.set(new Lt(), 1 / 0)
              );
            if (t) {
              const n = this.boundingSphere.center;
              if ((Mn.setFromBufferAttribute(t), e))
                for (let t = 0, n = e.length; t < n; t++) {
                  const n = e[t];
                  Sn.setFromBufferAttribute(n),
                    this.morphTargetsRelative
                      ? (Tn.addVectors(Mn.min, Sn.min),
                        Mn.expandByPoint(Tn),
                        Tn.addVectors(Mn.max, Sn.max),
                        Mn.expandByPoint(Tn))
                      : (Mn.expandByPoint(Sn.min), Mn.expandByPoint(Sn.max));
                }
              Mn.getCenter(n);
              let i = 0;
              for (let e = 0, r = t.count; e < r; e++)
                Tn.fromBufferAttribute(t, e),
                  (i = Math.max(i, n.distanceToSquared(Tn)));
              if (e)
                for (let r = 0, s = e.length; r < s; r++) {
                  const s = e[r],
                    a = this.morphTargetsRelative;
                  for (let e = 0, r = s.count; e < r; e++)
                    Tn.fromBufferAttribute(s, e),
                      a && (bn.fromBufferAttribute(t, e), Tn.add(bn)),
                      (i = Math.max(i, n.distanceToSquared(Tn)));
                }
              (this.boundingSphere.radius = Math.sqrt(i)),
                isNaN(this.boundingSphere.radius) &&
                  console.error(
                    'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                    this
                  );
            }
          }
          computeFaceNormals() {}
          computeTangents() {
            const t = this.index,
              e = this.attributes;
            if (
              null === t ||
              void 0 === e.position ||
              void 0 === e.normal ||
              void 0 === e.uv
            )
              return void console.error(
                "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
              );
            const n = t.array,
              i = e.position.array,
              r = e.normal.array,
              s = e.uv.array,
              a = i.length / 3;
            void 0 === e.tangent &&
              this.setAttribute("tangent", new sn(new Float32Array(4 * a), 4));
            const o = e.tangent.array,
              l = [],
              c = [];
            for (let t = 0; t < a; t++) (l[t] = new Lt()), (c[t] = new Lt());
            const h = new Lt(),
              u = new Lt(),
              d = new Lt(),
              p = new vt(),
              m = new vt(),
              f = new vt(),
              g = new Lt(),
              v = new Lt();
            function y(t, e, n) {
              h.fromArray(i, 3 * t),
                u.fromArray(i, 3 * e),
                d.fromArray(i, 3 * n),
                p.fromArray(s, 2 * t),
                m.fromArray(s, 2 * e),
                f.fromArray(s, 2 * n),
                u.sub(h),
                d.sub(h),
                m.sub(p),
                f.sub(p);
              const r = 1 / (m.x * f.y - f.x * m.y);
              isFinite(r) &&
                (g
                  .copy(u)
                  .multiplyScalar(f.y)
                  .addScaledVector(d, -m.y)
                  .multiplyScalar(r),
                v
                  .copy(d)
                  .multiplyScalar(m.x)
                  .addScaledVector(u, -f.x)
                  .multiplyScalar(r),
                l[t].add(g),
                l[e].add(g),
                l[n].add(g),
                c[t].add(v),
                c[e].add(v),
                c[n].add(v));
            }
            let x = this.groups;
            0 === x.length && (x = [{ start: 0, count: n.length }]);
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3)
                y(n[t + 0], n[t + 1], n[t + 2]);
            }
            const _ = new Lt(),
              w = new Lt(),
              b = new Lt(),
              M = new Lt();
            function S(t) {
              b.fromArray(r, 3 * t), M.copy(b);
              const e = l[t];
              _.copy(e),
                _.sub(b.multiplyScalar(b.dot(e))).normalize(),
                w.crossVectors(M, e);
              const n = w.dot(c[t]) < 0 ? -1 : 1;
              (o[4 * t] = _.x),
                (o[4 * t + 1] = _.y),
                (o[4 * t + 2] = _.z),
                (o[4 * t + 3] = n);
            }
            for (let t = 0, e = x.length; t < e; ++t) {
              const e = x[t],
                i = e.start;
              for (let t = i, r = i + e.count; t < r; t += 3)
                S(n[t + 0]), S(n[t + 1]), S(n[t + 2]);
            }
          }
          computeVertexNormals() {
            const t = this.index,
              e = this.getAttribute("position");
            if (void 0 !== e) {
              let n = this.getAttribute("normal");
              if (void 0 === n)
                (n = new sn(new Float32Array(3 * e.count), 3)),
                  this.setAttribute("normal", n);
              else
                for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
              const i = new Lt(),
                r = new Lt(),
                s = new Lt(),
                a = new Lt(),
                o = new Lt(),
                l = new Lt(),
                c = new Lt(),
                h = new Lt();
              if (t)
                for (let u = 0, d = t.count; u < d; u += 3) {
                  const d = t.getX(u + 0),
                    p = t.getX(u + 1),
                    m = t.getX(u + 2);
                  i.fromBufferAttribute(e, d),
                    r.fromBufferAttribute(e, p),
                    s.fromBufferAttribute(e, m),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    a.fromBufferAttribute(n, d),
                    o.fromBufferAttribute(n, p),
                    l.fromBufferAttribute(n, m),
                    a.add(c),
                    o.add(c),
                    l.add(c),
                    n.setXYZ(d, a.x, a.y, a.z),
                    n.setXYZ(p, o.x, o.y, o.z),
                    n.setXYZ(m, l.x, l.y, l.z);
                }
              else
                for (let t = 0, a = e.count; t < a; t += 3)
                  i.fromBufferAttribute(e, t + 0),
                    r.fromBufferAttribute(e, t + 1),
                    s.fromBufferAttribute(e, t + 2),
                    c.subVectors(s, r),
                    h.subVectors(i, r),
                    c.cross(h),
                    n.setXYZ(t + 0, c.x, c.y, c.z),
                    n.setXYZ(t + 1, c.x, c.y, c.z),
                    n.setXYZ(t + 2, c.x, c.y, c.z);
              this.normalizeNormals(), (n.needsUpdate = !0);
            }
          }
          merge(t, e) {
            if (!t || !t.isBufferGeometry)
              return void console.error(
                "THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
                t
              );
            void 0 === e &&
              ((e = 0),
              console.warn(
                "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
              ));
            const n = this.attributes;
            for (const i in n) {
              if (void 0 === t.attributes[i]) continue;
              const r = n[i].array,
                s = t.attributes[i],
                a = s.array,
                o = s.itemSize * e,
                l = Math.min(a.length, r.length - o);
              for (let t = 0, e = o; t < l; t++, e++) r[e] = a[t];
            }
            return this;
          }
          normalizeNormals() {
            const t = this.attributes.normal;
            for (let e = 0, n = t.count; e < n; e++)
              Tn.fromBufferAttribute(t, e),
                Tn.normalize(),
                t.setXYZ(e, Tn.x, Tn.y, Tn.z);
          }
          toNonIndexed() {
            function t(t, e) {
              const n = t.array,
                i = t.itemSize,
                r = t.normalized,
                s = new n.constructor(e.length * i);
              let a = 0,
                o = 0;
              for (let t = 0, r = e.length; t < r; t++) {
                a = e[t] * i;
                for (let t = 0; t < i; t++) s[o++] = n[a++];
              }
              return new sn(s, i, r);
            }
            if (null === this.index)
              return (
                console.warn(
                  "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
                ),
                this
              );
            const e = new En(),
              n = this.index.array,
              i = this.attributes;
            for (const r in i) {
              const s = t(i[r], n);
              e.setAttribute(r, s);
            }
            const r = this.morphAttributes;
            for (const i in r) {
              const s = [],
                a = r[i];
              for (let e = 0, i = a.length; e < i; e++) {
                const i = t(a[e], n);
                s.push(i);
              }
              e.morphAttributes[i] = s;
            }
            e.morphTargetsRelative = this.morphTargetsRelative;
            const s = this.groups;
            for (let t = 0, n = s.length; t < n; t++) {
              const n = s[t];
              e.addGroup(n.start, n.count, n.materialIndex);
            }
            return e;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON",
              },
            };
            if (
              ((t.uuid = this.uuid),
              (t.type = this.type),
              "" !== this.name && (t.name = this.name),
              Object.keys(this.userData).length > 0 &&
                (t.userData = this.userData),
              void 0 !== this.parameters)
            ) {
              const e = this.parameters;
              for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
              return t;
            }
            t.data = { attributes: {} };
            const e = this.index;
            null !== e &&
              (t.data.index = {
                type: e.array.constructor.name,
                array: Array.prototype.slice.call(e.array),
              });
            const n = this.attributes;
            for (const e in n) {
              const i = n[e];
              t.data.attributes[e] = i.toJSON(t.data);
            }
            const i = {};
            let r = !1;
            for (const e in this.morphAttributes) {
              const n = this.morphAttributes[e],
                s = [];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                s.push(i.toJSON(t.data));
              }
              s.length > 0 && ((i[e] = s), (r = !0));
            }
            r &&
              ((t.data.morphAttributes = i),
              (t.data.morphTargetsRelative = this.morphTargetsRelative));
            const s = this.groups;
            s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
            const a = this.boundingSphere;
            return (
              null !== a &&
                (t.data.boundingSphere = {
                  center: a.center.toArray(),
                  radius: a.radius,
                }),
              t
            );
          }
          clone() {
            return new En().copy(this);
          }
          copy(t) {
            (this.index = null),
              (this.attributes = {}),
              (this.morphAttributes = {}),
              (this.groups = []),
              (this.boundingBox = null),
              (this.boundingSphere = null);
            const e = {};
            this.name = t.name;
            const n = t.index;
            null !== n && this.setIndex(n.clone(e));
            const i = t.attributes;
            for (const t in i) {
              const n = i[t];
              this.setAttribute(t, n.clone(e));
            }
            const r = t.morphAttributes;
            for (const t in r) {
              const n = [],
                i = r[t];
              for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
              this.morphAttributes[t] = n;
            }
            this.morphTargetsRelative = t.morphTargetsRelative;
            const s = t.groups;
            for (let t = 0, e = s.length; t < e; t++) {
              const e = s[t];
              this.addGroup(e.start, e.count, e.materialIndex);
            }
            const a = t.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const o = t.boundingSphere;
            return (
              null !== o && (this.boundingSphere = o.clone()),
              (this.drawRange.start = t.drawRange.start),
              (this.drawRange.count = t.drawRange.count),
              (this.userData = t.userData),
              this
            );
          }
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        En.prototype.isBufferGeometry = !0;
        const An = new se(),
          Ln = new re(),
          Rn = new Jt(),
          Cn = new Lt(),
          Pn = new Lt(),
          Dn = new Lt(),
          In = new Lt(),
          Nn = new Lt(),
          Bn = new Lt(),
          zn = new Lt(),
          Fn = new Lt(),
          On = new Lt(),
          Hn = new vt(),
          Gn = new vt(),
          Un = new vt(),
          kn = new Lt(),
          Vn = new Lt();
        class Wn extends Ce {
          constructor(t = new En(), e = new en()) {
            super(),
              (this.type = "Mesh"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.morphTargetInfluences &&
                (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
              void 0 !== t.morphTargetDictionary &&
                (this.morphTargetDictionary = Object.assign(
                  {},
                  t.morphTargetDictionary
                )),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.material,
              r = this.matrixWorld;
            if (void 0 === i) return;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Rn.copy(n.boundingSphere),
              Rn.applyMatrix4(r),
              !1 === t.ray.intersectsSphere(Rn))
            )
              return;
            if (
              (An.copy(r).invert(),
              Ln.copy(t.ray).applyMatrix4(An),
              null !== n.boundingBox && !1 === Ln.intersectsBox(n.boundingBox))
            )
              return;
            let s;
            if (n.isBufferGeometry) {
              const r = n.index,
                a = n.attributes.position,
                o = n.morphAttributes.position,
                l = n.morphTargetsRelative,
                c = n.attributes.uv,
                h = n.attributes.uv2,
                u = n.groups,
                d = n.drawRange;
              if (null !== r)
                if (Array.isArray(i))
                  for (let n = 0, p = u.length; n < p; n++) {
                    const p = u[n],
                      m = i[p.materialIndex];
                    for (
                      let n = Math.max(p.start, d.start),
                        i = Math.min(p.start + p.count, d.start + d.count);
                      n < i;
                      n += 3
                    ) {
                      const i = r.getX(n),
                        u = r.getX(n + 1),
                        d = r.getX(n + 2);
                      (s = jn(this, m, t, Ln, a, o, l, c, h, i, u, d)),
                        s &&
                          ((s.faceIndex = Math.floor(n / 3)),
                          (s.face.materialIndex = p.materialIndex),
                          e.push(s));
                    }
                  }
                else {
                  for (
                    let n = Math.max(0, d.start),
                      u = Math.min(r.count, d.start + d.count);
                    n < u;
                    n += 3
                  ) {
                    const u = r.getX(n),
                      d = r.getX(n + 1),
                      p = r.getX(n + 2);
                    (s = jn(this, i, t, Ln, a, o, l, c, h, u, d, p)),
                      s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
                  }
                }
              else if (void 0 !== a)
                if (Array.isArray(i))
                  for (let n = 0, r = u.length; n < r; n++) {
                    const r = u[n],
                      p = i[r.materialIndex];
                    for (
                      let n = Math.max(r.start, d.start),
                        i = Math.min(r.start + r.count, d.start + d.count);
                      n < i;
                      n += 3
                    ) {
                      (s = jn(this, p, t, Ln, a, o, l, c, h, n, n + 1, n + 2)),
                        s &&
                          ((s.faceIndex = Math.floor(n / 3)),
                          (s.face.materialIndex = r.materialIndex),
                          e.push(s));
                    }
                  }
                else {
                  for (
                    let n = Math.max(0, d.start),
                      r = Math.min(a.count, d.start + d.count);
                    n < r;
                    n += 3
                  ) {
                    (s = jn(this, i, t, Ln, a, o, l, c, h, n, n + 1, n + 2)),
                      s && ((s.faceIndex = Math.floor(n / 3)), e.push(s));
                  }
                }
            } else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
        }
        function jn(t, e, n, i, r, s, a, o, l, c, h, u) {
          Cn.fromBufferAttribute(r, c),
            Pn.fromBufferAttribute(r, h),
            Dn.fromBufferAttribute(r, u);
          const d = t.morphTargetInfluences;
          if (e.morphTargets && s && d) {
            zn.set(0, 0, 0), Fn.set(0, 0, 0), On.set(0, 0, 0);
            for (let t = 0, e = s.length; t < e; t++) {
              const e = d[t],
                n = s[t];
              0 !== e &&
                (In.fromBufferAttribute(n, c),
                Nn.fromBufferAttribute(n, h),
                Bn.fromBufferAttribute(n, u),
                a
                  ? (zn.addScaledVector(In, e),
                    Fn.addScaledVector(Nn, e),
                    On.addScaledVector(Bn, e))
                  : (zn.addScaledVector(In.sub(Cn), e),
                    Fn.addScaledVector(Nn.sub(Pn), e),
                    On.addScaledVector(Bn.sub(Dn), e)));
            }
            Cn.add(zn), Pn.add(Fn), Dn.add(On);
          }
          t.isSkinnedMesh &&
            e.skinning &&
            (t.boneTransform(c, Cn),
            t.boneTransform(h, Pn),
            t.boneTransform(u, Dn));
          const p = (function (t, e, n, i, r, s, a, o) {
            let l;
            if (
              ((l =
                1 === e.side
                  ? i.intersectTriangle(a, s, r, !0, o)
                  : i.intersectTriangle(r, s, a, 2 !== e.side, o)),
              null === l)
            )
              return null;
            Vn.copy(o), Vn.applyMatrix4(t.matrixWorld);
            const c = n.ray.origin.distanceTo(Vn);
            return c < n.near || c > n.far
              ? null
              : { distance: c, point: Vn.clone(), object: t };
          })(t, e, n, i, Cn, Pn, Dn, kn);
          if (p) {
            o &&
              (Hn.fromBufferAttribute(o, c),
              Gn.fromBufferAttribute(o, h),
              Un.fromBufferAttribute(o, u),
              (p.uv = je.getUV(kn, Cn, Pn, Dn, Hn, Gn, Un, new vt()))),
              l &&
                (Hn.fromBufferAttribute(l, c),
                Gn.fromBufferAttribute(l, h),
                Un.fromBufferAttribute(l, u),
                (p.uv2 = je.getUV(kn, Cn, Pn, Dn, Hn, Gn, Un, new vt())));
            const t = { a: c, b: h, c: u, normal: new Lt(), materialIndex: 0 };
            je.getNormal(Cn, Pn, Dn, t.normal), (p.face = t);
          }
          return p;
        }
        Wn.prototype.isMesh = !0;
        class qn extends En {
          constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
            super(),
              (this.type = "BoxGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                depth: n,
                widthSegments: i,
                heightSegments: r,
                depthSegments: s,
              });
            const a = this;
            (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
            const o = [],
              l = [],
              c = [],
              h = [];
            let u = 0,
              d = 0;
            function p(t, e, n, i, r, s, p, m, f, g, v) {
              const y = s / f,
                x = p / g,
                _ = s / 2,
                w = p / 2,
                b = m / 2,
                M = f + 1,
                S = g + 1;
              let T = 0,
                E = 0;
              const A = new Lt();
              for (let s = 0; s < S; s++) {
                const a = s * x - w;
                for (let o = 0; o < M; o++) {
                  const u = o * y - _;
                  (A[t] = u * i),
                    (A[e] = a * r),
                    (A[n] = b),
                    l.push(A.x, A.y, A.z),
                    (A[t] = 0),
                    (A[e] = 0),
                    (A[n] = m > 0 ? 1 : -1),
                    c.push(A.x, A.y, A.z),
                    h.push(o / f),
                    h.push(1 - s / g),
                    (T += 1);
                }
              }
              for (let t = 0; t < g; t++)
                for (let e = 0; e < f; e++) {
                  const n = u + e + M * t,
                    i = u + e + M * (t + 1),
                    r = u + (e + 1) + M * (t + 1),
                    s = u + (e + 1) + M * t;
                  o.push(n, i, s), o.push(i, r, s), (E += 6);
                }
              a.addGroup(d, E, v), (d += E), (u += T);
            }
            p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
              p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
              p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
              p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
              p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
              p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
              this.setIndex(o),
              this.setAttribute("position", new mn(l, 3)),
              this.setAttribute("normal", new mn(c, 3)),
              this.setAttribute("uv", new mn(h, 2));
          }
        }
        function Xn(t) {
          const e = {};
          for (const n in t) {
            e[n] = {};
            for (const i in t[n]) {
              const r = t[n][i];
              r &&
              (r.isColor ||
                r.isMatrix3 ||
                r.isMatrix4 ||
                r.isVector2 ||
                r.isVector3 ||
                r.isVector4 ||
                r.isTexture ||
                r.isQuaternion)
                ? (e[n][i] = r.clone())
                : Array.isArray(r)
                ? (e[n][i] = r.slice())
                : (e[n][i] = r);
            }
          }
          return e;
        }
        function Yn(t) {
          const e = {};
          for (let n = 0; n < t.length; n++) {
            const i = Xn(t[n]);
            for (const t in i) e[t] = i[t];
          }
          return e;
        }
        const Zn = { clone: Xn, merge: Yn };
        class Jn extends Xe {
          constructor(t) {
            super(),
              (this.type = "ShaderMaterial"),
              (this.defines = {}),
              (this.uniforms = {}),
              (this.vertexShader =
                "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
              (this.fragmentShader =
                "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
              (this.linewidth = 1),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.lights = !1),
              (this.clipping = !1),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1,
              }),
              (this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0],
              }),
              (this.index0AttributeName = void 0),
              (this.uniformsNeedUpdate = !1),
              (this.glslVersion = null),
              void 0 !== t &&
                (void 0 !== t.attributes &&
                  console.error(
                    "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."
                  ),
                this.setValues(t));
          }
          copy(t) {
            return (
              super.copy(t),
              (this.fragmentShader = t.fragmentShader),
              (this.vertexShader = t.vertexShader),
              (this.uniforms = Xn(t.uniforms)),
              (this.defines = Object.assign({}, t.defines)),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.lights = t.lights),
              (this.clipping = t.clipping),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.extensions = Object.assign({}, t.extensions)),
              (this.glslVersion = t.glslVersion),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            (e.glslVersion = this.glslVersion), (e.uniforms = {});
            for (const n in this.uniforms) {
              const i = this.uniforms[n].value;
              i && i.isTexture
                ? (e.uniforms[n] = { type: "t", value: i.toJSON(t).uuid })
                : i && i.isColor
                ? (e.uniforms[n] = { type: "c", value: i.getHex() })
                : i && i.isVector2
                ? (e.uniforms[n] = { type: "v2", value: i.toArray() })
                : i && i.isVector3
                ? (e.uniforms[n] = { type: "v3", value: i.toArray() })
                : i && i.isVector4
                ? (e.uniforms[n] = { type: "v4", value: i.toArray() })
                : i && i.isMatrix3
                ? (e.uniforms[n] = { type: "m3", value: i.toArray() })
                : i && i.isMatrix4
                ? (e.uniforms[n] = { type: "m4", value: i.toArray() })
                : (e.uniforms[n] = { value: i });
            }
            Object.keys(this.defines).length > 0 && (e.defines = this.defines),
              (e.vertexShader = this.vertexShader),
              (e.fragmentShader = this.fragmentShader);
            const n = {};
            for (const t in this.extensions)
              !0 === this.extensions[t] && (n[t] = !0);
            return Object.keys(n).length > 0 && (e.extensions = n), e;
          }
        }
        Jn.prototype.isShaderMaterial = !0;
        class Qn extends Ce {
          constructor() {
            super(),
              (this.type = "Camera"),
              (this.matrixWorldInverse = new se()),
              (this.projectionMatrix = new se()),
              (this.projectionMatrixInverse = new se());
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              this.matrixWorldInverse.copy(t.matrixWorldInverse),
              this.projectionMatrix.copy(t.projectionMatrix),
              this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
              this
            );
          }
          getWorldDirection(t) {
            void 0 === t &&
              (console.warn(
                "THREE.Camera: .getWorldDirection() target is now required"
              ),
              (t = new Lt())),
              this.updateWorldMatrix(!0, !1);
            const e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize();
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          updateWorldMatrix(t, e) {
            super.updateWorldMatrix(t, e),
              this.matrixWorldInverse.copy(this.matrixWorld).invert();
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        Qn.prototype.isCamera = !0;
        class Kn extends Qn {
          constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
            super(),
              (this.type = "PerspectiveCamera"),
              (this.fov = t),
              (this.zoom = 1),
              (this.near = n),
              (this.far = i),
              (this.focus = 10),
              (this.aspect = e),
              (this.view = null),
              (this.filmGauge = 35),
              (this.filmOffset = 0),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.fov = t.fov),
              (this.zoom = t.zoom),
              (this.near = t.near),
              (this.far = t.far),
              (this.focus = t.focus),
              (this.aspect = t.aspect),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              (this.filmGauge = t.filmGauge),
              (this.filmOffset = t.filmOffset),
              this
            );
          }
          setFocalLength(t) {
            const e = (0.5 * this.getFilmHeight()) / t;
            (this.fov = 2 * lt * Math.atan(e)), this.updateProjectionMatrix();
          }
          getFocalLength() {
            const t = Math.tan(0.5 * ot * this.fov);
            return (0.5 * this.getFilmHeight()) / t;
          }
          getEffectiveFOV() {
            return (
              2 * lt * Math.atan(Math.tan(0.5 * ot * this.fov) / this.zoom)
            );
          }
          getFilmWidth() {
            return this.filmGauge * Math.min(this.aspect, 1);
          }
          getFilmHeight() {
            return this.filmGauge / Math.max(this.aspect, 1);
          }
          setViewOffset(t, e, n, i, r, s) {
            (this.aspect = t / e),
              null === this.view &&
                (this.view = {
                  enabled: !0,
                  fullWidth: 1,
                  fullHeight: 1,
                  offsetX: 0,
                  offsetY: 0,
                  width: 1,
                  height: 1,
                }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = this.near;
            let e = (t * Math.tan(0.5 * ot * this.fov)) / this.zoom,
              n = 2 * e,
              i = this.aspect * n,
              r = -0.5 * i;
            const s = this.view;
            if (null !== this.view && this.view.enabled) {
              const t = s.fullWidth,
                a = s.fullHeight;
              (r += (s.offsetX * i) / t),
                (e -= (s.offsetY * n) / a),
                (i *= s.width / t),
                (n *= s.height / a);
            }
            const a = this.filmOffset;
            0 !== a && (r += (t * a) / this.getFilmWidth()),
              this.projectionMatrix.makePerspective(
                r,
                r + i,
                e,
                e - n,
                t,
                this.far
              ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.fov = this.fov),
              (e.object.zoom = this.zoom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              (e.object.focus = this.focus),
              (e.object.aspect = this.aspect),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              (e.object.filmGauge = this.filmGauge),
              (e.object.filmOffset = this.filmOffset),
              e
            );
          }
        }
        Kn.prototype.isPerspectiveCamera = !0;
        const $n = 90;
        class ti extends Ce {
          constructor(t, e, n) {
            if (
              (super(),
              (this.type = "CubeCamera"),
              !0 !== n.isWebGLCubeRenderTarget)
            )
              return void console.error(
                "THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter."
              );
            this.renderTarget = n;
            const i = new Kn($n, 1, t, e);
            (i.layers = this.layers),
              i.up.set(0, -1, 0),
              i.lookAt(new Lt(1, 0, 0)),
              this.add(i);
            const r = new Kn($n, 1, t, e);
            (r.layers = this.layers),
              r.up.set(0, -1, 0),
              r.lookAt(new Lt(-1, 0, 0)),
              this.add(r);
            const s = new Kn($n, 1, t, e);
            (s.layers = this.layers),
              s.up.set(0, 0, 1),
              s.lookAt(new Lt(0, 1, 0)),
              this.add(s);
            const a = new Kn($n, 1, t, e);
            (a.layers = this.layers),
              a.up.set(0, 0, -1),
              a.lookAt(new Lt(0, -1, 0)),
              this.add(a);
            const o = new Kn($n, 1, t, e);
            (o.layers = this.layers),
              o.up.set(0, -1, 0),
              o.lookAt(new Lt(0, 0, 1)),
              this.add(o);
            const l = new Kn($n, 1, t, e);
            (l.layers = this.layers),
              l.up.set(0, -1, 0),
              l.lookAt(new Lt(0, 0, -1)),
              this.add(l);
          }
          update(t, e) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget,
              [i, r, s, a, o, l] = this.children,
              c = t.xr.enabled,
              h = t.getRenderTarget();
            t.xr.enabled = !1;
            const u = n.texture.generateMipmaps;
            (n.texture.generateMipmaps = !1),
              t.setRenderTarget(n, 0),
              t.render(e, i),
              t.setRenderTarget(n, 1),
              t.render(e, r),
              t.setRenderTarget(n, 2),
              t.render(e, s),
              t.setRenderTarget(n, 3),
              t.render(e, a),
              t.setRenderTarget(n, 4),
              t.render(e, o),
              (n.texture.generateMipmaps = u),
              t.setRenderTarget(n, 5),
              t.render(e, l),
              t.setRenderTarget(h),
              (t.xr.enabled = c);
          }
        }
        class ei extends bt {
          constructor(t, e, n, i, s, a, o, l, c, h) {
            super(
              (t = void 0 !== t ? t : []),
              (e = void 0 !== e ? e : r),
              n,
              i,
              s,
              a,
              (o = void 0 !== o ? o : T),
              l,
              c,
              h
            ),
              (this._needsFlipEnvMap = !0),
              (this.flipY = !1);
          }
          get images() {
            return this.image;
          }
          set images(t) {
            this.image = t;
          }
        }
        ei.prototype.isCubeTexture = !0;
        class ni extends Tt {
          constructor(t, e, n) {
            Number.isInteger(e) &&
              (console.warn(
                "THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"
              ),
              (e = n)),
              super(t, t, e),
              (e = e || {}),
              (this.texture = new ei(
                void 0,
                e.mapping,
                e.wrapS,
                e.wrapT,
                e.magFilter,
                e.minFilter,
                e.format,
                e.type,
                e.anisotropy,
                e.encoding
              )),
              (this.texture.generateMipmaps =
                void 0 !== e.generateMipmaps && e.generateMipmaps),
              (this.texture.minFilter =
                void 0 !== e.minFilter ? e.minFilter : g),
              (this.texture._needsFlipEnvMap = !1);
          }
          fromEquirectangularTexture(t, e) {
            (this.texture.type = e.type),
              (this.texture.format = E),
              (this.texture.encoding = e.encoding),
              (this.texture.generateMipmaps = e.generateMipmaps),
              (this.texture.minFilter = e.minFilter),
              (this.texture.magFilter = e.magFilter);
            const n = {
                uniforms: { tEquirect: { value: null } },
                vertexShader:
                  "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader:
                  "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
              },
              i = new qn(5, 5, 5),
              r = new Jn({
                name: "CubemapFromEquirect",
                uniforms: Xn(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: 1,
                blending: 0,
              });
            r.uniforms.tEquirect.value = e;
            const s = new Wn(i, r),
              a = e.minFilter;
            e.minFilter === y && (e.minFilter = g);
            return (
              new ti(1, 10, this).update(t, s),
              (e.minFilter = a),
              s.geometry.dispose(),
              s.material.dispose(),
              this
            );
          }
          clear(t, e, n, i) {
            const r = t.getRenderTarget();
            for (let r = 0; r < 6; r++)
              t.setRenderTarget(this, r), t.clear(e, n, i);
            t.setRenderTarget(r);
          }
        }
        ni.prototype.isWebGLCubeRenderTarget = !0;
        class ii extends bt {
          constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
            super(null, s, a, o, l, c, i, r, h, u),
              (this.image = { data: t || null, width: e || 1, height: n || 1 }),
              (this.magFilter = void 0 !== l ? l : p),
              (this.minFilter = void 0 !== c ? c : p),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        ii.prototype.isDataTexture = !0;
        const ri = new Jt(),
          si = new Lt();
        class ai {
          constructor(
            t = new Ne(),
            e = new Ne(),
            n = new Ne(),
            i = new Ne(),
            r = new Ne(),
            s = new Ne()
          ) {
            this.planes = [t, e, n, i, r, s];
          }
          set(t, e, n, i, r, s) {
            const a = this.planes;
            return (
              a[0].copy(t),
              a[1].copy(e),
              a[2].copy(n),
              a[3].copy(i),
              a[4].copy(r),
              a[5].copy(s),
              this
            );
          }
          copy(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
            return this;
          }
          setFromProjectionMatrix(t) {
            const e = this.planes,
              n = t.elements,
              i = n[0],
              r = n[1],
              s = n[2],
              a = n[3],
              o = n[4],
              l = n[5],
              c = n[6],
              h = n[7],
              u = n[8],
              d = n[9],
              p = n[10],
              m = n[11],
              f = n[12],
              g = n[13],
              v = n[14],
              y = n[15];
            return (
              e[0].setComponents(a - i, h - o, m - u, y - f).normalize(),
              e[1].setComponents(a + i, h + o, m + u, y + f).normalize(),
              e[2].setComponents(a + r, h + l, m + d, y + g).normalize(),
              e[3].setComponents(a - r, h - l, m - d, y - g).normalize(),
              e[4].setComponents(a - s, h - c, m - p, y - v).normalize(),
              e[5].setComponents(a + s, h + c, m + p, y + v).normalize(),
              this
            );
          }
          intersectsObject(t) {
            const e = t.geometry;
            return (
              null === e.boundingSphere && e.computeBoundingSphere(),
              ri.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
              this.intersectsSphere(ri)
            );
          }
          intersectsSprite(t) {
            return (
              ri.center.set(0, 0, 0),
              (ri.radius = 0.7071067811865476),
              ri.applyMatrix4(t.matrixWorld),
              this.intersectsSphere(ri)
            );
          }
          intersectsSphere(t) {
            const e = this.planes,
              n = t.center,
              i = -t.radius;
            for (let t = 0; t < 6; t++) {
              if (e[t].distanceToPoint(n) < i) return !1;
            }
            return !0;
          }
          intersectsBox(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++) {
              const i = e[n];
              if (
                ((si.x = i.normal.x > 0 ? t.max.x : t.min.x),
                (si.y = i.normal.y > 0 ? t.max.y : t.min.y),
                (si.z = i.normal.z > 0 ? t.max.z : t.min.z),
                i.distanceToPoint(si) < 0)
              )
                return !1;
            }
            return !0;
          }
          containsPoint(t) {
            const e = this.planes;
            for (let n = 0; n < 6; n++)
              if (e[n].distanceToPoint(t) < 0) return !1;
            return !0;
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        function oi() {
          let t = null,
            e = !1,
            n = null,
            i = null;
          function r(e, s) {
            n(e, s), (i = t.requestAnimationFrame(r));
          }
          return {
            start: function () {
              !0 !== e &&
                null !== n &&
                ((i = t.requestAnimationFrame(r)), (e = !0));
            },
            stop: function () {
              t.cancelAnimationFrame(i), (e = !1);
            },
            setAnimationLoop: function (t) {
              n = t;
            },
            setContext: function (e) {
              t = e;
            },
          };
        }
        function li(t, e) {
          const n = e.isWebGL2,
            i = new WeakMap();
          return {
            get: function (t) {
              return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
            },
            remove: function (e) {
              e.isInterleavedBufferAttribute && (e = e.data);
              const n = i.get(e);
              n && (t.deleteBuffer(n.buffer), i.delete(e));
            },
            update: function (e, r) {
              if (e.isGLBufferAttribute) {
                const t = i.get(e);
                return void (
                  (!t || t.version < e.version) &&
                  i.set(e, {
                    buffer: e.buffer,
                    type: e.type,
                    bytesPerElement: e.elementSize,
                    version: e.version,
                  })
                );
              }
              e.isInterleavedBufferAttribute && (e = e.data);
              const s = i.get(e);
              void 0 === s
                ? i.set(
                    e,
                    (function (e, i) {
                      const r = e.array,
                        s = e.usage,
                        a = t.createBuffer();
                      t.bindBuffer(i, a),
                        t.bufferData(i, r, s),
                        e.onUploadCallback();
                      let o = 5126;
                      return (
                        r instanceof Float32Array
                          ? (o = 5126)
                          : r instanceof Float64Array
                          ? console.warn(
                              "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."
                            )
                          : r instanceof Uint16Array
                          ? e.isFloat16BufferAttribute
                            ? n
                              ? (o = 5131)
                              : console.warn(
                                  "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                                )
                            : (o = 5123)
                          : r instanceof Int16Array
                          ? (o = 5122)
                          : r instanceof Uint32Array
                          ? (o = 5125)
                          : r instanceof Int32Array
                          ? (o = 5124)
                          : r instanceof Int8Array
                          ? (o = 5120)
                          : r instanceof Uint8Array && (o = 5121),
                        {
                          buffer: a,
                          type: o,
                          bytesPerElement: r.BYTES_PER_ELEMENT,
                          version: e.version,
                        }
                      );
                    })(e, r)
                  )
                : s.version < e.version &&
                  (!(function (e, i, r) {
                    const s = i.array,
                      a = i.updateRange;
                    t.bindBuffer(r, e),
                      -1 === a.count
                        ? t.bufferSubData(r, 0, s)
                        : (n
                            ? t.bufferSubData(
                                r,
                                a.offset * s.BYTES_PER_ELEMENT,
                                s,
                                a.offset,
                                a.count
                              )
                            : t.bufferSubData(
                                r,
                                a.offset * s.BYTES_PER_ELEMENT,
                                s.subarray(a.offset, a.offset + a.count)
                              ),
                          (a.count = -1));
                  })(s.buffer, e, r),
                  (s.version = e.version));
            },
          };
        }
        class ci extends En {
          constructor(t = 1, e = 1, n = 1, i = 1) {
            super(),
              (this.type = "PlaneGeometry"),
              (this.parameters = {
                width: t,
                height: e,
                widthSegments: n,
                heightSegments: i,
              });
            const r = t / 2,
              s = e / 2,
              a = Math.floor(n),
              o = Math.floor(i),
              l = a + 1,
              c = o + 1,
              h = t / a,
              u = e / o,
              d = [],
              p = [],
              m = [],
              f = [];
            for (let t = 0; t < c; t++) {
              const e = t * u - s;
              for (let n = 0; n < l; n++) {
                const i = n * h - r;
                p.push(i, -e, 0),
                  m.push(0, 0, 1),
                  f.push(n / a),
                  f.push(1 - t / o);
              }
            }
            for (let t = 0; t < o; t++)
              for (let e = 0; e < a; e++) {
                const n = e + l * t,
                  i = e + l * (t + 1),
                  r = e + 1 + l * (t + 1),
                  s = e + 1 + l * t;
                d.push(n, i, s), d.push(i, r, s);
              }
            this.setIndex(d),
              this.setAttribute("position", new mn(p, 3)),
              this.setAttribute("normal", new mn(m, 3)),
              this.setAttribute("uv", new mn(f, 2));
          }
        }
        const hi = {
            alphamap_fragment:
              "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
            alphamap_pars_fragment:
              "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            alphatest_fragment:
              "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
            aomap_fragment:
              "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
            aomap_pars_fragment:
              "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "vec3 transformed = vec3( position );",
            beginnormal_vertex:
              "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
            bsdfs:
              "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
            bumpmap_pars_fragment:
              "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
            clipping_planes_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
            clipping_planes_pars_fragment:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
            clipping_planes_pars_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
            clipping_planes_vertex:
              "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
            color_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_pars_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
            color_vertex:
              "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
            common:
              "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
            cube_uv_reflection_fragment:
              "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
            defaultnormal_vertex:
              "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
            displacementmap_pars_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
            displacementmap_vertex:
              "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
            emissivemap_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
            emissivemap_pars_fragment:
              "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
            encodings_fragment:
              "gl_FragColor = linearToOutputTexel( gl_FragColor );",
            encodings_pars_fragment:
              "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
            envmap_fragment:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
            envmap_common_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
            envmap_pars_fragment:
              "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
            envmap_pars_vertex:
              "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
            envmap_physical_pars_fragment:
              "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
            envmap_vertex:
              "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
            fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
            fog_pars_vertex:
              "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
            fog_fragment:
              "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
            fog_pars_fragment:
              "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            gradientmap_pars_fragment:
              "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
            lightmap_fragment:
              "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
            lightmap_pars_fragment:
              "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex:
              "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
            lights_pars_begin:
              "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
            lights_toon_fragment:
              "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
            lights_toon_pars_fragment:
              "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
            lights_phong_fragment:
              "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
            lights_phong_pars_fragment:
              "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
            lights_physical_fragment:
              "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
            lights_physical_pars_fragment:
              "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
            lights_fragment_begin:
              "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
            lights_fragment_maps:
              "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
            lights_fragment_end:
              "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
            logdepthbuf_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment:
              "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
            logdepthbuf_pars_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
            logdepthbuf_vertex:
              "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
            map_fragment:
              "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
            map_pars_fragment:
              "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
            map_particle_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
            map_particle_pars_fragment:
              "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
            metalnessmap_fragment:
              "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
            metalnessmap_pars_fragment:
              "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex:
              "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
            morphtarget_pars_vertex:
              "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex:
              "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
            normal_fragment_begin:
              "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
            normal_fragment_maps:
              "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
            normalmap_pars_fragment:
              "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
            clearcoat_normal_fragment_begin:
              "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
            clearcoat_normal_fragment_maps:
              "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
            clearcoat_pars_fragment:
              "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
            packing:
              "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
            premultiplied_alpha_fragment:
              "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
            project_vertex:
              "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
            dithering_fragment:
              "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
            dithering_pars_fragment:
              "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
            roughnessmap_fragment:
              "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
            roughnessmap_pars_fragment:
              "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
            shadowmap_pars_vertex:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
            shadowmap_vertex:
              "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
            shadowmask_pars_fragment:
              "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
            skinbase_vertex:
              "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex:
              "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
            skinning_vertex:
              "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
            skinnormal_vertex:
              "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
            specularmap_fragment:
              "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment:
              "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment:
              "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
            tonemapping_pars_fragment:
              "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
            transmissionmap_fragment:
              "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
            transmissionmap_pars_fragment:
              "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
            uv_pars_fragment:
              "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex:
              "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
            uv_vertex:
              "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
            uv2_pars_fragment:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
            uv2_vertex:
              "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
            worldpos_vertex:
              "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
            background_frag:
              "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            background_vert:
              "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
            cube_frag:
              "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            cube_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
            depth_frag:
              "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
            depth_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
            distanceRGBA_frag:
              "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
            distanceRGBA_vert:
              "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
            equirect_frag:
              "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
            equirect_vert:
              "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
            linedashed_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            linedashed_vert:
              "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
            meshbasic_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshbasic_vert:
              "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
            meshlambert_frag:
              "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshlambert_vert:
              "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshmatcap_frag:
              "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshmatcap_vert:
              "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
            meshtoon_frag:
              "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshtoon_vert:
              "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphong_frag:
              "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphong_vert:
              "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            meshphysical_frag:
              "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
            meshphysical_vert:
              "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            normal_frag:
              "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
            normal_vert:
              "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
            points_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
            points_vert:
              "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
            shadow_frag:
              "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            shadow_vert:
              "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
            sprite_frag:
              "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
            sprite_vert:
              "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          },
          ui = {
            common: {
              diffuse: { value: new tn(15658734) },
              opacity: { value: 1 },
              map: { value: null },
              uvTransform: { value: new yt() },
              uv2Transform: { value: new yt() },
              alphaMap: { value: null },
            },
            specularmap: { specularMap: { value: null } },
            envmap: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              reflectivity: { value: 1 },
              refractionRatio: { value: 0.98 },
              maxMipLevel: { value: 0 },
            },
            aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
            lightmap: {
              lightMap: { value: null },
              lightMapIntensity: { value: 1 },
            },
            emissivemap: { emissiveMap: { value: null } },
            bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
            normalmap: {
              normalMap: { value: null },
              normalScale: { value: new vt(1, 1) },
            },
            displacementmap: {
              displacementMap: { value: null },
              displacementScale: { value: 1 },
              displacementBias: { value: 0 },
            },
            roughnessmap: { roughnessMap: { value: null } },
            metalnessmap: { metalnessMap: { value: null } },
            gradientmap: { gradientMap: { value: null } },
            fog: {
              fogDensity: { value: 25e-5 },
              fogNear: { value: 1 },
              fogFar: { value: 2e3 },
              fogColor: { value: new tn(16777215) },
            },
            lights: {
              ambientLightColor: { value: [] },
              lightProbe: { value: [] },
              directionalLights: {
                value: [],
                properties: { direction: {}, color: {} },
              },
              directionalLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              directionalShadowMap: { value: [] },
              directionalShadowMatrix: { value: [] },
              spotLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  direction: {},
                  distance: {},
                  coneCos: {},
                  penumbraCos: {},
                  decay: {},
                },
              },
              spotLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                },
              },
              spotShadowMap: { value: [] },
              spotShadowMatrix: { value: [] },
              pointLights: {
                value: [],
                properties: {
                  color: {},
                  position: {},
                  decay: {},
                  distance: {},
                },
              },
              pointLightShadows: {
                value: [],
                properties: {
                  shadowBias: {},
                  shadowNormalBias: {},
                  shadowRadius: {},
                  shadowMapSize: {},
                  shadowCameraNear: {},
                  shadowCameraFar: {},
                },
              },
              pointShadowMap: { value: [] },
              pointShadowMatrix: { value: [] },
              hemisphereLights: {
                value: [],
                properties: { direction: {}, skyColor: {}, groundColor: {} },
              },
              rectAreaLights: {
                value: [],
                properties: { color: {}, position: {}, width: {}, height: {} },
              },
              ltc_1: { value: null },
              ltc_2: { value: null },
            },
            points: {
              diffuse: { value: new tn(15658734) },
              opacity: { value: 1 },
              size: { value: 1 },
              scale: { value: 1 },
              map: { value: null },
              alphaMap: { value: null },
              uvTransform: { value: new yt() },
            },
            sprite: {
              diffuse: { value: new tn(15658734) },
              opacity: { value: 1 },
              center: { value: new vt(0.5, 0.5) },
              rotation: { value: 0 },
              map: { value: null },
              alphaMap: { value: null },
              uvTransform: { value: new yt() },
            },
          },
          di = {
            basic: {
              uniforms: Yn([
                ui.common,
                ui.specularmap,
                ui.envmap,
                ui.aomap,
                ui.lightmap,
                ui.fog,
              ]),
              vertexShader: hi.meshbasic_vert,
              fragmentShader: hi.meshbasic_frag,
            },
            lambert: {
              uniforms: Yn([
                ui.common,
                ui.specularmap,
                ui.envmap,
                ui.aomap,
                ui.lightmap,
                ui.emissivemap,
                ui.fog,
                ui.lights,
                { emissive: { value: new tn(0) } },
              ]),
              vertexShader: hi.meshlambert_vert,
              fragmentShader: hi.meshlambert_frag,
            },
            phong: {
              uniforms: Yn([
                ui.common,
                ui.specularmap,
                ui.envmap,
                ui.aomap,
                ui.lightmap,
                ui.emissivemap,
                ui.bumpmap,
                ui.normalmap,
                ui.displacementmap,
                ui.fog,
                ui.lights,
                {
                  emissive: { value: new tn(0) },
                  specular: { value: new tn(1118481) },
                  shininess: { value: 30 },
                },
              ]),
              vertexShader: hi.meshphong_vert,
              fragmentShader: hi.meshphong_frag,
            },
            standard: {
              uniforms: Yn([
                ui.common,
                ui.envmap,
                ui.aomap,
                ui.lightmap,
                ui.emissivemap,
                ui.bumpmap,
                ui.normalmap,
                ui.displacementmap,
                ui.roughnessmap,
                ui.metalnessmap,
                ui.fog,
                ui.lights,
                {
                  emissive: { value: new tn(0) },
                  roughness: { value: 1 },
                  metalness: { value: 0 },
                  envMapIntensity: { value: 1 },
                },
              ]),
              vertexShader: hi.meshphysical_vert,
              fragmentShader: hi.meshphysical_frag,
            },
            toon: {
              uniforms: Yn([
                ui.common,
                ui.aomap,
                ui.lightmap,
                ui.emissivemap,
                ui.bumpmap,
                ui.normalmap,
                ui.displacementmap,
                ui.gradientmap,
                ui.fog,
                ui.lights,
                { emissive: { value: new tn(0) } },
              ]),
              vertexShader: hi.meshtoon_vert,
              fragmentShader: hi.meshtoon_frag,
            },
            matcap: {
              uniforms: Yn([
                ui.common,
                ui.bumpmap,
                ui.normalmap,
                ui.displacementmap,
                ui.fog,
                { matcap: { value: null } },
              ]),
              vertexShader: hi.meshmatcap_vert,
              fragmentShader: hi.meshmatcap_frag,
            },
            points: {
              uniforms: Yn([ui.points, ui.fog]),
              vertexShader: hi.points_vert,
              fragmentShader: hi.points_frag,
            },
            dashed: {
              uniforms: Yn([
                ui.common,
                ui.fog,
                {
                  scale: { value: 1 },
                  dashSize: { value: 1 },
                  totalSize: { value: 2 },
                },
              ]),
              vertexShader: hi.linedashed_vert,
              fragmentShader: hi.linedashed_frag,
            },
            depth: {
              uniforms: Yn([ui.common, ui.displacementmap]),
              vertexShader: hi.depth_vert,
              fragmentShader: hi.depth_frag,
            },
            normal: {
              uniforms: Yn([
                ui.common,
                ui.bumpmap,
                ui.normalmap,
                ui.displacementmap,
                { opacity: { value: 1 } },
              ]),
              vertexShader: hi.normal_vert,
              fragmentShader: hi.normal_frag,
            },
            sprite: {
              uniforms: Yn([ui.sprite, ui.fog]),
              vertexShader: hi.sprite_vert,
              fragmentShader: hi.sprite_frag,
            },
            background: {
              uniforms: {
                uvTransform: { value: new yt() },
                t2D: { value: null },
              },
              vertexShader: hi.background_vert,
              fragmentShader: hi.background_frag,
            },
            cube: {
              uniforms: Yn([ui.envmap, { opacity: { value: 1 } }]),
              vertexShader: hi.cube_vert,
              fragmentShader: hi.cube_frag,
            },
            equirect: {
              uniforms: { tEquirect: { value: null } },
              vertexShader: hi.equirect_vert,
              fragmentShader: hi.equirect_frag,
            },
            distanceRGBA: {
              uniforms: Yn([
                ui.common,
                ui.displacementmap,
                {
                  referencePosition: { value: new Lt() },
                  nearDistance: { value: 1 },
                  farDistance: { value: 1e3 },
                },
              ]),
              vertexShader: hi.distanceRGBA_vert,
              fragmentShader: hi.distanceRGBA_frag,
            },
            shadow: {
              uniforms: Yn([
                ui.lights,
                ui.fog,
                { color: { value: new tn(0) }, opacity: { value: 1 } },
              ]),
              vertexShader: hi.shadow_vert,
              fragmentShader: hi.shadow_frag,
            },
          };
        function pi(t, e, n, i, r) {
          const s = new tn(0);
          let a,
            o,
            c = 0,
            h = null,
            u = 0,
            d = null;
          function p(t, e) {
            n.buffers.color.setClear(t.r, t.g, t.b, e, r);
          }
          return {
            getClearColor: function () {
              return s;
            },
            setClearColor: function (t, e = 1) {
              s.set(t), (c = e), p(s, c);
            },
            getClearAlpha: function () {
              return c;
            },
            setClearAlpha: function (t) {
              (c = t), p(s, c);
            },
            render: function (n, r, m, f) {
              let g = !0 === r.isScene ? r.background : null;
              g && g.isTexture && (g = e.get(g));
              const v = t.xr,
                y = v.getSession && v.getSession();
              y && "additive" === y.environmentBlendMode && (g = null),
                null === g ? p(s, c) : g && g.isColor && (p(g, 1), (f = !0)),
                (t.autoClear || f) &&
                  t.clear(
                    t.autoClearColor,
                    t.autoClearDepth,
                    t.autoClearStencil
                  ),
                g && (g.isCubeTexture || g.mapping === l)
                  ? (void 0 === o &&
                      ((o = new Wn(
                        new qn(1, 1, 1),
                        new Jn({
                          name: "BackgroundCubeMaterial",
                          uniforms: Xn(di.cube.uniforms),
                          vertexShader: di.cube.vertexShader,
                          fragmentShader: di.cube.fragmentShader,
                          side: 1,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      o.geometry.deleteAttribute("normal"),
                      o.geometry.deleteAttribute("uv"),
                      (o.onBeforeRender = function (t, e, n) {
                        this.matrixWorld.copyPosition(n.matrixWorld);
                      }),
                      Object.defineProperty(o.material, "envMap", {
                        get: function () {
                          return this.uniforms.envMap.value;
                        },
                      }),
                      i.update(o)),
                    (o.material.uniforms.envMap.value = g),
                    (o.material.uniforms.flipEnvMap.value =
                      g.isCubeTexture && g._needsFlipEnvMap ? -1 : 1),
                    (h === g && u === g.version && d === t.toneMapping) ||
                      ((o.material.needsUpdate = !0),
                      (h = g),
                      (u = g.version),
                      (d = t.toneMapping)),
                    n.unshift(o, o.geometry, o.material, 0, 0, null))
                  : g &&
                    g.isTexture &&
                    (void 0 === a &&
                      ((a = new Wn(
                        new ci(2, 2),
                        new Jn({
                          name: "BackgroundMaterial",
                          uniforms: Xn(di.background.uniforms),
                          vertexShader: di.background.vertexShader,
                          fragmentShader: di.background.fragmentShader,
                          side: 0,
                          depthTest: !1,
                          depthWrite: !1,
                          fog: !1,
                        })
                      )),
                      a.geometry.deleteAttribute("normal"),
                      Object.defineProperty(a.material, "map", {
                        get: function () {
                          return this.uniforms.t2D.value;
                        },
                      }),
                      i.update(a)),
                    (a.material.uniforms.t2D.value = g),
                    !0 === g.matrixAutoUpdate && g.updateMatrix(),
                    a.material.uniforms.uvTransform.value.copy(g.matrix),
                    (h === g && u === g.version && d === t.toneMapping) ||
                      ((a.material.needsUpdate = !0),
                      (h = g),
                      (u = g.version),
                      (d = t.toneMapping)),
                    n.unshift(a, a.geometry, a.material, 0, 0, null));
            },
          };
        }
        function mi(t, e, n, i) {
          const r = t.getParameter(34921),
            s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
            a = i.isWebGL2 || null !== s,
            o = {},
            l = d(null);
          let c = l;
          function h(e) {
            return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
          }
          function u(e) {
            return i.isWebGL2
              ? t.deleteVertexArray(e)
              : s.deleteVertexArrayOES(e);
          }
          function d(t) {
            const e = [],
              n = [],
              i = [];
            for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
            return {
              geometry: null,
              program: null,
              wireframe: !1,
              newAttributes: e,
              enabledAttributes: n,
              attributeDivisors: i,
              object: t,
              attributes: {},
              index: null,
            };
          }
          function p() {
            const t = c.newAttributes;
            for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
          }
          function m(t) {
            f(t, 0);
          }
          function f(n, r) {
            const s = c.newAttributes,
              a = c.enabledAttributes,
              o = c.attributeDivisors;
            if (
              ((s[n] = 1),
              0 === a[n] && (t.enableVertexAttribArray(n), (a[n] = 1)),
              o[n] !== r)
            ) {
              (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
                i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
              ](n, r),
                (o[n] = r);
            }
          }
          function g() {
            const e = c.newAttributes,
              n = c.enabledAttributes;
            for (let i = 0, r = n.length; i < r; i++)
              n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
          }
          function v(e, n, r, s, a, o) {
            !0 !== i.isWebGL2 || (5124 !== r && 5125 !== r)
              ? t.vertexAttribPointer(e, n, r, s, a, o)
              : t.vertexAttribIPointer(e, n, r, a, o);
          }
          function y() {
            x(), c !== l && ((c = l), h(c.object));
          }
          function x() {
            (l.geometry = null), (l.program = null), (l.wireframe = !1);
          }
          return {
            setup: function (r, l, u, y, x) {
              let _ = !1;
              if (a) {
                const e = (function (e, n, r) {
                  const a = !0 === r.wireframe;
                  let l = o[e.id];
                  void 0 === l && ((l = {}), (o[e.id] = l));
                  let c = l[n.id];
                  void 0 === c && ((c = {}), (l[n.id] = c));
                  let h = c[a];
                  void 0 === h &&
                    ((h = d(
                      i.isWebGL2
                        ? t.createVertexArray()
                        : s.createVertexArrayOES()
                    )),
                    (c[a] = h));
                  return h;
                })(y, u, l);
                c !== e && ((c = e), h(c.object)),
                  (_ = (function (t, e) {
                    const n = c.attributes,
                      i = t.attributes;
                    let r = 0;
                    for (const t in i) {
                      const e = n[t],
                        s = i[t];
                      if (void 0 === e) return !0;
                      if (e.attribute !== s) return !0;
                      if (e.data !== s.data) return !0;
                      r++;
                    }
                    return c.attributesNum !== r || c.index !== e;
                  })(y, x)),
                  _ &&
                    (function (t, e) {
                      const n = {},
                        i = t.attributes;
                      let r = 0;
                      for (const t in i) {
                        const e = i[t],
                          s = {};
                        (s.attribute = e),
                          e.data && (s.data = e.data),
                          (n[t] = s),
                          r++;
                      }
                      (c.attributes = n), (c.attributesNum = r), (c.index = e);
                    })(y, x);
              } else {
                const t = !0 === l.wireframe;
                (c.geometry === y.id &&
                  c.program === u.id &&
                  c.wireframe === t) ||
                  ((c.geometry = y.id),
                  (c.program = u.id),
                  (c.wireframe = t),
                  (_ = !0));
              }
              !0 === r.isInstancedMesh && (_ = !0),
                null !== x && n.update(x, 34963),
                _ &&
                  (!(function (r, s, a, o) {
                    if (
                      !1 === i.isWebGL2 &&
                      (r.isInstancedMesh || o.isInstancedBufferGeometry) &&
                      null === e.get("ANGLE_instanced_arrays")
                    )
                      return;
                    p();
                    const l = o.attributes,
                      c = a.getAttributes(),
                      h = s.defaultAttributeValues;
                    for (const e in c) {
                      const i = c[e];
                      if (i >= 0) {
                        const s = l[e];
                        if (void 0 !== s) {
                          const e = s.normalized,
                            r = s.itemSize,
                            a = n.get(s);
                          if (void 0 === a) continue;
                          const l = a.buffer,
                            c = a.type,
                            h = a.bytesPerElement;
                          if (s.isInterleavedBufferAttribute) {
                            const n = s.data,
                              a = n.stride,
                              u = s.offset;
                            n && n.isInstancedInterleavedBuffer
                              ? (f(i, n.meshPerAttribute),
                                void 0 === o._maxInstanceCount &&
                                  (o._maxInstanceCount =
                                    n.meshPerAttribute * n.count))
                              : m(i),
                              t.bindBuffer(34962, l),
                              v(i, r, c, e, a * h, u * h);
                          } else
                            s.isInstancedBufferAttribute
                              ? (f(i, s.meshPerAttribute),
                                void 0 === o._maxInstanceCount &&
                                  (o._maxInstanceCount =
                                    s.meshPerAttribute * s.count))
                              : m(i),
                              t.bindBuffer(34962, l),
                              v(i, r, c, e, 0, 0);
                        } else if ("instanceMatrix" === e) {
                          const e = n.get(r.instanceMatrix);
                          if (void 0 === e) continue;
                          const s = e.buffer,
                            a = e.type;
                          f(i + 0, 1),
                            f(i + 1, 1),
                            f(i + 2, 1),
                            f(i + 3, 1),
                            t.bindBuffer(34962, s),
                            t.vertexAttribPointer(i + 0, 4, a, !1, 64, 0),
                            t.vertexAttribPointer(i + 1, 4, a, !1, 64, 16),
                            t.vertexAttribPointer(i + 2, 4, a, !1, 64, 32),
                            t.vertexAttribPointer(i + 3, 4, a, !1, 64, 48);
                        } else if ("instanceColor" === e) {
                          const e = n.get(r.instanceColor);
                          if (void 0 === e) continue;
                          const s = e.buffer,
                            a = e.type;
                          f(i, 1),
                            t.bindBuffer(34962, s),
                            t.vertexAttribPointer(i, 3, a, !1, 12, 0);
                        } else if (void 0 !== h) {
                          const n = h[e];
                          if (void 0 !== n)
                            switch (n.length) {
                              case 2:
                                t.vertexAttrib2fv(i, n);
                                break;
                              case 3:
                                t.vertexAttrib3fv(i, n);
                                break;
                              case 4:
                                t.vertexAttrib4fv(i, n);
                                break;
                              default:
                                t.vertexAttrib1fv(i, n);
                            }
                        }
                      }
                    }
                    g();
                  })(r, l, u, y),
                  null !== x && t.bindBuffer(34963, n.get(x).buffer));
            },
            reset: y,
            resetDefaultState: x,
            dispose: function () {
              y();
              for (const t in o) {
                const e = o[t];
                for (const t in e) {
                  const n = e[t];
                  for (const t in n) u(n[t].object), delete n[t];
                  delete e[t];
                }
                delete o[t];
              }
            },
            releaseStatesOfGeometry: function (t) {
              if (void 0 === o[t.id]) return;
              const e = o[t.id];
              for (const t in e) {
                const n = e[t];
                for (const t in n) u(n[t].object), delete n[t];
                delete e[t];
              }
              delete o[t.id];
            },
            releaseStatesOfProgram: function (t) {
              for (const e in o) {
                const n = o[e];
                if (void 0 === n[t.id]) continue;
                const i = n[t.id];
                for (const t in i) u(i[t].object), delete i[t];
                delete n[t.id];
              }
            },
            initAttributes: p,
            enableAttribute: m,
            disableUnusedAttributes: g,
          };
        }
        function fi(t, e, n, i) {
          const r = i.isWebGL2;
          let s;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.render = function (e, i) {
              t.drawArrays(s, e, i), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, a, o) {
              if (0 === o) return;
              let l, c;
              if (r) (l = t), (c = "drawArraysInstanced");
              else if (
                ((l = e.get("ANGLE_instanced_arrays")),
                (c = "drawArraysInstancedANGLE"),
                null === l)
              )
                return void console.error(
                  "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              l[c](s, i, a, o), n.update(a, s, o);
            });
        }
        function gi(t, e, n) {
          let i;
          function r(e) {
            if ("highp" === e) {
              if (
                t.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
                t.getShaderPrecisionFormat(35632, 36338).precision > 0
              )
                return "highp";
              e = "mediump";
            }
            return "mediump" === e &&
              t.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
              t.getShaderPrecisionFormat(35632, 36337).precision > 0
              ? "mediump"
              : "lowp";
          }
          const s =
            ("undefined" != typeof WebGL2RenderingContext &&
              t instanceof WebGL2RenderingContext) ||
            ("undefined" != typeof WebGL2ComputeRenderingContext &&
              t instanceof WebGL2ComputeRenderingContext);
          let a = void 0 !== n.precision ? n.precision : "highp";
          const o = r(a);
          o !== a &&
            (console.warn(
              "THREE.WebGLRenderer:",
              a,
              "not supported, using",
              o,
              "instead."
            ),
            (a = o));
          const l = !0 === n.logarithmicDepthBuffer,
            c = t.getParameter(34930),
            h = t.getParameter(35660),
            u = t.getParameter(3379),
            d = t.getParameter(34076),
            p = t.getParameter(34921),
            m = t.getParameter(36347),
            f = t.getParameter(36348),
            g = t.getParameter(36349),
            v = h > 0,
            y = s || e.has("OES_texture_float");
          return {
            isWebGL2: s,
            getMaxAnisotropy: function () {
              if (void 0 !== i) return i;
              if (!0 === e.has("EXT_texture_filter_anisotropic")) {
                const n = e.get("EXT_texture_filter_anisotropic");
                i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
              } else i = 0;
              return i;
            },
            getMaxPrecision: r,
            precision: a,
            logarithmicDepthBuffer: l,
            maxTextures: c,
            maxVertexTextures: h,
            maxTextureSize: u,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: m,
            maxVaryings: f,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: s ? t.getParameter(36183) : 0,
          };
        }
        function vi(t) {
          const e = this;
          let n = null,
            i = 0,
            r = !1,
            s = !1;
          const a = new Ne(),
            o = new yt(),
            l = { value: null, needsUpdate: !1 };
          function c() {
            l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
              (e.numPlanes = i),
              (e.numIntersection = 0);
          }
          function h(t, n, i, r) {
            const s = null !== t ? t.length : 0;
            let c = null;
            if (0 !== s) {
              if (((c = l.value), !0 !== r || null === c)) {
                const e = i + 4 * s,
                  r = n.matrixWorldInverse;
                o.getNormalMatrix(r),
                  (null === c || c.length < e) && (c = new Float32Array(e));
                for (let e = 0, n = i; e !== s; ++e, n += 4)
                  a.copy(t[e]).applyMatrix4(r, o),
                    a.normal.toArray(c, n),
                    (c[n + 3] = a.constant);
              }
              (l.value = c), (l.needsUpdate = !0);
            }
            return (e.numPlanes = s), (e.numIntersection = 0), c;
          }
          (this.uniform = l),
            (this.numPlanes = 0),
            (this.numIntersection = 0),
            (this.init = function (t, e, s) {
              const a = 0 !== t.length || e || 0 !== i || r;
              return (r = e), (n = h(t, s, 0)), (i = t.length), a;
            }),
            (this.beginShadows = function () {
              (s = !0), h(null);
            }),
            (this.endShadows = function () {
              (s = !1), c();
            }),
            (this.setState = function (e, a, o) {
              const u = e.clippingPlanes,
                d = e.clipIntersection,
                p = e.clipShadows,
                m = t.get(e);
              if (!r || null === u || 0 === u.length || (s && !p))
                s ? h(null) : c();
              else {
                const t = s ? 0 : i,
                  e = 4 * t;
                let r = m.clippingState || null;
                (l.value = r), (r = h(u, a, e, o));
                for (let t = 0; t !== e; ++t) r[t] = n[t];
                (m.clippingState = r),
                  (this.numIntersection = d ? this.numPlanes : 0),
                  (this.numPlanes += t);
              }
            });
        }
        function yi(t) {
          let e = new WeakMap();
          function n(t, e) {
            return e === a ? (t.mapping = r) : e === o && (t.mapping = s), t;
          }
          function i(t) {
            const n = t.target;
            n.removeEventListener("dispose", i);
            const r = e.get(n);
            void 0 !== r && (e.delete(n), r.dispose());
          }
          return {
            get: function (r) {
              if (r && r.isTexture) {
                const s = r.mapping;
                if (s === a || s === o) {
                  if (e.has(r)) {
                    return n(e.get(r).texture, r.mapping);
                  }
                  {
                    const s = r.image;
                    if (s && s.height > 0) {
                      const a = t.getRenderTarget(),
                        o = new ni(s.height / 2);
                      return (
                        o.fromEquirectangularTexture(t, r),
                        e.set(r, o),
                        t.setRenderTarget(a),
                        r.addEventListener("dispose", i),
                        n(o.texture, r.mapping)
                      );
                    }
                    return null;
                  }
                }
              }
              return r;
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function xi(t) {
          const e = {};
          function n(n) {
            if (void 0 !== e[n]) return e[n];
            let i;
            switch (n) {
              case "WEBGL_depth_texture":
                i =
                  t.getExtension("WEBGL_depth_texture") ||
                  t.getExtension("MOZ_WEBGL_depth_texture") ||
                  t.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
              case "EXT_texture_filter_anisotropic":
                i =
                  t.getExtension("EXT_texture_filter_anisotropic") ||
                  t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                  t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
              case "WEBGL_compressed_texture_s3tc":
                i =
                  t.getExtension("WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
              case "WEBGL_compressed_texture_pvrtc":
                i =
                  t.getExtension("WEBGL_compressed_texture_pvrtc") ||
                  t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
              default:
                i = t.getExtension(n);
            }
            return (e[n] = i), i;
          }
          return {
            has: function (t) {
              return null !== n(t);
            },
            init: function (t) {
              t.isWebGL2
                ? n("EXT_color_buffer_float")
                : (n("WEBGL_depth_texture"),
                  n("OES_texture_float"),
                  n("OES_texture_half_float"),
                  n("OES_texture_half_float_linear"),
                  n("OES_standard_derivatives"),
                  n("OES_element_index_uint"),
                  n("OES_vertex_array_object"),
                  n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float");
            },
            get: function (t) {
              const e = n(t);
              return (
                null === e &&
                  console.warn(
                    "THREE.WebGLRenderer: " + t + " extension not supported."
                  ),
                e
              );
            },
          };
        }
        function _i(t, e, n, i) {
          const r = {},
            s = new WeakMap();
          function a(t) {
            const o = t.target;
            null !== o.index && e.remove(o.index);
            for (const t in o.attributes) e.remove(o.attributes[t]);
            o.removeEventListener("dispose", a), delete r[o.id];
            const l = s.get(o);
            l && (e.remove(l), s.delete(o)),
              i.releaseStatesOfGeometry(o),
              !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
              n.memory.geometries--;
          }
          function o(t) {
            const n = [],
              i = t.index,
              r = t.attributes.position;
            let a = 0;
            if (null !== i) {
              const t = i.array;
              a = i.version;
              for (let e = 0, i = t.length; e < i; e += 3) {
                const i = t[e + 0],
                  r = t[e + 1],
                  s = t[e + 2];
                n.push(i, r, r, s, s, i);
              }
            } else {
              const t = r.array;
              a = r.version;
              for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
                const t = e + 0,
                  i = e + 1,
                  r = e + 2;
                n.push(t, i, i, r, r, t);
              }
            }
            const o = new (gn(n) > 65535 ? dn : hn)(n, 1);
            o.version = a;
            const l = s.get(t);
            l && e.remove(l), s.set(t, o);
          }
          return {
            get: function (t, e) {
              return (
                !0 === r[e.id] ||
                  (e.addEventListener("dispose", a),
                  (r[e.id] = !0),
                  n.memory.geometries++),
                e
              );
            },
            update: function (t) {
              const n = t.attributes;
              for (const t in n) e.update(n[t], 34962);
              const i = t.morphAttributes;
              for (const t in i) {
                const n = i[t];
                for (let t = 0, i = n.length; t < i; t++) e.update(n[t], 34962);
              }
            },
            getWireframeAttribute: function (t) {
              const e = s.get(t);
              if (e) {
                const n = t.index;
                null !== n && e.version < n.version && o(t);
              } else o(t);
              return s.get(t);
            },
          };
        }
        function wi(t, e, n, i) {
          const r = i.isWebGL2;
          let s, a, o;
          (this.setMode = function (t) {
            s = t;
          }),
            (this.setIndex = function (t) {
              (a = t.type), (o = t.bytesPerElement);
            }),
            (this.render = function (e, i) {
              t.drawElements(s, i, a, e * o), n.update(i, s, 1);
            }),
            (this.renderInstances = function (i, l, c) {
              if (0 === c) return;
              let h, u;
              if (r) (h = t), (u = "drawElementsInstanced");
              else if (
                ((h = e.get("ANGLE_instanced_arrays")),
                (u = "drawElementsInstancedANGLE"),
                null === h)
              )
                return void console.error(
                  "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
                );
              h[u](s, l, a, i * o, c), n.update(l, s, c);
            });
        }
        function bi(t) {
          const e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
          return {
            memory: { geometries: 0, textures: 0 },
            render: e,
            programs: null,
            autoReset: !0,
            reset: function () {
              e.frame++,
                (e.calls = 0),
                (e.triangles = 0),
                (e.points = 0),
                (e.lines = 0);
            },
            update: function (t, n, i) {
              switch ((e.calls++, n)) {
                case 4:
                  e.triangles += i * (t / 3);
                  break;
                case 1:
                  e.lines += i * (t / 2);
                  break;
                case 3:
                  e.lines += i * (t - 1);
                  break;
                case 2:
                  e.lines += i * t;
                  break;
                case 0:
                  e.points += i * t;
                  break;
                default:
                  console.error("THREE.WebGLInfo: Unknown draw mode:", n);
              }
            },
          };
        }
        function Mi(t, e) {
          return t[0] - e[0];
        }
        function Si(t, e) {
          return Math.abs(e[1]) - Math.abs(t[1]);
        }
        function Ti(t) {
          const e = {},
            n = new Float32Array(8),
            i = [];
          for (let t = 0; t < 8; t++) i[t] = [t, 0];
          return {
            update: function (r, s, a, o) {
              const l = r.morphTargetInfluences,
                c = void 0 === l ? 0 : l.length;
              let h = e[s.id];
              if (void 0 === h) {
                h = [];
                for (let t = 0; t < c; t++) h[t] = [t, 0];
                e[s.id] = h;
              }
              for (let t = 0; t < c; t++) {
                const e = h[t];
                (e[0] = t), (e[1] = l[t]);
              }
              h.sort(Si);
              for (let t = 0; t < 8; t++)
                t < c && h[t][1]
                  ? ((i[t][0] = h[t][0]), (i[t][1] = h[t][1]))
                  : ((i[t][0] = Number.MAX_SAFE_INTEGER), (i[t][1] = 0));
              i.sort(Mi);
              const u = a.morphTargets && s.morphAttributes.position,
                d = a.morphNormals && s.morphAttributes.normal;
              let p = 0;
              for (let t = 0; t < 8; t++) {
                const e = i[t],
                  r = e[0],
                  a = e[1];
                r !== Number.MAX_SAFE_INTEGER && a
                  ? (u &&
                      s.getAttribute("morphTarget" + t) !== u[r] &&
                      s.setAttribute("morphTarget" + t, u[r]),
                    d &&
                      s.getAttribute("morphNormal" + t) !== d[r] &&
                      s.setAttribute("morphNormal" + t, d[r]),
                    (n[t] = a),
                    (p += a))
                  : (u &&
                      !0 === s.hasAttribute("morphTarget" + t) &&
                      s.deleteAttribute("morphTarget" + t),
                    d &&
                      !0 === s.hasAttribute("morphNormal" + t) &&
                      s.deleteAttribute("morphNormal" + t),
                    (n[t] = 0));
              }
              const m = s.morphTargetsRelative ? 1 : 1 - p;
              o.getUniforms().setValue(t, "morphTargetBaseInfluence", m),
                o.getUniforms().setValue(t, "morphTargetInfluences", n);
            },
          };
        }
        function Ei(t, e, n, i) {
          let r = new WeakMap();
          function s(t) {
            const e = t.target;
            e.removeEventListener("dispose", s),
              n.remove(e.instanceMatrix),
              null !== e.instanceColor && n.remove(e.instanceColor);
          }
          return {
            update: function (t) {
              const a = i.render.frame,
                o = t.geometry,
                l = e.get(t, o);
              return (
                r.get(l) !== a && (e.update(l), r.set(l, a)),
                t.isInstancedMesh &&
                  (!1 === t.hasEventListener("dispose", s) &&
                    t.addEventListener("dispose", s),
                  n.update(t.instanceMatrix, 34962),
                  null !== t.instanceColor && n.update(t.instanceColor, 34962)),
                l
              );
            },
            dispose: function () {
              r = new WeakMap();
            },
          };
        }
        di.physical = {
          uniforms: Yn([
            di.standard.uniforms,
            {
              clearcoat: { value: 0 },
              clearcoatMap: { value: null },
              clearcoatRoughness: { value: 0 },
              clearcoatRoughnessMap: { value: null },
              clearcoatNormalScale: { value: new vt(1, 1) },
              clearcoatNormalMap: { value: null },
              sheen: { value: new tn(0) },
              transmission: { value: 0 },
              transmissionMap: { value: null },
            },
          ]),
          vertexShader: hi.meshphysical_vert,
          fragmentShader: hi.meshphysical_frag,
        };
        class Ai extends bt {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = p),
              (this.minFilter = p),
              (this.wrapR = u),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        Ai.prototype.isDataTexture2DArray = !0;
        class Li extends bt {
          constructor(t = null, e = 1, n = 1, i = 1) {
            super(null),
              (this.image = { data: t, width: e, height: n, depth: i }),
              (this.magFilter = p),
              (this.minFilter = p),
              (this.wrapR = u),
              (this.generateMipmaps = !1),
              (this.flipY = !1),
              (this.unpackAlignment = 1),
              (this.needsUpdate = !0);
          }
        }
        Li.prototype.isDataTexture3D = !0;
        const Ri = new bt(),
          Ci = new Ai(),
          Pi = new Li(),
          Di = new ei(),
          Ii = [],
          Ni = [],
          Bi = new Float32Array(16),
          zi = new Float32Array(9),
          Fi = new Float32Array(4);
        function Oi(t, e, n) {
          const i = t[0];
          if (i <= 0 || i > 0) return t;
          const r = e * n;
          let s = Ii[r];
          if (
            (void 0 === s && ((s = new Float32Array(r)), (Ii[r] = s)), 0 !== e)
          ) {
            i.toArray(s, 0);
            for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
          }
          return s;
        }
        function Hi(t, e) {
          if (t.length !== e.length) return !1;
          for (let n = 0, i = t.length; n < i; n++)
            if (t[n] !== e[n]) return !1;
          return !0;
        }
        function Gi(t, e) {
          for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
        }
        function Ui(t, e) {
          let n = Ni[e];
          void 0 === n && ((n = new Int32Array(e)), (Ni[e] = n));
          for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
          return n;
        }
        function ki(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
        }
        function Vi(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y) ||
              (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
          else {
            if (Hi(n, e)) return;
            t.uniform2fv(this.addr, e), Gi(n, e);
          }
        }
        function Wi(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
              (t.uniform3f(this.addr, e.x, e.y, e.z),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z));
          else if (void 0 !== e.r)
            (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
              (t.uniform3f(this.addr, e.r, e.g, e.b),
              (n[0] = e.r),
              (n[1] = e.g),
              (n[2] = e.b));
          else {
            if (Hi(n, e)) return;
            t.uniform3fv(this.addr, e), Gi(n, e);
          }
        }
        function ji(t, e) {
          const n = this.cache;
          if (void 0 !== e.x)
            (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
              (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
              (n[0] = e.x),
              (n[1] = e.y),
              (n[2] = e.z),
              (n[3] = e.w));
          else {
            if (Hi(n, e)) return;
            t.uniform4fv(this.addr, e), Gi(n, e);
          }
        }
        function qi(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (Hi(n, e)) return;
            t.uniformMatrix2fv(this.addr, !1, e), Gi(n, e);
          } else {
            if (Hi(n, i)) return;
            Fi.set(i), t.uniformMatrix2fv(this.addr, !1, Fi), Gi(n, i);
          }
        }
        function Xi(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (Hi(n, e)) return;
            t.uniformMatrix3fv(this.addr, !1, e), Gi(n, e);
          } else {
            if (Hi(n, i)) return;
            zi.set(i), t.uniformMatrix3fv(this.addr, !1, zi), Gi(n, i);
          }
        }
        function Yi(t, e) {
          const n = this.cache,
            i = e.elements;
          if (void 0 === i) {
            if (Hi(n, e)) return;
            t.uniformMatrix4fv(this.addr, !1, e), Gi(n, e);
          } else {
            if (Hi(n, i)) return;
            Bi.set(i), t.uniformMatrix4fv(this.addr, !1, Bi), Gi(n, i);
          }
        }
        function Zi(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
        }
        function Ji(t, e) {
          const n = this.cache;
          Hi(n, e) || (t.uniform2iv(this.addr, e), Gi(n, e));
        }
        function Qi(t, e) {
          const n = this.cache;
          Hi(n, e) || (t.uniform3iv(this.addr, e), Gi(n, e));
        }
        function Ki(t, e) {
          const n = this.cache;
          Hi(n, e) || (t.uniform4iv(this.addr, e), Gi(n, e));
        }
        function $i(t, e) {
          const n = this.cache;
          n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
        }
        function tr(t, e) {
          const n = this.cache;
          Hi(n, e) || (t.uniform2uiv(this.addr, e), Gi(n, e));
        }
        function er(t, e) {
          const n = this.cache;
          Hi(n, e) || (t.uniform3uiv(this.addr, e), Gi(n, e));
        }
        function nr(t, e) {
          const n = this.cache;
          Hi(n, e) || (t.uniform4uiv(this.addr, e), Gi(n, e));
        }
        function ir(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.safeSetTexture2D(e || Ri, r);
        }
        function rr(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture3D(e || Pi, r);
        }
        function sr(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.safeSetTextureCube(e || Di, r);
        }
        function ar(t, e, n) {
          const i = this.cache,
            r = n.allocateTextureUnit();
          i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
            n.setTexture2DArray(e || Ci, r);
        }
        function or(t, e) {
          t.uniform1fv(this.addr, e);
        }
        function lr(t, e) {
          const n = Oi(e, this.size, 2);
          t.uniform2fv(this.addr, n);
        }
        function cr(t, e) {
          const n = Oi(e, this.size, 3);
          t.uniform3fv(this.addr, n);
        }
        function hr(t, e) {
          const n = Oi(e, this.size, 4);
          t.uniform4fv(this.addr, n);
        }
        function ur(t, e) {
          const n = Oi(e, this.size, 4);
          t.uniformMatrix2fv(this.addr, !1, n);
        }
        function dr(t, e) {
          const n = Oi(e, this.size, 9);
          t.uniformMatrix3fv(this.addr, !1, n);
        }
        function pr(t, e) {
          const n = Oi(e, this.size, 16);
          t.uniformMatrix4fv(this.addr, !1, n);
        }
        function mr(t, e) {
          t.uniform1iv(this.addr, e);
        }
        function fr(t, e) {
          t.uniform2iv(this.addr, e);
        }
        function gr(t, e) {
          t.uniform3iv(this.addr, e);
        }
        function vr(t, e) {
          t.uniform4iv(this.addr, e);
        }
        function yr(t, e) {
          t.uniform1uiv(this.addr, e);
        }
        function xr(t, e) {
          t.uniform2uiv(this.addr, e);
        }
        function _r(t, e) {
          t.uniform3uiv(this.addr, e);
        }
        function wr(t, e) {
          t.uniform4uiv(this.addr, e);
        }
        function br(t, e, n) {
          const i = e.length,
            r = Ui(n, i);
          t.uniform1iv(this.addr, r);
          for (let t = 0; t !== i; ++t) n.safeSetTexture2D(e[t] || Ri, r[t]);
        }
        function Mr(t, e, n) {
          const i = e.length,
            r = Ui(n, i);
          t.uniform1iv(this.addr, r);
          for (let t = 0; t !== i; ++t) n.safeSetTextureCube(e[t] || Di, r[t]);
        }
        function Sr(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return ki;
                case 35664:
                  return Vi;
                case 35665:
                  return Wi;
                case 35666:
                  return ji;
                case 35674:
                  return qi;
                case 35675:
                  return Xi;
                case 35676:
                  return Yi;
                case 5124:
                case 35670:
                  return Zi;
                case 35667:
                case 35671:
                  return Ji;
                case 35668:
                case 35672:
                  return Qi;
                case 35669:
                case 35673:
                  return Ki;
                case 5125:
                  return $i;
                case 36294:
                  return tr;
                case 36295:
                  return er;
                case 36296:
                  return nr;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return ir;
                case 35679:
                case 36299:
                case 36307:
                  return rr;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return sr;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return ar;
              }
            })(e.type));
        }
        function Tr(t, e, n) {
          (this.id = t),
            (this.addr = n),
            (this.cache = []),
            (this.size = e.size),
            (this.setValue = (function (t) {
              switch (t) {
                case 5126:
                  return or;
                case 35664:
                  return lr;
                case 35665:
                  return cr;
                case 35666:
                  return hr;
                case 35674:
                  return ur;
                case 35675:
                  return dr;
                case 35676:
                  return pr;
                case 5124:
                case 35670:
                  return mr;
                case 35667:
                case 35671:
                  return fr;
                case 35668:
                case 35672:
                  return gr;
                case 35669:
                case 35673:
                  return vr;
                case 5125:
                  return yr;
                case 36294:
                  return xr;
                case 36295:
                  return _r;
                case 36296:
                  return wr;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return br;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Mr;
              }
            })(e.type));
        }
        function Er(t) {
          (this.id = t), (this.seq = []), (this.map = {});
        }
        (Tr.prototype.updateCache = function (t) {
          const e = this.cache;
          t instanceof Float32Array &&
            e.length !== t.length &&
            (this.cache = new Float32Array(t.length)),
            Gi(e, t);
        }),
          (Er.prototype.setValue = function (t, e, n) {
            const i = this.seq;
            for (let r = 0, s = i.length; r !== s; ++r) {
              const s = i[r];
              s.setValue(t, e[s.id], n);
            }
          });
        const Ar = /(\w+)(\])?(\[|\.)?/g;
        function Lr(t, e) {
          t.seq.push(e), (t.map[e.id] = e);
        }
        function Rr(t, e, n) {
          const i = t.name,
            r = i.length;
          for (Ar.lastIndex = 0; ; ) {
            const s = Ar.exec(i),
              a = Ar.lastIndex;
            let o = s[1];
            const l = "]" === s[2],
              c = s[3];
            if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
              Lr(n, void 0 === c ? new Sr(o, t, e) : new Tr(o, t, e));
              break;
            }
            {
              let t = n.map[o];
              void 0 === t && ((t = new Er(o)), Lr(n, t)), (n = t);
            }
          }
        }
        function Cr(t, e) {
          (this.seq = []), (this.map = {});
          const n = t.getProgramParameter(e, 35718);
          for (let i = 0; i < n; ++i) {
            const n = t.getActiveUniform(e, i);
            Rr(n, t.getUniformLocation(e, n.name), this);
          }
        }
        function Pr(t, e, n) {
          const i = t.createShader(e);
          return t.shaderSource(i, n), t.compileShader(i), i;
        }
        (Cr.prototype.setValue = function (t, e, n, i) {
          const r = this.map[e];
          void 0 !== r && r.setValue(t, n, i);
        }),
          (Cr.prototype.setOptional = function (t, e, n) {
            const i = e[n];
            void 0 !== i && this.setValue(t, n, i);
          }),
          (Cr.upload = function (t, e, n, i) {
            for (let r = 0, s = e.length; r !== s; ++r) {
              const s = e[r],
                a = n[s.id];
              !1 !== a.needsUpdate && s.setValue(t, a.value, i);
            }
          }),
          (Cr.seqWithValue = function (t, e) {
            const n = [];
            for (let i = 0, r = t.length; i !== r; ++i) {
              const r = t[i];
              r.id in e && n.push(r);
            }
            return n;
          });
        let Dr = 0;
        function Ir(t) {
          switch (t) {
            case X:
              return ["Linear", "( value )"];
            case Y:
              return ["sRGB", "( value )"];
            case J:
              return ["RGBE", "( value )"];
            case Q:
              return ["RGBM", "( value, 7.0 )"];
            case K:
              return ["RGBM", "( value, 16.0 )"];
            case $:
              return ["RGBD", "( value, 256.0 )"];
            case Z:
              return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            case 3003:
              return ["LogLuv", "( value )"];
            default:
              return (
                console.warn("THREE.WebGLProgram: Unsupported encoding:", t),
                ["Linear", "( value )"]
              );
          }
        }
        function Nr(t, e, n) {
          const i = t.getShaderParameter(e, 35713),
            r = t.getShaderInfoLog(e).trim();
          if (i && "" === r) return "";
          return (
            "THREE.WebGLShader: gl.getShaderInfoLog() " +
            n +
            "\n" +
            r +
            (function (t) {
              const e = t.split("\n");
              for (let t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
              return e.join("\n");
            })(t.getShaderSource(e))
          );
        }
        function Br(t, e) {
          const n = Ir(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return " +
            n[0] +
            "ToLinear" +
            n[1] +
            "; }"
          );
        }
        function zr(t, e) {
          const n = Ir(e);
          return (
            "vec4 " +
            t +
            "( vec4 value ) { return LinearTo" +
            n[0] +
            n[1] +
            "; }"
          );
        }
        function Fr(t, e) {
          let n;
          switch (e) {
            case 1:
              n = "Linear";
              break;
            case 2:
              n = "Reinhard";
              break;
            case 3:
              n = "OptimizedCineon";
              break;
            case 4:
              n = "ACESFilmic";
              break;
            case 5:
              n = "Custom";
              break;
            default:
              console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
                (n = "Linear");
          }
          return (
            "vec3 " +
            t +
            "( vec3 color ) { return " +
            n +
            "ToneMapping( color ); }"
          );
        }
        function Or(t) {
          return "" !== t;
        }
        function Hr(t, e) {
          return t
            .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
            .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
            .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
            .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
            .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
            .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
            .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
        }
        function Gr(t, e) {
          return t
            .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
            .replace(
              /UNION_CLIPPING_PLANES/g,
              e.numClippingPlanes - e.numClipIntersection
            );
        }
        const Ur = /^[ \t]*#include +<([\w\d./]+)>/gm;
        function kr(t) {
          return t.replace(Ur, Vr);
        }
        function Vr(t, e) {
          const n = hi[e];
          if (void 0 === n)
            throw new Error("Can not resolve #include <" + e + ">");
          return kr(n);
        }
        const Wr =
            /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
          jr =
            /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
        function qr(t) {
          return t.replace(jr, Yr).replace(Wr, Xr);
        }
        function Xr(t, e, n, i) {
          return (
            console.warn(
              "WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."
            ),
            Yr(t, e, n, i)
          );
        }
        function Yr(t, e, n, i) {
          let r = "";
          for (let t = parseInt(e); t < parseInt(n); t++)
            r += i
              .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
              .replace(/UNROLLED_LOOP_INDEX/g, t);
          return r;
        }
        function Zr(t) {
          let e =
            "precision " +
            t.precision +
            " float;\nprecision " +
            t.precision +
            " int;";
          return (
            "highp" === t.precision
              ? (e += "\n#define HIGH_PRECISION")
              : "mediump" === t.precision
              ? (e += "\n#define MEDIUM_PRECISION")
              : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
            e
          );
        }
        function Jr(t, e, n, i) {
          const a = t.getContext(),
            o = n.defines;
          let h = n.vertexShader,
            u = n.fragmentShader;
          const d = (function (t) {
              let e = "SHADOWMAP_TYPE_BASIC";
              return (
                1 === t.shadowMapType
                  ? (e = "SHADOWMAP_TYPE_PCF")
                  : 2 === t.shadowMapType
                  ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
                  : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
                e
              );
            })(n),
            p = (function (t) {
              let e = "ENVMAP_TYPE_CUBE";
              if (t.envMap)
                switch (t.envMapMode) {
                  case r:
                  case s:
                    e = "ENVMAP_TYPE_CUBE";
                    break;
                  case l:
                  case c:
                    e = "ENVMAP_TYPE_CUBE_UV";
                }
              return e;
            })(n),
            m = (function (t) {
              let e = "ENVMAP_MODE_REFLECTION";
              if (t.envMap)
                switch (t.envMapMode) {
                  case s:
                  case c:
                    e = "ENVMAP_MODE_REFRACTION";
                }
              return e;
            })(n),
            f = (function (t) {
              let e = "ENVMAP_BLENDING_NONE";
              if (t.envMap)
                switch (t.combine) {
                  case 0:
                    e = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                  case 1:
                    e = "ENVMAP_BLENDING_MIX";
                    break;
                  case 2:
                    e = "ENVMAP_BLENDING_ADD";
                }
              return e;
            })(n),
            g = t.gammaFactor > 0 ? t.gammaFactor : 1,
            v = n.isWebGL2
              ? ""
              : (function (t) {
                  return [
                    t.extensionDerivatives ||
                    t.envMapCubeUV ||
                    t.bumpMap ||
                    t.tangentSpaceNormalMap ||
                    t.clearcoatNormalMap ||
                    t.flatShading ||
                    "physical" === t.shaderID
                      ? "#extension GL_OES_standard_derivatives : enable"
                      : "",
                    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                    t.rendererExtensionFragDepth
                      ? "#extension GL_EXT_frag_depth : enable"
                      : "",
                    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                      ? "#extension GL_EXT_draw_buffers : require"
                      : "",
                    (t.extensionShaderTextureLOD || t.envMap) &&
                    t.rendererExtensionShaderTextureLod
                      ? "#extension GL_EXT_shader_texture_lod : enable"
                      : "",
                  ]
                    .filter(Or)
                    .join("\n");
                })(n),
            y = (function (t) {
              const e = [];
              for (const n in t) {
                const i = t[n];
                !1 !== i && e.push("#define " + n + " " + i);
              }
              return e.join("\n");
            })(o),
            x = a.createProgram();
          let _,
            w,
            b = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
          n.isRawShaderMaterial
            ? ((_ = [y].filter(Or).join("\n")),
              _.length > 0 && (_ += "\n"),
              (w = [v, y].filter(Or).join("\n")),
              w.length > 0 && (w += "\n"))
            : ((_ = [
                Zr(n),
                "#define SHADER_NAME " + n.shaderName,
                y,
                n.instancing ? "#define USE_INSTANCING" : "",
                n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
                n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
                "#define GAMMA_FACTOR " + g,
                "#define MAX_BONES " + n.maxBones,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + m : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.displacementMap && n.supportsVertexTextures
                  ? "#define USE_DISPLACEMENTMAP"
                  : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.skinning ? "#define USE_SKINNING" : "",
                n.useVertexTexture ? "#define BONE_TEXTURE" : "",
                n.morphTargets ? "#define USE_MORPHTARGETS" : "",
                n.morphNormals && !1 === n.flatShading
                  ? "#define USE_MORPHNORMALS"
                  : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + d : "",
                n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                "uniform mat4 modelMatrix;",
                "uniform mat4 modelViewMatrix;",
                "uniform mat4 projectionMatrix;",
                "uniform mat4 viewMatrix;",
                "uniform mat3 normalMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                "#ifdef USE_INSTANCING",
                "\tattribute mat4 instanceMatrix;",
                "#endif",
                "#ifdef USE_INSTANCING_COLOR",
                "\tattribute vec3 instanceColor;",
                "#endif",
                "attribute vec3 position;",
                "attribute vec3 normal;",
                "attribute vec2 uv;",
                "#ifdef USE_TANGENT",
                "\tattribute vec4 tangent;",
                "#endif",
                "#if defined( USE_COLOR_ALPHA )",
                "\tattribute vec4 color;",
                "#elif defined( USE_COLOR )",
                "\tattribute vec3 color;",
                "#endif",
                "#ifdef USE_MORPHTARGETS",
                "\tattribute vec3 morphTarget0;",
                "\tattribute vec3 morphTarget1;",
                "\tattribute vec3 morphTarget2;",
                "\tattribute vec3 morphTarget3;",
                "\t#ifdef USE_MORPHNORMALS",
                "\t\tattribute vec3 morphNormal0;",
                "\t\tattribute vec3 morphNormal1;",
                "\t\tattribute vec3 morphNormal2;",
                "\t\tattribute vec3 morphNormal3;",
                "\t#else",
                "\t\tattribute vec3 morphTarget4;",
                "\t\tattribute vec3 morphTarget5;",
                "\t\tattribute vec3 morphTarget6;",
                "\t\tattribute vec3 morphTarget7;",
                "\t#endif",
                "#endif",
                "#ifdef USE_SKINNING",
                "\tattribute vec4 skinIndex;",
                "\tattribute vec4 skinWeight;",
                "#endif",
                "\n",
              ]
                .filter(Or)
                .join("\n")),
              (w = [
                v,
                Zr(n),
                "#define SHADER_NAME " + n.shaderName,
                y,
                n.alphaTest
                  ? "#define ALPHATEST " +
                    n.alphaTest +
                    (n.alphaTest % 1 ? "" : ".0")
                  : "",
                "#define GAMMA_FACTOR " + g,
                n.useFog && n.fog ? "#define USE_FOG" : "",
                n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
                n.map ? "#define USE_MAP" : "",
                n.matcap ? "#define USE_MATCAP" : "",
                n.envMap ? "#define USE_ENVMAP" : "",
                n.envMap ? "#define " + p : "",
                n.envMap ? "#define " + m : "",
                n.envMap ? "#define " + f : "",
                n.lightMap ? "#define USE_LIGHTMAP" : "",
                n.aoMap ? "#define USE_AOMAP" : "",
                n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
                n.bumpMap ? "#define USE_BUMPMAP" : "",
                n.normalMap ? "#define USE_NORMALMAP" : "",
                n.normalMap && n.objectSpaceNormalMap
                  ? "#define OBJECTSPACE_NORMALMAP"
                  : "",
                n.normalMap && n.tangentSpaceNormalMap
                  ? "#define TANGENTSPACE_NORMALMAP"
                  : "",
                n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
                n.clearcoatRoughnessMap
                  ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                  : "",
                n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
                n.specularMap ? "#define USE_SPECULARMAP" : "",
                n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
                n.metalnessMap ? "#define USE_METALNESSMAP" : "",
                n.alphaMap ? "#define USE_ALPHAMAP" : "",
                n.sheen ? "#define USE_SHEEN" : "",
                n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
                n.vertexTangents ? "#define USE_TANGENT" : "",
                n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
                n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
                n.vertexUvs ? "#define USE_UV" : "",
                n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "",
                n.gradientMap ? "#define USE_GRADIENTMAP" : "",
                n.flatShading ? "#define FLAT_SHADED" : "",
                n.doubleSided ? "#define DOUBLE_SIDED" : "",
                n.flipSided ? "#define FLIP_SIDED" : "",
                n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
                n.shadowMapEnabled ? "#define " + d : "",
                n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
                n.physicallyCorrectLights
                  ? "#define PHYSICALLY_CORRECT_LIGHTS"
                  : "",
                n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
                n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
                  ? "#define USE_LOGDEPTHBUF_EXT"
                  : "",
                (n.extensionShaderTextureLOD || n.envMap) &&
                n.rendererExtensionShaderTextureLod
                  ? "#define TEXTURE_LOD_EXT"
                  : "",
                "uniform mat4 viewMatrix;",
                "uniform vec3 cameraPosition;",
                "uniform bool isOrthographic;",
                0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
                0 !== n.toneMapping ? hi.tonemapping_pars_fragment : "",
                0 !== n.toneMapping ? Fr("toneMapping", n.toneMapping) : "",
                n.dithering ? "#define DITHERING" : "",
                hi.encodings_pars_fragment,
                n.map ? Br("mapTexelToLinear", n.mapEncoding) : "",
                n.matcap ? Br("matcapTexelToLinear", n.matcapEncoding) : "",
                n.envMap ? Br("envMapTexelToLinear", n.envMapEncoding) : "",
                n.emissiveMap
                  ? Br("emissiveMapTexelToLinear", n.emissiveMapEncoding)
                  : "",
                n.lightMap
                  ? Br("lightMapTexelToLinear", n.lightMapEncoding)
                  : "",
                zr("linearToOutputTexel", n.outputEncoding),
                n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
                "\n",
              ]
                .filter(Or)
                .join("\n"))),
            (h = kr(h)),
            (h = Hr(h, n)),
            (h = Gr(h, n)),
            (u = kr(u)),
            (u = Hr(u, n)),
            (u = Gr(u, n)),
            (h = qr(h)),
            (u = qr(u)),
            n.isWebGL2 &&
              !0 !== n.isRawShaderMaterial &&
              ((b = "#version 300 es\n"),
              (_ =
                [
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                _),
              (w =
                [
                  "#define varying in",
                  n.glslVersion === it ? "" : "out highp vec4 pc_fragColor;",
                  n.glslVersion === it
                    ? ""
                    : "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                w));
          const M = b + w + u,
            S = Pr(a, 35633, b + _ + h),
            T = Pr(a, 35632, M);
          if (
            (a.attachShader(x, S),
            a.attachShader(x, T),
            void 0 !== n.index0AttributeName
              ? a.bindAttribLocation(x, 0, n.index0AttributeName)
              : !0 === n.morphTargets && a.bindAttribLocation(x, 0, "position"),
            a.linkProgram(x),
            t.debug.checkShaderErrors)
          ) {
            const t = a.getProgramInfoLog(x).trim(),
              e = a.getShaderInfoLog(S).trim(),
              n = a.getShaderInfoLog(T).trim();
            let i = !0,
              r = !0;
            if (!1 === a.getProgramParameter(x, 35714)) {
              i = !1;
              const e = Nr(a, S, "vertex"),
                n = Nr(a, T, "fragment");
              console.error(
                "THREE.WebGLProgram: shader error: ",
                a.getError(),
                "35715",
                a.getProgramParameter(x, 35715),
                "gl.getProgramInfoLog",
                t,
                e,
                n
              );
            } else
              "" !== t
                ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t)
                : ("" !== e && "" !== n) || (r = !1);
            r &&
              (this.diagnostics = {
                runnable: i,
                programLog: t,
                vertexShader: { log: e, prefix: _ },
                fragmentShader: { log: n, prefix: w },
              });
          }
          let E, A;
          return (
            a.deleteShader(S),
            a.deleteShader(T),
            (this.getUniforms = function () {
              return void 0 === E && (E = new Cr(a, x)), E;
            }),
            (this.getAttributes = function () {
              return (
                void 0 === A &&
                  (A = (function (t, e) {
                    const n = {},
                      i = t.getProgramParameter(e, 35721);
                    for (let r = 0; r < i; r++) {
                      const i = t.getActiveAttrib(e, r).name;
                      n[i] = t.getAttribLocation(e, i);
                    }
                    return n;
                  })(a, x)),
                A
              );
            }),
            (this.destroy = function () {
              i.releaseStatesOfProgram(this),
                a.deleteProgram(x),
                (this.program = void 0);
            }),
            (this.name = n.shaderName),
            (this.id = Dr++),
            (this.cacheKey = e),
            (this.usedTimes = 1),
            (this.program = x),
            (this.vertexShader = S),
            (this.fragmentShader = T),
            this
          );
        }
        function Qr(t, e, n, i, r, s) {
          const a = [],
            o = i.isWebGL2,
            h = i.logarithmicDepthBuffer,
            u = i.floatVertexTextures,
            d = i.maxVertexUniforms,
            p = i.vertexTextures;
          let m = i.precision;
          const f = {
              MeshDepthMaterial: "depth",
              MeshDistanceMaterial: "distanceRGBA",
              MeshNormalMaterial: "normal",
              MeshBasicMaterial: "basic",
              MeshLambertMaterial: "lambert",
              MeshPhongMaterial: "phong",
              MeshToonMaterial: "toon",
              MeshStandardMaterial: "physical",
              MeshPhysicalMaterial: "physical",
              MeshMatcapMaterial: "matcap",
              LineBasicMaterial: "basic",
              LineDashedMaterial: "dashed",
              PointsMaterial: "points",
              ShadowMaterial: "shadow",
              SpriteMaterial: "sprite",
            },
            g = [
              "precision",
              "isWebGL2",
              "supportsVertexTextures",
              "outputEncoding",
              "instancing",
              "instancingColor",
              "map",
              "mapEncoding",
              "matcap",
              "matcapEncoding",
              "envMap",
              "envMapMode",
              "envMapEncoding",
              "envMapCubeUV",
              "lightMap",
              "lightMapEncoding",
              "aoMap",
              "emissiveMap",
              "emissiveMapEncoding",
              "bumpMap",
              "normalMap",
              "objectSpaceNormalMap",
              "tangentSpaceNormalMap",
              "clearcoatMap",
              "clearcoatRoughnessMap",
              "clearcoatNormalMap",
              "displacementMap",
              "specularMap",
              "roughnessMap",
              "metalnessMap",
              "gradientMap",
              "alphaMap",
              "combine",
              "vertexColors",
              "vertexAlphas",
              "vertexTangents",
              "vertexUvs",
              "uvsVertexOnly",
              "fog",
              "useFog",
              "fogExp2",
              "flatShading",
              "sizeAttenuation",
              "logarithmicDepthBuffer",
              "skinning",
              "maxBones",
              "useVertexTexture",
              "morphTargets",
              "morphNormals",
              "premultipliedAlpha",
              "numDirLights",
              "numPointLights",
              "numSpotLights",
              "numHemiLights",
              "numRectAreaLights",
              "numDirLightShadows",
              "numPointLightShadows",
              "numSpotLightShadows",
              "shadowMapEnabled",
              "shadowMapType",
              "toneMapping",
              "physicallyCorrectLights",
              "alphaTest",
              "doubleSided",
              "flipSided",
              "numClippingPlanes",
              "numClipIntersection",
              "depthPacking",
              "dithering",
              "sheen",
              "transmissionMap",
            ];
          function v(t) {
            let e;
            return (
              t && t.isTexture
                ? (e = t.encoding)
                : t && t.isWebGLRenderTarget
                ? (console.warn(
                    "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (e = t.texture.encoding))
                : (e = X),
              e
            );
          }
          return {
            getParameters: function (r, a, g, y, x) {
              const _ = y.fog,
                w = r.isMeshStandardMaterial ? y.environment : null,
                b = e.get(r.envMap || w),
                M = f[r.type],
                S = x.isSkinnedMesh
                  ? (function (t) {
                      const e = t.skeleton.bones;
                      if (u) return 1024;
                      {
                        const t = d,
                          n = Math.floor((t - 20) / 4),
                          i = Math.min(n, e.length);
                        return i < e.length
                          ? (console.warn(
                              "THREE.WebGLRenderer: Skeleton has " +
                                e.length +
                                " bones. This GPU supports " +
                                i +
                                "."
                            ),
                            0)
                          : i;
                      }
                    })(x)
                  : 0;
              let T, E;
              if (
                (null !== r.precision &&
                  ((m = i.getMaxPrecision(r.precision)),
                  m !== r.precision &&
                    console.warn(
                      "THREE.WebGLProgram.getParameters:",
                      r.precision,
                      "not supported, using",
                      m,
                      "instead."
                    )),
                M)
              ) {
                const t = di[M];
                (T = t.vertexShader), (E = t.fragmentShader);
              } else (T = r.vertexShader), (E = r.fragmentShader);
              const A = t.getRenderTarget();
              return {
                isWebGL2: o,
                shaderID: M,
                shaderName: r.type,
                vertexShader: T,
                fragmentShader: E,
                defines: r.defines,
                isRawShaderMaterial: !0 === r.isRawShaderMaterial,
                glslVersion: r.glslVersion,
                precision: m,
                instancing: !0 === x.isInstancedMesh,
                instancingColor:
                  !0 === x.isInstancedMesh && null !== x.instanceColor,
                supportsVertexTextures: p,
                outputEncoding: null !== A ? v(A.texture) : t.outputEncoding,
                map: !!r.map,
                mapEncoding: v(r.map),
                matcap: !!r.matcap,
                matcapEncoding: v(r.matcap),
                envMap: !!b,
                envMapMode: b && b.mapping,
                envMapEncoding: v(b),
                envMapCubeUV: !!b && (b.mapping === l || b.mapping === c),
                lightMap: !!r.lightMap,
                lightMapEncoding: v(r.lightMap),
                aoMap: !!r.aoMap,
                emissiveMap: !!r.emissiveMap,
                emissiveMapEncoding: v(r.emissiveMap),
                bumpMap: !!r.bumpMap,
                normalMap: !!r.normalMap,
                objectSpaceNormalMap: 1 === r.normalMapType,
                tangentSpaceNormalMap: 0 === r.normalMapType,
                clearcoatMap: !!r.clearcoatMap,
                clearcoatRoughnessMap: !!r.clearcoatRoughnessMap,
                clearcoatNormalMap: !!r.clearcoatNormalMap,
                displacementMap: !!r.displacementMap,
                roughnessMap: !!r.roughnessMap,
                metalnessMap: !!r.metalnessMap,
                specularMap: !!r.specularMap,
                alphaMap: !!r.alphaMap,
                gradientMap: !!r.gradientMap,
                sheen: !!r.sheen,
                transmissionMap: !!r.transmissionMap,
                combine: r.combine,
                vertexTangents: r.normalMap && r.vertexTangents,
                vertexColors: r.vertexColors,
                vertexAlphas:
                  !0 === r.vertexColors &&
                  x.geometry &&
                  x.geometry.attributes.color &&
                  4 === x.geometry.attributes.color.itemSize,
                vertexUvs: !!(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatMap ||
                  r.clearcoatRoughnessMap ||
                  r.clearcoatNormalMap ||
                  r.displacementMap ||
                  r.transmissionMap
                ),
                uvsVertexOnly: !(
                  r.map ||
                  r.bumpMap ||
                  r.normalMap ||
                  r.specularMap ||
                  r.alphaMap ||
                  r.emissiveMap ||
                  r.roughnessMap ||
                  r.metalnessMap ||
                  r.clearcoatNormalMap ||
                  r.transmissionMap ||
                  !r.displacementMap
                ),
                fog: !!_,
                useFog: r.fog,
                fogExp2: _ && _.isFogExp2,
                flatShading: !!r.flatShading,
                sizeAttenuation: r.sizeAttenuation,
                logarithmicDepthBuffer: h,
                skinning: r.skinning && S > 0,
                maxBones: S,
                useVertexTexture: u,
                morphTargets: r.morphTargets,
                morphNormals: r.morphNormals,
                numDirLights: a.directional.length,
                numPointLights: a.point.length,
                numSpotLights: a.spot.length,
                numRectAreaLights: a.rectArea.length,
                numHemiLights: a.hemi.length,
                numDirLightShadows: a.directionalShadowMap.length,
                numPointLightShadows: a.pointShadowMap.length,
                numSpotLightShadows: a.spotShadowMap.length,
                numClippingPlanes: s.numPlanes,
                numClipIntersection: s.numIntersection,
                dithering: r.dithering,
                shadowMapEnabled: t.shadowMap.enabled && g.length > 0,
                shadowMapType: t.shadowMap.type,
                toneMapping: r.toneMapped ? t.toneMapping : 0,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: r.premultipliedAlpha,
                alphaTest: r.alphaTest,
                doubleSided: 2 === r.side,
                flipSided: 1 === r.side,
                depthPacking: void 0 !== r.depthPacking && r.depthPacking,
                index0AttributeName: r.index0AttributeName,
                extensionDerivatives: r.extensions && r.extensions.derivatives,
                extensionFragDepth: r.extensions && r.extensions.fragDepth,
                extensionDrawBuffers: r.extensions && r.extensions.drawBuffers,
                extensionShaderTextureLOD:
                  r.extensions && r.extensions.shaderTextureLOD,
                rendererExtensionFragDepth: o || n.has("EXT_frag_depth"),
                rendererExtensionDrawBuffers: o || n.has("WEBGL_draw_buffers"),
                rendererExtensionShaderTextureLod:
                  o || n.has("EXT_shader_texture_lod"),
                customProgramCacheKey: r.customProgramCacheKey(),
              };
            },
            getProgramCacheKey: function (e) {
              const n = [];
              if (
                (e.shaderID
                  ? n.push(e.shaderID)
                  : (n.push(e.fragmentShader), n.push(e.vertexShader)),
                void 0 !== e.defines)
              )
                for (const t in e.defines) n.push(t), n.push(e.defines[t]);
              if (!1 === e.isRawShaderMaterial) {
                for (let t = 0; t < g.length; t++) n.push(e[g[t]]);
                n.push(t.outputEncoding), n.push(t.gammaFactor);
              }
              return n.push(e.customProgramCacheKey), n.join();
            },
            getUniforms: function (t) {
              const e = f[t.type];
              let n;
              if (e) {
                const t = di[e];
                n = Zn.clone(t.uniforms);
              } else n = t.uniforms;
              return n;
            },
            acquireProgram: function (e, n) {
              let i;
              for (let t = 0, e = a.length; t < e; t++) {
                const e = a[t];
                if (e.cacheKey === n) {
                  (i = e), ++i.usedTimes;
                  break;
                }
              }
              return void 0 === i && ((i = new Jr(t, n, e, r)), a.push(i)), i;
            },
            releaseProgram: function (t) {
              if (0 == --t.usedTimes) {
                const e = a.indexOf(t);
                (a[e] = a[a.length - 1]), a.pop(), t.destroy();
              }
            },
            programs: a,
          };
        }
        function Kr() {
          let t = new WeakMap();
          return {
            get: function (e) {
              let n = t.get(e);
              return void 0 === n && ((n = {}), t.set(e, n)), n;
            },
            remove: function (e) {
              t.delete(e);
            },
            update: function (e, n, i) {
              t.get(e)[n] = i;
            },
            dispose: function () {
              t = new WeakMap();
            },
          };
        }
        function $r(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.program !== e.program
            ? t.program.id - e.program.id
            : t.material.id !== e.material.id
            ? t.material.id - e.material.id
            : t.z !== e.z
            ? t.z - e.z
            : t.id - e.id;
        }
        function ts(t, e) {
          return t.groupOrder !== e.groupOrder
            ? t.groupOrder - e.groupOrder
            : t.renderOrder !== e.renderOrder
            ? t.renderOrder - e.renderOrder
            : t.z !== e.z
            ? e.z - t.z
            : t.id - e.id;
        }
        function es(t) {
          const e = [];
          let n = 0;
          const i = [],
            r = [],
            s = { id: -1 };
          function a(i, r, a, o, l, c) {
            let h = e[n];
            const u = t.get(a);
            return (
              void 0 === h
                ? ((h = {
                    id: i.id,
                    object: i,
                    geometry: r,
                    material: a,
                    program: u.program || s,
                    groupOrder: o,
                    renderOrder: i.renderOrder,
                    z: l,
                    group: c,
                  }),
                  (e[n] = h))
                : ((h.id = i.id),
                  (h.object = i),
                  (h.geometry = r),
                  (h.material = a),
                  (h.program = u.program || s),
                  (h.groupOrder = o),
                  (h.renderOrder = i.renderOrder),
                  (h.z = l),
                  (h.group = c)),
              n++,
              h
            );
          }
          return {
            opaque: i,
            transparent: r,
            init: function () {
              (n = 0), (i.length = 0), (r.length = 0);
            },
            push: function (t, e, n, s, o, l) {
              const c = a(t, e, n, s, o, l);
              (!0 === n.transparent ? r : i).push(c);
            },
            unshift: function (t, e, n, s, o, l) {
              const c = a(t, e, n, s, o, l);
              (!0 === n.transparent ? r : i).unshift(c);
            },
            finish: function () {
              for (let t = n, i = e.length; t < i; t++) {
                const n = e[t];
                if (null === n.id) break;
                (n.id = null),
                  (n.object = null),
                  (n.geometry = null),
                  (n.material = null),
                  (n.program = null),
                  (n.group = null);
              }
            },
            sort: function (t, e) {
              i.length > 1 && i.sort(t || $r), r.length > 1 && r.sort(e || ts);
            },
          };
        }
        function ns(t) {
          let e = new WeakMap();
          return {
            get: function (n, i) {
              let r;
              return (
                !1 === e.has(n)
                  ? ((r = new es(t)), e.set(n, [r]))
                  : i >= e.get(n).length
                  ? ((r = new es(t)), e.get(n).push(r))
                  : (r = e.get(n)[i]),
                r
              );
            },
            dispose: function () {
              e = new WeakMap();
            },
          };
        }
        function is() {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                  n = { direction: new Lt(), color: new tn() };
                  break;
                case "SpotLight":
                  n = {
                    position: new Lt(),
                    direction: new Lt(),
                    color: new tn(),
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0,
                  };
                  break;
                case "PointLight":
                  n = {
                    position: new Lt(),
                    color: new tn(),
                    distance: 0,
                    decay: 0,
                  };
                  break;
                case "HemisphereLight":
                  n = {
                    direction: new Lt(),
                    skyColor: new tn(),
                    groundColor: new tn(),
                  };
                  break;
                case "RectAreaLight":
                  n = {
                    color: new tn(),
                    position: new Lt(),
                    halfWidth: new Lt(),
                    halfHeight: new Lt(),
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        }
        let rs = 0;
        function ss(t, e) {
          return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0);
        }
        function as(t, e) {
          const n = new is(),
            i = (function () {
              const t = {};
              return {
                get: function (e) {
                  if (void 0 !== t[e.id]) return t[e.id];
                  let n;
                  switch (e.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new vt(),
                      };
                      break;
                    case "PointLight":
                      n = {
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new vt(),
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3,
                      };
                  }
                  return (t[e.id] = n), n;
                },
              };
            })(),
            r = {
              version: 0,
              hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
              },
              ambient: [0, 0, 0],
              probe: [],
              directional: [],
              directionalShadow: [],
              directionalShadowMap: [],
              directionalShadowMatrix: [],
              spot: [],
              spotShadow: [],
              spotShadowMap: [],
              spotShadowMatrix: [],
              rectArea: [],
              rectAreaLTC1: null,
              rectAreaLTC2: null,
              point: [],
              pointShadow: [],
              pointShadowMap: [],
              pointShadowMatrix: [],
              hemi: [],
            };
          for (let t = 0; t < 9; t++) r.probe.push(new Lt());
          const s = new Lt(),
            a = new se(),
            o = new se();
          return {
            setup: function (s) {
              let a = 0,
                o = 0,
                l = 0;
              for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
              let c = 0,
                h = 0,
                u = 0,
                d = 0,
                p = 0,
                m = 0,
                f = 0,
                g = 0;
              s.sort(ss);
              for (let t = 0, e = s.length; t < e; t++) {
                const e = s[t],
                  v = e.color,
                  y = e.intensity,
                  x = e.distance,
                  _ = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
                if (e.isAmbientLight)
                  (a += v.r * y), (o += v.g * y), (l += v.b * y);
                else if (e.isLightProbe)
                  for (let t = 0; t < 9; t++)
                    r.probe[t].addScaledVector(e.sh.coefficients[t], y);
                else if (e.isDirectionalLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.directionalShadow[c] = n),
                      (r.directionalShadowMap[c] = _),
                      (r.directionalShadowMatrix[c] = e.shadow.matrix),
                      m++;
                  }
                  (r.directional[c] = t), c++;
                } else if (e.isSpotLight) {
                  const t = n.get(e);
                  if (
                    (t.position.setFromMatrixPosition(e.matrixWorld),
                    t.color.copy(v).multiplyScalar(y),
                    (t.distance = x),
                    (t.coneCos = Math.cos(e.angle)),
                    (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (r.spotShadow[u] = n),
                      (r.spotShadowMap[u] = _),
                      (r.spotShadowMatrix[u] = e.shadow.matrix),
                      g++;
                  }
                  (r.spot[u] = t), u++;
                } else if (e.isRectAreaLight) {
                  const t = n.get(e);
                  t.color.copy(v).multiplyScalar(y),
                    t.halfWidth.set(0.5 * e.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * e.height, 0),
                    (r.rectArea[d] = t),
                    d++;
                } else if (e.isPointLight) {
                  const t = n.get(e);
                  if (
                    (t.color.copy(e.color).multiplyScalar(e.intensity),
                    (t.distance = e.distance),
                    (t.decay = e.decay),
                    e.castShadow)
                  ) {
                    const t = e.shadow,
                      n = i.get(e);
                    (n.shadowBias = t.bias),
                      (n.shadowNormalBias = t.normalBias),
                      (n.shadowRadius = t.radius),
                      (n.shadowMapSize = t.mapSize),
                      (n.shadowCameraNear = t.camera.near),
                      (n.shadowCameraFar = t.camera.far),
                      (r.pointShadow[h] = n),
                      (r.pointShadowMap[h] = _),
                      (r.pointShadowMatrix[h] = e.shadow.matrix),
                      f++;
                  }
                  (r.point[h] = t), h++;
                } else if (e.isHemisphereLight) {
                  const t = n.get(e);
                  t.skyColor.copy(e.color).multiplyScalar(y),
                    t.groundColor.copy(e.groundColor).multiplyScalar(y),
                    (r.hemi[p] = t),
                    p++;
                }
              }
              d > 0 &&
                (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
                  ? ((r.rectAreaLTC1 = ui.LTC_FLOAT_1),
                    (r.rectAreaLTC2 = ui.LTC_FLOAT_2))
                  : !0 === t.has("OES_texture_half_float_linear")
                  ? ((r.rectAreaLTC1 = ui.LTC_HALF_1),
                    (r.rectAreaLTC2 = ui.LTC_HALF_2))
                  : console.error(
                      "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                    )),
                (r.ambient[0] = a),
                (r.ambient[1] = o),
                (r.ambient[2] = l);
              const v = r.hash;
              (v.directionalLength === c &&
                v.pointLength === h &&
                v.spotLength === u &&
                v.rectAreaLength === d &&
                v.hemiLength === p &&
                v.numDirectionalShadows === m &&
                v.numPointShadows === f &&
                v.numSpotShadows === g) ||
                ((r.directional.length = c),
                (r.spot.length = u),
                (r.rectArea.length = d),
                (r.point.length = h),
                (r.hemi.length = p),
                (r.directionalShadow.length = m),
                (r.directionalShadowMap.length = m),
                (r.pointShadow.length = f),
                (r.pointShadowMap.length = f),
                (r.spotShadow.length = g),
                (r.spotShadowMap.length = g),
                (r.directionalShadowMatrix.length = m),
                (r.pointShadowMatrix.length = f),
                (r.spotShadowMatrix.length = g),
                (v.directionalLength = c),
                (v.pointLength = h),
                (v.spotLength = u),
                (v.rectAreaLength = d),
                (v.hemiLength = p),
                (v.numDirectionalShadows = m),
                (v.numPointShadows = f),
                (v.numSpotShadows = g),
                (r.version = rs++));
            },
            setupView: function (t, e) {
              let n = 0,
                i = 0,
                l = 0,
                c = 0,
                h = 0;
              const u = e.matrixWorldInverse;
              for (let e = 0, d = t.length; e < d; e++) {
                const d = t[e];
                if (d.isDirectionalLight) {
                  const t = r.directional[n];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    n++;
                } else if (d.isSpotLight) {
                  const t = r.spot[l];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    t.direction.setFromMatrixPosition(d.matrixWorld),
                    s.setFromMatrixPosition(d.target.matrixWorld),
                    t.direction.sub(s),
                    t.direction.transformDirection(u),
                    l++;
                } else if (d.isRectAreaLight) {
                  const t = r.rectArea[c];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    o.identity(),
                    a.copy(d.matrixWorld),
                    a.premultiply(u),
                    o.extractRotation(a),
                    t.halfWidth.set(0.5 * d.width, 0, 0),
                    t.halfHeight.set(0, 0.5 * d.height, 0),
                    t.halfWidth.applyMatrix4(o),
                    t.halfHeight.applyMatrix4(o),
                    c++;
                } else if (d.isPointLight) {
                  const t = r.point[i];
                  t.position.setFromMatrixPosition(d.matrixWorld),
                    t.position.applyMatrix4(u),
                    i++;
                } else if (d.isHemisphereLight) {
                  const t = r.hemi[h];
                  t.direction.setFromMatrixPosition(d.matrixWorld),
                    t.direction.transformDirection(u),
                    t.direction.normalize(),
                    h++;
                }
              }
            },
            state: r,
          };
        }
        function os(t, e) {
          const n = new as(t, e),
            i = [],
            r = [];
          return {
            init: function () {
              (i.length = 0), (r.length = 0);
            },
            state: { lightsArray: i, shadowsArray: r, lights: n },
            setupLights: function () {
              n.setup(i);
            },
            setupLightsView: function (t) {
              n.setupView(i, t);
            },
            pushLight: function (t) {
              i.push(t);
            },
            pushShadow: function (t) {
              r.push(t);
            },
          };
        }
        function ls(t, e) {
          let n = new WeakMap();
          return {
            get: function (i, r = 0) {
              let s;
              return (
                !1 === n.has(i)
                  ? ((s = new os(t, e)), n.set(i, [s]))
                  : r >= n.get(i).length
                  ? ((s = new os(t, e)), n.get(i).push(s))
                  : (s = n.get(i)[r]),
                s
              );
            },
            dispose: function () {
              n = new WeakMap();
            },
          };
        }
        class cs extends Xe {
          constructor(t) {
            super(),
              (this.type = "MeshDepthMaterial"),
              (this.depthPacking = 3200),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.depthPacking = t.depthPacking),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              this
            );
          }
        }
        cs.prototype.isMeshDepthMaterial = !0;
        class hs extends Xe {
          constructor(t) {
            super(),
              (this.type = "MeshDistanceMaterial"),
              (this.referencePosition = new Lt()),
              (this.nearDistance = 1),
              (this.farDistance = 1e3),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.map = null),
              (this.alphaMap = null),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.fog = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.referencePosition.copy(t.referencePosition),
              (this.nearDistance = t.nearDistance),
              (this.farDistance = t.farDistance),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              this
            );
          }
        }
        hs.prototype.isMeshDistanceMaterial = !0;
        function us(t, e, n) {
          let i = new ai();
          const r = new vt(),
            s = new vt(),
            a = new St(),
            o = [],
            l = [],
            c = {},
            h = n.maxTextureSize,
            u = { 0: 1, 1: 0, 2: 2 },
            d = new Jn({
              defines: { SAMPLE_RATE: 2 / 8, HALF_SAMPLE_RATE: 1 / 8 },
              uniforms: {
                shadow_pass: { value: null },
                resolution: { value: new vt() },
                radius: { value: 4 },
              },
              vertexShader:
                "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
              fragmentShader:
                "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
            }),
            m = d.clone();
          m.defines.HORIZONTAL_PASS = 1;
          const f = new En();
          f.setAttribute(
            "position",
            new sn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
          );
          const v = new Wn(f, d),
            y = this;
          function x(n, i) {
            const r = e.update(v);
            (d.uniforms.shadow_pass.value = n.map.texture),
              (d.uniforms.resolution.value = n.mapSize),
              (d.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.mapPass),
              t.clear(),
              t.renderBufferDirect(i, null, r, d, v, null),
              (m.uniforms.shadow_pass.value = n.mapPass.texture),
              (m.uniforms.resolution.value = n.mapSize),
              (m.uniforms.radius.value = n.radius),
              t.setRenderTarget(n.map),
              t.clear(),
              t.renderBufferDirect(i, null, r, m, v, null);
          }
          function _(t, e, n) {
            const i = (t << 0) | (e << 1) | (n << 2);
            let r = o[i];
            return (
              void 0 === r &&
                ((r = new cs({
                  depthPacking: 3201,
                  morphTargets: t,
                  skinning: e,
                })),
                (o[i] = r)),
              r
            );
          }
          function w(t, e, n) {
            const i = (t << 0) | (e << 1) | (n << 2);
            let r = l[i];
            return (
              void 0 === r &&
                ((r = new hs({ morphTargets: t, skinning: e })), (l[i] = r)),
              r
            );
          }
          function b(e, n, i, r, s, a, o) {
            let l = null,
              h = _,
              d = e.customDepthMaterial;
            if (
              (!0 === r.isPointLight &&
                ((h = w), (d = e.customDistanceMaterial)),
              void 0 === d)
            ) {
              let t = !1;
              !0 === i.morphTargets &&
                (t =
                  n.morphAttributes &&
                  n.morphAttributes.position &&
                  n.morphAttributes.position.length > 0);
              let r = !1;
              !0 === e.isSkinnedMesh &&
                (!0 === i.skinning
                  ? (r = !0)
                  : console.warn(
                      "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
                      e
                    ));
              l = h(t, r, !0 === e.isInstancedMesh);
            } else l = d;
            if (
              t.localClippingEnabled &&
              !0 === i.clipShadows &&
              0 !== i.clippingPlanes.length
            ) {
              const t = l.uuid,
                e = i.uuid;
              let n = c[t];
              void 0 === n && ((n = {}), (c[t] = n));
              let r = n[e];
              void 0 === r && ((r = l.clone()), (n[e] = r)), (l = r);
            }
            return (
              (l.visible = i.visible),
              (l.wireframe = i.wireframe),
              (l.side =
                3 === o
                  ? null !== i.shadowSide
                    ? i.shadowSide
                    : i.side
                  : null !== i.shadowSide
                  ? i.shadowSide
                  : u[i.side]),
              (l.clipShadows = i.clipShadows),
              (l.clippingPlanes = i.clippingPlanes),
              (l.clipIntersection = i.clipIntersection),
              (l.wireframeLinewidth = i.wireframeLinewidth),
              (l.linewidth = i.linewidth),
              !0 === r.isPointLight &&
                !0 === l.isMeshDistanceMaterial &&
                (l.referencePosition.setFromMatrixPosition(r.matrixWorld),
                (l.nearDistance = s),
                (l.farDistance = a)),
              l
            );
          }
          function M(n, r, s, a, o) {
            if (!1 === n.visible) return;
            if (
              n.layers.test(r.layers) &&
              (n.isMesh || n.isLine || n.isPoints) &&
              (n.castShadow || (n.receiveShadow && 3 === o)) &&
              (!n.frustumCulled || i.intersectsObject(n))
            ) {
              n.modelViewMatrix.multiplyMatrices(
                s.matrixWorldInverse,
                n.matrixWorld
              );
              const i = e.update(n),
                r = n.material;
              if (Array.isArray(r)) {
                const e = i.groups;
                for (let l = 0, c = e.length; l < c; l++) {
                  const c = e[l],
                    h = r[c.materialIndex];
                  if (h && h.visible) {
                    const e = b(n, i, h, a, s.near, s.far, o);
                    t.renderBufferDirect(s, null, i, e, n, c);
                  }
                }
              } else if (r.visible) {
                const e = b(n, i, r, a, s.near, s.far, o);
                t.renderBufferDirect(s, null, i, e, n, null);
              }
            }
            const l = n.children;
            for (let t = 0, e = l.length; t < e; t++) M(l[t], r, s, a, o);
          }
          (this.enabled = !1),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this.type = 1),
            (this.render = function (e, n, o) {
              if (!1 === y.enabled) return;
              if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
              if (0 === e.length) return;
              const l = t.getRenderTarget(),
                c = t.getActiveCubeFace(),
                u = t.getActiveMipmapLevel(),
                d = t.state;
              d.setBlending(0),
                d.buffers.color.setClear(1, 1, 1, 1),
                d.buffers.depth.setTest(!0),
                d.setScissorTest(!1);
              for (let l = 0, c = e.length; l < c; l++) {
                const c = e[l],
                  u = c.shadow;
                if (void 0 === u) {
                  console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
                  continue;
                }
                if (!1 === u.autoUpdate && !1 === u.needsUpdate) continue;
                r.copy(u.mapSize);
                const m = u.getFrameExtents();
                if (
                  (r.multiply(m),
                  s.copy(u.mapSize),
                  (r.x > h || r.y > h) &&
                    (r.x > h &&
                      ((s.x = Math.floor(h / m.x)),
                      (r.x = s.x * m.x),
                      (u.mapSize.x = s.x)),
                    r.y > h &&
                      ((s.y = Math.floor(h / m.y)),
                      (r.y = s.y * m.y),
                      (u.mapSize.y = s.y))),
                  null === u.map && !u.isPointLightShadow && 3 === this.type)
                ) {
                  const t = { minFilter: g, magFilter: g, format: E };
                  (u.map = new Tt(r.x, r.y, t)),
                    (u.map.texture.name = c.name + ".shadowMap"),
                    (u.mapPass = new Tt(r.x, r.y, t)),
                    u.camera.updateProjectionMatrix();
                }
                if (null === u.map) {
                  const t = { minFilter: p, magFilter: p, format: E };
                  (u.map = new Tt(r.x, r.y, t)),
                    (u.map.texture.name = c.name + ".shadowMap"),
                    u.camera.updateProjectionMatrix();
                }
                t.setRenderTarget(u.map), t.clear();
                const f = u.getViewportCount();
                for (let t = 0; t < f; t++) {
                  const e = u.getViewport(t);
                  a.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
                    d.viewport(a),
                    u.updateMatrices(c, t),
                    (i = u.getFrustum()),
                    M(n, o, u.camera, c, this.type);
                }
                u.isPointLightShadow || 3 !== this.type || x(u, o),
                  (u.needsUpdate = !1);
              }
              (y.needsUpdate = !1), t.setRenderTarget(l, c, u);
            });
        }
        function ds(t, e, i) {
          const r = i.isWebGL2;
          const s = new (function () {
              let e = !1;
              const n = new St();
              let i = null;
              const r = new St(0, 0, 0, 0);
              return {
                setMask: function (n) {
                  i === n || e || (t.colorMask(n, n, n, n), (i = n));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e, i, s, a, o) {
                  !0 === o && ((e *= a), (i *= a), (s *= a)),
                    n.set(e, i, s, a),
                    !1 === r.equals(n) && (t.clearColor(e, i, s, a), r.copy(n));
                },
                reset: function () {
                  (e = !1), (i = null), r.set(-1, 0, 0, 0);
                },
              };
            })(),
            a = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null;
              return {
                setTest: function (t) {
                  t ? z(2929) : F(2929);
                },
                setMask: function (i) {
                  n === i || e || (t.depthMask(i), (n = i));
                },
                setFunc: function (e) {
                  if (i !== e) {
                    if (e)
                      switch (e) {
                        case 0:
                          t.depthFunc(512);
                          break;
                        case 1:
                          t.depthFunc(519);
                          break;
                        case 2:
                          t.depthFunc(513);
                          break;
                        case 3:
                          t.depthFunc(515);
                          break;
                        case 4:
                          t.depthFunc(514);
                          break;
                        case 5:
                          t.depthFunc(518);
                          break;
                        case 6:
                          t.depthFunc(516);
                          break;
                        case 7:
                          t.depthFunc(517);
                          break;
                        default:
                          t.depthFunc(515);
                      }
                    else t.depthFunc(515);
                    i = e;
                  }
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  r !== e && (t.clearDepth(e), (r = e));
                },
                reset: function () {
                  (e = !1), (n = null), (i = null), (r = null);
                },
              };
            })(),
            o = new (function () {
              let e = !1,
                n = null,
                i = null,
                r = null,
                s = null,
                a = null,
                o = null,
                l = null,
                c = null;
              return {
                setTest: function (t) {
                  e || (t ? z(2960) : F(2960));
                },
                setMask: function (i) {
                  n === i || e || (t.stencilMask(i), (n = i));
                },
                setFunc: function (e, n, a) {
                  (i === e && r === n && s === a) ||
                    (t.stencilFunc(e, n, a), (i = e), (r = n), (s = a));
                },
                setOp: function (e, n, i) {
                  (a === e && o === n && l === i) ||
                    (t.stencilOp(e, n, i), (a = e), (o = n), (l = i));
                },
                setLocked: function (t) {
                  e = t;
                },
                setClear: function (e) {
                  c !== e && (t.clearStencil(e), (c = e));
                },
                reset: function () {
                  (e = !1),
                    (n = null),
                    (i = null),
                    (r = null),
                    (s = null),
                    (a = null),
                    (o = null),
                    (l = null),
                    (c = null);
                },
              };
            })();
          let l = {},
            c = null,
            h = {},
            u = null,
            d = !1,
            p = null,
            m = null,
            f = null,
            g = null,
            v = null,
            y = null,
            x = null,
            _ = !1,
            w = null,
            b = null,
            M = null,
            S = null,
            T = null;
          const E = t.getParameter(35661);
          let A = !1,
            L = 0;
          const R = t.getParameter(7938);
          -1 !== R.indexOf("WebGL")
            ? ((L = parseFloat(/^WebGL (\d)/.exec(R)[1])), (A = L >= 1))
            : -1 !== R.indexOf("OpenGL ES") &&
              ((L = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (A = L >= 2));
          let C = null,
            P = {};
          const D = new St(0, 0, t.canvas.width, t.canvas.height),
            I = new St(0, 0, t.canvas.width, t.canvas.height);
          function N(e, n, i) {
            const r = new Uint8Array(4),
              s = t.createTexture();
            t.bindTexture(e, s),
              t.texParameteri(e, 10241, 9728),
              t.texParameteri(e, 10240, 9728);
            for (let e = 0; e < i; e++)
              t.texImage2D(n + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return s;
          }
          const B = {};
          function z(e) {
            !0 !== l[e] && (t.enable(e), (l[e] = !0));
          }
          function F(e) {
            !1 !== l[e] && (t.disable(e), (l[e] = !1));
          }
          (B[3553] = N(3553, 3553, 1)),
            (B[34067] = N(34067, 34069, 6)),
            s.setClear(0, 0, 0, 1),
            a.setClear(1),
            o.setClear(0),
            z(2929),
            a.setFunc(3),
            U(!1),
            k(1),
            z(2884),
            G(0);
          const O = { [n]: 32774, 101: 32778, 102: 32779 };
          if (r) (O[103] = 32775), (O[104] = 32776);
          else {
            const t = e.get("EXT_blend_minmax");
            null !== t && ((O[103] = t.MIN_EXT), (O[104] = t.MAX_EXT));
          }
          const H = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773,
          };
          function G(e, i, r, s, a, o, l, c) {
            if (0 !== e) {
              if ((!1 === d && (z(3042), (d = !0)), 5 === e))
                (a = a || i),
                  (o = o || r),
                  (l = l || s),
                  (i === m && a === v) ||
                    (t.blendEquationSeparate(O[i], O[a]), (m = i), (v = a)),
                  (r === f && s === g && o === y && l === x) ||
                    (t.blendFuncSeparate(H[r], H[s], H[o], H[l]),
                    (f = r),
                    (g = s),
                    (y = o),
                    (x = l)),
                  (p = e),
                  (_ = null);
              else if (e !== p || c !== _) {
                if (
                  ((m === n && v === n) ||
                    (t.blendEquation(32774), (m = n), (v = n)),
                  c)
                )
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(1, 771, 1, 771);
                      break;
                    case 2:
                      t.blendFunc(1, 1);
                      break;
                    case 3:
                      t.blendFuncSeparate(0, 0, 769, 771);
                      break;
                    case 4:
                      t.blendFuncSeparate(0, 768, 0, 770);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                else
                  switch (e) {
                    case 1:
                      t.blendFuncSeparate(770, 771, 1, 771);
                      break;
                    case 2:
                      t.blendFunc(770, 1);
                      break;
                    case 3:
                      t.blendFunc(0, 769);
                      break;
                    case 4:
                      t.blendFunc(0, 768);
                      break;
                    default:
                      console.error("THREE.WebGLState: Invalid blending: ", e);
                  }
                (f = null),
                  (g = null),
                  (y = null),
                  (x = null),
                  (p = e),
                  (_ = c);
              }
            } else !0 === d && (F(3042), (d = !1));
          }
          function U(e) {
            w !== e && (e ? t.frontFace(2304) : t.frontFace(2305), (w = e));
          }
          function k(e) {
            0 !== e
              ? (z(2884),
                e !== b &&
                  (1 === e
                    ? t.cullFace(1029)
                    : 2 === e
                    ? t.cullFace(1028)
                    : t.cullFace(1032)))
              : F(2884),
              (b = e);
          }
          function V(e, n, i) {
            e
              ? (z(32823),
                (S === n && T === i) ||
                  (t.polygonOffset(n, i), (S = n), (T = i)))
              : F(32823);
          }
          function W(e) {
            void 0 === e && (e = 33984 + E - 1),
              C !== e && (t.activeTexture(e), (C = e));
          }
          return {
            buffers: { color: s, depth: a, stencil: o },
            enable: z,
            disable: F,
            bindFramebuffer: function (e, n) {
              null === n && null !== c && (n = c),
                h[e] !== n &&
                  (t.bindFramebuffer(e, n),
                  (h[e] = n),
                  r &&
                    (36009 === e && (h[36160] = n),
                    36160 === e && (h[36009] = n)));
            },
            bindXRFramebuffer: function (e) {
              e !== c && (t.bindFramebuffer(36160, e), (c = e));
            },
            useProgram: function (e) {
              return u !== e && (t.useProgram(e), (u = e), !0);
            },
            setBlending: G,
            setMaterial: function (t, e) {
              2 === t.side ? F(2884) : z(2884);
              let n = 1 === t.side;
              e && (n = !n),
                U(n),
                1 === t.blending && !1 === t.transparent
                  ? G(0)
                  : G(
                      t.blending,
                      t.blendEquation,
                      t.blendSrc,
                      t.blendDst,
                      t.blendEquationAlpha,
                      t.blendSrcAlpha,
                      t.blendDstAlpha,
                      t.premultipliedAlpha
                    ),
                a.setFunc(t.depthFunc),
                a.setTest(t.depthTest),
                a.setMask(t.depthWrite),
                s.setMask(t.colorWrite);
              const i = t.stencilWrite;
              o.setTest(i),
                i &&
                  (o.setMask(t.stencilWriteMask),
                  o.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                  o.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
                V(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
                !0 === t.alphaToCoverage ? z(32926) : F(32926);
            },
            setFlipSided: U,
            setCullFace: k,
            setLineWidth: function (e) {
              e !== M && (A && t.lineWidth(e), (M = e));
            },
            setPolygonOffset: V,
            setScissorTest: function (t) {
              t ? z(3089) : F(3089);
            },
            activeTexture: W,
            bindTexture: function (e, n) {
              null === C && W();
              let i = P[C];
              void 0 === i &&
                ((i = { type: void 0, texture: void 0 }), (P[C] = i)),
                (i.type === e && i.texture === n) ||
                  (t.bindTexture(e, n || B[e]), (i.type = e), (i.texture = n));
            },
            unbindTexture: function () {
              const e = P[C];
              void 0 !== e &&
                void 0 !== e.type &&
                (t.bindTexture(e.type, null),
                (e.type = void 0),
                (e.texture = void 0));
            },
            compressedTexImage2D: function () {
              try {
                t.compressedTexImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage2D: function () {
              try {
                t.texImage2D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            texImage3D: function () {
              try {
                t.texImage3D.apply(t, arguments);
              } catch (t) {
                console.error("THREE.WebGLState:", t);
              }
            },
            scissor: function (e) {
              !1 === D.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), D.copy(e));
            },
            viewport: function (e) {
              !1 === I.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), I.copy(e));
            },
            reset: function () {
              t.disable(3042),
                t.disable(2884),
                t.disable(2929),
                t.disable(32823),
                t.disable(3089),
                t.disable(2960),
                t.disable(32926),
                t.blendEquation(32774),
                t.blendFunc(1, 0),
                t.blendFuncSeparate(1, 0, 1, 0),
                t.colorMask(!0, !0, !0, !0),
                t.clearColor(0, 0, 0, 0),
                t.depthMask(!0),
                t.depthFunc(513),
                t.clearDepth(1),
                t.stencilMask(4294967295),
                t.stencilFunc(519, 0, 4294967295),
                t.stencilOp(7680, 7680, 7680),
                t.clearStencil(0),
                t.cullFace(1029),
                t.frontFace(2305),
                t.polygonOffset(0, 0),
                t.activeTexture(33984),
                t.bindFramebuffer(36160, null),
                !0 === r &&
                  (t.bindFramebuffer(36009, null),
                  t.bindFramebuffer(36008, null)),
                t.useProgram(null),
                t.lineWidth(1),
                t.scissor(0, 0, t.canvas.width, t.canvas.height),
                t.viewport(0, 0, t.canvas.width, t.canvas.height),
                (l = {}),
                (C = null),
                (P = {}),
                (c = null),
                (h = {}),
                (u = null),
                (d = !1),
                (p = null),
                (m = null),
                (f = null),
                (g = null),
                (v = null),
                (y = null),
                (x = null),
                (_ = !1),
                (w = null),
                (b = null),
                (M = null),
                (S = null),
                (T = null),
                D.set(0, 0, t.canvas.width, t.canvas.height),
                I.set(0, 0, t.canvas.width, t.canvas.height),
                s.reset(),
                a.reset(),
                o.reset();
            },
          };
        }
        function ps(t, e, n, i, r, s, a) {
          const o = r.isWebGL2,
            l = r.maxTextures,
            c = r.maxCubemapSize,
            x = r.maxTextureSize,
            R = r.maxSamples,
            C = new WeakMap();
          let P,
            D = !1;
          try {
            D =
              "undefined" != typeof OffscreenCanvas &&
              null !== new OffscreenCanvas(1, 1).getContext("2d");
          } catch (t) {}
          function I(t, e) {
            return D
              ? new OffscreenCanvas(t, e)
              : document.createElementNS(
                  "http://www.w3.org/1999/xhtml",
                  "canvas"
                );
          }
          function N(t, e, n, i) {
            let r = 1;
            if (
              ((t.width > i || t.height > i) &&
                (r = i / Math.max(t.width, t.height)),
              r < 1 || !0 === e)
            ) {
              if (
                ("undefined" != typeof HTMLImageElement &&
                  t instanceof HTMLImageElement) ||
                ("undefined" != typeof HTMLCanvasElement &&
                  t instanceof HTMLCanvasElement) ||
                ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
              ) {
                const i = e ? ft : Math.floor,
                  s = i(r * t.width),
                  a = i(r * t.height);
                void 0 === P && (P = I(s, a));
                const o = n ? I(s, a) : P;
                (o.width = s), (o.height = a);
                return (
                  o.getContext("2d").drawImage(t, 0, 0, s, a),
                  console.warn(
                    "THREE.WebGLRenderer: Texture has been resized from (" +
                      t.width +
                      "x" +
                      t.height +
                      ") to (" +
                      s +
                      "x" +
                      a +
                      ")."
                  ),
                  o
                );
              }
              return (
                "data" in t &&
                  console.warn(
                    "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                      t.width +
                      "x" +
                      t.height +
                      ")."
                  ),
                t
              );
            }
            return t;
          }
          function B(t) {
            return pt(t.width) && pt(t.height);
          }
          function z(t, e) {
            return (
              t.generateMipmaps && e && t.minFilter !== p && t.minFilter !== g
            );
          }
          function F(e, n, r, s) {
            t.generateMipmap(e);
            i.get(n).__maxMipLevel = Math.log2(Math.max(r, s));
          }
          function O(n, i, r) {
            if (!1 === o) return i;
            if (null !== n) {
              if (void 0 !== t[n]) return t[n];
              console.warn(
                "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                  n +
                  "'"
              );
            }
            let s = i;
            return (
              6403 === i &&
                (5126 === r && (s = 33326),
                5131 === r && (s = 33325),
                5121 === r && (s = 33321)),
              6407 === i &&
                (5126 === r && (s = 34837),
                5131 === r && (s = 34843),
                5121 === r && (s = 32849)),
              6408 === i &&
                (5126 === r && (s = 34836),
                5131 === r && (s = 34842),
                5121 === r && (s = 32856)),
              (33325 !== s && 33326 !== s && 34842 !== s && 34836 !== s) ||
                e.get("EXT_color_buffer_float"),
              s
            );
          }
          function H(t) {
            return t === p || t === m || t === f ? 9728 : 9729;
          }
          function G(e) {
            const n = e.target;
            n.removeEventListener("dispose", G),
              (function (e) {
                const n = i.get(e);
                if (void 0 === n.__webglInit) return;
                t.deleteTexture(n.__webglTexture), i.remove(e);
              })(n),
              n.isVideoTexture && C.delete(n),
              a.memory.textures--;
          }
          function U(e) {
            const n = e.target;
            n.removeEventListener("dispose", U),
              (function (e) {
                const n = e.texture,
                  r = i.get(e),
                  s = i.get(n);
                if (!e) return;
                void 0 !== s.__webglTexture &&
                  t.deleteTexture(s.__webglTexture);
                e.depthTexture && e.depthTexture.dispose();
                if (e.isWebGLCubeRenderTarget)
                  for (let e = 0; e < 6; e++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e]),
                      r.__webglDepthbuffer &&
                        t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
                else
                  t.deleteFramebuffer(r.__webglFramebuffer),
                    r.__webglDepthbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthbuffer),
                    r.__webglMultisampledFramebuffer &&
                      t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                    r.__webglColorRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglColorRenderbuffer),
                    r.__webglDepthRenderbuffer &&
                      t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
                i.remove(n), i.remove(e);
              })(n),
              a.memory.textures--;
          }
          let k = 0;
          function V(t, e) {
            const r = i.get(t);
            if (
              (t.isVideoTexture &&
                (function (t) {
                  const e = a.render.frame;
                  C.get(t) !== e && (C.set(t, e), t.update());
                })(t),
              t.version > 0 && r.__version !== t.version)
            ) {
              const n = t.image;
              if (void 0 === n)
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is undefined"
                );
              else {
                if (!1 !== n.complete) return void Z(r, t, e);
                console.warn(
                  "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
                );
              }
            }
            n.activeTexture(33984 + e), n.bindTexture(3553, r.__webglTexture);
          }
          function W(e, r) {
            const a = i.get(e);
            e.version > 0 && a.__version !== e.version
              ? (function (e, i, r) {
                  if (6 !== i.image.length) return;
                  Y(e, i),
                    n.activeTexture(33984 + r),
                    n.bindTexture(34067, e.__webglTexture),
                    t.pixelStorei(37440, i.flipY),
                    t.pixelStorei(37441, i.premultiplyAlpha),
                    t.pixelStorei(3317, i.unpackAlignment),
                    t.pixelStorei(37443, 0);
                  const a =
                      i &&
                      (i.isCompressedTexture || i.image[0].isCompressedTexture),
                    l = i.image[0] && i.image[0].isDataTexture,
                    h = [];
                  for (let t = 0; t < 6; t++)
                    h[t] =
                      a || l
                        ? l
                          ? i.image[t].image
                          : i.image[t]
                        : N(i.image[t], !1, !0, c);
                  const u = h[0],
                    d = B(u) || o,
                    p = s.convert(i.format),
                    m = s.convert(i.type),
                    f = O(i.internalFormat, p, m);
                  let g;
                  if ((X(34067, i, d), a)) {
                    for (let t = 0; t < 6; t++) {
                      g = h[t].mipmaps;
                      for (let e = 0; e < g.length; e++) {
                        const r = g[e];
                        i.format !== E && i.format !== T
                          ? null !== p
                            ? n.compressedTexImage2D(
                                34069 + t,
                                e,
                                f,
                                r.width,
                                r.height,
                                0,
                                r.data
                              )
                            : console.warn(
                                "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                              )
                          : n.texImage2D(
                              34069 + t,
                              e,
                              f,
                              r.width,
                              r.height,
                              0,
                              p,
                              m,
                              r.data
                            );
                      }
                    }
                    e.__maxMipLevel = g.length - 1;
                  } else {
                    g = i.mipmaps;
                    for (let t = 0; t < 6; t++)
                      if (l) {
                        n.texImage2D(
                          34069 + t,
                          0,
                          f,
                          h[t].width,
                          h[t].height,
                          0,
                          p,
                          m,
                          h[t].data
                        );
                        for (let e = 0; e < g.length; e++) {
                          const i = g[e].image[t].image;
                          n.texImage2D(
                            34069 + t,
                            e + 1,
                            f,
                            i.width,
                            i.height,
                            0,
                            p,
                            m,
                            i.data
                          );
                        }
                      } else {
                        n.texImage2D(34069 + t, 0, f, p, m, h[t]);
                        for (let e = 0; e < g.length; e++) {
                          const i = g[e];
                          n.texImage2D(34069 + t, e + 1, f, p, m, i.image[t]);
                        }
                      }
                    e.__maxMipLevel = g.length;
                  }
                  z(i, d) && F(34067, i, u.width, u.height);
                  (e.__version = i.version), i.onUpdate && i.onUpdate(i);
                })(a, e, r)
              : (n.activeTexture(33984 + r),
                n.bindTexture(34067, a.__webglTexture));
          }
          const j = { [h]: 10497, [u]: 33071, [d]: 33648 },
            q = {
              [p]: 9728,
              [m]: 9984,
              [f]: 9986,
              [g]: 9729,
              [v]: 9985,
              [y]: 9987,
            };
          function X(n, s, a) {
            if (
              (a
                ? (t.texParameteri(n, 10242, j[s.wrapS]),
                  t.texParameteri(n, 10243, j[s.wrapT]),
                  (32879 !== n && 35866 !== n) ||
                    t.texParameteri(n, 32882, j[s.wrapR]),
                  t.texParameteri(n, 10240, q[s.magFilter]),
                  t.texParameteri(n, 10241, q[s.minFilter]))
                : (t.texParameteri(n, 10242, 33071),
                  t.texParameteri(n, 10243, 33071),
                  (32879 !== n && 35866 !== n) ||
                    t.texParameteri(n, 32882, 33071),
                  (s.wrapS === u && s.wrapT === u) ||
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                    ),
                  t.texParameteri(n, 10240, H(s.magFilter)),
                  t.texParameteri(n, 10241, H(s.minFilter)),
                  s.minFilter !== p &&
                    s.minFilter !== g &&
                    console.warn(
                      "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                    )),
              !0 === e.has("EXT_texture_filter_anisotropic"))
            ) {
              const a = e.get("EXT_texture_filter_anisotropic");
              if (s.type === b && !1 === e.has("OES_texture_float_linear"))
                return;
              if (
                !1 === o &&
                s.type === M &&
                !1 === e.has("OES_texture_half_float_linear")
              )
                return;
              (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
                (t.texParameterf(
                  n,
                  a.TEXTURE_MAX_ANISOTROPY_EXT,
                  Math.min(s.anisotropy, r.getMaxAnisotropy())
                ),
                (i.get(s).__currentAnisotropy = s.anisotropy));
            }
          }
          function Y(e, n) {
            void 0 === e.__webglInit &&
              ((e.__webglInit = !0),
              n.addEventListener("dispose", G),
              (e.__webglTexture = t.createTexture()),
              a.memory.textures++);
          }
          function Z(e, i, r) {
            let a = 3553;
            i.isDataTexture2DArray && (a = 35866),
              i.isDataTexture3D && (a = 32879),
              Y(e, i),
              n.activeTexture(33984 + r),
              n.bindTexture(a, e.__webglTexture),
              t.pixelStorei(37440, i.flipY),
              t.pixelStorei(37441, i.premultiplyAlpha),
              t.pixelStorei(3317, i.unpackAlignment),
              t.pixelStorei(37443, 0);
            const l =
                (function (t) {
                  return (
                    !o &&
                    (t.wrapS !== u ||
                      t.wrapT !== u ||
                      (t.minFilter !== p && t.minFilter !== g))
                  );
                })(i) && !1 === B(i.image),
              c = N(i.image, l, !1, x),
              h = B(c) || o,
              d = s.convert(i.format);
            let m,
              f = s.convert(i.type),
              v = O(i.internalFormat, d, f);
            X(a, i, h);
            const y = i.mipmaps;
            if (i.isDepthTexture)
              (v = 6402),
                o
                  ? (v =
                      i.type === b
                        ? 36012
                        : i.type === w
                        ? 33190
                        : i.type === S
                        ? 35056
                        : 33189)
                  : i.type === b &&
                    console.error(
                      "WebGLRenderer: Floating point depth texture requires WebGL2."
                    ),
                i.format === A &&
                  6402 === v &&
                  i.type !== _ &&
                  i.type !== w &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                  ),
                  (i.type = _),
                  (f = s.convert(i.type))),
                i.format === L &&
                  6402 === v &&
                  ((v = 34041),
                  i.type !== S &&
                    (console.warn(
                      "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                    ),
                    (i.type = S),
                    (f = s.convert(i.type)))),
                n.texImage2D(3553, 0, v, c.width, c.height, 0, d, f, null);
            else if (i.isDataTexture)
              if (y.length > 0 && h) {
                for (let t = 0, e = y.length; t < e; t++)
                  (m = y[t]),
                    n.texImage2D(
                      3553,
                      t,
                      v,
                      m.width,
                      m.height,
                      0,
                      d,
                      f,
                      m.data
                    );
                (i.generateMipmaps = !1), (e.__maxMipLevel = y.length - 1);
              } else
                n.texImage2D(3553, 0, v, c.width, c.height, 0, d, f, c.data),
                  (e.__maxMipLevel = 0);
            else if (i.isCompressedTexture) {
              for (let t = 0, e = y.length; t < e; t++)
                (m = y[t]),
                  i.format !== E && i.format !== T
                    ? null !== d
                      ? n.compressedTexImage2D(
                          3553,
                          t,
                          v,
                          m.width,
                          m.height,
                          0,
                          m.data
                        )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : n.texImage2D(
                        3553,
                        t,
                        v,
                        m.width,
                        m.height,
                        0,
                        d,
                        f,
                        m.data
                      );
              e.__maxMipLevel = y.length - 1;
            } else if (i.isDataTexture2DArray)
              n.texImage3D(
                35866,
                0,
                v,
                c.width,
                c.height,
                c.depth,
                0,
                d,
                f,
                c.data
              ),
                (e.__maxMipLevel = 0);
            else if (i.isDataTexture3D)
              n.texImage3D(
                32879,
                0,
                v,
                c.width,
                c.height,
                c.depth,
                0,
                d,
                f,
                c.data
              ),
                (e.__maxMipLevel = 0);
            else if (y.length > 0 && h) {
              for (let t = 0, e = y.length; t < e; t++)
                (m = y[t]), n.texImage2D(3553, t, v, d, f, m);
              (i.generateMipmaps = !1), (e.__maxMipLevel = y.length - 1);
            } else n.texImage2D(3553, 0, v, d, f, c), (e.__maxMipLevel = 0);
            z(i, h) && F(a, i, c.width, c.height),
              (e.__version = i.version),
              i.onUpdate && i.onUpdate(i);
          }
          function J(e, r, a, o) {
            const l = r.texture,
              c = s.convert(l.format),
              h = s.convert(l.type),
              u = O(l.internalFormat, c, h);
            32879 === o || 35866 === o
              ? n.texImage3D(o, 0, u, r.width, r.height, r.depth, 0, c, h, null)
              : n.texImage2D(o, 0, u, r.width, r.height, 0, c, h, null),
              n.bindFramebuffer(36160, e),
              t.framebufferTexture2D(36160, a, o, i.get(l).__webglTexture, 0),
              n.bindFramebuffer(36160, null);
          }
          function Q(e, n, i) {
            if (
              (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer)
            ) {
              let r = 33189;
              if (i) {
                const e = n.depthTexture;
                e &&
                  e.isDepthTexture &&
                  (e.type === b ? (r = 36012) : e.type === w && (r = 33190));
                const i = $(n);
                t.renderbufferStorageMultisample(
                  36161,
                  i,
                  r,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, r, n.width, n.height);
              t.framebufferRenderbuffer(36160, 36096, 36161, e);
            } else if (n.depthBuffer && n.stencilBuffer) {
              if (i) {
                const e = $(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  35056,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, 34041, n.width, n.height);
              t.framebufferRenderbuffer(36160, 33306, 36161, e);
            } else {
              const e = n.texture,
                r = s.convert(e.format),
                a = s.convert(e.type),
                o = O(e.internalFormat, r, a);
              if (i) {
                const e = $(n);
                t.renderbufferStorageMultisample(
                  36161,
                  e,
                  o,
                  n.width,
                  n.height
                );
              } else t.renderbufferStorage(36161, o, n.width, n.height);
            }
            t.bindRenderbuffer(36161, null);
          }
          function K(e) {
            const r = i.get(e),
              s = !0 === e.isWebGLCubeRenderTarget;
            if (e.depthTexture) {
              if (s)
                throw new Error(
                  "target.depthTexture not supported in Cube render targets"
                );
              !(function (e, r) {
                if (r && r.isWebGLCubeRenderTarget)
                  throw new Error(
                    "Depth Texture with cube render targets is not supported"
                  );
                if (
                  (n.bindFramebuffer(36160, e),
                  !r.depthTexture || !r.depthTexture.isDepthTexture)
                )
                  throw new Error(
                    "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                  );
                (i.get(r.depthTexture).__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                  V(r.depthTexture, 0);
                const s = i.get(r.depthTexture).__webglTexture;
                if (r.depthTexture.format === A)
                  t.framebufferTexture2D(36160, 36096, 3553, s, 0);
                else {
                  if (r.depthTexture.format !== L)
                    throw new Error("Unknown depthTexture format");
                  t.framebufferTexture2D(36160, 33306, 3553, s, 0);
                }
              })(r.__webglFramebuffer, e);
            } else if (s) {
              r.__webglDepthbuffer = [];
              for (let i = 0; i < 6; i++)
                n.bindFramebuffer(36160, r.__webglFramebuffer[i]),
                  (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
                  Q(r.__webglDepthbuffer[i], e, !1);
            } else
              n.bindFramebuffer(36160, r.__webglFramebuffer),
                (r.__webglDepthbuffer = t.createRenderbuffer()),
                Q(r.__webglDepthbuffer, e, !1);
            n.bindFramebuffer(36160, null);
          }
          function $(t) {
            return o && t.isWebGLMultisampleRenderTarget
              ? Math.min(R, t.samples)
              : 0;
          }
          let tt = !1,
            et = !1;
          (this.allocateTextureUnit = function () {
            const t = k;
            return (
              t >= l &&
                console.warn(
                  "THREE.WebGLTextures: Trying to use " +
                    t +
                    " texture units while this GPU supports only " +
                    l
                ),
              (k += 1),
              t
            );
          }),
            (this.resetTextureUnits = function () {
              k = 0;
            }),
            (this.setTexture2D = V),
            (this.setTexture2DArray = function (t, e) {
              const r = i.get(t);
              t.version > 0 && r.__version !== t.version
                ? Z(r, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(35866, r.__webglTexture));
            }),
            (this.setTexture3D = function (t, e) {
              const r = i.get(t);
              t.version > 0 && r.__version !== t.version
                ? Z(r, t, e)
                : (n.activeTexture(33984 + e),
                  n.bindTexture(32879, r.__webglTexture));
            }),
            (this.setTextureCube = W),
            (this.setupRenderTarget = function (e) {
              const r = e.texture,
                l = i.get(e),
                c = i.get(r);
              e.addEventListener("dispose", U),
                (c.__webglTexture = t.createTexture()),
                (c.__version = r.version),
                a.memory.textures++;
              const h = !0 === e.isWebGLCubeRenderTarget,
                u = !0 === e.isWebGLMultisampleRenderTarget,
                d = r.isDataTexture3D || r.isDataTexture2DArray,
                p = B(e) || o;
              if (
                (!o ||
                  r.format !== T ||
                  (r.type !== b && r.type !== M) ||
                  ((r.format = E),
                  console.warn(
                    "THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead."
                  )),
                h)
              ) {
                l.__webglFramebuffer = [];
                for (let e = 0; e < 6; e++)
                  l.__webglFramebuffer[e] = t.createFramebuffer();
              } else if (((l.__webglFramebuffer = t.createFramebuffer()), u))
                if (o) {
                  (l.__webglMultisampledFramebuffer = t.createFramebuffer()),
                    (l.__webglColorRenderbuffer = t.createRenderbuffer()),
                    t.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
                  const i = s.convert(r.format),
                    a = s.convert(r.type),
                    o = O(r.internalFormat, i, a),
                    c = $(e);
                  t.renderbufferStorageMultisample(
                    36161,
                    c,
                    o,
                    e.width,
                    e.height
                  ),
                    n.bindFramebuffer(36160, l.__webglMultisampledFramebuffer),
                    t.framebufferRenderbuffer(
                      36160,
                      36064,
                      36161,
                      l.__webglColorRenderbuffer
                    ),
                    t.bindRenderbuffer(36161, null),
                    e.depthBuffer &&
                      ((l.__webglDepthRenderbuffer = t.createRenderbuffer()),
                      Q(l.__webglDepthRenderbuffer, e, !0)),
                    n.bindFramebuffer(36160, null);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                  );
              if (h) {
                n.bindTexture(34067, c.__webglTexture), X(34067, r, p);
                for (let t = 0; t < 6; t++)
                  J(l.__webglFramebuffer[t], e, 36064, 34069 + t);
                z(r, p) && F(34067, r, e.width, e.height),
                  n.bindTexture(34067, null);
              } else {
                let t = 3553;
                if (d)
                  if (o) {
                    t = r.isDataTexture3D ? 32879 : 35866;
                  } else
                    console.warn(
                      "THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2."
                    );
                n.bindTexture(t, c.__webglTexture),
                  X(t, r, p),
                  J(l.__webglFramebuffer, e, 36064, t),
                  z(r, p) && F(3553, r, e.width, e.height),
                  n.bindTexture(3553, null);
              }
              e.depthBuffer && K(e);
            }),
            (this.updateRenderTargetMipmap = function (t) {
              const e = t.texture;
              if (z(e, B(t) || o)) {
                const r = t.isWebGLCubeRenderTarget ? 34067 : 3553,
                  s = i.get(e).__webglTexture;
                n.bindTexture(r, s),
                  F(r, e, t.width, t.height),
                  n.bindTexture(r, null);
              }
            }),
            (this.updateMultisampleRenderTarget = function (e) {
              if (e.isWebGLMultisampleRenderTarget)
                if (o) {
                  const r = e.width,
                    s = e.height;
                  let a = 16384;
                  e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024);
                  const o = i.get(e);
                  n.bindFramebuffer(36008, o.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, o.__webglFramebuffer),
                    t.blitFramebuffer(0, 0, r, s, 0, 0, r, s, a, 9728),
                    n.bindFramebuffer(36008, null),
                    n.bindFramebuffer(36009, o.__webglMultisampledFramebuffer);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."
                  );
            }),
            (this.safeSetTexture2D = function (t, e) {
              t &&
                t.isWebGLRenderTarget &&
                (!1 === tt &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
                  ),
                  (tt = !0)),
                (t = t.texture)),
                V(t, e);
            }),
            (this.safeSetTextureCube = function (t, e) {
              t &&
                t.isWebGLCubeRenderTarget &&
                (!1 === et &&
                  (console.warn(
                    "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
                  ),
                  (et = !0)),
                (t = t.texture)),
                W(t, e);
            });
        }
        function ms(t, e, n) {
          const i = n.isWebGL2;
          return {
            convert: function (t) {
              let n;
              if (t === x) return 5121;
              if (1017 === t) return 32819;
              if (1018 === t) return 32820;
              if (1019 === t) return 33635;
              if (1010 === t) return 5120;
              if (1011 === t) return 5122;
              if (t === _) return 5123;
              if (1013 === t) return 5124;
              if (t === w) return 5125;
              if (t === b) return 5126;
              if (t === M)
                return i
                  ? 5131
                  : ((n = e.get("OES_texture_half_float")),
                    null !== n ? n.HALF_FLOAT_OES : null);
              if (1021 === t) return 6406;
              if (t === T) return 6407;
              if (t === E) return 6408;
              if (1024 === t) return 6409;
              if (1025 === t) return 6410;
              if (t === A) return 6402;
              if (t === L) return 34041;
              if (1028 === t) return 6403;
              if (1029 === t) return 36244;
              if (1030 === t) return 33319;
              if (1031 === t) return 33320;
              if (1032 === t) return 36248;
              if (1033 === t) return 36249;
              if (t === R || t === C || t === P || t === D) {
                if (((n = e.get("WEBGL_compressed_texture_s3tc")), null === n))
                  return null;
                if (t === R) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (t === C) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (t === P) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (t === D) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
              if (t === I || t === N || t === B || t === z) {
                if (((n = e.get("WEBGL_compressed_texture_pvrtc")), null === n))
                  return null;
                if (t === I) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (t === N) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (t === B) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (t === z) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
              }
              if (36196 === t)
                return (
                  (n = e.get("WEBGL_compressed_texture_etc1")),
                  null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null
                );
              if (
                (t === F || t === O) &&
                ((n = e.get("WEBGL_compressed_texture_etc")), null !== n)
              ) {
                if (t === F) return n.COMPRESSED_RGB8_ETC2;
                if (t === O) return n.COMPRESSED_RGBA8_ETC2_EAC;
              }
              return 37808 === t ||
                37809 === t ||
                37810 === t ||
                37811 === t ||
                37812 === t ||
                37813 === t ||
                37814 === t ||
                37815 === t ||
                37816 === t ||
                37817 === t ||
                37818 === t ||
                37819 === t ||
                37820 === t ||
                37821 === t ||
                37840 === t ||
                37841 === t ||
                37842 === t ||
                37843 === t ||
                37844 === t ||
                37845 === t ||
                37846 === t ||
                37847 === t ||
                37848 === t ||
                37849 === t ||
                37850 === t ||
                37851 === t ||
                37852 === t ||
                37853 === t
                ? ((n = e.get("WEBGL_compressed_texture_astc")),
                  null !== n ? t : null)
                : 36492 === t
                ? ((n = e.get("EXT_texture_compression_bptc")),
                  null !== n ? t : null)
                : t === S
                ? i
                  ? 34042
                  : ((n = e.get("WEBGL_depth_texture")),
                    null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null)
                : void 0;
            },
          };
        }
        class fs extends Kn {
          constructor(t = []) {
            super(), (this.cameras = t);
          }
        }
        fs.prototype.isArrayCamera = !0;
        class gs extends Ce {
          constructor() {
            super(), (this.type = "Group");
          }
        }
        gs.prototype.isGroup = !0;
        const vs = { type: "move" };
        class ys {
          constructor() {
            (this._targetRay = null), (this._grip = null), (this._hand = null);
          }
          getHandSpace() {
            return (
              null === this._hand &&
                ((this._hand = new gs()),
                (this._hand.matrixAutoUpdate = !1),
                (this._hand.visible = !1),
                (this._hand.joints = {}),
                (this._hand.inputState = { pinching: !1 })),
              this._hand
            );
          }
          getTargetRaySpace() {
            return (
              null === this._targetRay &&
                ((this._targetRay = new gs()),
                (this._targetRay.matrixAutoUpdate = !1),
                (this._targetRay.visible = !1),
                (this._targetRay.hasLinearVelocity = !1),
                (this._targetRay.linearVelocity = new Lt()),
                (this._targetRay.hasAngularVelocity = !1),
                (this._targetRay.angularVelocity = new Lt())),
              this._targetRay
            );
          }
          getGripSpace() {
            return (
              null === this._grip &&
                ((this._grip = new gs()),
                (this._grip.matrixAutoUpdate = !1),
                (this._grip.visible = !1),
                (this._grip.hasLinearVelocity = !1),
                (this._grip.linearVelocity = new Lt()),
                (this._grip.hasAngularVelocity = !1),
                (this._grip.angularVelocity = new Lt())),
              this._grip
            );
          }
          dispatchEvent(t) {
            return (
              null !== this._targetRay && this._targetRay.dispatchEvent(t),
              null !== this._grip && this._grip.dispatchEvent(t),
              null !== this._hand && this._hand.dispatchEvent(t),
              this
            );
          }
          disconnect(t) {
            return (
              this.dispatchEvent({ type: "disconnected", data: t }),
              null !== this._targetRay && (this._targetRay.visible = !1),
              null !== this._grip && (this._grip.visible = !1),
              null !== this._hand && (this._hand.visible = !1),
              this
            );
          }
          update(t, e, n) {
            let i = null,
              r = null,
              s = null;
            const a = this._targetRay,
              o = this._grip,
              l = this._hand;
            if (t && "visible-blurred" !== e.session.visibilityState)
              if (
                (null !== a &&
                  ((i = e.getPose(t.targetRaySpace, n)),
                  null !== i &&
                    (a.matrix.fromArray(i.transform.matrix),
                    a.matrix.decompose(a.position, a.rotation, a.scale),
                    i.linearVelocity
                      ? ((a.hasLinearVelocity = !0),
                        a.linearVelocity.copy(i.linearVelocity))
                      : (a.hasLinearVelocity = !1),
                    i.angularVelocity
                      ? ((a.hasAngularVelocity = !0),
                        a.angularVelocity.copy(i.angularVelocity))
                      : (a.hasAngularVelocity = !1),
                    this.dispatchEvent(vs))),
                l && t.hand)
              ) {
                s = !0;
                for (const i of t.hand.values()) {
                  const t = e.getJointPose(i, n);
                  if (void 0 === l.joints[i.jointName]) {
                    const t = new gs();
                    (t.matrixAutoUpdate = !1),
                      (t.visible = !1),
                      (l.joints[i.jointName] = t),
                      l.add(t);
                  }
                  const r = l.joints[i.jointName];
                  null !== t &&
                    (r.matrix.fromArray(t.transform.matrix),
                    r.matrix.decompose(r.position, r.rotation, r.scale),
                    (r.jointRadius = t.radius)),
                    (r.visible = null !== t);
                }
                const i = l.joints["index-finger-tip"],
                  r = l.joints["thumb-tip"],
                  a = i.position.distanceTo(r.position),
                  o = 0.02,
                  c = 0.005;
                l.inputState.pinching && a > o + c
                  ? ((l.inputState.pinching = !1),
                    this.dispatchEvent({
                      type: "pinchend",
                      handedness: t.handedness,
                      target: this,
                    }))
                  : !l.inputState.pinching &&
                    a <= o - c &&
                    ((l.inputState.pinching = !0),
                    this.dispatchEvent({
                      type: "pinchstart",
                      handedness: t.handedness,
                      target: this,
                    }));
              } else
                null !== o &&
                  t.gripSpace &&
                  ((r = e.getPose(t.gripSpace, n)),
                  null !== r &&
                    (o.matrix.fromArray(r.transform.matrix),
                    o.matrix.decompose(o.position, o.rotation, o.scale),
                    r.linearVelocity
                      ? ((o.hasLinearVelocity = !0),
                        o.linearVelocity.copy(r.linearVelocity))
                      : (o.hasLinearVelocity = !1),
                    r.angularVelocity
                      ? ((o.hasAngularVelocity = !0),
                        o.angularVelocity.copy(r.angularVelocity))
                      : (o.hasAngularVelocity = !1)));
            return (
              null !== a && (a.visible = null !== i),
              null !== o && (o.visible = null !== r),
              null !== l && (l.visible = null !== s),
              this
            );
          }
        }
        class xs extends rt {
          constructor(t, e) {
            super();
            const n = this,
              i = t.state;
            let r = null,
              s = 1,
              a = null,
              o = "local-floor",
              l = null;
            const c = [],
              h = new Map(),
              u = new Kn();
            u.layers.enable(1), (u.viewport = new St());
            const d = new Kn();
            d.layers.enable(2), (d.viewport = new St());
            const p = [u, d],
              m = new fs();
            m.layers.enable(1), m.layers.enable(2);
            let f = null,
              g = null;
            function v(t) {
              const e = h.get(t.inputSource);
              e && e.dispatchEvent({ type: t.type, data: t.inputSource });
            }
            function y() {
              h.forEach(function (t, e) {
                t.disconnect(e);
              }),
                h.clear(),
                (f = null),
                (g = null),
                i.bindXRFramebuffer(null),
                t.setRenderTarget(t.getRenderTarget()),
                S.stop(),
                (n.isPresenting = !1),
                n.dispatchEvent({ type: "sessionend" });
            }
            function x(t) {
              const e = r.inputSources;
              for (let t = 0; t < c.length; t++) h.set(e[t], c[t]);
              for (let e = 0; e < t.removed.length; e++) {
                const n = t.removed[e],
                  i = h.get(n);
                i &&
                  (i.dispatchEvent({ type: "disconnected", data: n }),
                  h.delete(n));
              }
              for (let e = 0; e < t.added.length; e++) {
                const n = t.added[e],
                  i = h.get(n);
                i && i.dispatchEvent({ type: "connected", data: n });
              }
            }
            (this.enabled = !1),
              (this.isPresenting = !1),
              (this.getController = function (t) {
                let e = c[t];
                return (
                  void 0 === e && ((e = new ys()), (c[t] = e)),
                  e.getTargetRaySpace()
                );
              }),
              (this.getControllerGrip = function (t) {
                let e = c[t];
                return (
                  void 0 === e && ((e = new ys()), (c[t] = e)), e.getGripSpace()
                );
              }),
              (this.getHand = function (t) {
                let e = c[t];
                return (
                  void 0 === e && ((e = new ys()), (c[t] = e)), e.getHandSpace()
                );
              }),
              (this.setFramebufferScaleFactor = function (t) {
                (s = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                    );
              }),
              (this.setReferenceSpaceType = function (t) {
                (o = t),
                  !0 === n.isPresenting &&
                    console.warn(
                      "THREE.WebXRManager: Cannot change reference space type while presenting."
                    );
              }),
              (this.getReferenceSpace = function () {
                return a;
              }),
              (this.getSession = function () {
                return r;
              }),
              (this.setSession = async function (t) {
                if (((r = t), null !== r)) {
                  r.addEventListener("select", v),
                    r.addEventListener("selectstart", v),
                    r.addEventListener("selectend", v),
                    r.addEventListener("squeeze", v),
                    r.addEventListener("squeezestart", v),
                    r.addEventListener("squeezeend", v),
                    r.addEventListener("end", y),
                    r.addEventListener("inputsourceschange", x);
                  const t = e.getContextAttributes();
                  !0 !== t.xrCompatible && (await e.makeXRCompatible());
                  const i = {
                      antialias: t.antialias,
                      alpha: t.alpha,
                      depth: t.depth,
                      stencil: t.stencil,
                      framebufferScaleFactor: s,
                    },
                    l = new XRWebGLLayer(r, e, i);
                  r.updateRenderState({ baseLayer: l }),
                    (a = await r.requestReferenceSpace(o)),
                    S.setContext(r),
                    S.start(),
                    (n.isPresenting = !0),
                    n.dispatchEvent({ type: "sessionstart" });
                }
              });
            const _ = new Lt(),
              w = new Lt();
            function b(t, e) {
              null === e
                ? t.matrixWorld.copy(t.matrix)
                : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
                t.matrixWorldInverse.copy(t.matrixWorld).invert();
            }
            this.getCamera = function (t) {
              (m.near = d.near = u.near = t.near),
                (m.far = d.far = u.far = t.far),
                (f === m.near && g === m.far) ||
                  (r.updateRenderState({ depthNear: m.near, depthFar: m.far }),
                  (f = m.near),
                  (g = m.far));
              const e = t.parent,
                n = m.cameras;
              b(m, e);
              for (let t = 0; t < n.length; t++) b(n[t], e);
              t.matrixWorld.copy(m.matrixWorld),
                t.matrix.copy(m.matrix),
                t.matrix.decompose(t.position, t.quaternion, t.scale);
              const i = t.children;
              for (let t = 0, e = i.length; t < e; t++)
                i[t].updateMatrixWorld(!0);
              return (
                2 === n.length
                  ? (function (t, e, n) {
                      _.setFromMatrixPosition(e.matrixWorld),
                        w.setFromMatrixPosition(n.matrixWorld);
                      const i = _.distanceTo(w),
                        r = e.projectionMatrix.elements,
                        s = n.projectionMatrix.elements,
                        a = r[14] / (r[10] - 1),
                        o = r[14] / (r[10] + 1),
                        l = (r[9] + 1) / r[5],
                        c = (r[9] - 1) / r[5],
                        h = (r[8] - 1) / r[0],
                        u = (s[8] + 1) / s[0],
                        d = a * h,
                        p = a * u,
                        m = i / (-h + u),
                        f = m * -h;
                      e.matrixWorld.decompose(
                        t.position,
                        t.quaternion,
                        t.scale
                      ),
                        t.translateX(f),
                        t.translateZ(m),
                        t.matrixWorld.compose(
                          t.position,
                          t.quaternion,
                          t.scale
                        ),
                        t.matrixWorldInverse.copy(t.matrixWorld).invert();
                      const g = a + m,
                        v = o + m,
                        y = d - f,
                        x = p + (i - f),
                        b = ((l * o) / v) * g,
                        M = ((c * o) / v) * g;
                      t.projectionMatrix.makePerspective(y, x, b, M, g, v);
                    })(m, u, d)
                  : m.projectionMatrix.copy(u.projectionMatrix),
                m
              );
            };
            let M = null;
            const S = new oi();
            S.setAnimationLoop(function (t, e) {
              if (((l = e.getViewerPose(a)), null !== l)) {
                const t = l.views,
                  e = r.renderState.baseLayer;
                i.bindXRFramebuffer(e.framebuffer);
                let n = !1;
                t.length !== m.cameras.length &&
                  ((m.cameras.length = 0), (n = !0));
                for (let i = 0; i < t.length; i++) {
                  const r = t[i],
                    s = e.getViewport(r),
                    a = p[i];
                  a.matrix.fromArray(r.transform.matrix),
                    a.projectionMatrix.fromArray(r.projectionMatrix),
                    a.viewport.set(s.x, s.y, s.width, s.height),
                    0 === i && m.matrix.copy(a.matrix),
                    !0 === n && m.cameras.push(a);
                }
              }
              const n = r.inputSources;
              for (let t = 0; t < c.length; t++) {
                const i = c[t],
                  r = n[t];
                i.update(r, e, a);
              }
              M && M(t, e);
            }),
              (this.setAnimationLoop = function (t) {
                M = t;
              }),
              (this.dispose = function () {});
          }
        }
        function _s(t) {
          function e(e, n) {
            (e.opacity.value = n.opacity),
              n.color && e.diffuse.value.copy(n.color),
              n.emissive &&
                e.emissive.value
                  .copy(n.emissive)
                  .multiplyScalar(n.emissiveIntensity),
              n.map && (e.map.value = n.map),
              n.alphaMap && (e.alphaMap.value = n.alphaMap),
              n.specularMap && (e.specularMap.value = n.specularMap);
            const i = t.get(n).envMap;
            if (i) {
              (e.envMap.value = i),
                (e.flipEnvMap.value =
                  i.isCubeTexture && i._needsFlipEnvMap ? -1 : 1),
                (e.reflectivity.value = n.reflectivity),
                (e.refractionRatio.value = n.refractionRatio);
              const r = t.get(i).__maxMipLevel;
              void 0 !== r && (e.maxMipLevel.value = r);
            }
            let r, s;
            n.lightMap &&
              ((e.lightMap.value = n.lightMap),
              (e.lightMapIntensity.value = n.lightMapIntensity)),
              n.aoMap &&
                ((e.aoMap.value = n.aoMap),
                (e.aoMapIntensity.value = n.aoMapIntensity)),
              n.map
                ? (r = n.map)
                : n.specularMap
                ? (r = n.specularMap)
                : n.displacementMap
                ? (r = n.displacementMap)
                : n.normalMap
                ? (r = n.normalMap)
                : n.bumpMap
                ? (r = n.bumpMap)
                : n.roughnessMap
                ? (r = n.roughnessMap)
                : n.metalnessMap
                ? (r = n.metalnessMap)
                : n.alphaMap
                ? (r = n.alphaMap)
                : n.emissiveMap
                ? (r = n.emissiveMap)
                : n.clearcoatMap
                ? (r = n.clearcoatMap)
                : n.clearcoatNormalMap
                ? (r = n.clearcoatNormalMap)
                : n.clearcoatRoughnessMap && (r = n.clearcoatRoughnessMap),
              void 0 !== r &&
                (r.isWebGLRenderTarget && (r = r.texture),
                !0 === r.matrixAutoUpdate && r.updateMatrix(),
                e.uvTransform.value.copy(r.matrix)),
              n.aoMap ? (s = n.aoMap) : n.lightMap && (s = n.lightMap),
              void 0 !== s &&
                (s.isWebGLRenderTarget && (s = s.texture),
                !0 === s.matrixAutoUpdate && s.updateMatrix(),
                e.uv2Transform.value.copy(s.matrix));
          }
          function n(e, n) {
            (e.roughness.value = n.roughness),
              (e.metalness.value = n.metalness),
              n.roughnessMap && (e.roughnessMap.value = n.roughnessMap),
              n.metalnessMap && (e.metalnessMap.value = n.metalnessMap),
              n.emissiveMap && (e.emissiveMap.value = n.emissiveMap),
              n.bumpMap &&
                ((e.bumpMap.value = n.bumpMap),
                (e.bumpScale.value = n.bumpScale),
                1 === n.side && (e.bumpScale.value *= -1)),
              n.normalMap &&
                ((e.normalMap.value = n.normalMap),
                e.normalScale.value.copy(n.normalScale),
                1 === n.side && e.normalScale.value.negate()),
              n.displacementMap &&
                ((e.displacementMap.value = n.displacementMap),
                (e.displacementScale.value = n.displacementScale),
                (e.displacementBias.value = n.displacementBias));
            t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity);
          }
          return {
            refreshFogUniforms: function (t, e) {
              t.fogColor.value.copy(e.color),
                e.isFog
                  ? ((t.fogNear.value = e.near), (t.fogFar.value = e.far))
                  : e.isFogExp2 && (t.fogDensity.value = e.density);
            },
            refreshMaterialUniforms: function (t, i, r, s) {
              i.isMeshBasicMaterial
                ? e(t, i)
                : i.isMeshLambertMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                  })(t, i))
                : i.isMeshToonMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.gradientMap && (t.gradientMap.value = e.gradientMap);
                    e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshPhongMaterial
                ? (e(t, i),
                  (function (t, e) {
                    t.specular.value.copy(e.specular),
                      (t.shininess.value = Math.max(e.shininess, 1e-4)),
                      e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshStandardMaterial
                ? (e(t, i),
                  i.isMeshPhysicalMaterial
                    ? (function (t, e) {
                        n(t, e),
                          (t.reflectivity.value = e.reflectivity),
                          (t.clearcoat.value = e.clearcoat),
                          (t.clearcoatRoughness.value = e.clearcoatRoughness),
                          e.sheen && t.sheen.value.copy(e.sheen);
                        e.clearcoatMap &&
                          (t.clearcoatMap.value = e.clearcoatMap);
                        e.clearcoatRoughnessMap &&
                          (t.clearcoatRoughnessMap.value =
                            e.clearcoatRoughnessMap);
                        e.clearcoatNormalMap &&
                          (t.clearcoatNormalScale.value.copy(
                            e.clearcoatNormalScale
                          ),
                          (t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                          1 === e.side &&
                            t.clearcoatNormalScale.value.negate());
                        (t.transmission.value = e.transmission),
                          e.transmissionMap &&
                            (t.transmissionMap.value = e.transmissionMap);
                      })(t, i)
                    : n(t, i))
                : i.isMeshMatcapMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.matcap && (t.matcap.value = e.matcap);
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshDepthMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isMeshDistanceMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                    t.referencePosition.value.copy(e.referencePosition),
                      (t.nearDistance.value = e.nearDistance),
                      (t.farDistance.value = e.farDistance);
                  })(t, i))
                : i.isMeshNormalMaterial
                ? (e(t, i),
                  (function (t, e) {
                    e.bumpMap &&
                      ((t.bumpMap.value = e.bumpMap),
                      (t.bumpScale.value = e.bumpScale),
                      1 === e.side && (t.bumpScale.value *= -1));
                    e.normalMap &&
                      ((t.normalMap.value = e.normalMap),
                      t.normalScale.value.copy(e.normalScale),
                      1 === e.side && t.normalScale.value.negate());
                    e.displacementMap &&
                      ((t.displacementMap.value = e.displacementMap),
                      (t.displacementScale.value = e.displacementScale),
                      (t.displacementBias.value = e.displacementBias));
                  })(t, i))
                : i.isLineBasicMaterial
                ? ((function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity);
                  })(t, i),
                  i.isLineDashedMaterial &&
                    (function (t, e) {
                      (t.dashSize.value = e.dashSize),
                        (t.totalSize.value = e.dashSize + e.gapSize),
                        (t.scale.value = e.scale);
                    })(t, i))
                : i.isPointsMaterial
                ? (function (t, e, n, i) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.size.value = e.size * n),
                      (t.scale.value = 0.5 * i),
                      e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let r;
                    e.map ? (r = e.map) : e.alphaMap && (r = e.alphaMap);
                    void 0 !== r &&
                      (!0 === r.matrixAutoUpdate && r.updateMatrix(),
                      t.uvTransform.value.copy(r.matrix));
                  })(t, i, r, s)
                : i.isSpriteMaterial
                ? (function (t, e) {
                    t.diffuse.value.copy(e.color),
                      (t.opacity.value = e.opacity),
                      (t.rotation.value = e.rotation),
                      e.map && (t.map.value = e.map);
                    e.alphaMap && (t.alphaMap.value = e.alphaMap);
                    let n;
                    e.map ? (n = e.map) : e.alphaMap && (n = e.alphaMap);
                    void 0 !== n &&
                      (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                      t.uvTransform.value.copy(n.matrix));
                  })(t, i)
                : i.isShadowMaterial
                ? (t.color.value.copy(i.color), (t.opacity.value = i.opacity))
                : i.isShaderMaterial && (i.uniformsNeedUpdate = !1);
            },
          };
        }
        function ws(t) {
          const e =
              void 0 !== (t = t || {}).canvas
                ? t.canvas
                : (function () {
                    const t = document.createElementNS(
                      "http://www.w3.org/1999/xhtml",
                      "canvas"
                    );
                    return (t.style.display = "block"), t;
                  })(),
            n = void 0 !== t.context ? t.context : null,
            i = void 0 !== t.alpha && t.alpha,
            r = void 0 === t.depth || t.depth,
            s = void 0 === t.stencil || t.stencil,
            a = void 0 !== t.antialias && t.antialias,
            o = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            l = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            c = void 0 !== t.powerPreference ? t.powerPreference : "default",
            h =
              void 0 !== t.failIfMajorPerformanceCaveat &&
              t.failIfMajorPerformanceCaveat;
          let u = null,
            d = null;
          const p = [],
            m = [];
          (this.domElement = e),
            (this.debug = { checkShaderErrors: !0 }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this.gammaFactor = 2),
            (this.outputEncoding = X),
            (this.physicallyCorrectLights = !1),
            (this.toneMapping = 0),
            (this.toneMappingExposure = 1);
          const f = this;
          let g = !1,
            v = 0,
            y = 0,
            _ = null,
            w = -1,
            S = null;
          const T = new St(),
            A = new St();
          let L = null,
            R = e.width,
            C = e.height,
            P = 1,
            D = null,
            I = null;
          const N = new St(0, 0, R, C),
            B = new St(0, 0, R, C);
          let z = !1;
          const F = new ai();
          let O = !1,
            H = !1;
          const G = new se(),
            U = new Lt(),
            k = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          function V() {
            return null === _ ? P : 1;
          }
          let W,
            j,
            q,
            Y,
            Z,
            J,
            Q,
            K,
            $,
            tt,
            et,
            nt,
            it,
            rt,
            st,
            at,
            ot,
            lt,
            ct,
            ht,
            ut,
            dt,
            pt = n;
          function ft(t, n) {
            for (let i = 0; i < t.length; i++) {
              const r = t[i],
                s = e.getContext(r, n);
              if (null !== s) return s;
            }
            return null;
          }
          try {
            const t = {
              alpha: i,
              depth: r,
              stencil: s,
              antialias: a,
              premultipliedAlpha: o,
              preserveDrawingBuffer: l,
              powerPreference: c,
              failIfMajorPerformanceCaveat: h,
            };
            if (
              (e.addEventListener("webglcontextlost", xt, !1),
              e.addEventListener("webglcontextrestored", _t, !1),
              null === pt)
            ) {
              const e = ["webgl2", "webgl", "experimental-webgl"];
              if (
                (!0 === f.isWebGL1Renderer && e.shift(),
                (pt = ft(e, t)),
                null === pt)
              )
                throw ft(e)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
            void 0 === pt.getShaderPrecisionFormat &&
              (pt.getShaderPrecisionFormat = function () {
                return { rangeMin: 1, rangeMax: 1, precision: 1 };
              });
          } catch (t) {
            throw (console.error("THREE.WebGLRenderer: " + t.message), t);
          }
          function gt() {
            (W = new xi(pt)),
              (j = new gi(pt, W, t)),
              W.init(j),
              (ut = new ms(pt, W, j)),
              (q = new ds(pt, W, j)),
              (Y = new bi(pt)),
              (Z = new Kr()),
              (J = new ps(pt, W, q, Z, j, ut, Y)),
              (Q = new yi(f)),
              (K = new li(pt, j)),
              (dt = new mi(pt, W, K, j)),
              ($ = new _i(pt, K, Y, dt)),
              (tt = new Ei(pt, $, K, Y)),
              (lt = new Ti(pt)),
              (st = new vi(Z)),
              (et = new Qr(f, Q, W, j, dt, st)),
              (nt = new _s(Z)),
              (it = new ns(Z)),
              (rt = new ls(W, j)),
              (ot = new pi(f, Q, q, tt, o)),
              (at = new us(f, tt, j)),
              (ct = new fi(pt, W, Y, j)),
              (ht = new wi(pt, W, Y, j)),
              (Y.programs = et.programs),
              (f.capabilities = j),
              (f.extensions = W),
              (f.properties = Z),
              (f.renderLists = it),
              (f.shadowMap = at),
              (f.state = q),
              (f.info = Y);
          }
          gt();
          const yt = new xs(f, pt);
          function xt(t) {
            t.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (g = !0);
          }
          function _t() {
            console.log("THREE.WebGLRenderer: Context Restored."), (g = !1);
            const t = Y.autoReset,
              e = at.enabled,
              n = at.autoUpdate,
              i = at.needsUpdate,
              r = at.type;
            gt(),
              (Y.autoReset = t),
              (at.enabled = e),
              (at.autoUpdate = n),
              (at.needsUpdate = i),
              (at.type = r);
          }
          function wt(t) {
            const e = t.target;
            e.removeEventListener("dispose", wt),
              (function (t) {
                (function (t) {
                  const e = Z.get(t).programs;
                  void 0 !== e &&
                    e.forEach(function (t) {
                      et.releaseProgram(t);
                    });
                })(t),
                  Z.remove(t);
              })(e);
          }
          (this.xr = yt),
            (this.getContext = function () {
              return pt;
            }),
            (this.getContextAttributes = function () {
              return pt.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const t = W.get("WEBGL_lose_context");
              t && t.loseContext();
            }),
            (this.forceContextRestore = function () {
              const t = W.get("WEBGL_lose_context");
              t && t.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return P;
            }),
            (this.setPixelRatio = function (t) {
              void 0 !== t && ((P = t), this.setSize(R, C, !1));
            }),
            (this.getSize = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    "WebGLRenderer: .getsize() now requires a Vector2 as an argument"
                  ),
                  (t = new vt())),
                t.set(R, C)
              );
            }),
            (this.setSize = function (t, n, i) {
              yt.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                  )
                : ((R = t),
                  (C = n),
                  (e.width = Math.floor(t * P)),
                  (e.height = Math.floor(n * P)),
                  !1 !== i &&
                    ((e.style.width = t + "px"), (e.style.height = n + "px")),
                  this.setViewport(0, 0, t, n));
            }),
            (this.getDrawingBufferSize = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    "WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"
                  ),
                  (t = new vt())),
                t.set(R * P, C * P).floor()
              );
            }),
            (this.setDrawingBufferSize = function (t, n, i) {
              (R = t),
                (C = n),
                (P = i),
                (e.width = Math.floor(t * i)),
                (e.height = Math.floor(n * i)),
                this.setViewport(0, 0, t, n);
            }),
            (this.getCurrentViewport = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    "WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"
                  ),
                  (t = new St())),
                t.copy(T)
              );
            }),
            (this.getViewport = function (t) {
              return t.copy(N);
            }),
            (this.setViewport = function (t, e, n, i) {
              t.isVector4 ? N.set(t.x, t.y, t.z, t.w) : N.set(t, e, n, i),
                q.viewport(T.copy(N).multiplyScalar(P).floor());
            }),
            (this.getScissor = function (t) {
              return t.copy(B);
            }),
            (this.setScissor = function (t, e, n, i) {
              t.isVector4 ? B.set(t.x, t.y, t.z, t.w) : B.set(t, e, n, i),
                q.scissor(A.copy(B).multiplyScalar(P).floor());
            }),
            (this.getScissorTest = function () {
              return z;
            }),
            (this.setScissorTest = function (t) {
              q.setScissorTest((z = t));
            }),
            (this.setOpaqueSort = function (t) {
              D = t;
            }),
            (this.setTransparentSort = function (t) {
              I = t;
            }),
            (this.getClearColor = function (t) {
              return (
                void 0 === t &&
                  (console.warn(
                    "WebGLRenderer: .getClearColor() now requires a Color as an argument"
                  ),
                  (t = new tn())),
                t.copy(ot.getClearColor())
              );
            }),
            (this.setClearColor = function () {
              ot.setClearColor.apply(ot, arguments);
            }),
            (this.getClearAlpha = function () {
              return ot.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              ot.setClearAlpha.apply(ot, arguments);
            }),
            (this.clear = function (t, e, n) {
              let i = 0;
              (void 0 === t || t) && (i |= 16384),
                (void 0 === e || e) && (i |= 256),
                (void 0 === n || n) && (i |= 1024),
                pt.clear(i);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              e.removeEventListener("webglcontextlost", xt, !1),
                e.removeEventListener("webglcontextrestored", _t, !1),
                it.dispose(),
                rt.dispose(),
                Z.dispose(),
                Q.dispose(),
                tt.dispose(),
                dt.dispose(),
                yt.dispose(),
                yt.removeEventListener("sessionstart", Mt),
                yt.removeEventListener("sessionend", Tt),
                Et.stop();
            }),
            (this.renderBufferImmediate = function (t, e) {
              dt.initAttributes();
              const n = Z.get(t);
              t.hasPositions && !n.position && (n.position = pt.createBuffer()),
                t.hasNormals && !n.normal && (n.normal = pt.createBuffer()),
                t.hasUvs && !n.uv && (n.uv = pt.createBuffer()),
                t.hasColors && !n.color && (n.color = pt.createBuffer());
              const i = e.getAttributes();
              t.hasPositions &&
                (pt.bindBuffer(34962, n.position),
                pt.bufferData(34962, t.positionArray, 35048),
                dt.enableAttribute(i.position),
                pt.vertexAttribPointer(i.position, 3, 5126, !1, 0, 0)),
                t.hasNormals &&
                  (pt.bindBuffer(34962, n.normal),
                  pt.bufferData(34962, t.normalArray, 35048),
                  dt.enableAttribute(i.normal),
                  pt.vertexAttribPointer(i.normal, 3, 5126, !1, 0, 0)),
                t.hasUvs &&
                  (pt.bindBuffer(34962, n.uv),
                  pt.bufferData(34962, t.uvArray, 35048),
                  dt.enableAttribute(i.uv),
                  pt.vertexAttribPointer(i.uv, 2, 5126, !1, 0, 0)),
                t.hasColors &&
                  (pt.bindBuffer(34962, n.color),
                  pt.bufferData(34962, t.colorArray, 35048),
                  dt.enableAttribute(i.color),
                  pt.vertexAttribPointer(i.color, 3, 5126, !1, 0, 0)),
                dt.disableUnusedAttributes(),
                pt.drawArrays(4, 0, t.count),
                (t.count = 0);
            }),
            (this.renderBufferDirect = function (t, e, n, i, r, s) {
              null === e && (e = k);
              const a = r.isMesh && r.matrixWorld.determinant() < 0,
                o = It(t, e, i, r);
              q.setMaterial(i, a);
              let l = n.index;
              const c = n.attributes.position;
              if (null === l) {
                if (void 0 === c || 0 === c.count) return;
              } else if (0 === l.count) return;
              let h,
                u = 1;
              !0 === i.wireframe && ((l = $.getWireframeAttribute(n)), (u = 2)),
                (i.morphTargets || i.morphNormals) && lt.update(r, n, i, o),
                dt.setup(r, i, o, n, l);
              let d = ct;
              null !== l && ((h = K.get(l)), (d = ht), d.setIndex(h));
              const p = null !== l ? l.count : c.count,
                m = n.drawRange.start * u,
                f = n.drawRange.count * u,
                g = null !== s ? s.start * u : 0,
                v = null !== s ? s.count * u : 1 / 0,
                y = Math.max(m, g),
                x = Math.min(p, m + f, g + v) - 1,
                _ = Math.max(0, x - y + 1);
              if (0 !== _) {
                if (r.isMesh)
                  !0 === i.wireframe
                    ? (q.setLineWidth(i.wireframeLinewidth * V()), d.setMode(1))
                    : d.setMode(4);
                else if (r.isLine) {
                  let t = i.linewidth;
                  void 0 === t && (t = 1),
                    q.setLineWidth(t * V()),
                    r.isLineSegments
                      ? d.setMode(1)
                      : r.isLineLoop
                      ? d.setMode(2)
                      : d.setMode(3);
                } else r.isPoints ? d.setMode(0) : r.isSprite && d.setMode(4);
                if (r.isInstancedMesh) d.renderInstances(y, _, r.count);
                else if (n.isInstancedBufferGeometry) {
                  const t = Math.min(n.instanceCount, n._maxInstanceCount);
                  d.renderInstances(y, _, t);
                } else d.render(y, _);
              }
            }),
            (this.compile = function (t, e) {
              (d = rt.get(t)),
                d.init(),
                t.traverseVisible(function (t) {
                  t.isLight &&
                    t.layers.test(e.layers) &&
                    (d.pushLight(t), t.castShadow && d.pushShadow(t));
                }),
                d.setupLights(),
                t.traverse(function (e) {
                  const n = e.material;
                  if (n)
                    if (Array.isArray(n))
                      for (let i = 0; i < n.length; i++) {
                        Pt(n[i], t, e);
                      }
                    else Pt(n, t, e);
                });
            });
          let bt = null;
          function Mt() {
            Et.stop();
          }
          function Tt() {
            Et.start();
          }
          const Et = new oi();
          function At(t, e, n, i) {
            if (!1 === t.visible) return;
            if (t.layers.test(e.layers))
              if (t.isGroup) n = t.renderOrder;
              else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
              else if (t.isLight)
                d.pushLight(t), t.castShadow && d.pushShadow(t);
              else if (t.isSprite) {
                if (!t.frustumCulled || F.intersectsSprite(t)) {
                  i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
                  const e = tt.update(t),
                    r = t.material;
                  r.visible && u.push(t, e, r, n, U.z, null);
                }
              } else if (t.isImmediateRenderObject)
                i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G),
                  u.push(t, null, t.material, n, U.z, null);
              else if (
                (t.isMesh || t.isLine || t.isPoints) &&
                (t.isSkinnedMesh &&
                  t.skeleton.frame !== Y.render.frame &&
                  (t.skeleton.update(), (t.skeleton.frame = Y.render.frame)),
                !t.frustumCulled || F.intersectsObject(t))
              ) {
                i && U.setFromMatrixPosition(t.matrixWorld).applyMatrix4(G);
                const e = tt.update(t),
                  r = t.material;
                if (Array.isArray(r)) {
                  const i = e.groups;
                  for (let s = 0, a = i.length; s < a; s++) {
                    const a = i[s],
                      o = r[a.materialIndex];
                    o && o.visible && u.push(t, e, o, n, U.z, a);
                  }
                } else r.visible && u.push(t, e, r, n, U.z, null);
              }
            const r = t.children;
            for (let t = 0, s = r.length; t < s; t++) At(r[t], e, n, i);
          }
          function Rt(t, e, n) {
            const i = !0 === e.isScene ? e.overrideMaterial : null;
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r],
                a = s.object,
                o = s.geometry,
                l = null === i ? s.material : i,
                c = s.group;
              if (n.isArrayCamera) {
                const t = n.cameras;
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n];
                  a.layers.test(i.layers) &&
                    (q.viewport(T.copy(i.viewport)),
                    d.setupLightsView(i),
                    Ct(a, e, i, o, l, c));
                }
              } else Ct(a, e, n, o, l, c);
            }
          }
          function Ct(t, e, n, i, r, s) {
            if (
              (t.onBeforeRender(f, e, n, i, r, s),
              t.modelViewMatrix.multiplyMatrices(
                n.matrixWorldInverse,
                t.matrixWorld
              ),
              t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
              t.isImmediateRenderObject)
            ) {
              const i = It(n, e, r, t);
              q.setMaterial(r),
                dt.reset(),
                (function (t, e) {
                  t.render(function (t) {
                    f.renderBufferImmediate(t, e);
                  });
                })(t, i);
            } else f.renderBufferDirect(n, e, i, r, t, s);
            t.onAfterRender(f, e, n, i, r, s);
          }
          function Pt(t, e, n) {
            !0 !== e.isScene && (e = k);
            const i = Z.get(t),
              r = d.state.lights,
              s = d.state.shadowsArray,
              a = r.state.version,
              o = et.getParameters(t, r.state, s, e, n),
              l = et.getProgramCacheKey(o);
            let c = i.programs;
            (i.environment = t.isMeshStandardMaterial ? e.environment : null),
              (i.fog = e.fog),
              (i.envMap = Q.get(t.envMap || i.environment)),
              void 0 === c &&
                (t.addEventListener("dispose", wt),
                (c = new Map()),
                (i.programs = c));
            let h = c.get(l);
            if (void 0 !== h) {
              if (i.currentProgram === h && i.lightsStateVersion === a)
                return Dt(t, o), h;
            } else (o.uniforms = et.getUniforms(t)), t.onBuild(o, f), t.onBeforeCompile(o, f), (h = et.acquireProgram(o, l)), c.set(l, h), (i.uniforms = o.uniforms);
            const u = i.uniforms;
            ((t.isShaderMaterial || t.isRawShaderMaterial) &&
              !0 !== t.clipping) ||
              (u.clippingPlanes = st.uniform),
              Dt(t, o),
              (i.needsLights = (function (t) {
                return (
                  t.isMeshLambertMaterial ||
                  t.isMeshToonMaterial ||
                  t.isMeshPhongMaterial ||
                  t.isMeshStandardMaterial ||
                  t.isShadowMaterial ||
                  (t.isShaderMaterial && !0 === t.lights)
                );
              })(t)),
              (i.lightsStateVersion = a),
              i.needsLights &&
                ((u.ambientLightColor.value = r.state.ambient),
                (u.lightProbe.value = r.state.probe),
                (u.directionalLights.value = r.state.directional),
                (u.directionalLightShadows.value = r.state.directionalShadow),
                (u.spotLights.value = r.state.spot),
                (u.spotLightShadows.value = r.state.spotShadow),
                (u.rectAreaLights.value = r.state.rectArea),
                (u.ltc_1.value = r.state.rectAreaLTC1),
                (u.ltc_2.value = r.state.rectAreaLTC2),
                (u.pointLights.value = r.state.point),
                (u.pointLightShadows.value = r.state.pointShadow),
                (u.hemisphereLights.value = r.state.hemi),
                (u.directionalShadowMap.value = r.state.directionalShadowMap),
                (u.directionalShadowMatrix.value =
                  r.state.directionalShadowMatrix),
                (u.spotShadowMap.value = r.state.spotShadowMap),
                (u.spotShadowMatrix.value = r.state.spotShadowMatrix),
                (u.pointShadowMap.value = r.state.pointShadowMap),
                (u.pointShadowMatrix.value = r.state.pointShadowMatrix));
            const p = h.getUniforms(),
              m = Cr.seqWithValue(p.seq, u);
            return (i.currentProgram = h), (i.uniformsList = m), h;
          }
          function Dt(t, e) {
            const n = Z.get(t);
            (n.outputEncoding = e.outputEncoding),
              (n.instancing = e.instancing),
              (n.numClippingPlanes = e.numClippingPlanes),
              (n.numIntersection = e.numClipIntersection),
              (n.vertexAlphas = e.vertexAlphas);
          }
          function It(t, e, n, i) {
            !0 !== e.isScene && (e = k), J.resetTextureUnits();
            const r = e.fog,
              s = n.isMeshStandardMaterial ? e.environment : null,
              a = null === _ ? f.outputEncoding : _.texture.encoding,
              o = Q.get(n.envMap || s),
              l =
                !0 === n.vertexColors &&
                i.geometry &&
                i.geometry.attributes.color &&
                4 === i.geometry.attributes.color.itemSize,
              c = Z.get(n),
              h = d.state.lights;
            if (!0 === O && (!0 === H || t !== S)) {
              const e = t === S && n.id === w;
              st.setState(n, t, e);
            }
            let u = !1;
            n.version === c.__version
              ? (c.needsLights && c.lightsStateVersion !== h.state.version) ||
                c.outputEncoding !== a ||
                (i.isInstancedMesh && !1 === c.instancing)
                ? (u = !0)
                : i.isInstancedMesh || !0 !== c.instancing
                ? c.envMap !== o || (n.fog && c.fog !== r)
                  ? (u = !0)
                  : void 0 === c.numClippingPlanes ||
                    (c.numClippingPlanes === st.numPlanes &&
                      c.numIntersection === st.numIntersection)
                  ? c.vertexAlphas !== l && (u = !0)
                  : (u = !0)
                : (u = !0)
              : ((u = !0), (c.__version = n.version));
            let p = c.currentProgram;
            !0 === u && (p = Pt(n, e, i));
            let m = !1,
              g = !1,
              v = !1;
            const y = p.getUniforms(),
              x = c.uniforms;
            if (
              (q.useProgram(p.program) && ((m = !0), (g = !0), (v = !0)),
              n.id !== w && ((w = n.id), (g = !0)),
              m || S !== t)
            ) {
              if (
                (y.setValue(pt, "projectionMatrix", t.projectionMatrix),
                j.logarithmicDepthBuffer &&
                  y.setValue(
                    pt,
                    "logDepthBufFC",
                    2 / (Math.log(t.far + 1) / Math.LN2)
                  ),
                S !== t && ((S = t), (g = !0), (v = !0)),
                n.isShaderMaterial ||
                  n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshStandardMaterial ||
                  n.envMap)
              ) {
                const e = y.map.cameraPosition;
                void 0 !== e &&
                  e.setValue(pt, U.setFromMatrixPosition(t.matrixWorld));
              }
              (n.isMeshPhongMaterial ||
                n.isMeshToonMaterial ||
                n.isMeshLambertMaterial ||
                n.isMeshBasicMaterial ||
                n.isMeshStandardMaterial ||
                n.isShaderMaterial) &&
                y.setValue(pt, "isOrthographic", !0 === t.isOrthographicCamera),
                (n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshLambertMaterial ||
                  n.isMeshBasicMaterial ||
                  n.isMeshStandardMaterial ||
                  n.isShaderMaterial ||
                  n.isShadowMaterial ||
                  n.skinning) &&
                  y.setValue(pt, "viewMatrix", t.matrixWorldInverse);
            }
            if (n.skinning) {
              y.setOptional(pt, i, "bindMatrix"),
                y.setOptional(pt, i, "bindMatrixInverse");
              const t = i.skeleton;
              if (t) {
                const e = t.bones;
                if (j.floatVertexTextures) {
                  if (null === t.boneTexture) {
                    let n = Math.sqrt(4 * e.length);
                    (n = mt(n)), (n = Math.max(n, 4));
                    const i = new Float32Array(n * n * 4);
                    i.set(t.boneMatrices);
                    const r = new ii(i, n, n, E, b);
                    (t.boneMatrices = i),
                      (t.boneTexture = r),
                      (t.boneTextureSize = n);
                  }
                  y.setValue(pt, "boneTexture", t.boneTexture, J),
                    y.setValue(pt, "boneTextureSize", t.boneTextureSize);
                } else y.setOptional(pt, t, "boneMatrices");
              }
            }
            var M, T;
            return (
              (g || c.receiveShadow !== i.receiveShadow) &&
                ((c.receiveShadow = i.receiveShadow),
                y.setValue(pt, "receiveShadow", i.receiveShadow)),
              g &&
                (y.setValue(pt, "toneMappingExposure", f.toneMappingExposure),
                c.needsLights &&
                  ((T = v),
                  ((M = x).ambientLightColor.needsUpdate = T),
                  (M.lightProbe.needsUpdate = T),
                  (M.directionalLights.needsUpdate = T),
                  (M.directionalLightShadows.needsUpdate = T),
                  (M.pointLights.needsUpdate = T),
                  (M.pointLightShadows.needsUpdate = T),
                  (M.spotLights.needsUpdate = T),
                  (M.spotLightShadows.needsUpdate = T),
                  (M.rectAreaLights.needsUpdate = T),
                  (M.hemisphereLights.needsUpdate = T)),
                r && n.fog && nt.refreshFogUniforms(x, r),
                nt.refreshMaterialUniforms(x, n, P, C),
                Cr.upload(pt, c.uniformsList, x, J)),
              n.isShaderMaterial &&
                !0 === n.uniformsNeedUpdate &&
                (Cr.upload(pt, c.uniformsList, x, J),
                (n.uniformsNeedUpdate = !1)),
              n.isSpriteMaterial && y.setValue(pt, "center", i.center),
              y.setValue(pt, "modelViewMatrix", i.modelViewMatrix),
              y.setValue(pt, "normalMatrix", i.normalMatrix),
              y.setValue(pt, "modelMatrix", i.matrixWorld),
              p
            );
          }
          Et.setAnimationLoop(function (t) {
            bt && bt(t);
          }),
            "undefined" != typeof window && Et.setContext(window),
            (this.setAnimationLoop = function (t) {
              (bt = t),
                yt.setAnimationLoop(t),
                null === t ? Et.stop() : Et.start();
            }),
            yt.addEventListener("sessionstart", Mt),
            yt.addEventListener("sessionend", Tt),
            (this.render = function (t, e) {
              let n, i;
              if (
                (void 0 !== arguments[2] &&
                  (console.warn(
                    "THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
                  ),
                  (n = arguments[2])),
                void 0 !== arguments[3] &&
                  (console.warn(
                    "THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."
                  ),
                  (i = arguments[3])),
                void 0 !== e && !0 !== e.isCamera)
              )
                return void console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
              if (!0 === g) return;
              !0 === t.autoUpdate && t.updateMatrixWorld(),
                null === e.parent && e.updateMatrixWorld(),
                !0 === yt.enabled &&
                  !0 === yt.isPresenting &&
                  (e = yt.getCamera(e)),
                !0 === t.isScene && t.onBeforeRender(f, t, e, n || _),
                (d = rt.get(t, m.length)),
                d.init(),
                m.push(d),
                G.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
                F.setFromProjectionMatrix(G),
                (H = this.localClippingEnabled),
                (O = st.init(this.clippingPlanes, H, e)),
                (u = it.get(t, p.length)),
                u.init(),
                p.push(u),
                At(t, e, 0, f.sortObjects),
                u.finish(),
                !0 === f.sortObjects && u.sort(D, I),
                !0 === O && st.beginShadows();
              const r = d.state.shadowsArray;
              at.render(r, t, e),
                d.setupLights(),
                d.setupLightsView(e),
                !0 === O && st.endShadows(),
                !0 === this.info.autoReset && this.info.reset(),
                void 0 !== n && this.setRenderTarget(n),
                ot.render(u, t, e, i);
              const s = u.opaque,
                a = u.transparent;
              s.length > 0 && Rt(s, t, e),
                a.length > 0 && Rt(a, t, e),
                null !== _ &&
                  (J.updateRenderTargetMipmap(_),
                  J.updateMultisampleRenderTarget(_)),
                !0 === t.isScene && t.onAfterRender(f, t, e),
                q.buffers.depth.setTest(!0),
                q.buffers.depth.setMask(!0),
                q.buffers.color.setMask(!0),
                q.setPolygonOffset(!1),
                dt.resetDefaultState(),
                (w = -1),
                (S = null),
                m.pop(),
                (d = m.length > 0 ? m[m.length - 1] : null),
                p.pop(),
                (u = p.length > 0 ? p[p.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return v;
            }),
            (this.getActiveMipmapLevel = function () {
              return y;
            }),
            (this.getRenderTarget = function () {
              return _;
            }),
            (this.setRenderTarget = function (t, e = 0, n = 0) {
              (_ = t),
                (v = e),
                (y = n),
                t &&
                  void 0 === Z.get(t).__webglFramebuffer &&
                  J.setupRenderTarget(t);
              let i = null,
                r = !1,
                s = !1;
              if (t) {
                const n = t.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (s = !0);
                const a = Z.get(t).__webglFramebuffer;
                t.isWebGLCubeRenderTarget
                  ? ((i = a[e]), (r = !0))
                  : (i = t.isWebGLMultisampleRenderTarget
                      ? Z.get(t).__webglMultisampledFramebuffer
                      : a),
                  T.copy(t.viewport),
                  A.copy(t.scissor),
                  (L = t.scissorTest);
              } else
                T.copy(N).multiplyScalar(P).floor(),
                  A.copy(B).multiplyScalar(P).floor(),
                  (L = z);
              if (
                (q.bindFramebuffer(36160, i),
                q.viewport(T),
                q.scissor(A),
                q.setScissorTest(L),
                r)
              ) {
                const i = Z.get(t.texture);
                pt.framebufferTexture2D(
                  36160,
                  36064,
                  34069 + e,
                  i.__webglTexture,
                  n
                );
              } else if (s) {
                const i = Z.get(t.texture),
                  r = e || 0;
                pt.framebufferTextureLayer(
                  36160,
                  36064,
                  i.__webglTexture,
                  n || 0,
                  r
                );
              }
            }),
            (this.readRenderTargetPixels = function (t, e, n, i, r, s, a) {
              if (!t || !t.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let o = Z.get(t).__webglFramebuffer;
              if (
                (t.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)
              ) {
                q.bindFramebuffer(36160, o);
                try {
                  const a = t.texture,
                    o = a.format,
                    l = a.type;
                  if (o !== E && ut.convert(o) !== pt.getParameter(35739))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  const c =
                    l === M &&
                    (W.has("EXT_color_buffer_half_float") ||
                      (j.isWebGL2 && W.has("EXT_color_buffer_float")));
                  if (
                    !(
                      l === x ||
                      ut.convert(l) === pt.getParameter(35738) ||
                      (l === b &&
                        (j.isWebGL2 ||
                          W.has("OES_texture_float") ||
                          W.has("WEBGL_color_buffer_float"))) ||
                      c
                    )
                  )
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  36053 === pt.checkFramebufferStatus(36160)
                    ? e >= 0 &&
                      e <= t.width - i &&
                      n >= 0 &&
                      n <= t.height - r &&
                      pt.readPixels(e, n, i, r, ut.convert(o), ut.convert(l), s)
                    : console.error(
                        "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
                      );
                } finally {
                  const t = null !== _ ? Z.get(_).__webglFramebuffer : null;
                  q.bindFramebuffer(36160, t);
                }
              }
            }),
            (this.copyFramebufferToTexture = function (t, e, n = 0) {
              const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                s = Math.floor(e.image.height * i),
                a = ut.convert(e.format);
              J.setTexture2D(e, 0),
                pt.copyTexImage2D(3553, n, a, t.x, t.y, r, s, 0),
                q.unbindTexture();
            }),
            (this.copyTextureToTexture = function (t, e, n, i = 0) {
              const r = e.image.width,
                s = e.image.height,
                a = ut.convert(n.format),
                o = ut.convert(n.type);
              J.setTexture2D(n, 0),
                pt.pixelStorei(37440, n.flipY),
                pt.pixelStorei(37441, n.premultiplyAlpha),
                pt.pixelStorei(3317, n.unpackAlignment),
                e.isDataTexture
                  ? pt.texSubImage2D(
                      3553,
                      i,
                      t.x,
                      t.y,
                      r,
                      s,
                      a,
                      o,
                      e.image.data
                    )
                  : e.isCompressedTexture
                  ? pt.compressedTexSubImage2D(
                      3553,
                      i,
                      t.x,
                      t.y,
                      e.mipmaps[0].width,
                      e.mipmaps[0].height,
                      a,
                      e.mipmaps[0].data
                    )
                  : pt.texSubImage2D(3553, i, t.x, t.y, a, o, e.image),
                0 === i && n.generateMipmaps && pt.generateMipmap(3553),
                q.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
              if (f.isWebGL1Renderer)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
                );
              const { width: s, height: a, data: o } = n.image,
                l = ut.convert(i.format),
                c = ut.convert(i.type);
              let h;
              if (i.isDataTexture3D) J.setTexture3D(i, 0), (h = 32879);
              else {
                if (!i.isDataTexture2DArray)
                  return void console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                  );
                J.setTexture2DArray(i, 0), (h = 35866);
              }
              pt.pixelStorei(37440, i.flipY),
                pt.pixelStorei(37441, i.premultiplyAlpha),
                pt.pixelStorei(3317, i.unpackAlignment);
              const u = pt.getParameter(3314),
                d = pt.getParameter(32878),
                p = pt.getParameter(3316),
                m = pt.getParameter(3315),
                g = pt.getParameter(32877);
              pt.pixelStorei(3314, s),
                pt.pixelStorei(32878, a),
                pt.pixelStorei(3316, t.min.x),
                pt.pixelStorei(3315, t.min.y),
                pt.pixelStorei(32877, t.min.z),
                pt.texSubImage3D(
                  h,
                  r,
                  e.x,
                  e.y,
                  e.z,
                  t.max.x - t.min.x + 1,
                  t.max.y - t.min.y + 1,
                  t.max.z - t.min.z + 1,
                  l,
                  c,
                  o
                ),
                pt.pixelStorei(3314, u),
                pt.pixelStorei(32878, d),
                pt.pixelStorei(3316, p),
                pt.pixelStorei(3315, m),
                pt.pixelStorei(32877, g),
                0 === r && i.generateMipmaps && pt.generateMipmap(h),
                q.unbindTexture();
            }),
            (this.initTexture = function (t) {
              J.setTexture2D(t, 0), q.unbindTexture();
            }),
            (this.resetState = function () {
              (v = 0), (y = 0), (_ = null), q.reset(), dt.reset();
            }),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        class bs extends ws {}
        bs.prototype.isWebGL1Renderer = !0;
        class Ms {
          constructor(t, e = 25e-5) {
            (this.name = ""), (this.color = new tn(t)), (this.density = e);
          }
          clone() {
            return new Ms(this.color, this.density);
          }
          toJSON() {
            return {
              type: "FogExp2",
              color: this.color.getHex(),
              density: this.density,
            };
          }
        }
        Ms.prototype.isFogExp2 = !0;
        class Ss {
          constructor(t, e = 1, n = 1e3) {
            (this.name = ""),
              (this.color = new tn(t)),
              (this.near = e),
              (this.far = n);
          }
          clone() {
            return new Ss(this.color, this.near, this.far);
          }
          toJSON() {
            return {
              type: "Fog",
              color: this.color.getHex(),
              near: this.near,
              far: this.far,
            };
          }
        }
        Ss.prototype.isFog = !0;
        class Ts extends Ce {
          constructor() {
            super(),
              (this.type = "Scene"),
              (this.background = null),
              (this.environment = null),
              (this.fog = null),
              (this.overrideMaterial = null),
              (this.autoUpdate = !0),
              "undefined" != typeof __THREE_DEVTOOLS__ &&
                __THREE_DEVTOOLS__.dispatchEvent(
                  new CustomEvent("observe", { detail: this })
                );
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              null !== t.background && (this.background = t.background.clone()),
              null !== t.environment &&
                (this.environment = t.environment.clone()),
              null !== t.fog && (this.fog = t.fog.clone()),
              null !== t.overrideMaterial &&
                (this.overrideMaterial = t.overrideMaterial.clone()),
              (this.autoUpdate = t.autoUpdate),
              (this.matrixAutoUpdate = t.matrixAutoUpdate),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              null !== this.background &&
                (e.object.background = this.background.toJSON(t)),
              null !== this.environment &&
                (e.object.environment = this.environment.toJSON(t)),
              null !== this.fog && (e.object.fog = this.fog.toJSON()),
              e
            );
          }
        }
        Ts.prototype.isScene = !0;
        class Es {
          constructor(t, e) {
            (this.array = t),
              (this.stride = e),
              (this.count = void 0 !== t ? t.length / e : 0),
              (this.usage = et),
              (this.updateRange = { offset: 0, count: -1 }),
              (this.version = 0),
              (this.uuid = ct()),
              (this.onUploadCallback = function () {});
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setUsage(t) {
            return (this.usage = t), this;
          }
          copy(t) {
            return (
              (this.array = new t.array.constructor(t.array)),
              (this.count = t.count),
              (this.stride = t.stride),
              (this.usage = t.usage),
              this
            );
          }
          copyAt(t, e, n) {
            (t *= this.stride), (n *= e.stride);
            for (let i = 0, r = this.stride; i < r; i++)
              this.array[t + i] = e.array[n + i];
            return this;
          }
          set(t, e = 0) {
            return this.array.set(t, e), this;
          }
          clone(t) {
            void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = ct()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] =
                  this.array.slice(0).buffer);
            const e = new this.array.constructor(
                t.arrayBuffers[this.array.buffer._uuid]
              ),
              n = new Es(e, this.stride);
            return n.setUsage(this.usage), n;
          }
          onUpload(t) {
            return (this.onUploadCallback = t), this;
          }
          toJSON(t) {
            return (
              void 0 === t.arrayBuffers && (t.arrayBuffers = {}),
              void 0 === this.array.buffer._uuid &&
                (this.array.buffer._uuid = ct()),
              void 0 === t.arrayBuffers[this.array.buffer._uuid] &&
                (t.arrayBuffers[this.array.buffer._uuid] =
                  Array.prototype.slice.call(
                    new Uint32Array(this.array.buffer)
                  )),
              {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride,
              }
            );
          }
        }
        Es.prototype.isInterleavedBuffer = !0;
        const As = new Lt();
        class Ls {
          constructor(t, e, n, i) {
            (this.name = ""),
              (this.data = t),
              (this.itemSize = e),
              (this.offset = n),
              (this.normalized = !0 === i);
          }
          get count() {
            return this.data.count;
          }
          get array() {
            return this.data.array;
          }
          set needsUpdate(t) {
            this.data.needsUpdate = t;
          }
          applyMatrix4(t) {
            for (let e = 0, n = this.data.count; e < n; e++)
              (As.x = this.getX(e)),
                (As.y = this.getY(e)),
                (As.z = this.getZ(e)),
                As.applyMatrix4(t),
                this.setXYZ(e, As.x, As.y, As.z);
            return this;
          }
          applyNormalMatrix(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (As.x = this.getX(e)),
                (As.y = this.getY(e)),
                (As.z = this.getZ(e)),
                As.applyNormalMatrix(t),
                this.setXYZ(e, As.x, As.y, As.z);
            return this;
          }
          transformDirection(t) {
            for (let e = 0, n = this.count; e < n; e++)
              (As.x = this.getX(e)),
                (As.y = this.getY(e)),
                (As.z = this.getZ(e)),
                As.transformDirection(t),
                this.setXYZ(e, As.x, As.y, As.z);
            return this;
          }
          setX(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset] = e), this
            );
          }
          setY(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 1] = e),
              this
            );
          }
          setZ(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 2] = e),
              this
            );
          }
          setW(t, e) {
            return (
              (this.data.array[t * this.data.stride + this.offset + 3] = e),
              this
            );
          }
          getX(t) {
            return this.data.array[t * this.data.stride + this.offset];
          }
          getY(t) {
            return this.data.array[t * this.data.stride + this.offset + 1];
          }
          getZ(t) {
            return this.data.array[t * this.data.stride + this.offset + 2];
          }
          getW(t) {
            return this.data.array[t * this.data.stride + this.offset + 3];
          }
          setXY(t, e, n) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              this
            );
          }
          setXYZ(t, e, n, i) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              this
            );
          }
          setXYZW(t, e, n, i, r) {
            return (
              (t = t * this.data.stride + this.offset),
              (this.data.array[t + 0] = e),
              (this.data.array[t + 1] = n),
              (this.data.array[t + 2] = i),
              (this.data.array[t + 3] = r),
              this
            );
          }
          clone(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return new sn(
                new this.array.constructor(t),
                this.itemSize,
                this.normalized
              );
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)),
              new Ls(
                t.interleavedBuffers[this.data.uuid],
                this.itemSize,
                this.offset,
                this.normalized
              )
            );
          }
          toJSON(t) {
            if (void 0 === t) {
              console.log(
                "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data."
              );
              const t = [];
              for (let e = 0; e < this.count; e++) {
                const n = e * this.data.stride + this.offset;
                for (let e = 0; e < this.itemSize; e++)
                  t.push(this.data.array[n + e]);
              }
              return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized,
              };
            }
            return (
              void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}),
              void 0 === t.interleavedBuffers[this.data.uuid] &&
                (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)),
              {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized,
              }
            );
          }
        }
        Ls.prototype.isInterleavedBufferAttribute = !0;
        class Rs extends Xe {
          constructor(t) {
            super(),
              (this.type = "SpriteMaterial"),
              (this.color = new tn(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.rotation = 0),
              (this.sizeAttenuation = !0),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.rotation = t.rotation),
              (this.sizeAttenuation = t.sizeAttenuation),
              this
            );
          }
        }
        let Cs;
        Rs.prototype.isSpriteMaterial = !0;
        const Ps = new Lt(),
          Ds = new Lt(),
          Is = new Lt(),
          Ns = new vt(),
          Bs = new vt(),
          zs = new se(),
          Fs = new Lt(),
          Os = new Lt(),
          Hs = new Lt(),
          Gs = new vt(),
          Us = new vt(),
          ks = new vt();
        class Vs extends Ce {
          constructor(t) {
            if ((super(), (this.type = "Sprite"), void 0 === Cs)) {
              Cs = new En();
              const t = new Float32Array([
                  -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1,
                  -0.5, 0.5, 0, 0, 1,
                ]),
                e = new Es(t, 5);
              Cs.setIndex([0, 1, 2, 0, 2, 3]),
                Cs.setAttribute("position", new Ls(e, 3, 0, !1)),
                Cs.setAttribute("uv", new Ls(e, 2, 3, !1));
            }
            (this.geometry = Cs),
              (this.material = void 0 !== t ? t : new Rs()),
              (this.center = new vt(0.5, 0.5));
          }
          raycast(t, e) {
            null === t.camera &&
              console.error(
                'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
              ),
              Ds.setFromMatrixScale(this.matrixWorld),
              zs.copy(t.camera.matrixWorld),
              this.modelViewMatrix.multiplyMatrices(
                t.camera.matrixWorldInverse,
                this.matrixWorld
              ),
              Is.setFromMatrixPosition(this.modelViewMatrix),
              t.camera.isPerspectiveCamera &&
                !1 === this.material.sizeAttenuation &&
                Ds.multiplyScalar(-Is.z);
            const n = this.material.rotation;
            let i, r;
            0 !== n && ((r = Math.cos(n)), (i = Math.sin(n)));
            const s = this.center;
            Ws(Fs.set(-0.5, -0.5, 0), Is, s, Ds, i, r),
              Ws(Os.set(0.5, -0.5, 0), Is, s, Ds, i, r),
              Ws(Hs.set(0.5, 0.5, 0), Is, s, Ds, i, r),
              Gs.set(0, 0),
              Us.set(1, 0),
              ks.set(1, 1);
            let a = t.ray.intersectTriangle(Fs, Os, Hs, !1, Ps);
            if (
              null === a &&
              (Ws(Os.set(-0.5, 0.5, 0), Is, s, Ds, i, r),
              Us.set(0, 1),
              (a = t.ray.intersectTriangle(Fs, Hs, Os, !1, Ps)),
              null === a)
            )
              return;
            const o = t.ray.origin.distanceTo(Ps);
            o < t.near ||
              o > t.far ||
              e.push({
                distance: o,
                point: Ps.clone(),
                uv: je.getUV(Ps, Fs, Os, Hs, Gs, Us, ks, new vt()),
                face: null,
                object: this,
              });
          }
          copy(t) {
            return (
              super.copy(t),
              void 0 !== t.center && this.center.copy(t.center),
              (this.material = t.material),
              this
            );
          }
        }
        function Ws(t, e, n, i, r, s) {
          Ns.subVectors(t, n).addScalar(0.5).multiply(i),
            void 0 !== r
              ? ((Bs.x = s * Ns.x - r * Ns.y), (Bs.y = r * Ns.x + s * Ns.y))
              : Bs.copy(Ns),
            t.copy(e),
            (t.x += Bs.x),
            (t.y += Bs.y),
            t.applyMatrix4(zs);
        }
        Vs.prototype.isSprite = !0;
        const js = new Lt(),
          qs = new Lt();
        class Xs extends Ce {
          constructor() {
            super(),
              (this._currentLevel = 0),
              (this.type = "LOD"),
              Object.defineProperties(this, {
                levels: { enumerable: !0, value: [] },
                isLOD: { value: !0 },
              }),
              (this.autoUpdate = !0);
          }
          copy(t) {
            super.copy(t, !1);
            const e = t.levels;
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              this.addLevel(n.object.clone(), n.distance);
            }
            return (this.autoUpdate = t.autoUpdate), this;
          }
          addLevel(t, e = 0) {
            e = Math.abs(e);
            const n = this.levels;
            let i;
            for (i = 0; i < n.length && !(e < n[i].distance); i++);
            return (
              n.splice(i, 0, { distance: e, object: t }), this.add(t), this
            );
          }
          getCurrentLevel() {
            return this._currentLevel;
          }
          getObjectForDistance(t) {
            const e = this.levels;
            if (e.length > 0) {
              let n, i;
              for (n = 1, i = e.length; n < i && !(t < e[n].distance); n++);
              return e[n - 1].object;
            }
            return null;
          }
          raycast(t, e) {
            if (this.levels.length > 0) {
              js.setFromMatrixPosition(this.matrixWorld);
              const n = t.ray.origin.distanceTo(js);
              this.getObjectForDistance(n).raycast(t, e);
            }
          }
          update(t) {
            const e = this.levels;
            if (e.length > 1) {
              js.setFromMatrixPosition(t.matrixWorld),
                qs.setFromMatrixPosition(this.matrixWorld);
              const n = js.distanceTo(qs) / t.zoom;
              let i, r;
              for (
                e[0].object.visible = !0, i = 1, r = e.length;
                i < r && n >= e[i].distance;
                i++
              )
                (e[i - 1].object.visible = !1), (e[i].object.visible = !0);
              for (this._currentLevel = i - 1; i < r; i++)
                e[i].object.visible = !1;
            }
          }
          toJSON(t) {
            const e = super.toJSON(t);
            !1 === this.autoUpdate && (e.object.autoUpdate = !1),
              (e.object.levels = []);
            const n = this.levels;
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              e.object.levels.push({
                object: i.object.uuid,
                distance: i.distance,
              });
            }
            return e;
          }
        }
        const Ys = new Lt(),
          Zs = new St(),
          Js = new St(),
          Qs = new Lt(),
          Ks = new se();
        class $s extends Wn {
          constructor(t, e) {
            super(t, e),
              (this.type = "SkinnedMesh"),
              (this.bindMode = "attached"),
              (this.bindMatrix = new se()),
              (this.bindMatrixInverse = new se());
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bindMode = t.bindMode),
              this.bindMatrix.copy(t.bindMatrix),
              this.bindMatrixInverse.copy(t.bindMatrixInverse),
              (this.skeleton = t.skeleton),
              this
            );
          }
          bind(t, e) {
            (this.skeleton = t),
              void 0 === e &&
                (this.updateMatrixWorld(!0),
                this.skeleton.calculateInverses(),
                (e = this.matrixWorld)),
              this.bindMatrix.copy(e),
              this.bindMatrixInverse.copy(e).invert();
          }
          pose() {
            this.skeleton.pose();
          }
          normalizeSkinWeights() {
            const t = new St(),
              e = this.geometry.attributes.skinWeight;
            for (let n = 0, i = e.count; n < i; n++) {
              (t.x = e.getX(n)),
                (t.y = e.getY(n)),
                (t.z = e.getZ(n)),
                (t.w = e.getW(n));
              const i = 1 / t.manhattanLength();
              i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0),
                e.setXYZW(n, t.x, t.y, t.z, t.w);
            }
          }
          updateMatrixWorld(t) {
            super.updateMatrixWorld(t),
              "attached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
                : "detached" === this.bindMode
                ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
                : console.warn(
                    "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                  );
          }
          boneTransform(t, e) {
            const n = this.skeleton,
              i = this.geometry;
            Zs.fromBufferAttribute(i.attributes.skinIndex, t),
              Js.fromBufferAttribute(i.attributes.skinWeight, t),
              Ys.fromBufferAttribute(i.attributes.position, t).applyMatrix4(
                this.bindMatrix
              ),
              e.set(0, 0, 0);
            for (let t = 0; t < 4; t++) {
              const i = Js.getComponent(t);
              if (0 !== i) {
                const r = Zs.getComponent(t);
                Ks.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                  e.addScaledVector(Qs.copy(Ys).applyMatrix4(Ks), i);
              }
            }
            return e.applyMatrix4(this.bindMatrixInverse);
          }
        }
        $s.prototype.isSkinnedMesh = !0;
        class ta extends Ce {
          constructor() {
            super(), (this.type = "Bone");
          }
        }
        ta.prototype.isBone = !0;
        const ea = new se(),
          na = new se();
        class ia {
          constructor(t = [], e = []) {
            (this.uuid = ct()),
              (this.bones = t.slice(0)),
              (this.boneInverses = e),
              (this.boneMatrices = null),
              (this.boneTexture = null),
              (this.boneTextureSize = 0),
              (this.frame = -1),
              this.init();
          }
          init() {
            const t = this.bones,
              e = this.boneInverses;
            if (
              ((this.boneMatrices = new Float32Array(16 * t.length)),
              0 === e.length)
            )
              this.calculateInverses();
            else if (t.length !== e.length) {
              console.warn(
                "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
              ),
                (this.boneInverses = []);
              for (let t = 0, e = this.bones.length; t < e; t++)
                this.boneInverses.push(new se());
            }
          }
          calculateInverses() {
            this.boneInverses.length = 0;
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = new se();
              this.bones[t] && e.copy(this.bones[t].matrixWorld).invert(),
                this.boneInverses.push(e);
            }
          }
          pose() {
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e && e.matrixWorld.copy(this.boneInverses[t]).invert();
            }
            for (let t = 0, e = this.bones.length; t < e; t++) {
              const e = this.bones[t];
              e &&
                (e.parent && e.parent.isBone
                  ? (e.matrix.copy(e.parent.matrixWorld).invert(),
                    e.matrix.multiply(e.matrixWorld))
                  : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale));
            }
          }
          update() {
            const t = this.bones,
              e = this.boneInverses,
              n = this.boneMatrices,
              i = this.boneTexture;
            for (let i = 0, r = t.length; i < r; i++) {
              const r = t[i] ? t[i].matrixWorld : na;
              ea.multiplyMatrices(r, e[i]), ea.toArray(n, 16 * i);
            }
            null !== i && (i.needsUpdate = !0);
          }
          clone() {
            return new ia(this.bones, this.boneInverses);
          }
          getBoneByName(t) {
            for (let e = 0, n = this.bones.length; e < n; e++) {
              const n = this.bones[e];
              if (n.name === t) return n;
            }
          }
          dispose() {
            null !== this.boneTexture &&
              (this.boneTexture.dispose(), (this.boneTexture = null));
          }
          fromJSON(t, e) {
            this.uuid = t.uuid;
            for (let n = 0, i = t.bones.length; n < i; n++) {
              const i = t.bones[n];
              let r = e[i];
              void 0 === r &&
                (console.warn("THREE.Skeleton: No bone found with UUID:", i),
                (r = new ta())),
                this.bones.push(r),
                this.boneInverses.push(new se().fromArray(t.boneInverses[n]));
            }
            return this.init(), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "Skeleton",
                generator: "Skeleton.toJSON",
              },
              bones: [],
              boneInverses: [],
            };
            t.uuid = this.uuid;
            const e = this.bones,
              n = this.boneInverses;
            for (let i = 0, r = e.length; i < r; i++) {
              const r = e[i];
              t.bones.push(r.uuid);
              const s = n[i];
              t.boneInverses.push(s.toArray());
            }
            return t;
          }
        }
        const ra = new se(),
          sa = new se(),
          aa = [],
          oa = new Wn();
        class la extends Wn {
          constructor(t, e, n) {
            super(t, e),
              (this.instanceMatrix = new sn(new Float32Array(16 * n), 16)),
              (this.instanceColor = null),
              (this.count = n),
              (this.frustumCulled = !1);
          }
          copy(t) {
            return (
              super.copy(t),
              this.instanceMatrix.copy(t.instanceMatrix),
              null !== t.instanceColor &&
                (this.instanceColor = t.instanceColor.clone()),
              (this.count = t.count),
              this
            );
          }
          getColorAt(t, e) {
            e.fromArray(this.instanceColor.array, 3 * t);
          }
          getMatrixAt(t, e) {
            e.fromArray(this.instanceMatrix.array, 16 * t);
          }
          raycast(t, e) {
            const n = this.matrixWorld,
              i = this.count;
            if (
              ((oa.geometry = this.geometry),
              (oa.material = this.material),
              void 0 !== oa.material)
            )
              for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, ra),
                  sa.multiplyMatrices(n, ra),
                  (oa.matrixWorld = sa),
                  oa.raycast(t, aa);
                for (let t = 0, n = aa.length; t < n; t++) {
                  const n = aa[t];
                  (n.instanceId = r), (n.object = this), e.push(n);
                }
                aa.length = 0;
              }
          }
          setColorAt(t, e) {
            null === this.instanceColor &&
              (this.instanceColor = new sn(
                new Float32Array(3 * this.count),
                3
              )),
              e.toArray(this.instanceColor.array, 3 * t);
          }
          setMatrixAt(t, e) {
            e.toArray(this.instanceMatrix.array, 16 * t);
          }
          updateMorphTargets() {}
          dispose() {
            this.dispatchEvent({ type: "dispose" });
          }
        }
        la.prototype.isInstancedMesh = !0;
        class ca extends Xe {
          constructor(t) {
            super(),
              (this.type = "LineBasicMaterial"),
              (this.color = new tn(16777215)),
              (this.linewidth = 1),
              (this.linecap = "round"),
              (this.linejoin = "round"),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.linewidth = t.linewidth),
              (this.linecap = t.linecap),
              (this.linejoin = t.linejoin),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        ca.prototype.isLineBasicMaterial = !0;
        const ha = new Lt(),
          ua = new Lt(),
          da = new se(),
          pa = new re(),
          ma = new Jt();
        class fa extends Ce {
          constructor(t = new En(), e = new ca()) {
            super(),
              (this.type = "Line"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [0];
                for (let t = 1, i = e.count; t < i; t++)
                  ha.fromBufferAttribute(e, t - 1),
                    ua.fromBufferAttribute(e, t),
                    (n[t] = n[t - 1]),
                    (n[t] += ha.distanceTo(ua));
                t.setAttribute("lineDistance", new mn(n, 1));
              } else
                console.warn(
                  "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else
              t.isGeometry &&
                console.error(
                  "THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            return this;
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Line.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              ma.copy(n.boundingSphere),
              ma.applyMatrix4(i),
              (ma.radius += r),
              !1 === t.ray.intersectsSphere(ma))
            )
              return;
            da.copy(i).invert(), pa.copy(t.ray).applyMatrix4(da);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              l = new Lt(),
              c = new Lt(),
              h = new Lt(),
              u = new Lt(),
              d = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              const i = n.index,
                r = n.attributes.position;
              if (null !== i) {
                for (
                  let n = Math.max(0, s.start),
                    a = Math.min(i.count, s.start + s.count) - 1;
                  n < a;
                  n += d
                ) {
                  const s = i.getX(n),
                    a = i.getX(n + 1);
                  l.fromBufferAttribute(r, s), c.fromBufferAttribute(r, a);
                  if (pa.distanceSqToSegment(l, c, u, h) > o) continue;
                  u.applyMatrix4(this.matrixWorld);
                  const d = t.ray.origin.distanceTo(u);
                  d < t.near ||
                    d > t.far ||
                    e.push({
                      distance: d,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              } else {
                for (
                  let n = Math.max(0, s.start),
                    i = Math.min(r.count, s.start + s.count) - 1;
                  n < i;
                  n += d
                ) {
                  l.fromBufferAttribute(r, n), c.fromBufferAttribute(r, n + 1);
                  if (pa.distanceSqToSegment(l, c, u, h) > o) continue;
                  u.applyMatrix4(this.matrixWorld);
                  const i = t.ray.origin.distanceTo(u);
                  i < t.near ||
                    i > t.far ||
                    e.push({
                      distance: i,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: n,
                      face: null,
                      faceIndex: null,
                      object: this,
                    });
                }
              }
            } else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
        }
        fa.prototype.isLine = !0;
        const ga = new Lt(),
          va = new Lt();
        class ya extends fa {
          constructor(t, e) {
            super(t, e), (this.type = "LineSegments");
          }
          computeLineDistances() {
            const t = this.geometry;
            if (t.isBufferGeometry)
              if (null === t.index) {
                const e = t.attributes.position,
                  n = [];
                for (let t = 0, i = e.count; t < i; t += 2)
                  ga.fromBufferAttribute(e, t),
                    va.fromBufferAttribute(e, t + 1),
                    (n[t] = 0 === t ? 0 : n[t - 1]),
                    (n[t + 1] = n[t] + ga.distanceTo(va));
                t.setAttribute("lineDistance", new mn(n, 1));
              } else
                console.warn(
                  "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
                );
            else
              t.isGeometry &&
                console.error(
                  "THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            return this;
          }
        }
        ya.prototype.isLineSegments = !0;
        class xa extends fa {
          constructor(t, e) {
            super(t, e), (this.type = "LineLoop");
          }
        }
        xa.prototype.isLineLoop = !0;
        class _a extends Xe {
          constructor(t) {
            super(),
              (this.type = "PointsMaterial"),
              (this.color = new tn(16777215)),
              (this.map = null),
              (this.alphaMap = null),
              (this.size = 1),
              (this.sizeAttenuation = !0),
              (this.morphTargets = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.alphaMap = t.alphaMap),
              (this.size = t.size),
              (this.sizeAttenuation = t.sizeAttenuation),
              (this.morphTargets = t.morphTargets),
              this
            );
          }
        }
        _a.prototype.isPointsMaterial = !0;
        const wa = new se(),
          ba = new re(),
          Ma = new Jt(),
          Sa = new Lt();
        class Ta extends Ce {
          constructor(t = new En(), e = new _a()) {
            super(),
              (this.type = "Points"),
              (this.geometry = t),
              (this.material = e),
              this.updateMorphTargets();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.material = t.material),
              (this.geometry = t.geometry),
              this
            );
          }
          raycast(t, e) {
            const n = this.geometry,
              i = this.matrixWorld,
              r = t.params.Points.threshold,
              s = n.drawRange;
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              Ma.copy(n.boundingSphere),
              Ma.applyMatrix4(i),
              (Ma.radius += r),
              !1 === t.ray.intersectsSphere(Ma))
            )
              return;
            wa.copy(i).invert(), ba.copy(t.ray).applyMatrix4(wa);
            const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a;
            if (n.isBufferGeometry) {
              const r = n.index,
                a = n.attributes.position;
              if (null !== r) {
                for (
                  let n = Math.max(0, s.start),
                    l = Math.min(r.count, s.start + s.count);
                  n < l;
                  n++
                ) {
                  const s = r.getX(n);
                  Sa.fromBufferAttribute(a, s), Ea(Sa, s, o, i, t, e, this);
                }
              } else {
                for (
                  let n = Math.max(0, s.start),
                    r = Math.min(a.count, s.start + s.count);
                  n < r;
                  n++
                )
                  Sa.fromBufferAttribute(a, n), Ea(Sa, n, o, i, t, e, this);
              }
            } else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
          }
          updateMorphTargets() {
            const t = this.geometry;
            if (t.isBufferGeometry) {
              const e = t.morphAttributes,
                n = Object.keys(e);
              if (n.length > 0) {
                const t = e[n[0]];
                if (void 0 !== t) {
                  (this.morphTargetInfluences = []),
                    (this.morphTargetDictionary = {});
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e].name || String(e);
                    this.morphTargetInfluences.push(0),
                      (this.morphTargetDictionary[n] = e);
                  }
                }
              }
            } else {
              const e = t.morphTargets;
              void 0 !== e &&
                e.length > 0 &&
                console.error(
                  "THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead."
                );
            }
          }
        }
        function Ea(t, e, n, i, r, s, a) {
          const o = ba.distanceSqToPoint(t);
          if (o < n) {
            const n = new Lt();
            ba.closestPointToPoint(t, n), n.applyMatrix4(i);
            const l = r.ray.origin.distanceTo(n);
            if (l < r.near || l > r.far) return;
            s.push({
              distance: l,
              distanceToRay: Math.sqrt(o),
              point: n,
              index: e,
              face: null,
              object: a,
            });
          }
        }
        Ta.prototype.isPoints = !0;
        class Aa extends bt {
          constructor(t, e, n, i, r, s, a, o, l) {
            super(t, e, n, i, r, s, a, o, l),
              (this.format = void 0 !== a ? a : T),
              (this.minFilter = void 0 !== s ? s : g),
              (this.magFilter = void 0 !== r ? r : g),
              (this.generateMipmaps = !1);
            const c = this;
            "requestVideoFrameCallback" in t &&
              t.requestVideoFrameCallback(function e() {
                (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
              });
          }
          clone() {
            return new this.constructor(this.image).copy(this);
          }
          update() {
            const t = this.image;
            !1 === "requestVideoFrameCallback" in t &&
              t.readyState >= t.HAVE_CURRENT_DATA &&
              (this.needsUpdate = !0);
          }
        }
        Aa.prototype.isVideoTexture = !0;
        class La extends bt {
          constructor(t, e, n, i, r, s, a, o, l, c, h, u) {
            super(null, s, a, o, l, c, i, r, h, u),
              (this.image = { width: e, height: n }),
              (this.mipmaps = t),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        La.prototype.isCompressedTexture = !0;
        class Ra extends bt {
          constructor(t, e, n, i, r, s, a, o, l) {
            super(t, e, n, i, r, s, a, o, l), (this.needsUpdate = !0);
          }
        }
        Ra.prototype.isCanvasTexture = !0;
        class Ca extends bt {
          constructor(t, e, n, i, r, s, a, o, l, c) {
            if ((c = void 0 !== c ? c : A) !== A && c !== L)
              throw new Error(
                "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
              );
            void 0 === n && c === A && (n = _),
              void 0 === n && c === L && (n = S),
              super(null, i, r, s, a, o, c, n, l),
              (this.image = { width: t, height: e }),
              (this.magFilter = void 0 !== a ? a : p),
              (this.minFilter = void 0 !== o ? o : p),
              (this.flipY = !1),
              (this.generateMipmaps = !1);
          }
        }
        Ca.prototype.isDepthTexture = !0;
        class Pa extends En {
          constructor(t = 1, e = 8, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = "CircleGeometry"),
              (this.parameters = {
                radius: t,
                segments: e,
                thetaStart: n,
                thetaLength: i,
              }),
              (e = Math.max(3, e));
            const r = [],
              s = [],
              a = [],
              o = [],
              l = new Lt(),
              c = new vt();
            s.push(0, 0, 0), a.push(0, 0, 1), o.push(0.5, 0.5);
            for (let r = 0, h = 3; r <= e; r++, h += 3) {
              const u = n + (r / e) * i;
              (l.x = t * Math.cos(u)),
                (l.y = t * Math.sin(u)),
                s.push(l.x, l.y, l.z),
                a.push(0, 0, 1),
                (c.x = (s[h] / t + 1) / 2),
                (c.y = (s[h + 1] / t + 1) / 2),
                o.push(c.x, c.y);
            }
            for (let t = 1; t <= e; t++) r.push(t, t + 1, 0);
            this.setIndex(r),
              this.setAttribute("position", new mn(s, 3)),
              this.setAttribute("normal", new mn(a, 3)),
              this.setAttribute("uv", new mn(o, 2));
          }
        }
        class Da extends En {
          constructor(
            t = 1,
            e = 1,
            n = 1,
            i = 8,
            r = 1,
            s = !1,
            a = 0,
            o = 2 * Math.PI
          ) {
            super(),
              (this.type = "CylinderGeometry"),
              (this.parameters = {
                radiusTop: t,
                radiusBottom: e,
                height: n,
                radialSegments: i,
                heightSegments: r,
                openEnded: s,
                thetaStart: a,
                thetaLength: o,
              });
            const l = this;
            (i = Math.floor(i)), (r = Math.floor(r));
            const c = [],
              h = [],
              u = [],
              d = [];
            let p = 0;
            const m = [],
              f = n / 2;
            let g = 0;
            function v(n) {
              const r = p,
                s = new vt(),
                m = new Lt();
              let v = 0;
              const y = !0 === n ? t : e,
                x = !0 === n ? 1 : -1;
              for (let t = 1; t <= i; t++)
                h.push(0, f * x, 0), u.push(0, x, 0), d.push(0.5, 0.5), p++;
              const _ = p;
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * o + a,
                  n = Math.cos(e),
                  r = Math.sin(e);
                (m.x = y * r),
                  (m.y = f * x),
                  (m.z = y * n),
                  h.push(m.x, m.y, m.z),
                  u.push(0, x, 0),
                  (s.x = 0.5 * n + 0.5),
                  (s.y = 0.5 * r * x + 0.5),
                  d.push(s.x, s.y),
                  p++;
              }
              for (let t = 0; t < i; t++) {
                const e = r + t,
                  i = _ + t;
                !0 === n ? c.push(i, i + 1, e) : c.push(i + 1, i, e), (v += 3);
              }
              l.addGroup(g, v, !0 === n ? 1 : 2), (g += v);
            }
            !(function () {
              const s = new Lt(),
                v = new Lt();
              let y = 0;
              const x = (e - t) / n;
              for (let l = 0; l <= r; l++) {
                const c = [],
                  g = l / r,
                  y = g * (e - t) + t;
                for (let t = 0; t <= i; t++) {
                  const e = t / i,
                    r = e * o + a,
                    l = Math.sin(r),
                    m = Math.cos(r);
                  (v.x = y * l),
                    (v.y = -g * n + f),
                    (v.z = y * m),
                    h.push(v.x, v.y, v.z),
                    s.set(l, x, m).normalize(),
                    u.push(s.x, s.y, s.z),
                    d.push(e, 1 - g),
                    c.push(p++);
                }
                m.push(c);
              }
              for (let t = 0; t < i; t++)
                for (let e = 0; e < r; e++) {
                  const n = m[e][t],
                    i = m[e + 1][t],
                    r = m[e + 1][t + 1],
                    s = m[e][t + 1];
                  c.push(n, i, s), c.push(i, r, s), (y += 6);
                }
              l.addGroup(g, y, 0), (g += y);
            })(),
              !1 === s && (t > 0 && v(!0), e > 0 && v(!1)),
              this.setIndex(c),
              this.setAttribute("position", new mn(h, 3)),
              this.setAttribute("normal", new mn(u, 3)),
              this.setAttribute("uv", new mn(d, 2));
          }
        }
        class Ia extends Da {
          constructor(
            t = 1,
            e = 1,
            n = 8,
            i = 1,
            r = !1,
            s = 0,
            a = 2 * Math.PI
          ) {
            super(0, t, e, n, i, r, s, a),
              (this.type = "ConeGeometry"),
              (this.parameters = {
                radius: t,
                height: e,
                radialSegments: n,
                heightSegments: i,
                openEnded: r,
                thetaStart: s,
                thetaLength: a,
              });
          }
        }
        class Na extends En {
          constructor(t, e, n = 1, i = 0) {
            super(),
              (this.type = "PolyhedronGeometry"),
              (this.parameters = {
                vertices: t,
                indices: e,
                radius: n,
                detail: i,
              });
            const r = [],
              s = [];
            function a(t, e, n, i) {
              const r = i + 1,
                s = [];
              for (let i = 0; i <= r; i++) {
                s[i] = [];
                const a = t.clone().lerp(n, i / r),
                  o = e.clone().lerp(n, i / r),
                  l = r - i;
                for (let t = 0; t <= l; t++)
                  s[i][t] = 0 === t && i === r ? a : a.clone().lerp(o, t / l);
              }
              for (let t = 0; t < r; t++)
                for (let e = 0; e < 2 * (r - t) - 1; e++) {
                  const n = Math.floor(e / 2);
                  e % 2 == 0
                    ? (o(s[t][n + 1]), o(s[t + 1][n]), o(s[t][n]))
                    : (o(s[t][n + 1]), o(s[t + 1][n + 1]), o(s[t + 1][n]));
                }
            }
            function o(t) {
              r.push(t.x, t.y, t.z);
            }
            function l(e, n) {
              const i = 3 * e;
              (n.x = t[i + 0]), (n.y = t[i + 1]), (n.z = t[i + 2]);
            }
            function c(t, e, n, i) {
              i < 0 && 1 === t.x && (s[e] = t.x - 1),
                0 === n.x && 0 === n.z && (s[e] = i / 2 / Math.PI + 0.5);
            }
            function h(t) {
              return Math.atan2(t.z, -t.x);
            }
            !(function (t) {
              const n = new Lt(),
                i = new Lt(),
                r = new Lt();
              for (let s = 0; s < e.length; s += 3)
                l(e[s + 0], n), l(e[s + 1], i), l(e[s + 2], r), a(n, i, r, t);
            })(i),
              (function (t) {
                const e = new Lt();
                for (let n = 0; n < r.length; n += 3)
                  (e.x = r[n + 0]),
                    (e.y = r[n + 1]),
                    (e.z = r[n + 2]),
                    e.normalize().multiplyScalar(t),
                    (r[n + 0] = e.x),
                    (r[n + 1] = e.y),
                    (r[n + 2] = e.z);
              })(n),
              (function () {
                const t = new Lt();
                for (let n = 0; n < r.length; n += 3) {
                  (t.x = r[n + 0]), (t.y = r[n + 1]), (t.z = r[n + 2]);
                  const i = h(t) / 2 / Math.PI + 0.5,
                    a =
                      ((e = t),
                      Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z)) /
                        Math.PI +
                        0.5);
                  s.push(i, 1 - a);
                }
                var e;
                (function () {
                  const t = new Lt(),
                    e = new Lt(),
                    n = new Lt(),
                    i = new Lt(),
                    a = new vt(),
                    o = new vt(),
                    l = new vt();
                  for (let u = 0, d = 0; u < r.length; u += 9, d += 6) {
                    t.set(r[u + 0], r[u + 1], r[u + 2]),
                      e.set(r[u + 3], r[u + 4], r[u + 5]),
                      n.set(r[u + 6], r[u + 7], r[u + 8]),
                      a.set(s[d + 0], s[d + 1]),
                      o.set(s[d + 2], s[d + 3]),
                      l.set(s[d + 4], s[d + 5]),
                      i.copy(t).add(e).add(n).divideScalar(3);
                    const p = h(i);
                    c(a, d + 0, t, p), c(o, d + 2, e, p), c(l, d + 4, n, p);
                  }
                })(),
                  (function () {
                    for (let t = 0; t < s.length; t += 6) {
                      const e = s[t + 0],
                        n = s[t + 2],
                        i = s[t + 4],
                        r = Math.max(e, n, i),
                        a = Math.min(e, n, i);
                      r > 0.9 &&
                        a < 0.1 &&
                        (e < 0.2 && (s[t + 0] += 1),
                        n < 0.2 && (s[t + 2] += 1),
                        i < 0.2 && (s[t + 4] += 1));
                    }
                  })();
              })(),
              this.setAttribute("position", new mn(r, 3)),
              this.setAttribute("normal", new mn(r.slice(), 3)),
              this.setAttribute("uv", new mn(s, 2)),
              0 === i ? this.computeVertexNormals() : this.normalizeNormals();
          }
        }
        class Ba extends Na {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2,
              i = 1 / n;
            super(
              [
                -1,
                -1,
                -1,
                -1,
                -1,
                1,
                -1,
                1,
                -1,
                -1,
                1,
                1,
                1,
                -1,
                -1,
                1,
                -1,
                1,
                1,
                1,
                -1,
                1,
                1,
                1,
                0,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                -i,
                -n,
                0,
                -i,
                n,
                0,
                i,
                -n,
                0,
                i,
                n,
                0,
                -n,
                0,
                -i,
                n,
                0,
                -i,
                -n,
                0,
                i,
                n,
                0,
                i,
              ],
              [
                3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15,
                17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0,
                12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2,
                16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4,
                14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19,
                5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9,
              ],
              t,
              e
            ),
              (this.type = "DodecahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        const za = new Lt(),
          Fa = new Lt(),
          Oa = new Lt(),
          Ha = new je();
        class Ga extends En {
          constructor(t, e) {
            if (
              (super(),
              (this.type = "EdgesGeometry"),
              (this.parameters = { thresholdAngle: e }),
              (e = void 0 !== e ? e : 1),
              !0 === t.isGeometry)
            )
              return void console.error(
                "THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
            const n = Math.pow(10, 4),
              i = Math.cos(ot * e),
              r = t.getIndex(),
              s = t.getAttribute("position"),
              a = r ? r.count : s.count,
              o = [0, 0, 0],
              l = ["a", "b", "c"],
              c = new Array(3),
              h = {},
              u = [];
            for (let t = 0; t < a; t += 3) {
              r
                ? ((o[0] = r.getX(t)),
                  (o[1] = r.getX(t + 1)),
                  (o[2] = r.getX(t + 2)))
                : ((o[0] = t), (o[1] = t + 1), (o[2] = t + 2));
              const { a: e, b: a, c: d } = Ha;
              if (
                (e.fromBufferAttribute(s, o[0]),
                a.fromBufferAttribute(s, o[1]),
                d.fromBufferAttribute(s, o[2]),
                Ha.getNormal(Oa),
                (c[0] = `${Math.round(e.x * n)},${Math.round(
                  e.y * n
                )},${Math.round(e.z * n)}`),
                (c[1] = `${Math.round(a.x * n)},${Math.round(
                  a.y * n
                )},${Math.round(a.z * n)}`),
                (c[2] = `${Math.round(d.x * n)},${Math.round(
                  d.y * n
                )},${Math.round(d.z * n)}`),
                c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
              )
                for (let t = 0; t < 3; t++) {
                  const e = (t + 1) % 3,
                    n = c[t],
                    r = c[e],
                    s = Ha[l[t]],
                    a = Ha[l[e]],
                    d = `${n}_${r}`,
                    p = `${r}_${n}`;
                  p in h && h[p]
                    ? (Oa.dot(h[p].normal) <= i &&
                        (u.push(s.x, s.y, s.z), u.push(a.x, a.y, a.z)),
                      (h[p] = null))
                    : d in h ||
                      (h[d] = {
                        index0: o[t],
                        index1: o[e],
                        normal: Oa.clone(),
                      });
                }
            }
            for (const t in h)
              if (h[t]) {
                const { index0: e, index1: n } = h[t];
                za.fromBufferAttribute(s, e),
                  Fa.fromBufferAttribute(s, n),
                  u.push(za.x, za.y, za.z),
                  u.push(Fa.x, Fa.y, Fa.z);
              }
            this.setAttribute("position", new mn(u, 3));
          }
        }
        const Ua = function (t, e, n) {
          n = n || 2;
          const i = e && e.length,
            r = i ? e[0] * n : t.length;
          let s = ka(t, 0, r, n, !0);
          const a = [];
          if (!s || s.next === s.prev) return a;
          let o, l, c, h, u, d, p;
          if (
            (i &&
              (s = (function (t, e, n, i) {
                const r = [];
                let s, a, o, l, c;
                for (s = 0, a = e.length; s < a; s++)
                  (o = e[s] * i),
                    (l = s < a - 1 ? e[s + 1] * i : t.length),
                    (c = ka(t, o, l, i, !1)),
                    c === c.next && (c.steiner = !0),
                    r.push($a(c));
                for (r.sort(Za), s = 0; s < r.length; s++)
                  Ja(r[s], n), (n = Va(n, n.next));
                return n;
              })(t, e, s, n)),
            t.length > 80 * n)
          ) {
            (o = c = t[0]), (l = h = t[1]);
            for (let e = n; e < r; e += n)
              (u = t[e]),
                (d = t[e + 1]),
                u < o && (o = u),
                d < l && (l = d),
                u > c && (c = u),
                d > h && (h = d);
            (p = Math.max(c - o, h - l)), (p = 0 !== p ? 1 / p : 0);
          }
          return Wa(s, a, n, o, l, p), a;
        };
        function ka(t, e, n, i, r) {
          let s, a;
          if (
            r ===
            (function (t, e, n, i) {
              let r = 0;
              for (let s = e, a = n - i; s < n; s += i)
                (r += (t[a] - t[s]) * (t[s + 1] + t[a + 1])), (a = s);
              return r;
            })(t, e, n, i) >
              0
          )
            for (s = e; s < n; s += i) a = co(s, t[s], t[s + 1], a);
          else for (s = n - i; s >= e; s -= i) a = co(s, t[s], t[s + 1], a);
          return a && io(a, a.next) && (ho(a), (a = a.next)), a;
        }
        function Va(t, e) {
          if (!t) return t;
          e || (e = t);
          let n,
            i = t;
          do {
            if (
              ((n = !1),
              i.steiner || (!io(i, i.next) && 0 !== no(i.prev, i, i.next)))
            )
              i = i.next;
            else {
              if ((ho(i), (i = e = i.prev), i === i.next)) break;
              n = !0;
            }
          } while (n || i !== e);
          return e;
        }
        function Wa(t, e, n, i, r, s, a) {
          if (!t) return;
          !a &&
            s &&
            (function (t, e, n, i) {
              let r = t;
              do {
                null === r.z && (r.z = Ka(r.x, r.y, e, n, i)),
                  (r.prevZ = r.prev),
                  (r.nextZ = r.next),
                  (r = r.next);
              } while (r !== t);
              (r.prevZ.nextZ = null),
                (r.prevZ = null),
                (function (t) {
                  let e,
                    n,
                    i,
                    r,
                    s,
                    a,
                    o,
                    l,
                    c = 1;
                  do {
                    for (n = t, t = null, s = null, a = 0; n; ) {
                      for (
                        a++, i = n, o = 0, e = 0;
                        e < c && (o++, (i = i.nextZ), i);
                        e++
                      );
                      for (l = c; o > 0 || (l > 0 && i); )
                        0 !== o && (0 === l || !i || n.z <= i.z)
                          ? ((r = n), (n = n.nextZ), o--)
                          : ((r = i), (i = i.nextZ), l--),
                          s ? (s.nextZ = r) : (t = r),
                          (r.prevZ = s),
                          (s = r);
                      n = i;
                    }
                    (s.nextZ = null), (c *= 2);
                  } while (a > 1);
                })(r);
            })(t, i, r, s);
          let o,
            l,
            c = t;
          for (; t.prev !== t.next; )
            if (((o = t.prev), (l = t.next), s ? qa(t, i, r, s) : ja(t)))
              e.push(o.i / n),
                e.push(t.i / n),
                e.push(l.i / n),
                ho(t),
                (t = l.next),
                (c = l.next);
            else if ((t = l) === c) {
              a
                ? 1 === a
                  ? Wa((t = Xa(Va(t), e, n)), e, n, i, r, s, 2)
                  : 2 === a && Ya(t, e, n, i, r, s)
                : Wa(Va(t), e, n, i, r, s, 1);
              break;
            }
        }
        function ja(t) {
          const e = t.prev,
            n = t,
            i = t.next;
          if (no(e, n, i) >= 0) return !1;
          let r = t.next.next;
          for (; r !== t.prev; ) {
            if (
              to(e.x, e.y, n.x, n.y, i.x, i.y, r.x, r.y) &&
              no(r.prev, r, r.next) >= 0
            )
              return !1;
            r = r.next;
          }
          return !0;
        }
        function qa(t, e, n, i) {
          const r = t.prev,
            s = t,
            a = t.next;
          if (no(r, s, a) >= 0) return !1;
          const o = r.x < s.x ? (r.x < a.x ? r.x : a.x) : s.x < a.x ? s.x : a.x,
            l = r.y < s.y ? (r.y < a.y ? r.y : a.y) : s.y < a.y ? s.y : a.y,
            c = r.x > s.x ? (r.x > a.x ? r.x : a.x) : s.x > a.x ? s.x : a.x,
            h = r.y > s.y ? (r.y > a.y ? r.y : a.y) : s.y > a.y ? s.y : a.y,
            u = Ka(o, l, e, n, i),
            d = Ka(c, h, e, n, i);
          let p = t.prevZ,
            m = t.nextZ;
          for (; p && p.z >= u && m && m.z <= d; ) {
            if (
              p !== t.prev &&
              p !== t.next &&
              to(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
              no(p.prev, p, p.next) >= 0
            )
              return !1;
            if (
              ((p = p.prevZ),
              m !== t.prev &&
                m !== t.next &&
                to(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
                no(m.prev, m, m.next) >= 0)
            )
              return !1;
            m = m.nextZ;
          }
          for (; p && p.z >= u; ) {
            if (
              p !== t.prev &&
              p !== t.next &&
              to(r.x, r.y, s.x, s.y, a.x, a.y, p.x, p.y) &&
              no(p.prev, p, p.next) >= 0
            )
              return !1;
            p = p.prevZ;
          }
          for (; m && m.z <= d; ) {
            if (
              m !== t.prev &&
              m !== t.next &&
              to(r.x, r.y, s.x, s.y, a.x, a.y, m.x, m.y) &&
              no(m.prev, m, m.next) >= 0
            )
              return !1;
            m = m.nextZ;
          }
          return !0;
        }
        function Xa(t, e, n) {
          let i = t;
          do {
            const r = i.prev,
              s = i.next.next;
            !io(r, s) &&
              ro(r, i, i.next, s) &&
              oo(r, s) &&
              oo(s, r) &&
              (e.push(r.i / n),
              e.push(i.i / n),
              e.push(s.i / n),
              ho(i),
              ho(i.next),
              (i = t = s)),
              (i = i.next);
          } while (i !== t);
          return Va(i);
        }
        function Ya(t, e, n, i, r, s) {
          let a = t;
          do {
            let t = a.next.next;
            for (; t !== a.prev; ) {
              if (a.i !== t.i && eo(a, t)) {
                let o = lo(a, t);
                return (
                  (a = Va(a, a.next)),
                  (o = Va(o, o.next)),
                  Wa(a, e, n, i, r, s),
                  void Wa(o, e, n, i, r, s)
                );
              }
              t = t.next;
            }
            a = a.next;
          } while (a !== t);
        }
        function Za(t, e) {
          return t.x - e.x;
        }
        function Ja(t, e) {
          if (
            (e = (function (t, e) {
              let n = e;
              const i = t.x,
                r = t.y;
              let s,
                a = -1 / 0;
              do {
                if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
                  const t =
                    n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
                  if (t <= i && t > a) {
                    if (((a = t), t === i)) {
                      if (r === n.y) return n;
                      if (r === n.next.y) return n.next;
                    }
                    s = n.x < n.next.x ? n : n.next;
                  }
                }
                n = n.next;
              } while (n !== e);
              if (!s) return null;
              if (i === a) return s;
              const o = s,
                l = s.x,
                c = s.y;
              let h,
                u = 1 / 0;
              n = s;
              do {
                i >= n.x &&
                  n.x >= l &&
                  i !== n.x &&
                  to(r < c ? i : a, r, l, c, r < c ? a : i, r, n.x, n.y) &&
                  ((h = Math.abs(r - n.y) / (i - n.x)),
                  oo(n, t) &&
                    (h < u ||
                      (h === u && (n.x > s.x || (n.x === s.x && Qa(s, n))))) &&
                    ((s = n), (u = h))),
                  (n = n.next);
              } while (n !== o);
              return s;
            })(t, e))
          ) {
            const n = lo(e, t);
            Va(e, e.next), Va(n, n.next);
          }
        }
        function Qa(t, e) {
          return no(t.prev, t, e.prev) < 0 && no(e.next, t, t.next) < 0;
        }
        function Ka(t, e, n, i, r) {
          return (
            (t =
              1431655765 &
              ((t =
                858993459 &
                ((t =
                  252645135 &
                  ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
                    (t << 4))) |
                  (t << 2))) |
                (t << 1))) |
            ((e =
              1431655765 &
              ((e =
                858993459 &
                ((e =
                  252645135 &
                  ((e = 16711935 & ((e = 32767 * (e - i) * r) | (e << 8))) |
                    (e << 4))) |
                  (e << 2))) |
                (e << 1))) <<
              1)
          );
        }
        function $a(t) {
          let e = t,
            n = t;
          do {
            (e.x < n.x || (e.x === n.x && e.y < n.y)) && (n = e), (e = e.next);
          } while (e !== t);
          return n;
        }
        function to(t, e, n, i, r, s, a, o) {
          return (
            (r - a) * (e - o) - (t - a) * (s - o) >= 0 &&
            (t - a) * (i - o) - (n - a) * (e - o) >= 0 &&
            (n - a) * (s - o) - (r - a) * (i - o) >= 0
          );
        }
        function eo(t, e) {
          return (
            t.next.i !== e.i &&
            t.prev.i !== e.i &&
            !(function (t, e) {
              let n = t;
              do {
                if (
                  n.i !== t.i &&
                  n.next.i !== t.i &&
                  n.i !== e.i &&
                  n.next.i !== e.i &&
                  ro(n, n.next, t, e)
                )
                  return !0;
                n = n.next;
              } while (n !== t);
              return !1;
            })(t, e) &&
            ((oo(t, e) &&
              oo(e, t) &&
              (function (t, e) {
                let n = t,
                  i = !1;
                const r = (t.x + e.x) / 2,
                  s = (t.y + e.y) / 2;
                do {
                  n.y > s != n.next.y > s &&
                    n.next.y !== n.y &&
                    r <
                      ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                    (i = !i),
                    (n = n.next);
                } while (n !== t);
                return i;
              })(t, e) &&
              (no(t.prev, t, e.prev) || no(t, e.prev, e))) ||
              (io(t, e) &&
                no(t.prev, t, t.next) > 0 &&
                no(e.prev, e, e.next) > 0))
          );
        }
        function no(t, e, n) {
          return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y);
        }
        function io(t, e) {
          return t.x === e.x && t.y === e.y;
        }
        function ro(t, e, n, i) {
          const r = ao(no(t, e, n)),
            s = ao(no(t, e, i)),
            a = ao(no(n, i, t)),
            o = ao(no(n, i, e));
          return (
            (r !== s && a !== o) ||
            !(0 !== r || !so(t, n, e)) ||
            !(0 !== s || !so(t, i, e)) ||
            !(0 !== a || !so(n, t, i)) ||
            !(0 !== o || !so(n, e, i))
          );
        }
        function so(t, e, n) {
          return (
            e.x <= Math.max(t.x, n.x) &&
            e.x >= Math.min(t.x, n.x) &&
            e.y <= Math.max(t.y, n.y) &&
            e.y >= Math.min(t.y, n.y)
          );
        }
        function ao(t) {
          return t > 0 ? 1 : t < 0 ? -1 : 0;
        }
        function oo(t, e) {
          return no(t.prev, t, t.next) < 0
            ? no(t, e, t.next) >= 0 && no(t, t.prev, e) >= 0
            : no(t, e, t.prev) < 0 || no(t, t.next, e) < 0;
        }
        function lo(t, e) {
          const n = new uo(t.i, t.x, t.y),
            i = new uo(e.i, e.x, e.y),
            r = t.next,
            s = e.prev;
          return (
            (t.next = e),
            (e.prev = t),
            (n.next = r),
            (r.prev = n),
            (i.next = n),
            (n.prev = i),
            (s.next = i),
            (i.prev = s),
            i
          );
        }
        function co(t, e, n, i) {
          const r = new uo(t, e, n);
          return (
            i
              ? ((r.next = i.next),
                (r.prev = i),
                (i.next.prev = r),
                (i.next = r))
              : ((r.prev = r), (r.next = r)),
            r
          );
        }
        function ho(t) {
          (t.next.prev = t.prev),
            (t.prev.next = t.next),
            t.prevZ && (t.prevZ.nextZ = t.nextZ),
            t.nextZ && (t.nextZ.prevZ = t.prevZ);
        }
        function uo(t, e, n) {
          (this.i = t),
            (this.x = e),
            (this.y = n),
            (this.prev = null),
            (this.next = null),
            (this.z = null),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1);
        }
        class po {
          static area(t) {
            const e = t.length;
            let n = 0;
            for (let i = e - 1, r = 0; r < e; i = r++)
              n += t[i].x * t[r].y - t[r].x * t[i].y;
            return 0.5 * n;
          }
          static isClockWise(t) {
            return po.area(t) < 0;
          }
          static triangulateShape(t, e) {
            const n = [],
              i = [],
              r = [];
            mo(t), fo(n, t);
            let s = t.length;
            e.forEach(mo);
            for (let t = 0; t < e.length; t++)
              i.push(s), (s += e[t].length), fo(n, e[t]);
            const a = Ua(n, i);
            for (let t = 0; t < a.length; t += 3) r.push(a.slice(t, t + 3));
            return r;
          }
        }
        function mo(t) {
          const e = t.length;
          e > 2 && t[e - 1].equals(t[0]) && t.pop();
        }
        function fo(t, e) {
          for (let n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y);
        }
        class go extends En {
          constructor(t, e) {
            super(),
              (this.type = "ExtrudeGeometry"),
              (this.parameters = { shapes: t, options: e }),
              (t = Array.isArray(t) ? t : [t]);
            const n = this,
              i = [],
              r = [];
            for (let e = 0, n = t.length; e < n; e++) {
              s(t[e]);
            }
            function s(t) {
              const s = [],
                a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                o = void 0 !== e.steps ? e.steps : 1;
              let l = void 0 !== e.depth ? e.depth : 100,
                c = void 0 === e.bevelEnabled || e.bevelEnabled,
                h = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                u = void 0 !== e.bevelSize ? e.bevelSize : h - 2,
                d = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                p = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
              const m = e.extrudePath,
                f = void 0 !== e.UVGenerator ? e.UVGenerator : vo;
              void 0 !== e.amount &&
                (console.warn(
                  "THREE.ExtrudeBufferGeometry: amount has been renamed to depth."
                ),
                (l = e.amount));
              let g,
                v,
                y,
                x,
                _,
                w = !1;
              m &&
                ((g = m.getSpacedPoints(o)),
                (w = !0),
                (c = !1),
                (v = m.computeFrenetFrames(o, !1)),
                (y = new Lt()),
                (x = new Lt()),
                (_ = new Lt())),
                c || ((p = 0), (h = 0), (u = 0), (d = 0));
              const b = t.extractPoints(a);
              let M = b.shape;
              const S = b.holes;
              if (!po.isClockWise(M)) {
                M = M.reverse();
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  po.isClockWise(e) && (S[t] = e.reverse());
                }
              }
              const T = po.triangulateShape(M, S),
                E = M;
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                M = M.concat(e);
              }
              function A(t, e, n) {
                return (
                  e ||
                    console.error("THREE.ExtrudeGeometry: vec does not exist"),
                  e.clone().multiplyScalar(n).add(t)
                );
              }
              const L = M.length,
                R = T.length;
              function C(t, e, n) {
                let i, r, s;
                const a = t.x - e.x,
                  o = t.y - e.y,
                  l = n.x - t.x,
                  c = n.y - t.y,
                  h = a * a + o * o,
                  u = a * c - o * l;
                if (Math.abs(u) > Number.EPSILON) {
                  const u = Math.sqrt(h),
                    d = Math.sqrt(l * l + c * c),
                    p = e.x - o / u,
                    m = e.y + a / u,
                    f =
                      ((n.x - c / d - p) * c - (n.y + l / d - m) * l) /
                      (a * c - o * l);
                  (i = p + a * f - t.x), (r = m + o * f - t.y);
                  const g = i * i + r * r;
                  if (g <= 2) return new vt(i, r);
                  s = Math.sqrt(g / 2);
                } else {
                  let t = !1;
                  a > Number.EPSILON
                    ? l > Number.EPSILON && (t = !0)
                    : a < -Number.EPSILON
                    ? l < -Number.EPSILON && (t = !0)
                    : Math.sign(o) === Math.sign(c) && (t = !0),
                    t
                      ? ((i = -o), (r = a), (s = Math.sqrt(h)))
                      : ((i = a), (r = o), (s = Math.sqrt(h / 2)));
                }
                return new vt(i / s, r / s);
              }
              const P = [];
              for (
                let t = 0, e = E.length, n = e - 1, i = t + 1;
                t < e;
                t++, n++, i++
              )
                n === e && (n = 0),
                  i === e && (i = 0),
                  (P[t] = C(E[t], E[n], E[i]));
              const D = [];
              let I,
                N = P.concat();
              for (let t = 0, e = S.length; t < e; t++) {
                const e = S[t];
                I = [];
                for (
                  let t = 0, n = e.length, i = n - 1, r = t + 1;
                  t < n;
                  t++, i++, r++
                )
                  i === n && (i = 0),
                    r === n && (r = 0),
                    (I[t] = C(e[t], e[i], e[r]));
                D.push(I), (N = N.concat(I));
              }
              for (let t = 0; t < p; t++) {
                const e = t / p,
                  n = h * Math.cos((e * Math.PI) / 2),
                  i = u * Math.sin((e * Math.PI) / 2) + d;
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = A(E[t], P[t], i);
                  F(e.x, e.y, -n);
                }
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  I = D[t];
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = A(e[t], I[t], i);
                    F(r.x, r.y, -n);
                  }
                }
              }
              const B = u + d;
              for (let t = 0; t < L; t++) {
                const e = c ? A(M[t], N[t], B) : M[t];
                w
                  ? (x.copy(v.normals[0]).multiplyScalar(e.x),
                    y.copy(v.binormals[0]).multiplyScalar(e.y),
                    _.copy(g[0]).add(x).add(y),
                    F(_.x, _.y, _.z))
                  : F(e.x, e.y, 0);
              }
              for (let t = 1; t <= o; t++)
                for (let e = 0; e < L; e++) {
                  const n = c ? A(M[e], N[e], B) : M[e];
                  w
                    ? (x.copy(v.normals[t]).multiplyScalar(n.x),
                      y.copy(v.binormals[t]).multiplyScalar(n.y),
                      _.copy(g[t]).add(x).add(y),
                      F(_.x, _.y, _.z))
                    : F(n.x, n.y, (l / o) * t);
                }
              for (let t = p - 1; t >= 0; t--) {
                const e = t / p,
                  n = h * Math.cos((e * Math.PI) / 2),
                  i = u * Math.sin((e * Math.PI) / 2) + d;
                for (let t = 0, e = E.length; t < e; t++) {
                  const e = A(E[t], P[t], i);
                  F(e.x, e.y, l + n);
                }
                for (let t = 0, e = S.length; t < e; t++) {
                  const e = S[t];
                  I = D[t];
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = A(e[t], I[t], i);
                    w
                      ? F(r.x, r.y + g[o - 1].y, g[o - 1].x + n)
                      : F(r.x, r.y, l + n);
                  }
                }
              }
              function z(t, e) {
                let n = t.length;
                for (; --n >= 0; ) {
                  const i = n;
                  let r = n - 1;
                  r < 0 && (r = t.length - 1);
                  for (let t = 0, n = o + 2 * p; t < n; t++) {
                    const n = L * t,
                      s = L * (t + 1);
                    H(e + i + n, e + r + n, e + r + s, e + i + s);
                  }
                }
              }
              function F(t, e, n) {
                s.push(t), s.push(e), s.push(n);
              }
              function O(t, e, r) {
                G(t), G(e), G(r);
                const s = i.length / 3,
                  a = f.generateTopUV(n, i, s - 3, s - 2, s - 1);
                U(a[0]), U(a[1]), U(a[2]);
              }
              function H(t, e, r, s) {
                G(t), G(e), G(s), G(e), G(r), G(s);
                const a = i.length / 3,
                  o = f.generateSideWallUV(n, i, a - 6, a - 3, a - 2, a - 1);
                U(o[0]), U(o[1]), U(o[3]), U(o[1]), U(o[2]), U(o[3]);
              }
              function G(t) {
                i.push(s[3 * t + 0]),
                  i.push(s[3 * t + 1]),
                  i.push(s[3 * t + 2]);
              }
              function U(t) {
                r.push(t.x), r.push(t.y);
              }
              !(function () {
                const t = i.length / 3;
                if (c) {
                  let t = 0,
                    e = L * t;
                  for (let t = 0; t < R; t++) {
                    const n = T[t];
                    O(n[2] + e, n[1] + e, n[0] + e);
                  }
                  (t = o + 2 * p), (e = L * t);
                  for (let t = 0; t < R; t++) {
                    const n = T[t];
                    O(n[0] + e, n[1] + e, n[2] + e);
                  }
                } else {
                  for (let t = 0; t < R; t++) {
                    const e = T[t];
                    O(e[2], e[1], e[0]);
                  }
                  for (let t = 0; t < R; t++) {
                    const e = T[t];
                    O(e[0] + L * o, e[1] + L * o, e[2] + L * o);
                  }
                }
                n.addGroup(t, i.length / 3 - t, 0);
              })(),
                (function () {
                  const t = i.length / 3;
                  let e = 0;
                  z(E, e), (e += E.length);
                  for (let t = 0, n = S.length; t < n; t++) {
                    const n = S[t];
                    z(n, e), (e += n.length);
                  }
                  n.addGroup(t, i.length / 3 - t, 1);
                })();
            }
            this.setAttribute("position", new mn(i, 3)),
              this.setAttribute("uv", new mn(r, 2)),
              this.computeVertexNormals();
          }
          toJSON() {
            const t = En.prototype.toJSON.call(this);
            return (function (t, e, n) {
              if (((n.shapes = []), Array.isArray(t)))
                for (let e = 0, i = t.length; e < i; e++) {
                  const i = t[e];
                  n.shapes.push(i.uuid);
                }
              else n.shapes.push(t.uuid);
              void 0 !== e.extrudePath &&
                (n.options.extrudePath = e.extrudePath.toJSON());
              return n;
            })(this.parameters.shapes, this.parameters.options, t);
          }
        }
        const vo = {
          generateTopUV: function (t, e, n, i, r) {
            const s = e[3 * n],
              a = e[3 * n + 1],
              o = e[3 * i],
              l = e[3 * i + 1],
              c = e[3 * r],
              h = e[3 * r + 1];
            return [new vt(s, a), new vt(o, l), new vt(c, h)];
          },
          generateSideWallUV: function (t, e, n, i, r, s) {
            const a = e[3 * n],
              o = e[3 * n + 1],
              l = e[3 * n + 2],
              c = e[3 * i],
              h = e[3 * i + 1],
              u = e[3 * i + 2],
              d = e[3 * r],
              p = e[3 * r + 1],
              m = e[3 * r + 2],
              f = e[3 * s],
              g = e[3 * s + 1],
              v = e[3 * s + 2];
            return Math.abs(o - h) < 0.01
              ? [
                  new vt(a, 1 - l),
                  new vt(c, 1 - u),
                  new vt(d, 1 - m),
                  new vt(f, 1 - v),
                ]
              : [
                  new vt(o, 1 - l),
                  new vt(h, 1 - u),
                  new vt(p, 1 - m),
                  new vt(g, 1 - v),
                ];
          },
        };
        class yo extends Na {
          constructor(t = 1, e = 0) {
            const n = (1 + Math.sqrt(5)) / 2;
            super(
              [
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                0,
                0,
                -1,
                n,
                0,
                1,
                n,
                0,
                -1,
                -n,
                0,
                1,
                -n,
                n,
                0,
                -1,
                n,
                0,
                1,
                -n,
                0,
                -1,
                -n,
                0,
                1,
              ],
              [
                0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11,
                4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3,
                6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
              ],
              t,
              e
            ),
              (this.type = "IcosahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        class xo extends En {
          constructor(t, e = 12, n = 0, i = 2 * Math.PI) {
            super(),
              (this.type = "LatheGeometry"),
              (this.parameters = {
                points: t,
                segments: e,
                phiStart: n,
                phiLength: i,
              }),
              (e = Math.floor(e)),
              (i = ht(i, 0, 2 * Math.PI));
            const r = [],
              s = [],
              a = [],
              o = 1 / e,
              l = new Lt(),
              c = new vt();
            for (let r = 0; r <= e; r++) {
              const h = n + r * o * i,
                u = Math.sin(h),
                d = Math.cos(h);
              for (let n = 0; n <= t.length - 1; n++)
                (l.x = t[n].x * u),
                  (l.y = t[n].y),
                  (l.z = t[n].x * d),
                  s.push(l.x, l.y, l.z),
                  (c.x = r / e),
                  (c.y = n / (t.length - 1)),
                  a.push(c.x, c.y);
            }
            for (let n = 0; n < e; n++)
              for (let e = 0; e < t.length - 1; e++) {
                const i = e + n * t.length,
                  s = i,
                  a = i + t.length,
                  o = i + t.length + 1,
                  l = i + 1;
                r.push(s, a, l), r.push(a, o, l);
              }
            if (
              (this.setIndex(r),
              this.setAttribute("position", new mn(s, 3)),
              this.setAttribute("uv", new mn(a, 2)),
              this.computeVertexNormals(),
              i === 2 * Math.PI)
            ) {
              const n = this.attributes.normal.array,
                i = new Lt(),
                r = new Lt(),
                s = new Lt(),
                a = e * t.length * 3;
              for (let e = 0, o = 0; e < t.length; e++, o += 3)
                (i.x = n[o + 0]),
                  (i.y = n[o + 1]),
                  (i.z = n[o + 2]),
                  (r.x = n[a + o + 0]),
                  (r.y = n[a + o + 1]),
                  (r.z = n[a + o + 2]),
                  s.addVectors(i, r).normalize(),
                  (n[o + 0] = n[a + o + 0] = s.x),
                  (n[o + 1] = n[a + o + 1] = s.y),
                  (n[o + 2] = n[a + o + 2] = s.z);
            }
          }
        }
        class _o extends Na {
          constructor(t = 1, e = 0) {
            super(
              [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
              [
                0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4,
                1, 4, 2,
              ],
              t,
              e
            ),
              (this.type = "OctahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        class wo extends En {
          constructor(t, e, n) {
            super(),
              (this.type = "ParametricGeometry"),
              (this.parameters = { func: t, slices: e, stacks: n });
            const i = [],
              r = [],
              s = [],
              a = [],
              o = 1e-5,
              l = new Lt(),
              c = new Lt(),
              h = new Lt(),
              u = new Lt(),
              d = new Lt();
            t.length < 3 &&
              console.error(
                "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."
              );
            const p = e + 1;
            for (let i = 0; i <= n; i++) {
              const p = i / n;
              for (let n = 0; n <= e; n++) {
                const i = n / e;
                t(i, p, c),
                  r.push(c.x, c.y, c.z),
                  i - o >= 0
                    ? (t(i - o, p, h), u.subVectors(c, h))
                    : (t(i + o, p, h), u.subVectors(h, c)),
                  p - o >= 0
                    ? (t(i, p - o, h), d.subVectors(c, h))
                    : (t(i, p + o, h), d.subVectors(h, c)),
                  l.crossVectors(u, d).normalize(),
                  s.push(l.x, l.y, l.z),
                  a.push(i, p);
              }
            }
            for (let t = 0; t < n; t++)
              for (let n = 0; n < e; n++) {
                const e = t * p + n,
                  r = t * p + n + 1,
                  s = (t + 1) * p + n + 1,
                  a = (t + 1) * p + n;
                i.push(e, r, a), i.push(r, s, a);
              }
            this.setIndex(i),
              this.setAttribute("position", new mn(r, 3)),
              this.setAttribute("normal", new mn(s, 3)),
              this.setAttribute("uv", new mn(a, 2));
          }
        }
        class bo extends En {
          constructor(t = 0.5, e = 1, n = 8, i = 1, r = 0, s = 2 * Math.PI) {
            super(),
              (this.type = "RingGeometry"),
              (this.parameters = {
                innerRadius: t,
                outerRadius: e,
                thetaSegments: n,
                phiSegments: i,
                thetaStart: r,
                thetaLength: s,
              }),
              (n = Math.max(3, n));
            const a = [],
              o = [],
              l = [],
              c = [];
            let h = t;
            const u = (e - t) / (i = Math.max(1, i)),
              d = new Lt(),
              p = new vt();
            for (let t = 0; t <= i; t++) {
              for (let t = 0; t <= n; t++) {
                const i = r + (t / n) * s;
                (d.x = h * Math.cos(i)),
                  (d.y = h * Math.sin(i)),
                  o.push(d.x, d.y, d.z),
                  l.push(0, 0, 1),
                  (p.x = (d.x / e + 1) / 2),
                  (p.y = (d.y / e + 1) / 2),
                  c.push(p.x, p.y);
              }
              h += u;
            }
            for (let t = 0; t < i; t++) {
              const e = t * (n + 1);
              for (let t = 0; t < n; t++) {
                const i = t + e,
                  r = i,
                  s = i + n + 1,
                  o = i + n + 2,
                  l = i + 1;
                a.push(r, s, l), a.push(s, o, l);
              }
            }
            this.setIndex(a),
              this.setAttribute("position", new mn(o, 3)),
              this.setAttribute("normal", new mn(l, 3)),
              this.setAttribute("uv", new mn(c, 2));
          }
        }
        class Mo extends En {
          constructor(t, e = 12) {
            super(),
              (this.type = "ShapeGeometry"),
              (this.parameters = { shapes: t, curveSegments: e });
            const n = [],
              i = [],
              r = [],
              s = [];
            let a = 0,
              o = 0;
            if (!1 === Array.isArray(t)) l(t);
            else
              for (let e = 0; e < t.length; e++)
                l(t[e]), this.addGroup(a, o, e), (a += o), (o = 0);
            function l(t) {
              const a = i.length / 3,
                l = t.extractPoints(e);
              let c = l.shape;
              const h = l.holes;
              !1 === po.isClockWise(c) && (c = c.reverse());
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                !0 === po.isClockWise(e) && (h[t] = e.reverse());
              }
              const u = po.triangulateShape(c, h);
              for (let t = 0, e = h.length; t < e; t++) {
                const e = h[t];
                c = c.concat(e);
              }
              for (let t = 0, e = c.length; t < e; t++) {
                const e = c[t];
                i.push(e.x, e.y, 0), r.push(0, 0, 1), s.push(e.x, e.y);
              }
              for (let t = 0, e = u.length; t < e; t++) {
                const e = u[t],
                  i = e[0] + a,
                  r = e[1] + a,
                  s = e[2] + a;
                n.push(i, r, s), (o += 3);
              }
            }
            this.setIndex(n),
              this.setAttribute("position", new mn(i, 3)),
              this.setAttribute("normal", new mn(r, 3)),
              this.setAttribute("uv", new mn(s, 2));
          }
          toJSON() {
            const t = En.prototype.toJSON.call(this);
            return (function (t, e) {
              if (((e.shapes = []), Array.isArray(t)))
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = t[n];
                  e.shapes.push(i.uuid);
                }
              else e.shapes.push(t.uuid);
              return e;
            })(this.parameters.shapes, t);
          }
        }
        class So extends En {
          constructor(
            t = 1,
            e = 8,
            n = 6,
            i = 0,
            r = 2 * Math.PI,
            s = 0,
            a = Math.PI
          ) {
            super(),
              (this.type = "SphereGeometry"),
              (this.parameters = {
                radius: t,
                widthSegments: e,
                heightSegments: n,
                phiStart: i,
                phiLength: r,
                thetaStart: s,
                thetaLength: a,
              }),
              (e = Math.max(3, Math.floor(e))),
              (n = Math.max(2, Math.floor(n)));
            const o = Math.min(s + a, Math.PI);
            let l = 0;
            const c = [],
              h = new Lt(),
              u = new Lt(),
              d = [],
              p = [],
              m = [],
              f = [];
            for (let d = 0; d <= n; d++) {
              const g = [],
                v = d / n;
              let y = 0;
              0 == d && 0 == s
                ? (y = 0.5 / e)
                : d == n && o == Math.PI && (y = -0.5 / e);
              for (let n = 0; n <= e; n++) {
                const o = n / e;
                (h.x = -t * Math.cos(i + o * r) * Math.sin(s + v * a)),
                  (h.y = t * Math.cos(s + v * a)),
                  (h.z = t * Math.sin(i + o * r) * Math.sin(s + v * a)),
                  p.push(h.x, h.y, h.z),
                  u.copy(h).normalize(),
                  m.push(u.x, u.y, u.z),
                  f.push(o + y, 1 - v),
                  g.push(l++);
              }
              c.push(g);
            }
            for (let t = 0; t < n; t++)
              for (let i = 0; i < e; i++) {
                const e = c[t][i + 1],
                  r = c[t][i],
                  a = c[t + 1][i],
                  l = c[t + 1][i + 1];
                (0 !== t || s > 0) && d.push(e, r, l),
                  (t !== n - 1 || o < Math.PI) && d.push(r, a, l);
              }
            this.setIndex(d),
              this.setAttribute("position", new mn(p, 3)),
              this.setAttribute("normal", new mn(m, 3)),
              this.setAttribute("uv", new mn(f, 2));
          }
        }
        class To extends Na {
          constructor(t = 1, e = 0) {
            super(
              [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
              [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
              t,
              e
            ),
              (this.type = "TetrahedronGeometry"),
              (this.parameters = { radius: t, detail: e });
          }
        }
        class Eo extends go {
          constructor(t, e = {}) {
            const n = e.font;
            if (!n || !n.isFont)
              return (
                console.error(
                  "THREE.TextGeometry: font parameter is not an instance of THREE.Font."
                ),
                new En()
              );
            const i = n.generateShapes(t, e.size);
            (e.depth = void 0 !== e.height ? e.height : 50),
              void 0 === e.bevelThickness && (e.bevelThickness = 10),
              void 0 === e.bevelSize && (e.bevelSize = 8),
              void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
              super(i, e),
              (this.type = "TextGeometry");
          }
        }
        class Ao extends En {
          constructor(t = 1, e = 0.4, n = 8, i = 6, r = 2 * Math.PI) {
            super(),
              (this.type = "TorusGeometry"),
              (this.parameters = {
                radius: t,
                tube: e,
                radialSegments: n,
                tubularSegments: i,
                arc: r,
              }),
              (n = Math.floor(n)),
              (i = Math.floor(i));
            const s = [],
              a = [],
              o = [],
              l = [],
              c = new Lt(),
              h = new Lt(),
              u = new Lt();
            for (let s = 0; s <= n; s++)
              for (let d = 0; d <= i; d++) {
                const p = (d / i) * r,
                  m = (s / n) * Math.PI * 2;
                (h.x = (t + e * Math.cos(m)) * Math.cos(p)),
                  (h.y = (t + e * Math.cos(m)) * Math.sin(p)),
                  (h.z = e * Math.sin(m)),
                  a.push(h.x, h.y, h.z),
                  (c.x = t * Math.cos(p)),
                  (c.y = t * Math.sin(p)),
                  u.subVectors(h, c).normalize(),
                  o.push(u.x, u.y, u.z),
                  l.push(d / i),
                  l.push(s / n);
              }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * t + e - 1,
                  r = (i + 1) * (t - 1) + e - 1,
                  a = (i + 1) * (t - 1) + e,
                  o = (i + 1) * t + e;
                s.push(n, r, o), s.push(r, a, o);
              }
            this.setIndex(s),
              this.setAttribute("position", new mn(a, 3)),
              this.setAttribute("normal", new mn(o, 3)),
              this.setAttribute("uv", new mn(l, 2));
          }
        }
        class Lo extends En {
          constructor(t = 1, e = 0.4, n = 64, i = 8, r = 2, s = 3) {
            super(),
              (this.type = "TorusKnotGeometry"),
              (this.parameters = {
                radius: t,
                tube: e,
                tubularSegments: n,
                radialSegments: i,
                p: r,
                q: s,
              }),
              (n = Math.floor(n)),
              (i = Math.floor(i));
            const a = [],
              o = [],
              l = [],
              c = [],
              h = new Lt(),
              u = new Lt(),
              d = new Lt(),
              p = new Lt(),
              m = new Lt(),
              f = new Lt(),
              g = new Lt();
            for (let a = 0; a <= n; ++a) {
              const y = (a / n) * r * Math.PI * 2;
              v(y, r, s, t, d),
                v(y + 0.01, r, s, t, p),
                f.subVectors(p, d),
                g.addVectors(p, d),
                m.crossVectors(f, g),
                g.crossVectors(m, f),
                m.normalize(),
                g.normalize();
              for (let t = 0; t <= i; ++t) {
                const r = (t / i) * Math.PI * 2,
                  s = -e * Math.cos(r),
                  p = e * Math.sin(r);
                (h.x = d.x + (s * g.x + p * m.x)),
                  (h.y = d.y + (s * g.y + p * m.y)),
                  (h.z = d.z + (s * g.z + p * m.z)),
                  o.push(h.x, h.y, h.z),
                  u.subVectors(h, d).normalize(),
                  l.push(u.x, u.y, u.z),
                  c.push(a / n),
                  c.push(t / i);
              }
            }
            for (let t = 1; t <= n; t++)
              for (let e = 1; e <= i; e++) {
                const n = (i + 1) * (t - 1) + (e - 1),
                  r = (i + 1) * t + (e - 1),
                  s = (i + 1) * t + e,
                  o = (i + 1) * (t - 1) + e;
                a.push(n, r, o), a.push(r, s, o);
              }
            function v(t, e, n, i, r) {
              const s = Math.cos(t),
                a = Math.sin(t),
                o = (n / e) * t,
                l = Math.cos(o);
              (r.x = i * (2 + l) * 0.5 * s),
                (r.y = i * (2 + l) * a * 0.5),
                (r.z = i * Math.sin(o) * 0.5);
            }
            this.setIndex(a),
              this.setAttribute("position", new mn(o, 3)),
              this.setAttribute("normal", new mn(l, 3)),
              this.setAttribute("uv", new mn(c, 2));
          }
        }
        class Ro extends En {
          constructor(t, e = 64, n = 1, i = 8, r = !1) {
            super(),
              (this.type = "TubeGeometry"),
              (this.parameters = {
                path: t,
                tubularSegments: e,
                radius: n,
                radialSegments: i,
                closed: r,
              });
            const s = t.computeFrenetFrames(e, r);
            (this.tangents = s.tangents),
              (this.normals = s.normals),
              (this.binormals = s.binormals);
            const a = new Lt(),
              o = new Lt(),
              l = new vt();
            let c = new Lt();
            const h = [],
              u = [],
              d = [],
              p = [];
            function m(r) {
              c = t.getPointAt(r / e, c);
              const l = s.normals[r],
                d = s.binormals[r];
              for (let t = 0; t <= i; t++) {
                const e = (t / i) * Math.PI * 2,
                  r = Math.sin(e),
                  s = -Math.cos(e);
                (o.x = s * l.x + r * d.x),
                  (o.y = s * l.y + r * d.y),
                  (o.z = s * l.z + r * d.z),
                  o.normalize(),
                  u.push(o.x, o.y, o.z),
                  (a.x = c.x + n * o.x),
                  (a.y = c.y + n * o.y),
                  (a.z = c.z + n * o.z),
                  h.push(a.x, a.y, a.z);
              }
            }
            !(function () {
              for (let t = 0; t < e; t++) m(t);
              m(!1 === r ? e : 0),
                (function () {
                  for (let t = 0; t <= e; t++)
                    for (let n = 0; n <= i; n++)
                      (l.x = t / e), (l.y = n / i), d.push(l.x, l.y);
                })(),
                (function () {
                  for (let t = 1; t <= e; t++)
                    for (let e = 1; e <= i; e++) {
                      const n = (i + 1) * (t - 1) + (e - 1),
                        r = (i + 1) * t + (e - 1),
                        s = (i + 1) * t + e,
                        a = (i + 1) * (t - 1) + e;
                      p.push(n, r, a), p.push(r, s, a);
                    }
                })();
            })(),
              this.setIndex(p),
              this.setAttribute("position", new mn(h, 3)),
              this.setAttribute("normal", new mn(u, 3)),
              this.setAttribute("uv", new mn(d, 2));
          }
          toJSON() {
            const t = En.prototype.toJSON.call(this);
            return (t.path = this.parameters.path.toJSON()), t;
          }
        }
        class Co extends En {
          constructor(t) {
            if (
              (super(), (this.type = "WireframeGeometry"), !0 === t.isGeometry)
            )
              return void console.error(
                "THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."
              );
            const e = [],
              n = [0, 0],
              i = {},
              r = new Lt();
            if (null !== t.index) {
              const s = t.attributes.position,
                a = t.index;
              let o = t.groups;
              0 === o.length &&
                (o = [{ start: 0, count: a.count, materialIndex: 0 }]);
              for (let t = 0, e = o.length; t < e; ++t) {
                const e = o[t],
                  r = e.start;
                for (let t = r, s = r + e.count; t < s; t += 3)
                  for (let e = 0; e < 3; e++) {
                    const r = a.getX(t + e),
                      s = a.getX(t + ((e + 1) % 3));
                    (n[0] = Math.min(r, s)), (n[1] = Math.max(r, s));
                    const o = n[0] + "," + n[1];
                    void 0 === i[o] && (i[o] = { index1: n[0], index2: n[1] });
                  }
              }
              for (const t in i) {
                const n = i[t];
                r.fromBufferAttribute(s, n.index1),
                  e.push(r.x, r.y, r.z),
                  r.fromBufferAttribute(s, n.index2),
                  e.push(r.x, r.y, r.z);
              }
            } else {
              const n = t.attributes.position;
              for (let t = 0, i = n.count / 3; t < i; t++)
                for (let i = 0; i < 3; i++) {
                  const s = 3 * t + i;
                  r.fromBufferAttribute(n, s), e.push(r.x, r.y, r.z);
                  const a = 3 * t + ((i + 1) % 3);
                  r.fromBufferAttribute(n, a), e.push(r.x, r.y, r.z);
                }
            }
            this.setAttribute("position", new mn(e, 3));
          }
        }
        var Po = Object.freeze({
          __proto__: null,
          BoxGeometry: qn,
          BoxBufferGeometry: qn,
          CircleGeometry: Pa,
          CircleBufferGeometry: Pa,
          ConeGeometry: Ia,
          ConeBufferGeometry: Ia,
          CylinderGeometry: Da,
          CylinderBufferGeometry: Da,
          DodecahedronGeometry: Ba,
          DodecahedronBufferGeometry: Ba,
          EdgesGeometry: Ga,
          ExtrudeGeometry: go,
          ExtrudeBufferGeometry: go,
          IcosahedronGeometry: yo,
          IcosahedronBufferGeometry: yo,
          LatheGeometry: xo,
          LatheBufferGeometry: xo,
          OctahedronGeometry: _o,
          OctahedronBufferGeometry: _o,
          ParametricGeometry: wo,
          ParametricBufferGeometry: wo,
          PlaneGeometry: ci,
          PlaneBufferGeometry: ci,
          PolyhedronGeometry: Na,
          PolyhedronBufferGeometry: Na,
          RingGeometry: bo,
          RingBufferGeometry: bo,
          ShapeGeometry: Mo,
          ShapeBufferGeometry: Mo,
          SphereGeometry: So,
          SphereBufferGeometry: So,
          TetrahedronGeometry: To,
          TetrahedronBufferGeometry: To,
          TextGeometry: Eo,
          TextBufferGeometry: Eo,
          TorusGeometry: Ao,
          TorusBufferGeometry: Ao,
          TorusKnotGeometry: Lo,
          TorusKnotBufferGeometry: Lo,
          TubeGeometry: Ro,
          TubeBufferGeometry: Ro,
          WireframeGeometry: Co,
        });
        class Do extends Xe {
          constructor(t) {
            super(),
              (this.type = "ShadowMaterial"),
              (this.color = new tn(0)),
              (this.transparent = !0),
              this.setValues(t);
          }
          copy(t) {
            return super.copy(t), this.color.copy(t.color), this;
          }
        }
        Do.prototype.isShadowMaterial = !0;
        class Io extends Jn {
          constructor(t) {
            super(t), (this.type = "RawShaderMaterial");
          }
        }
        Io.prototype.isRawShaderMaterial = !0;
        class No extends Xe {
          constructor(t) {
            super(),
              (this.defines = { STANDARD: "" }),
              (this.type = "MeshStandardMaterial"),
              (this.color = new tn(16777215)),
              (this.roughness = 1),
              (this.metalness = 0),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new tn(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new vt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.roughnessMap = null),
              (this.metalnessMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.envMapIntensity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              (this.vertexTangents = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "" }),
              this.color.copy(t.color),
              (this.roughness = t.roughness),
              (this.metalness = t.metalness),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.roughnessMap = t.roughnessMap),
              (this.metalnessMap = t.metalnessMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.envMapIntensity = t.envMapIntensity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              (this.vertexTangents = t.vertexTangents),
              this
            );
          }
        }
        No.prototype.isMeshStandardMaterial = !0;
        class Bo extends No {
          constructor(t) {
            super(),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.type = "MeshPhysicalMaterial"),
              (this.clearcoat = 0),
              (this.clearcoatMap = null),
              (this.clearcoatRoughness = 0),
              (this.clearcoatRoughnessMap = null),
              (this.clearcoatNormalScale = new vt(1, 1)),
              (this.clearcoatNormalMap = null),
              (this.reflectivity = 0.5),
              Object.defineProperty(this, "ior", {
                get: function () {
                  return (
                    (1 + 0.4 * this.reflectivity) /
                    (1 - 0.4 * this.reflectivity)
                  );
                },
                set: function (t) {
                  this.reflectivity = ht((2.5 * (t - 1)) / (t + 1), 0, 1);
                },
              }),
              (this.sheen = null),
              (this.transmission = 0),
              (this.transmissionMap = null),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { STANDARD: "", PHYSICAL: "" }),
              (this.clearcoat = t.clearcoat),
              (this.clearcoatMap = t.clearcoatMap),
              (this.clearcoatRoughness = t.clearcoatRoughness),
              (this.clearcoatRoughnessMap = t.clearcoatRoughnessMap),
              (this.clearcoatNormalMap = t.clearcoatNormalMap),
              this.clearcoatNormalScale.copy(t.clearcoatNormalScale),
              (this.reflectivity = t.reflectivity),
              t.sheen
                ? (this.sheen = (this.sheen || new tn()).copy(t.sheen))
                : (this.sheen = null),
              (this.transmission = t.transmission),
              (this.transmissionMap = t.transmissionMap),
              this
            );
          }
        }
        Bo.prototype.isMeshPhysicalMaterial = !0;
        class zo extends Xe {
          constructor(t) {
            super(),
              (this.type = "MeshPhongMaterial"),
              (this.color = new tn(16777215)),
              (this.specular = new tn(1118481)),
              (this.shininess = 30),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new tn(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new vt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              this.specular.copy(t.specular),
              (this.shininess = t.shininess),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        zo.prototype.isMeshPhongMaterial = !0;
        class Fo extends Xe {
          constructor(t) {
            super(),
              (this.defines = { TOON: "" }),
              (this.type = "MeshToonMaterial"),
              (this.color = new tn(16777215)),
              (this.map = null),
              (this.gradientMap = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new tn(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new vt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.gradientMap = t.gradientMap),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            );
          }
        }
        Fo.prototype.isMeshToonMaterial = !0;
        class Oo extends Xe {
          constructor(t) {
            super(),
              (this.type = "MeshNormalMaterial"),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new vt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.fog = !1),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        Oo.prototype.isMeshNormalMaterial = !0;
        class Ho extends Xe {
          constructor(t) {
            super(),
              (this.type = "MeshLambertMaterial"),
              (this.color = new tn(16777215)),
              (this.map = null),
              (this.lightMap = null),
              (this.lightMapIntensity = 1),
              (this.aoMap = null),
              (this.aoMapIntensity = 1),
              (this.emissive = new tn(0)),
              (this.emissiveIntensity = 1),
              (this.emissiveMap = null),
              (this.specularMap = null),
              (this.alphaMap = null),
              (this.envMap = null),
              (this.combine = 0),
              (this.reflectivity = 1),
              (this.refractionRatio = 0.98),
              (this.wireframe = !1),
              (this.wireframeLinewidth = 1),
              (this.wireframeLinecap = "round"),
              (this.wireframeLinejoin = "round"),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.map = t.map),
              (this.lightMap = t.lightMap),
              (this.lightMapIntensity = t.lightMapIntensity),
              (this.aoMap = t.aoMap),
              (this.aoMapIntensity = t.aoMapIntensity),
              this.emissive.copy(t.emissive),
              (this.emissiveMap = t.emissiveMap),
              (this.emissiveIntensity = t.emissiveIntensity),
              (this.specularMap = t.specularMap),
              (this.alphaMap = t.alphaMap),
              (this.envMap = t.envMap),
              (this.combine = t.combine),
              (this.reflectivity = t.reflectivity),
              (this.refractionRatio = t.refractionRatio),
              (this.wireframe = t.wireframe),
              (this.wireframeLinewidth = t.wireframeLinewidth),
              (this.wireframeLinecap = t.wireframeLinecap),
              (this.wireframeLinejoin = t.wireframeLinejoin),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              this
            );
          }
        }
        Ho.prototype.isMeshLambertMaterial = !0;
        class Go extends Xe {
          constructor(t) {
            super(),
              (this.defines = { MATCAP: "" }),
              (this.type = "MeshMatcapMaterial"),
              (this.color = new tn(16777215)),
              (this.matcap = null),
              (this.map = null),
              (this.bumpMap = null),
              (this.bumpScale = 1),
              (this.normalMap = null),
              (this.normalMapType = 0),
              (this.normalScale = new vt(1, 1)),
              (this.displacementMap = null),
              (this.displacementScale = 1),
              (this.displacementBias = 0),
              (this.alphaMap = null),
              (this.skinning = !1),
              (this.morphTargets = !1),
              (this.morphNormals = !1),
              (this.flatShading = !1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.defines = { MATCAP: "" }),
              this.color.copy(t.color),
              (this.matcap = t.matcap),
              (this.map = t.map),
              (this.bumpMap = t.bumpMap),
              (this.bumpScale = t.bumpScale),
              (this.normalMap = t.normalMap),
              (this.normalMapType = t.normalMapType),
              this.normalScale.copy(t.normalScale),
              (this.displacementMap = t.displacementMap),
              (this.displacementScale = t.displacementScale),
              (this.displacementBias = t.displacementBias),
              (this.alphaMap = t.alphaMap),
              (this.skinning = t.skinning),
              (this.morphTargets = t.morphTargets),
              (this.morphNormals = t.morphNormals),
              (this.flatShading = t.flatShading),
              this
            );
          }
        }
        Go.prototype.isMeshMatcapMaterial = !0;
        class Uo extends ca {
          constructor(t) {
            super(),
              (this.type = "LineDashedMaterial"),
              (this.scale = 1),
              (this.dashSize = 3),
              (this.gapSize = 1),
              this.setValues(t);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.scale = t.scale),
              (this.dashSize = t.dashSize),
              (this.gapSize = t.gapSize),
              this
            );
          }
        }
        Uo.prototype.isLineDashedMaterial = !0;
        var ko = Object.freeze({
          __proto__: null,
          ShadowMaterial: Do,
          SpriteMaterial: Rs,
          RawShaderMaterial: Io,
          ShaderMaterial: Jn,
          PointsMaterial: _a,
          MeshPhysicalMaterial: Bo,
          MeshStandardMaterial: No,
          MeshPhongMaterial: zo,
          MeshToonMaterial: Fo,
          MeshNormalMaterial: Oo,
          MeshLambertMaterial: Ho,
          MeshDepthMaterial: cs,
          MeshDistanceMaterial: hs,
          MeshBasicMaterial: en,
          MeshMatcapMaterial: Go,
          LineDashedMaterial: Uo,
          LineBasicMaterial: ca,
          Material: Xe,
        });
        const Vo = {
          arraySlice: function (t, e, n) {
            return Vo.isTypedArray(t)
              ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
              : t.slice(e, n);
          },
          convertArray: function (t, e, n) {
            return !t || (!n && t.constructor === e)
              ? t
              : "number" == typeof e.BYTES_PER_ELEMENT
              ? new e(t)
              : Array.prototype.slice.call(t);
          },
          isTypedArray: function (t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView);
          },
          getKeyframeOrder: function (t) {
            const e = t.length,
              n = new Array(e);
            for (let t = 0; t !== e; ++t) n[t] = t;
            return (
              n.sort(function (e, n) {
                return t[e] - t[n];
              }),
              n
            );
          },
          sortedArray: function (t, e, n) {
            const i = t.length,
              r = new t.constructor(i);
            for (let s = 0, a = 0; a !== i; ++s) {
              const i = n[s] * e;
              for (let n = 0; n !== e; ++n) r[a++] = t[i + n];
            }
            return r;
          },
          flattenJSON: function (t, e, n, i) {
            let r = 1,
              s = t[0];
            for (; void 0 !== s && void 0 === s[i]; ) s = t[r++];
            if (void 0 === s) return;
            let a = s[i];
            if (void 0 !== a)
              if (Array.isArray(a))
                do {
                  (a = s[i]),
                    void 0 !== a && (e.push(s.time), n.push.apply(n, a)),
                    (s = t[r++]);
                } while (void 0 !== s);
              else if (void 0 !== a.toArray)
                do {
                  (a = s[i]),
                    void 0 !== a && (e.push(s.time), a.toArray(n, n.length)),
                    (s = t[r++]);
                } while (void 0 !== s);
              else
                do {
                  (a = s[i]),
                    void 0 !== a && (e.push(s.time), n.push(a)),
                    (s = t[r++]);
                } while (void 0 !== s);
          },
          subclip: function (t, e, n, i, r = 30) {
            const s = t.clone();
            s.name = e;
            const a = [];
            for (let t = 0; t < s.tracks.length; ++t) {
              const e = s.tracks[t],
                o = e.getValueSize(),
                l = [],
                c = [];
              for (let t = 0; t < e.times.length; ++t) {
                const s = e.times[t] * r;
                if (!(s < n || s >= i)) {
                  l.push(e.times[t]);
                  for (let n = 0; n < o; ++n) c.push(e.values[t * o + n]);
                }
              }
              0 !== l.length &&
                ((e.times = Vo.convertArray(l, e.times.constructor)),
                (e.values = Vo.convertArray(c, e.values.constructor)),
                a.push(e));
            }
            s.tracks = a;
            let o = 1 / 0;
            for (let t = 0; t < s.tracks.length; ++t)
              o > s.tracks[t].times[0] && (o = s.tracks[t].times[0]);
            for (let t = 0; t < s.tracks.length; ++t) s.tracks[t].shift(-1 * o);
            return s.resetDuration(), s;
          },
          makeClipAdditive: function (t, e = 0, n = t, i = 30) {
            i <= 0 && (i = 30);
            const r = n.tracks.length,
              s = e / i;
            for (let e = 0; e < r; ++e) {
              const i = n.tracks[e],
                r = i.ValueTypeName;
              if ("bool" === r || "string" === r) continue;
              const a = t.tracks.find(function (t) {
                return t.name === i.name && t.ValueTypeName === r;
              });
              if (void 0 === a) continue;
              let o = 0;
              const l = i.getValueSize();
              i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (o = l / 3);
              let c = 0;
              const h = a.getValueSize();
              a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
                (c = h / 3);
              const u = i.times.length - 1;
              let d;
              if (s <= i.times[0]) {
                const t = o,
                  e = l - o;
                d = Vo.arraySlice(i.values, t, e);
              } else if (s >= i.times[u]) {
                const t = u * l + o,
                  e = t + l - o;
                d = Vo.arraySlice(i.values, t, e);
              } else {
                const t = i.createInterpolant(),
                  e = o,
                  n = l - o;
                t.evaluate(s), (d = Vo.arraySlice(t.resultBuffer, e, n));
              }
              if ("quaternion" === r) {
                new At().fromArray(d).normalize().conjugate().toArray(d);
              }
              const p = a.times.length;
              for (let t = 0; t < p; ++t) {
                const e = t * h + c;
                if ("quaternion" === r)
                  At.multiplyQuaternionsFlat(a.values, e, d, 0, a.values, e);
                else {
                  const t = h - 2 * c;
                  for (let n = 0; n < t; ++n) a.values[e + n] -= d[n];
                }
              }
            }
            return (t.blendMode = q), t;
          },
        };
        class Wo {
          constructor(t, e, n, i) {
            (this.parameterPositions = t),
              (this._cachedIndex = 0),
              (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
              (this.sampleValues = e),
              (this.valueSize = n),
              (this.settings = null),
              (this.DefaultSettings_ = {});
          }
          evaluate(t) {
            const e = this.parameterPositions;
            let n = this._cachedIndex,
              i = e[n],
              r = e[n - 1];
            t: {
              e: {
                let s;
                n: {
                  i: if (!(t < i)) {
                    for (let s = n + 2; ; ) {
                      if (void 0 === i) {
                        if (t < r) break i;
                        return (
                          (n = e.length),
                          (this._cachedIndex = n),
                          this.afterEnd_(n - 1, t, r)
                        );
                      }
                      if (n === s) break;
                      if (((r = i), (i = e[++n]), t < i)) break e;
                    }
                    s = e.length;
                    break n;
                  }
                  if (t >= r) break t;
                  {
                    const a = e[1];
                    t < a && ((n = 2), (r = a));
                    for (let s = n - 2; ; ) {
                      if (void 0 === r)
                        return (
                          (this._cachedIndex = 0), this.beforeStart_(0, t, i)
                        );
                      if (n === s) break;
                      if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                    }
                    (s = n), (n = 0);
                  }
                }
                for (; n < s; ) {
                  const i = (n + s) >>> 1;
                  t < e[i] ? (s = i) : (n = i + 1);
                }
                if (((i = e[n]), (r = e[n - 1]), void 0 === r))
                  return (this._cachedIndex = 0), this.beforeStart_(0, t, i);
                if (void 0 === i)
                  return (
                    (n = e.length),
                    (this._cachedIndex = n),
                    this.afterEnd_(n - 1, r, t)
                  );
              }
              (this._cachedIndex = n), this.intervalChanged_(n, r, i);
            }
            return this.interpolate_(n, r, t, i);
          }
          getSettings_() {
            return this.settings || this.DefaultSettings_;
          }
          copySampleValue_(t) {
            const e = this.resultBuffer,
              n = this.sampleValues,
              i = this.valueSize,
              r = t * i;
            for (let t = 0; t !== i; ++t) e[t] = n[r + t];
            return e;
          }
          interpolate_() {
            throw new Error("call to abstract method");
          }
          intervalChanged_() {}
        }
        (Wo.prototype.beforeStart_ = Wo.prototype.copySampleValue_),
          (Wo.prototype.afterEnd_ = Wo.prototype.copySampleValue_);
        class jo extends Wo {
          constructor(t, e, n, i) {
            super(t, e, n, i),
              (this._weightPrev = -0),
              (this._offsetPrev = -0),
              (this._weightNext = -0),
              (this._offsetNext = -0),
              (this.DefaultSettings_ = { endingStart: k, endingEnd: k });
          }
          intervalChanged_(t, e, n) {
            const i = this.parameterPositions;
            let r = t - 2,
              s = t + 1,
              a = i[r],
              o = i[s];
            if (void 0 === a)
              switch (this.getSettings_().endingStart) {
                case V:
                  (r = t), (a = 2 * e - n);
                  break;
                case W:
                  (r = i.length - 2), (a = e + i[r] - i[r + 1]);
                  break;
                default:
                  (r = t), (a = n);
              }
            if (void 0 === o)
              switch (this.getSettings_().endingEnd) {
                case V:
                  (s = t), (o = 2 * n - e);
                  break;
                case W:
                  (s = 1), (o = n + i[1] - i[0]);
                  break;
                default:
                  (s = t - 1), (o = e);
              }
            const l = 0.5 * (n - e),
              c = this.valueSize;
            (this._weightPrev = l / (e - a)),
              (this._weightNext = l / (o - n)),
              (this._offsetPrev = r * c),
              (this._offsetNext = s * c);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = t * a,
              l = o - a,
              c = this._offsetPrev,
              h = this._offsetNext,
              u = this._weightPrev,
              d = this._weightNext,
              p = (n - e) / (i - e),
              m = p * p,
              f = m * p,
              g = -u * f + 2 * u * m - u * p,
              v = (1 + u) * f + (-1.5 - 2 * u) * m + (-0.5 + u) * p + 1,
              y = (-1 - d) * f + (1.5 + d) * m + 0.5 * p,
              x = d * f - d * m;
            for (let t = 0; t !== a; ++t)
              r[t] = g * s[c + t] + v * s[l + t] + y * s[o + t] + x * s[h + t];
            return r;
          }
        }
        class qo extends Wo {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = t * a,
              l = o - a,
              c = (n - e) / (i - e),
              h = 1 - c;
            for (let t = 0; t !== a; ++t) r[t] = s[l + t] * h + s[o + t] * c;
            return r;
          }
        }
        class Xo extends Wo {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t) {
            return this.copySampleValue_(t - 1);
          }
        }
        class Yo {
          constructor(t, e, n, i) {
            if (void 0 === t)
              throw new Error("THREE.KeyframeTrack: track name is undefined");
            if (void 0 === e || 0 === e.length)
              throw new Error(
                "THREE.KeyframeTrack: no keyframes in track named " + t
              );
            (this.name = t),
              (this.times = Vo.convertArray(e, this.TimeBufferType)),
              (this.values = Vo.convertArray(n, this.ValueBufferType)),
              this.setInterpolation(i || this.DefaultInterpolation);
          }
          static toJSON(t) {
            const e = t.constructor;
            let n;
            if (e.toJSON !== this.toJSON) n = e.toJSON(t);
            else {
              n = {
                name: t.name,
                times: Vo.convertArray(t.times, Array),
                values: Vo.convertArray(t.values, Array),
              };
              const e = t.getInterpolation();
              e !== t.DefaultInterpolation && (n.interpolation = e);
            }
            return (n.type = t.ValueTypeName), n;
          }
          InterpolantFactoryMethodDiscrete(t) {
            return new Xo(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodLinear(t) {
            return new qo(this.times, this.values, this.getValueSize(), t);
          }
          InterpolantFactoryMethodSmooth(t) {
            return new jo(this.times, this.values, this.getValueSize(), t);
          }
          setInterpolation(t) {
            let e;
            switch (t) {
              case H:
                e = this.InterpolantFactoryMethodDiscrete;
                break;
              case G:
                e = this.InterpolantFactoryMethodLinear;
                break;
              case U:
                e = this.InterpolantFactoryMethodSmooth;
            }
            if (void 0 === e) {
              const e =
                "unsupported interpolation for " +
                this.ValueTypeName +
                " keyframe track named " +
                this.name;
              if (void 0 === this.createInterpolant) {
                if (t === this.DefaultInterpolation) throw new Error(e);
                this.setInterpolation(this.DefaultInterpolation);
              }
              return console.warn("THREE.KeyframeTrack:", e), this;
            }
            return (this.createInterpolant = e), this;
          }
          getInterpolation() {
            switch (this.createInterpolant) {
              case this.InterpolantFactoryMethodDiscrete:
                return H;
              case this.InterpolantFactoryMethodLinear:
                return G;
              case this.InterpolantFactoryMethodSmooth:
                return U;
            }
          }
          getValueSize() {
            return this.values.length / this.times.length;
          }
          shift(t) {
            if (0 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
            }
            return this;
          }
          scale(t) {
            if (1 !== t) {
              const e = this.times;
              for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
            }
            return this;
          }
          trim(t, e) {
            const n = this.times,
              i = n.length;
            let r = 0,
              s = i - 1;
            for (; r !== i && n[r] < t; ) ++r;
            for (; -1 !== s && n[s] > e; ) --s;
            if ((++s, 0 !== r || s !== i)) {
              r >= s && ((s = Math.max(s, 1)), (r = s - 1));
              const t = this.getValueSize();
              (this.times = Vo.arraySlice(n, r, s)),
                (this.values = Vo.arraySlice(this.values, r * t, s * t));
            }
            return this;
          }
          validate() {
            let t = !0;
            const e = this.getValueSize();
            e - Math.floor(e) != 0 &&
              (console.error(
                "THREE.KeyframeTrack: Invalid value size in track.",
                this
              ),
              (t = !1));
            const n = this.times,
              i = this.values,
              r = n.length;
            0 === r &&
              (console.error("THREE.KeyframeTrack: Track is empty.", this),
              (t = !1));
            let s = null;
            for (let e = 0; e !== r; e++) {
              const i = n[e];
              if ("number" == typeof i && isNaN(i)) {
                console.error(
                  "THREE.KeyframeTrack: Time is not a valid number.",
                  this,
                  e,
                  i
                ),
                  (t = !1);
                break;
              }
              if (null !== s && s > i) {
                console.error(
                  "THREE.KeyframeTrack: Out of order keys.",
                  this,
                  e,
                  i,
                  s
                ),
                  (t = !1);
                break;
              }
              s = i;
            }
            if (void 0 !== i && Vo.isTypedArray(i))
              for (let e = 0, n = i.length; e !== n; ++e) {
                const n = i[e];
                if (isNaN(n)) {
                  console.error(
                    "THREE.KeyframeTrack: Value is not a valid number.",
                    this,
                    e,
                    n
                  ),
                    (t = !1);
                  break;
                }
              }
            return t;
          }
          optimize() {
            const t = Vo.arraySlice(this.times),
              e = Vo.arraySlice(this.values),
              n = this.getValueSize(),
              i = this.getInterpolation() === U,
              r = t.length - 1;
            let s = 1;
            for (let a = 1; a < r; ++a) {
              let r = !1;
              const o = t[a];
              if (o !== t[a + 1] && (1 !== a || o !== t[0]))
                if (i) r = !0;
                else {
                  const t = a * n,
                    i = t - n,
                    s = t + n;
                  for (let a = 0; a !== n; ++a) {
                    const n = e[t + a];
                    if (n !== e[i + a] || n !== e[s + a]) {
                      r = !0;
                      break;
                    }
                  }
                }
              if (r) {
                if (a !== s) {
                  t[s] = t[a];
                  const i = a * n,
                    r = s * n;
                  for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
                }
                ++s;
              }
            }
            if (r > 0) {
              t[s] = t[r];
              for (let t = r * n, i = s * n, a = 0; a !== n; ++a)
                e[i + a] = e[t + a];
              ++s;
            }
            return (
              s !== t.length
                ? ((this.times = Vo.arraySlice(t, 0, s)),
                  (this.values = Vo.arraySlice(e, 0, s * n)))
                : ((this.times = t), (this.values = e)),
              this
            );
          }
          clone() {
            const t = Vo.arraySlice(this.times, 0),
              e = Vo.arraySlice(this.values, 0),
              n = new (0, this.constructor)(this.name, t, e);
            return (n.createInterpolant = this.createInterpolant), n;
          }
        }
        (Yo.prototype.TimeBufferType = Float32Array),
          (Yo.prototype.ValueBufferType = Float32Array),
          (Yo.prototype.DefaultInterpolation = G);
        class Zo extends Yo {}
        (Zo.prototype.ValueTypeName = "bool"),
          (Zo.prototype.ValueBufferType = Array),
          (Zo.prototype.DefaultInterpolation = H),
          (Zo.prototype.InterpolantFactoryMethodLinear = void 0),
          (Zo.prototype.InterpolantFactoryMethodSmooth = void 0);
        class Jo extends Yo {}
        Jo.prototype.ValueTypeName = "color";
        class Qo extends Yo {}
        Qo.prototype.ValueTypeName = "number";
        class Ko extends Wo {
          constructor(t, e, n, i) {
            super(t, e, n, i);
          }
          interpolate_(t, e, n, i) {
            const r = this.resultBuffer,
              s = this.sampleValues,
              a = this.valueSize,
              o = (n - e) / (i - e);
            let l = t * a;
            for (let t = l + a; l !== t; l += 4)
              At.slerpFlat(r, 0, s, l - a, s, l, o);
            return r;
          }
        }
        class $o extends Yo {
          InterpolantFactoryMethodLinear(t) {
            return new Ko(this.times, this.values, this.getValueSize(), t);
          }
        }
        ($o.prototype.ValueTypeName = "quaternion"),
          ($o.prototype.DefaultInterpolation = G),
          ($o.prototype.InterpolantFactoryMethodSmooth = void 0);
        class tl extends Yo {}
        (tl.prototype.ValueTypeName = "string"),
          (tl.prototype.ValueBufferType = Array),
          (tl.prototype.DefaultInterpolation = H),
          (tl.prototype.InterpolantFactoryMethodLinear = void 0),
          (tl.prototype.InterpolantFactoryMethodSmooth = void 0);
        class el extends Yo {}
        el.prototype.ValueTypeName = "vector";
        class nl {
          constructor(t, e = -1, n, i = 2500) {
            (this.name = t),
              (this.tracks = n),
              (this.duration = e),
              (this.blendMode = i),
              (this.uuid = ct()),
              this.duration < 0 && this.resetDuration();
          }
          static parse(t) {
            const e = [],
              n = t.tracks,
              i = 1 / (t.fps || 1);
            for (let t = 0, r = n.length; t !== r; ++t)
              e.push(il(n[t]).scale(i));
            const r = new this(t.name, t.duration, e, t.blendMode);
            return (r.uuid = t.uuid), r;
          }
          static toJSON(t) {
            const e = [],
              n = t.tracks,
              i = {
                name: t.name,
                duration: t.duration,
                tracks: e,
                uuid: t.uuid,
                blendMode: t.blendMode,
              };
            for (let t = 0, i = n.length; t !== i; ++t) e.push(Yo.toJSON(n[t]));
            return i;
          }
          static CreateFromMorphTargetSequence(t, e, n, i) {
            const r = e.length,
              s = [];
            for (let t = 0; t < r; t++) {
              let a = [],
                o = [];
              a.push((t + r - 1) % r, t, (t + 1) % r), o.push(0, 1, 0);
              const l = Vo.getKeyframeOrder(a);
              (a = Vo.sortedArray(a, 1, l)),
                (o = Vo.sortedArray(o, 1, l)),
                i || 0 !== a[0] || (a.push(r), o.push(o[0])),
                s.push(
                  new Qo(
                    ".morphTargetInfluences[" + e[t].name + "]",
                    a,
                    o
                  ).scale(1 / n)
                );
            }
            return new this(t, -1, s);
          }
          static findByName(t, e) {
            let n = t;
            if (!Array.isArray(t)) {
              const e = t;
              n = (e.geometry && e.geometry.animations) || e.animations;
            }
            for (let t = 0; t < n.length; t++) if (n[t].name === e) return n[t];
            return null;
          }
          static CreateClipsFromMorphTargetSequences(t, e, n) {
            const i = {},
              r = /^([\w-]*?)([\d]+)$/;
            for (let e = 0, n = t.length; e < n; e++) {
              const n = t[e],
                s = n.name.match(r);
              if (s && s.length > 1) {
                const t = s[1];
                let e = i[t];
                e || (i[t] = e = []), e.push(n);
              }
            }
            const s = [];
            for (const t in i)
              s.push(this.CreateFromMorphTargetSequence(t, i[t], e, n));
            return s;
          }
          static parseAnimation(t, e) {
            if (!t)
              return (
                console.error(
                  "THREE.AnimationClip: No animation in JSONLoader data."
                ),
                null
              );
            const n = function (t, e, n, i, r) {
                if (0 !== n.length) {
                  const s = [],
                    a = [];
                  Vo.flattenJSON(n, s, a, i),
                    0 !== s.length && r.push(new t(e, s, a));
                }
              },
              i = [],
              r = t.name || "default",
              s = t.fps || 30,
              a = t.blendMode;
            let o = t.length || -1;
            const l = t.hierarchy || [];
            for (let t = 0; t < l.length; t++) {
              const r = l[t].keys;
              if (r && 0 !== r.length)
                if (r[0].morphTargets) {
                  const t = {};
                  let e;
                  for (e = 0; e < r.length; e++)
                    if (r[e].morphTargets)
                      for (let n = 0; n < r[e].morphTargets.length; n++)
                        t[r[e].morphTargets[n]] = -1;
                  for (const n in t) {
                    const t = [],
                      s = [];
                    for (let i = 0; i !== r[e].morphTargets.length; ++i) {
                      const i = r[e];
                      t.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                    }
                    i.push(new Qo(".morphTargetInfluence[" + n + "]", t, s));
                  }
                  o = t.length * (s || 1);
                } else {
                  const s = ".bones[" + e[t].name + "]";
                  n(el, s + ".position", r, "pos", i),
                    n($o, s + ".quaternion", r, "rot", i),
                    n(el, s + ".scale", r, "scl", i);
                }
            }
            if (0 === i.length) return null;
            return new this(r, o, i, a);
          }
          resetDuration() {
            let t = 0;
            for (let e = 0, n = this.tracks.length; e !== n; ++e) {
              const n = this.tracks[e];
              t = Math.max(t, n.times[n.times.length - 1]);
            }
            return (this.duration = t), this;
          }
          trim() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].trim(0, this.duration);
            return this;
          }
          validate() {
            let t = !0;
            for (let e = 0; e < this.tracks.length; e++)
              t = t && this.tracks[e].validate();
            return t;
          }
          optimize() {
            for (let t = 0; t < this.tracks.length; t++)
              this.tracks[t].optimize();
            return this;
          }
          clone() {
            const t = [];
            for (let e = 0; e < this.tracks.length; e++)
              t.push(this.tracks[e].clone());
            return new this.constructor(
              this.name,
              this.duration,
              t,
              this.blendMode
            );
          }
          toJSON() {
            return this.constructor.toJSON(this);
          }
        }
        function il(t) {
          if (void 0 === t.type)
            throw new Error(
              "THREE.KeyframeTrack: track type undefined, can not parse"
            );
          const e = (function (t) {
            switch (t.toLowerCase()) {
              case "scalar":
              case "double":
              case "float":
              case "number":
              case "integer":
                return Qo;
              case "vector":
              case "vector2":
              case "vector3":
              case "vector4":
                return el;
              case "color":
                return Jo;
              case "quaternion":
                return $o;
              case "bool":
              case "boolean":
                return Zo;
              case "string":
                return tl;
            }
            throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t);
          })(t.type);
          if (void 0 === t.times) {
            const e = [],
              n = [];
            Vo.flattenJSON(t.keys, e, n, "value"),
              (t.times = e),
              (t.values = n);
          }
          return void 0 !== e.parse
            ? e.parse(t)
            : new e(t.name, t.times, t.values, t.interpolation);
        }
        const rl = {
          enabled: !1,
          files: {},
          add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e);
          },
          get: function (t) {
            if (!1 !== this.enabled) return this.files[t];
          },
          remove: function (t) {
            delete this.files[t];
          },
          clear: function () {
            this.files = {};
          },
        };
        class sl {
          constructor(t, e, n) {
            const i = this;
            let r,
              s = !1,
              a = 0,
              o = 0;
            const l = [];
            (this.onStart = void 0),
              (this.onLoad = t),
              (this.onProgress = e),
              (this.onError = n),
              (this.itemStart = function (t) {
                o++,
                  !1 === s && void 0 !== i.onStart && i.onStart(t, a, o),
                  (s = !0);
              }),
              (this.itemEnd = function (t) {
                a++,
                  void 0 !== i.onProgress && i.onProgress(t, a, o),
                  a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
              }),
              (this.itemError = function (t) {
                void 0 !== i.onError && i.onError(t);
              }),
              (this.resolveURL = function (t) {
                return r ? r(t) : t;
              }),
              (this.setURLModifier = function (t) {
                return (r = t), this;
              }),
              (this.addHandler = function (t, e) {
                return l.push(t, e), this;
              }),
              (this.removeHandler = function (t) {
                const e = l.indexOf(t);
                return -1 !== e && l.splice(e, 2), this;
              }),
              (this.getHandler = function (t) {
                for (let e = 0, n = l.length; e < n; e += 2) {
                  const n = l[e],
                    i = l[e + 1];
                  if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
                }
                return null;
              });
          }
        }
        const al = new sl();
        class ol {
          constructor(t) {
            (this.manager = void 0 !== t ? t : al),
              (this.crossOrigin = "anonymous"),
              (this.withCredentials = !1),
              (this.path = ""),
              (this.resourcePath = ""),
              (this.requestHeader = {});
          }
          load() {}
          loadAsync(t, e) {
            const n = this;
            return new Promise(function (i, r) {
              n.load(t, i, e, r);
            });
          }
          parse() {}
          setCrossOrigin(t) {
            return (this.crossOrigin = t), this;
          }
          setWithCredentials(t) {
            return (this.withCredentials = t), this;
          }
          setPath(t) {
            return (this.path = t), this;
          }
          setResourcePath(t) {
            return (this.resourcePath = t), this;
          }
          setRequestHeader(t) {
            return (this.requestHeader = t), this;
          }
        }
        const ll = {};
        class cl extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              s = rl.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            if (void 0 !== ll[t])
              return void ll[t].push({ onLoad: e, onProgress: n, onError: i });
            const a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
            let o;
            if (a) {
              const n = a[1],
                s = !!a[2];
              let o = a[3];
              (o = decodeURIComponent(o)), s && (o = atob(o));
              try {
                let i;
                const s = (this.responseType || "").toLowerCase();
                switch (s) {
                  case "arraybuffer":
                  case "blob":
                    const t = new Uint8Array(o.length);
                    for (let e = 0; e < o.length; e++) t[e] = o.charCodeAt(e);
                    i =
                      "blob" === s
                        ? new Blob([t.buffer], { type: n })
                        : t.buffer;
                    break;
                  case "document":
                    const e = new DOMParser();
                    i = e.parseFromString(o, n);
                    break;
                  case "json":
                    i = JSON.parse(o);
                    break;
                  default:
                    i = o;
                }
                setTimeout(function () {
                  e && e(i), r.manager.itemEnd(t);
                }, 0);
              } catch (e) {
                setTimeout(function () {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                }, 0);
              }
            } else {
              (ll[t] = []),
                ll[t].push({ onLoad: e, onProgress: n, onError: i }),
                (o = new XMLHttpRequest()),
                o.open("GET", t, !0),
                o.addEventListener(
                  "load",
                  function (e) {
                    const n = this.response,
                      i = ll[t];
                    if (
                      (delete ll[t], 200 === this.status || 0 === this.status)
                    ) {
                      0 === this.status &&
                        console.warn(
                          "THREE.FileLoader: HTTP Status 0 received."
                        ),
                        rl.add(t, n);
                      for (let t = 0, e = i.length; t < e; t++) {
                        const e = i[t];
                        e.onLoad && e.onLoad(n);
                      }
                      r.manager.itemEnd(t);
                    } else {
                      for (let t = 0, n = i.length; t < n; t++) {
                        const n = i[t];
                        n.onError && n.onError(e);
                      }
                      r.manager.itemError(t), r.manager.itemEnd(t);
                    }
                  },
                  !1
                ),
                o.addEventListener(
                  "progress",
                  function (e) {
                    const n = ll[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t];
                      i.onProgress && i.onProgress(e);
                    }
                  },
                  !1
                ),
                o.addEventListener(
                  "error",
                  function (e) {
                    const n = ll[t];
                    delete ll[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t];
                      i.onError && i.onError(e);
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t);
                  },
                  !1
                ),
                o.addEventListener(
                  "abort",
                  function (e) {
                    const n = ll[t];
                    delete ll[t];
                    for (let t = 0, i = n.length; t < i; t++) {
                      const i = n[t];
                      i.onError && i.onError(e);
                    }
                    r.manager.itemError(t), r.manager.itemEnd(t);
                  },
                  !1
                ),
                void 0 !== this.responseType &&
                  (o.responseType = this.responseType),
                void 0 !== this.withCredentials &&
                  (o.withCredentials = this.withCredentials),
                o.overrideMimeType &&
                  o.overrideMimeType(
                    void 0 !== this.mimeType ? this.mimeType : "text/plain"
                  );
              for (const t in this.requestHeader)
                o.setRequestHeader(t, this.requestHeader[t]);
              o.send(null);
            }
            return r.manager.itemStart(t), o;
          }
          setResponseType(t) {
            return (this.responseType = t), this;
          }
          setMimeType(t) {
            return (this.mimeType = t), this;
          }
        }
        class hl extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              s = rl.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            const a = document.createElementNS(
              "http://www.w3.org/1999/xhtml",
              "img"
            );
            function o() {
              a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1),
                rl.add(t, this),
                e && e(this),
                r.manager.itemEnd(t);
            }
            function l(e) {
              a.removeEventListener("load", o, !1),
                a.removeEventListener("error", l, !1),
                i && i(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t);
            }
            return (
              a.addEventListener("load", o, !1),
              a.addEventListener("error", l, !1),
              "data:" !== t.substr(0, 5) &&
                void 0 !== this.crossOrigin &&
                (a.crossOrigin = this.crossOrigin),
              r.manager.itemStart(t),
              (a.src = t),
              a
            );
          }
        }
        class ul extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = new ei(),
              s = new hl(this.manager);
            s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
            let a = 0;
            function o(n) {
              s.load(
                t[n],
                function (t) {
                  (r.images[n] = t),
                    a++,
                    6 === a && ((r.needsUpdate = !0), e && e(r));
                },
                void 0,
                i
              );
            }
            for (let e = 0; e < t.length; ++e) o(e);
            return r;
          }
        }
        class dl extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              s = new ii(),
              a = new cl(this.manager);
            return (
              a.setResponseType("arraybuffer"),
              a.setRequestHeader(this.requestHeader),
              a.setPath(this.path),
              a.setWithCredentials(r.withCredentials),
              a.load(
                t,
                function (t) {
                  const n = r.parse(t);
                  n &&
                    (void 0 !== n.image
                      ? (s.image = n.image)
                      : void 0 !== n.data &&
                        ((s.image.width = n.width),
                        (s.image.height = n.height),
                        (s.image.data = n.data)),
                    (s.wrapS = void 0 !== n.wrapS ? n.wrapS : u),
                    (s.wrapT = void 0 !== n.wrapT ? n.wrapT : u),
                    (s.magFilter = void 0 !== n.magFilter ? n.magFilter : g),
                    (s.minFilter = void 0 !== n.minFilter ? n.minFilter : g),
                    (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                    void 0 !== n.encoding && (s.encoding = n.encoding),
                    void 0 !== n.flipY && (s.flipY = n.flipY),
                    void 0 !== n.format && (s.format = n.format),
                    void 0 !== n.type && (s.type = n.type),
                    void 0 !== n.mipmaps &&
                      ((s.mipmaps = n.mipmaps), (s.minFilter = y)),
                    1 === n.mipmapCount && (s.minFilter = g),
                    void 0 !== n.generateMipmaps &&
                      (s.generateMipmaps = n.generateMipmaps),
                    (s.needsUpdate = !0),
                    e && e(s, n));
                },
                n,
                i
              ),
              s
            );
          }
        }
        class pl extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = new bt(),
              s = new hl(this.manager);
            return (
              s.setCrossOrigin(this.crossOrigin),
              s.setPath(this.path),
              s.load(
                t,
                function (n) {
                  r.image = n;
                  const i =
                    t.search(/\.jpe?g($|\?)/i) > 0 ||
                    0 === t.search(/^data\:image\/jpeg/);
                  (r.format = i ? T : E),
                    (r.needsUpdate = !0),
                    void 0 !== e && e(r);
                },
                n,
                i
              ),
              r
            );
          }
        }
        class ml {
          constructor() {
            (this.type = "Curve"), (this.arcLengthDivisions = 200);
          }
          getPoint() {
            return (
              console.warn("THREE.Curve: .getPoint() not implemented."), null
            );
          }
          getPointAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getPoint(n, e);
          }
          getPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return e;
          }
          getSpacedPoints(t = 5) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
            return e;
          }
          getLength() {
            const t = this.getLengths();
            return t[t.length - 1];
          }
          getLengths(t = this.arcLengthDivisions) {
            if (
              this.cacheArcLengths &&
              this.cacheArcLengths.length === t + 1 &&
              !this.needsUpdate
            )
              return this.cacheArcLengths;
            this.needsUpdate = !1;
            const e = [];
            let n,
              i = this.getPoint(0),
              r = 0;
            e.push(0);
            for (let s = 1; s <= t; s++)
              (n = this.getPoint(s / t)),
                (r += n.distanceTo(i)),
                e.push(r),
                (i = n);
            return (this.cacheArcLengths = e), e;
          }
          updateArcLengths() {
            (this.needsUpdate = !0), this.getLengths();
          }
          getUtoTmapping(t, e) {
            const n = this.getLengths();
            let i = 0;
            const r = n.length;
            let s;
            s = e || t * n[r - 1];
            let a,
              o = 0,
              l = r - 1;
            for (; o <= l; )
              if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0))
                o = i + 1;
              else {
                if (!(a > 0)) {
                  l = i;
                  break;
                }
                l = i - 1;
              }
            if (((i = l), n[i] === s)) return i / (r - 1);
            const c = n[i];
            return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
          }
          getTangent(t, e) {
            const n = 1e-4;
            let i = t - n,
              r = t + n;
            i < 0 && (i = 0), r > 1 && (r = 1);
            const s = this.getPoint(i),
              a = this.getPoint(r),
              o = e || (s.isVector2 ? new vt() : new Lt());
            return o.copy(a).sub(s).normalize(), o;
          }
          getTangentAt(t, e) {
            const n = this.getUtoTmapping(t);
            return this.getTangent(n, e);
          }
          computeFrenetFrames(t, e) {
            const n = new Lt(),
              i = [],
              r = [],
              s = [],
              a = new Lt(),
              o = new se();
            for (let e = 0; e <= t; e++) {
              const n = e / t;
              (i[e] = this.getTangentAt(n, new Lt())), i[e].normalize();
            }
            (r[0] = new Lt()), (s[0] = new Lt());
            let l = Number.MAX_VALUE;
            const c = Math.abs(i[0].x),
              h = Math.abs(i[0].y),
              u = Math.abs(i[0].z);
            c <= l && ((l = c), n.set(1, 0, 0)),
              h <= l && ((l = h), n.set(0, 1, 0)),
              u <= l && n.set(0, 0, 1),
              a.crossVectors(i[0], n).normalize(),
              r[0].crossVectors(i[0], a),
              s[0].crossVectors(i[0], r[0]);
            for (let e = 1; e <= t; e++) {
              if (
                ((r[e] = r[e - 1].clone()),
                (s[e] = s[e - 1].clone()),
                a.crossVectors(i[e - 1], i[e]),
                a.length() > Number.EPSILON)
              ) {
                a.normalize();
                const t = Math.acos(ht(i[e - 1].dot(i[e]), -1, 1));
                r[e].applyMatrix4(o.makeRotationAxis(a, t));
              }
              s[e].crossVectors(i[e], r[e]);
            }
            if (!0 === e) {
              let e = Math.acos(ht(r[0].dot(r[t]), -1, 1));
              (e /= t), i[0].dot(a.crossVectors(r[0], r[t])) > 0 && (e = -e);
              for (let n = 1; n <= t; n++)
                r[n].applyMatrix4(o.makeRotationAxis(i[n], e * n)),
                  s[n].crossVectors(i[n], r[n]);
            }
            return { tangents: i, normals: r, binormals: s };
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
          toJSON() {
            const t = {
              metadata: {
                version: 4.5,
                type: "Curve",
                generator: "Curve.toJSON",
              },
            };
            return (
              (t.arcLengthDivisions = this.arcLengthDivisions),
              (t.type = this.type),
              t
            );
          }
          fromJSON(t) {
            return (this.arcLengthDivisions = t.arcLengthDivisions), this;
          }
        }
        class fl extends ml {
          constructor(
            t = 0,
            e = 0,
            n = 1,
            i = 1,
            r = 0,
            s = 2 * Math.PI,
            a = !1,
            o = 0
          ) {
            super(),
              (this.type = "EllipseCurve"),
              (this.aX = t),
              (this.aY = e),
              (this.xRadius = n),
              (this.yRadius = i),
              (this.aStartAngle = r),
              (this.aEndAngle = s),
              (this.aClockwise = a),
              (this.aRotation = o);
          }
          getPoint(t, e) {
            const n = e || new vt(),
              i = 2 * Math.PI;
            let r = this.aEndAngle - this.aStartAngle;
            const s = Math.abs(r) < Number.EPSILON;
            for (; r < 0; ) r += i;
            for (; r > i; ) r -= i;
            r < Number.EPSILON && (r = s ? 0 : i),
              !0 !== this.aClockwise || s || (r === i ? (r = -i) : (r -= i));
            const a = this.aStartAngle + t * r;
            let o = this.aX + this.xRadius * Math.cos(a),
              l = this.aY + this.yRadius * Math.sin(a);
            if (0 !== this.aRotation) {
              const t = Math.cos(this.aRotation),
                e = Math.sin(this.aRotation),
                n = o - this.aX,
                i = l - this.aY;
              (o = n * t - i * e + this.aX), (l = n * e + i * t + this.aY);
            }
            return n.set(o, l);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.aX = this.aX),
              (t.aY = this.aY),
              (t.xRadius = this.xRadius),
              (t.yRadius = this.yRadius),
              (t.aStartAngle = this.aStartAngle),
              (t.aEndAngle = this.aEndAngle),
              (t.aClockwise = this.aClockwise),
              (t.aRotation = this.aRotation),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              (this.aX = t.aX),
              (this.aY = t.aY),
              (this.xRadius = t.xRadius),
              (this.yRadius = t.yRadius),
              (this.aStartAngle = t.aStartAngle),
              (this.aEndAngle = t.aEndAngle),
              (this.aClockwise = t.aClockwise),
              (this.aRotation = t.aRotation),
              this
            );
          }
        }
        fl.prototype.isEllipseCurve = !0;
        class gl extends fl {
          constructor(t, e, n, i, r, s) {
            super(t, e, n, n, i, r, s), (this.type = "ArcCurve");
          }
        }
        function vl() {
          let t = 0,
            e = 0,
            n = 0,
            i = 0;
          function r(r, s, a, o) {
            (t = r),
              (e = a),
              (n = -3 * r + 3 * s - 2 * a - o),
              (i = 2 * r - 2 * s + a + o);
          }
          return {
            initCatmullRom: function (t, e, n, i, s) {
              r(e, n, s * (n - t), s * (i - e));
            },
            initNonuniformCatmullRom: function (t, e, n, i, s, a, o) {
              let l = (e - t) / s - (n - t) / (s + a) + (n - e) / a,
                c = (n - e) / a - (i - e) / (a + o) + (i - n) / o;
              (l *= a), (c *= a), r(e, n, l, c);
            },
            calc: function (r) {
              const s = r * r;
              return t + e * r + n * s + i * (s * r);
            },
          };
        }
        gl.prototype.isArcCurve = !0;
        const yl = new Lt(),
          xl = new vl(),
          _l = new vl(),
          wl = new vl();
        class bl extends ml {
          constructor(t = [], e = !1, n = "centripetal", i = 0.5) {
            super(),
              (this.type = "CatmullRomCurve3"),
              (this.points = t),
              (this.closed = e),
              (this.curveType = n),
              (this.tension = i);
          }
          getPoint(t, e = new Lt()) {
            const n = e,
              i = this.points,
              r = i.length,
              s = (r - (this.closed ? 0 : 1)) * t;
            let a,
              o,
              l = Math.floor(s),
              c = s - l;
            this.closed
              ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r)
              : 0 === c && l === r - 1 && ((l = r - 2), (c = 1)),
              this.closed || l > 0
                ? (a = i[(l - 1) % r])
                : (yl.subVectors(i[0], i[1]).add(i[0]), (a = yl));
            const h = i[l % r],
              u = i[(l + 1) % r];
            if (
              (this.closed || l + 2 < r
                ? (o = i[(l + 2) % r])
                : (yl.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]), (o = yl)),
              "centripetal" === this.curveType || "chordal" === this.curveType)
            ) {
              const t = "chordal" === this.curveType ? 0.5 : 0.25;
              let e = Math.pow(a.distanceToSquared(h), t),
                n = Math.pow(h.distanceToSquared(u), t),
                i = Math.pow(u.distanceToSquared(o), t);
              n < 1e-4 && (n = 1),
                e < 1e-4 && (e = n),
                i < 1e-4 && (i = n),
                xl.initNonuniformCatmullRom(a.x, h.x, u.x, o.x, e, n, i),
                _l.initNonuniformCatmullRom(a.y, h.y, u.y, o.y, e, n, i),
                wl.initNonuniformCatmullRom(a.z, h.z, u.z, o.z, e, n, i);
            } else "catmullrom" === this.curveType && (xl.initCatmullRom(a.x, h.x, u.x, o.x, this.tension), _l.initCatmullRom(a.y, h.y, u.y, o.y, this.tension), wl.initCatmullRom(a.z, h.z, u.z, o.z, this.tension));
            return n.set(xl.calc(c), _l.calc(c), wl.calc(c)), n;
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return (
              (t.closed = this.closed),
              (t.curveType = this.curveType),
              (t.tension = this.tension),
              t
            );
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new Lt().fromArray(n));
            }
            return (
              (this.closed = t.closed),
              (this.curveType = t.curveType),
              (this.tension = t.tension),
              this
            );
          }
        }
        function Ml(t, e, n, i, r) {
          const s = 0.5 * (i - e),
            a = 0.5 * (r - n),
            o = t * t;
          return (
            (2 * n - 2 * i + s + a) * (t * o) +
            (-3 * n + 3 * i - 2 * s - a) * o +
            s * t +
            n
          );
        }
        function Sl(t, e, n, i) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * e;
            })(t, e) +
            (function (t, e) {
              return 2 * (1 - t) * t * e;
            })(t, n) +
            (function (t, e) {
              return t * t * e;
            })(t, i)
          );
        }
        function Tl(t, e, n, i, r) {
          return (
            (function (t, e) {
              const n = 1 - t;
              return n * n * n * e;
            })(t, e) +
            (function (t, e) {
              const n = 1 - t;
              return 3 * n * n * t * e;
            })(t, n) +
            (function (t, e) {
              return 3 * (1 - t) * t * t * e;
            })(t, i) +
            (function (t, e) {
              return t * t * t * e;
            })(t, r)
          );
        }
        bl.prototype.isCatmullRomCurve3 = !0;
        class El extends ml {
          constructor(t = new vt(), e = new vt(), n = new vt(), i = new vt()) {
            super(),
              (this.type = "CubicBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = i);
          }
          getPoint(t, e = new vt()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2,
              a = this.v3;
            return (
              n.set(Tl(t, i.x, r.x, s.x, a.x), Tl(t, i.y, r.y, s.y, a.y)), n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        El.prototype.isCubicBezierCurve = !0;
        class Al extends ml {
          constructor(t = new Lt(), e = new Lt(), n = new Lt(), i = new Lt()) {
            super(),
              (this.type = "CubicBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n),
              (this.v3 = i);
          }
          getPoint(t, e = new Lt()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2,
              a = this.v3;
            return (
              n.set(
                Tl(t, i.x, r.x, s.x, a.x),
                Tl(t, i.y, r.y, s.y, a.y),
                Tl(t, i.z, r.z, s.z, a.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this.v3.copy(t.v3),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              (t.v3 = this.v3.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this.v3.fromArray(t.v3),
              this
            );
          }
        }
        Al.prototype.isCubicBezierCurve3 = !0;
        class Ll extends ml {
          constructor(t = new vt(), e = new vt()) {
            super(), (this.type = "LineCurve"), (this.v1 = t), (this.v2 = e);
          }
          getPoint(t, e = new vt()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          getTangent(t, e) {
            const n = e || new vt();
            return n.copy(this.v2).sub(this.v1).normalize(), n;
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Ll.prototype.isLineCurve = !0;
        class Rl extends ml {
          constructor(t = new Lt(), e = new Lt()) {
            super(),
              (this.type = "LineCurve3"),
              (this.isLineCurve3 = !0),
              (this.v1 = t),
              (this.v2 = e);
          }
          getPoint(t, e = new Lt()) {
            const n = e;
            return (
              1 === t
                ? n.copy(this.v2)
                : (n.copy(this.v2).sub(this.v1),
                  n.multiplyScalar(t).add(this.v1)),
              n
            );
          }
          getPointAt(t, e) {
            return this.getPoint(t, e);
          }
          copy(t) {
            return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        class Cl extends ml {
          constructor(t = new vt(), e = new vt(), n = new vt()) {
            super(),
              (this.type = "QuadraticBezierCurve"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new vt()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2;
            return n.set(Sl(t, i.x, r.x, s.x), Sl(t, i.y, r.y, s.y)), n;
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Cl.prototype.isQuadraticBezierCurve = !0;
        class Pl extends ml {
          constructor(t = new Lt(), e = new Lt(), n = new Lt()) {
            super(),
              (this.type = "QuadraticBezierCurve3"),
              (this.v0 = t),
              (this.v1 = e),
              (this.v2 = n);
          }
          getPoint(t, e = new Lt()) {
            const n = e,
              i = this.v0,
              r = this.v1,
              s = this.v2;
            return (
              n.set(
                Sl(t, i.x, r.x, s.x),
                Sl(t, i.y, r.y, s.y),
                Sl(t, i.z, r.z, s.z)
              ),
              n
            );
          }
          copy(t) {
            return (
              super.copy(t),
              this.v0.copy(t.v0),
              this.v1.copy(t.v1),
              this.v2.copy(t.v2),
              this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.v0 = this.v0.toArray()),
              (t.v1 = this.v1.toArray()),
              (t.v2 = this.v2.toArray()),
              t
            );
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.v0.fromArray(t.v0),
              this.v1.fromArray(t.v1),
              this.v2.fromArray(t.v2),
              this
            );
          }
        }
        Pl.prototype.isQuadraticBezierCurve3 = !0;
        class Dl extends ml {
          constructor(t = []) {
            super(), (this.type = "SplineCurve"), (this.points = t);
          }
          getPoint(t, e = new vt()) {
            const n = e,
              i = this.points,
              r = (i.length - 1) * t,
              s = Math.floor(r),
              a = r - s,
              o = i[0 === s ? s : s - 1],
              l = i[s],
              c = i[s > i.length - 2 ? i.length - 1 : s + 1],
              h = i[s > i.length - 3 ? i.length - 1 : s + 2];
            return (
              n.set(Ml(a, o.x, l.x, c.x, h.x), Ml(a, o.y, l.y, c.y, h.y)), n
            );
          }
          copy(t) {
            super.copy(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            t.points = [];
            for (let e = 0, n = this.points.length; e < n; e++) {
              const n = this.points[e];
              t.points.push(n.toArray());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.points = []);
            for (let e = 0, n = t.points.length; e < n; e++) {
              const n = t.points[e];
              this.points.push(new vt().fromArray(n));
            }
            return this;
          }
        }
        Dl.prototype.isSplineCurve = !0;
        var Il = Object.freeze({
          __proto__: null,
          ArcCurve: gl,
          CatmullRomCurve3: bl,
          CubicBezierCurve: El,
          CubicBezierCurve3: Al,
          EllipseCurve: fl,
          LineCurve: Ll,
          LineCurve3: Rl,
          QuadraticBezierCurve: Cl,
          QuadraticBezierCurve3: Pl,
          SplineCurve: Dl,
        });
        class Nl extends ml {
          constructor() {
            super(),
              (this.type = "CurvePath"),
              (this.curves = []),
              (this.autoClose = !1);
          }
          add(t) {
            this.curves.push(t);
          }
          closePath() {
            const t = this.curves[0].getPoint(0),
              e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new Ll(e, t));
          }
          getPoint(t) {
            const e = t * this.getLength(),
              n = this.getCurveLengths();
            let i = 0;
            for (; i < n.length; ) {
              if (n[i] >= e) {
                const t = n[i] - e,
                  r = this.curves[i],
                  s = r.getLength(),
                  a = 0 === s ? 0 : 1 - t / s;
                return r.getPointAt(a);
              }
              i++;
            }
            return null;
          }
          getLength() {
            const t = this.getCurveLengths();
            return t[t.length - 1];
          }
          updateArcLengths() {
            (this.needsUpdate = !0),
              (this.cacheLengths = null),
              this.getCurveLengths();
          }
          getCurveLengths() {
            if (
              this.cacheLengths &&
              this.cacheLengths.length === this.curves.length
            )
              return this.cacheLengths;
            const t = [];
            let e = 0;
            for (let n = 0, i = this.curves.length; n < i; n++)
              (e += this.curves[n].getLength()), t.push(e);
            return (this.cacheLengths = t), t;
          }
          getSpacedPoints(t = 40) {
            const e = [];
            for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
            return this.autoClose && e.push(e[0]), e;
          }
          getPoints(t = 12) {
            const e = [];
            let n;
            for (let i = 0, r = this.curves; i < r.length; i++) {
              const s = r[i],
                a =
                  s && s.isEllipseCurve
                    ? 2 * t
                    : s && (s.isLineCurve || s.isLineCurve3)
                    ? 1
                    : s && s.isSplineCurve
                    ? t * s.points.length
                    : t,
                o = s.getPoints(a);
              for (let t = 0; t < o.length; t++) {
                const i = o[t];
                (n && n.equals(i)) || (e.push(i), (n = i));
              }
            }
            return (
              this.autoClose &&
                e.length > 1 &&
                !e[e.length - 1].equals(e[0]) &&
                e.push(e[0]),
              e
            );
          }
          copy(t) {
            super.copy(t), (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(n.clone());
            }
            return (this.autoClose = t.autoClose), this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.autoClose = this.autoClose), (t.curves = []);
            for (let e = 0, n = this.curves.length; e < n; e++) {
              const n = this.curves[e];
              t.curves.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t),
              (this.autoClose = t.autoClose),
              (this.curves = []);
            for (let e = 0, n = t.curves.length; e < n; e++) {
              const n = t.curves[e];
              this.curves.push(new Il[n.type]().fromJSON(n));
            }
            return this;
          }
        }
        class Bl extends Nl {
          constructor(t) {
            super(),
              (this.type = "Path"),
              (this.currentPoint = new vt()),
              t && this.setFromPoints(t);
          }
          setFromPoints(t) {
            this.moveTo(t[0].x, t[0].y);
            for (let e = 1, n = t.length; e < n; e++)
              this.lineTo(t[e].x, t[e].y);
            return this;
          }
          moveTo(t, e) {
            return this.currentPoint.set(t, e), this;
          }
          lineTo(t, e) {
            const n = new Ll(this.currentPoint.clone(), new vt(t, e));
            return this.curves.push(n), this.currentPoint.set(t, e), this;
          }
          quadraticCurveTo(t, e, n, i) {
            const r = new Cl(
              this.currentPoint.clone(),
              new vt(t, e),
              new vt(n, i)
            );
            return this.curves.push(r), this.currentPoint.set(n, i), this;
          }
          bezierCurveTo(t, e, n, i, r, s) {
            const a = new El(
              this.currentPoint.clone(),
              new vt(t, e),
              new vt(n, i),
              new vt(r, s)
            );
            return this.curves.push(a), this.currentPoint.set(r, s), this;
          }
          splineThru(t) {
            const e = [this.currentPoint.clone()].concat(t),
              n = new Dl(e);
            return (
              this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
            );
          }
          arc(t, e, n, i, r, s) {
            const a = this.currentPoint.x,
              o = this.currentPoint.y;
            return this.absarc(t + a, e + o, n, i, r, s), this;
          }
          absarc(t, e, n, i, r, s) {
            return this.absellipse(t, e, n, n, i, r, s), this;
          }
          ellipse(t, e, n, i, r, s, a, o) {
            const l = this.currentPoint.x,
              c = this.currentPoint.y;
            return this.absellipse(t + l, e + c, n, i, r, s, a, o), this;
          }
          absellipse(t, e, n, i, r, s, a, o) {
            const l = new fl(t, e, n, i, r, s, a, o);
            if (this.curves.length > 0) {
              const t = l.getPoint(0);
              t.equals(this.currentPoint) || this.lineTo(t.x, t.y);
            }
            this.curves.push(l);
            const c = l.getPoint(1);
            return this.currentPoint.copy(c), this;
          }
          copy(t) {
            return super.copy(t), this.currentPoint.copy(t.currentPoint), this;
          }
          toJSON() {
            const t = super.toJSON();
            return (t.currentPoint = this.currentPoint.toArray()), t;
          }
          fromJSON(t) {
            return (
              super.fromJSON(t),
              this.currentPoint.fromArray(t.currentPoint),
              this
            );
          }
        }
        class zl extends Bl {
          constructor(t) {
            super(t),
              (this.uuid = ct()),
              (this.type = "Shape"),
              (this.holes = []);
          }
          getPointsHoles(t) {
            const e = [];
            for (let n = 0, i = this.holes.length; n < i; n++)
              e[n] = this.holes[n].getPoints(t);
            return e;
          }
          extractPoints(t) {
            return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
          }
          copy(t) {
            super.copy(t), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(n.clone());
            }
            return this;
          }
          toJSON() {
            const t = super.toJSON();
            (t.uuid = this.uuid), (t.holes = []);
            for (let e = 0, n = this.holes.length; e < n; e++) {
              const n = this.holes[e];
              t.holes.push(n.toJSON());
            }
            return t;
          }
          fromJSON(t) {
            super.fromJSON(t), (this.uuid = t.uuid), (this.holes = []);
            for (let e = 0, n = t.holes.length; e < n; e++) {
              const n = t.holes[e];
              this.holes.push(new Bl().fromJSON(n));
            }
            return this;
          }
        }
        class Fl extends Ce {
          constructor(t, e = 1) {
            super(),
              (this.type = "Light"),
              (this.color = new tn(t)),
              (this.intensity = e);
          }
          dispose() {}
          copy(t) {
            return (
              super.copy(t),
              this.color.copy(t.color),
              (this.intensity = t.intensity),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.color = this.color.getHex()),
              (e.object.intensity = this.intensity),
              void 0 !== this.groundColor &&
                (e.object.groundColor = this.groundColor.getHex()),
              void 0 !== this.distance && (e.object.distance = this.distance),
              void 0 !== this.angle && (e.object.angle = this.angle),
              void 0 !== this.decay && (e.object.decay = this.decay),
              void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
              void 0 !== this.shadow &&
                (e.object.shadow = this.shadow.toJSON()),
              e
            );
          }
        }
        Fl.prototype.isLight = !0;
        class Ol extends Fl {
          constructor(t, e, n) {
            super(t, n),
              (this.type = "HemisphereLight"),
              this.position.copy(Ce.DefaultUp),
              this.updateMatrix(),
              (this.groundColor = new tn(e));
          }
          copy(t) {
            return (
              Fl.prototype.copy.call(this, t),
              this.groundColor.copy(t.groundColor),
              this
            );
          }
        }
        Ol.prototype.isHemisphereLight = !0;
        const Hl = new se(),
          Gl = new Lt(),
          Ul = new Lt();
        class kl {
          constructor(t) {
            (this.camera = t),
              (this.bias = 0),
              (this.normalBias = 0),
              (this.radius = 1),
              (this.mapSize = new vt(512, 512)),
              (this.map = null),
              (this.mapPass = null),
              (this.matrix = new se()),
              (this.autoUpdate = !0),
              (this.needsUpdate = !1),
              (this._frustum = new ai()),
              (this._frameExtents = new vt(1, 1)),
              (this._viewportCount = 1),
              (this._viewports = [new St(0, 0, 1, 1)]);
          }
          getViewportCount() {
            return this._viewportCount;
          }
          getFrustum() {
            return this._frustum;
          }
          updateMatrices(t) {
            const e = this.camera,
              n = this.matrix;
            Gl.setFromMatrixPosition(t.matrixWorld),
              e.position.copy(Gl),
              Ul.setFromMatrixPosition(t.target.matrixWorld),
              e.lookAt(Ul),
              e.updateMatrixWorld(),
              Hl.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(Hl),
              n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
              n.multiply(e.projectionMatrix),
              n.multiply(e.matrixWorldInverse);
          }
          getViewport(t) {
            return this._viewports[t];
          }
          getFrameExtents() {
            return this._frameExtents;
          }
          dispose() {
            this.map && this.map.dispose(),
              this.mapPass && this.mapPass.dispose();
          }
          copy(t) {
            return (
              (this.camera = t.camera.clone()),
              (this.bias = t.bias),
              (this.radius = t.radius),
              this.mapSize.copy(t.mapSize),
              this
            );
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = {};
            return (
              0 !== this.bias && (t.bias = this.bias),
              0 !== this.normalBias && (t.normalBias = this.normalBias),
              1 !== this.radius && (t.radius = this.radius),
              (512 === this.mapSize.x && 512 === this.mapSize.y) ||
                (t.mapSize = this.mapSize.toArray()),
              (t.camera = this.camera.toJSON(!1).object),
              delete t.camera.matrix,
              t
            );
          }
        }
        class Vl extends kl {
          constructor() {
            super(new Kn(50, 1, 0.5, 500)), (this.focus = 1);
          }
          updateMatrices(t) {
            const e = this.camera,
              n = 2 * lt * t.angle * this.focus,
              i = this.mapSize.width / this.mapSize.height,
              r = t.distance || e.far;
            (n === e.fov && i === e.aspect && r === e.far) ||
              ((e.fov = n),
              (e.aspect = i),
              (e.far = r),
              e.updateProjectionMatrix()),
              super.updateMatrices(t);
          }
          copy(t) {
            return super.copy(t), (this.focus = t.focus), this;
          }
        }
        Vl.prototype.isSpotLightShadow = !0;
        class Wl extends Fl {
          constructor(t, e, n = 0, i = Math.PI / 3, r = 0, s = 1) {
            super(t, e),
              (this.type = "SpotLight"),
              this.position.copy(Ce.DefaultUp),
              this.updateMatrix(),
              (this.target = new Ce()),
              (this.distance = n),
              (this.angle = i),
              (this.penumbra = r),
              (this.decay = s),
              (this.shadow = new Vl());
          }
          get power() {
            return this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / Math.PI;
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.angle = t.angle),
              (this.penumbra = t.penumbra),
              (this.decay = t.decay),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        Wl.prototype.isSpotLight = !0;
        const jl = new se(),
          ql = new Lt(),
          Xl = new Lt();
        class Yl extends kl {
          constructor() {
            super(new Kn(90, 1, 0.5, 500)),
              (this._frameExtents = new vt(4, 2)),
              (this._viewportCount = 6),
              (this._viewports = [
                new St(2, 1, 1, 1),
                new St(0, 1, 1, 1),
                new St(3, 1, 1, 1),
                new St(1, 1, 1, 1),
                new St(3, 0, 1, 1),
                new St(1, 0, 1, 1),
              ]),
              (this._cubeDirections = [
                new Lt(1, 0, 0),
                new Lt(-1, 0, 0),
                new Lt(0, 0, 1),
                new Lt(0, 0, -1),
                new Lt(0, 1, 0),
                new Lt(0, -1, 0),
              ]),
              (this._cubeUps = [
                new Lt(0, 1, 0),
                new Lt(0, 1, 0),
                new Lt(0, 1, 0),
                new Lt(0, 1, 0),
                new Lt(0, 0, 1),
                new Lt(0, 0, -1),
              ]);
          }
          updateMatrices(t, e = 0) {
            const n = this.camera,
              i = this.matrix,
              r = t.distance || n.far;
            r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
              ql.setFromMatrixPosition(t.matrixWorld),
              n.position.copy(ql),
              Xl.copy(n.position),
              Xl.add(this._cubeDirections[e]),
              n.up.copy(this._cubeUps[e]),
              n.lookAt(Xl),
              n.updateMatrixWorld(),
              i.makeTranslation(-ql.x, -ql.y, -ql.z),
              jl.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
              this._frustum.setFromProjectionMatrix(jl);
          }
        }
        Yl.prototype.isPointLightShadow = !0;
        class Zl extends Fl {
          constructor(t, e, n = 0, i = 1) {
            super(t, e),
              (this.type = "PointLight"),
              (this.distance = n),
              (this.decay = i),
              (this.shadow = new Yl());
          }
          get power() {
            return 4 * this.intensity * Math.PI;
          }
          set power(t) {
            this.intensity = t / (4 * Math.PI);
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.distance = t.distance),
              (this.decay = t.decay),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        Zl.prototype.isPointLight = !0;
        class Jl extends Qn {
          constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
            super(),
              (this.type = "OrthographicCamera"),
              (this.zoom = 1),
              (this.view = null),
              (this.left = t),
              (this.right = e),
              (this.top = n),
              (this.bottom = i),
              (this.near = r),
              (this.far = s),
              this.updateProjectionMatrix();
          }
          copy(t, e) {
            return (
              super.copy(t, e),
              (this.left = t.left),
              (this.right = t.right),
              (this.top = t.top),
              (this.bottom = t.bottom),
              (this.near = t.near),
              (this.far = t.far),
              (this.zoom = t.zoom),
              (this.view = null === t.view ? null : Object.assign({}, t.view)),
              this
            );
          }
          setViewOffset(t, e, n, i, r, s) {
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
              (this.view.enabled = !0),
              (this.view.fullWidth = t),
              (this.view.fullHeight = e),
              (this.view.offsetX = n),
              (this.view.offsetY = i),
              (this.view.width = r),
              (this.view.height = s),
              this.updateProjectionMatrix();
          }
          clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
              this.updateProjectionMatrix();
          }
          updateProjectionMatrix() {
            const t = (this.right - this.left) / (2 * this.zoom),
              e = (this.top - this.bottom) / (2 * this.zoom),
              n = (this.right + this.left) / 2,
              i = (this.top + this.bottom) / 2;
            let r = n - t,
              s = n + t,
              a = i + e,
              o = i - e;
            if (null !== this.view && this.view.enabled) {
              const t =
                  (this.right - this.left) / this.view.fullWidth / this.zoom,
                e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
              (r += t * this.view.offsetX),
                (s = r + t * this.view.width),
                (a -= e * this.view.offsetY),
                (o = a - e * this.view.height);
            }
            this.projectionMatrix.makeOrthographic(
              r,
              s,
              a,
              o,
              this.near,
              this.far
            ),
              this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.zoom = this.zoom),
              (e.object.left = this.left),
              (e.object.right = this.right),
              (e.object.top = this.top),
              (e.object.bottom = this.bottom),
              (e.object.near = this.near),
              (e.object.far = this.far),
              null !== this.view &&
                (e.object.view = Object.assign({}, this.view)),
              e
            );
          }
        }
        Jl.prototype.isOrthographicCamera = !0;
        class Ql extends kl {
          constructor() {
            super(new Jl(-5, 5, 5, -5, 0.5, 500));
          }
        }
        Ql.prototype.isDirectionalLightShadow = !0;
        class Kl extends Fl {
          constructor(t, e) {
            super(t, e),
              (this.type = "DirectionalLight"),
              this.position.copy(Ce.DefaultUp),
              this.updateMatrix(),
              (this.target = new Ce()),
              (this.shadow = new Ql());
          }
          dispose() {
            this.shadow.dispose();
          }
          copy(t) {
            return (
              super.copy(t),
              (this.target = t.target.clone()),
              (this.shadow = t.shadow.clone()),
              this
            );
          }
        }
        Kl.prototype.isDirectionalLight = !0;
        class $l extends Fl {
          constructor(t, e) {
            super(t, e), (this.type = "AmbientLight");
          }
        }
        $l.prototype.isAmbientLight = !0;
        class tc extends Fl {
          constructor(t, e, n = 10, i = 10) {
            super(t, e),
              (this.type = "RectAreaLight"),
              (this.width = n),
              (this.height = i);
          }
          copy(t) {
            return (
              super.copy(t),
              (this.width = t.width),
              (this.height = t.height),
              this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.object.width = this.width), (e.object.height = this.height), e
            );
          }
        }
        tc.prototype.isRectAreaLight = !0;
        class ec {
          constructor() {
            this.coefficients = [];
            for (let t = 0; t < 9; t++) this.coefficients.push(new Lt());
          }
          set(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
            return this;
          }
          zero() {
            for (let t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
            return this;
          }
          getAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.coefficients;
            return (
              e.copy(s[0]).multiplyScalar(0.282095),
              e.addScaledVector(s[1], 0.488603 * i),
              e.addScaledVector(s[2], 0.488603 * r),
              e.addScaledVector(s[3], 0.488603 * n),
              e.addScaledVector(s[4], n * i * 1.092548),
              e.addScaledVector(s[5], i * r * 1.092548),
              e.addScaledVector(s[6], 0.315392 * (3 * r * r - 1)),
              e.addScaledVector(s[7], n * r * 1.092548),
              e.addScaledVector(s[8], 0.546274 * (n * n - i * i)),
              e
            );
          }
          getIrradianceAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z,
              s = this.coefficients;
            return (
              e.copy(s[0]).multiplyScalar(0.886227),
              e.addScaledVector(s[1], 1.023328 * i),
              e.addScaledVector(s[2], 1.023328 * r),
              e.addScaledVector(s[3], 1.023328 * n),
              e.addScaledVector(s[4], 0.858086 * n * i),
              e.addScaledVector(s[5], 0.858086 * i * r),
              e.addScaledVector(s[6], 0.743125 * r * r - 0.247708),
              e.addScaledVector(s[7], 0.858086 * n * r),
              e.addScaledVector(s[8], 0.429043 * (n * n - i * i)),
              e
            );
          }
          add(t) {
            for (let e = 0; e < 9; e++)
              this.coefficients[e].add(t.coefficients[e]);
            return this;
          }
          addScaledSH(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].addScaledVector(t.coefficients[n], e);
            return this;
          }
          scale(t) {
            for (let e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
            return this;
          }
          lerp(t, e) {
            for (let n = 0; n < 9; n++)
              this.coefficients[n].lerp(t.coefficients[n], e);
            return this;
          }
          equals(t) {
            for (let e = 0; e < 9; e++)
              if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
            return !0;
          }
          copy(t) {
            return this.set(t.coefficients);
          }
          clone() {
            return new this.constructor().copy(this);
          }
          fromArray(t, e = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
            return this;
          }
          toArray(t = [], e = 0) {
            const n = this.coefficients;
            for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
            return t;
          }
          static getBasisAt(t, e) {
            const n = t.x,
              i = t.y,
              r = t.z;
            (e[0] = 0.282095),
              (e[1] = 0.488603 * i),
              (e[2] = 0.488603 * r),
              (e[3] = 0.488603 * n),
              (e[4] = 1.092548 * n * i),
              (e[5] = 1.092548 * i * r),
              (e[6] = 0.315392 * (3 * r * r - 1)),
              (e[7] = 1.092548 * n * r),
              (e[8] = 0.546274 * (n * n - i * i));
          }
        }
        ec.prototype.isSphericalHarmonics3 = !0;
        class nc extends Fl {
          constructor(t = new ec(), e = 1) {
            super(void 0, e), (this.sh = t);
          }
          copy(t) {
            return super.copy(t), this.sh.copy(t.sh), this;
          }
          fromJSON(t) {
            return (
              (this.intensity = t.intensity), this.sh.fromArray(t.sh), this
            );
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (e.object.sh = this.sh.toArray()), e;
          }
        }
        nc.prototype.isLightProbe = !0;
        class ic extends ol {
          constructor(t) {
            super(t), (this.textures = {});
          }
          load(t, e, n, i) {
            const r = this,
              s = new cl(r.manager);
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i
              );
          }
          parse(t) {
            const e = this.textures;
            function n(t) {
              return (
                void 0 === e[t] &&
                  console.warn("THREE.MaterialLoader: Undefined texture", t),
                e[t]
              );
            }
            const i = new ko[t.type]();
            if (
              (void 0 !== t.uuid && (i.uuid = t.uuid),
              void 0 !== t.name && (i.name = t.name),
              void 0 !== t.color &&
                void 0 !== i.color &&
                i.color.setHex(t.color),
              void 0 !== t.roughness && (i.roughness = t.roughness),
              void 0 !== t.metalness && (i.metalness = t.metalness),
              void 0 !== t.sheen && (i.sheen = new tn().setHex(t.sheen)),
              void 0 !== t.emissive &&
                void 0 !== i.emissive &&
                i.emissive.setHex(t.emissive),
              void 0 !== t.specular &&
                void 0 !== i.specular &&
                i.specular.setHex(t.specular),
              void 0 !== t.shininess && (i.shininess = t.shininess),
              void 0 !== t.clearcoat && (i.clearcoat = t.clearcoat),
              void 0 !== t.clearcoatRoughness &&
                (i.clearcoatRoughness = t.clearcoatRoughness),
              void 0 !== t.fog && (i.fog = t.fog),
              void 0 !== t.flatShading && (i.flatShading = t.flatShading),
              void 0 !== t.blending && (i.blending = t.blending),
              void 0 !== t.combine && (i.combine = t.combine),
              void 0 !== t.side && (i.side = t.side),
              void 0 !== t.shadowSide && (i.shadowSide = t.shadowSide),
              void 0 !== t.opacity && (i.opacity = t.opacity),
              void 0 !== t.transparent && (i.transparent = t.transparent),
              void 0 !== t.alphaTest && (i.alphaTest = t.alphaTest),
              void 0 !== t.depthTest && (i.depthTest = t.depthTest),
              void 0 !== t.depthWrite && (i.depthWrite = t.depthWrite),
              void 0 !== t.colorWrite && (i.colorWrite = t.colorWrite),
              void 0 !== t.stencilWrite && (i.stencilWrite = t.stencilWrite),
              void 0 !== t.stencilWriteMask &&
                (i.stencilWriteMask = t.stencilWriteMask),
              void 0 !== t.stencilFunc && (i.stencilFunc = t.stencilFunc),
              void 0 !== t.stencilRef && (i.stencilRef = t.stencilRef),
              void 0 !== t.stencilFuncMask &&
                (i.stencilFuncMask = t.stencilFuncMask),
              void 0 !== t.stencilFail && (i.stencilFail = t.stencilFail),
              void 0 !== t.stencilZFail && (i.stencilZFail = t.stencilZFail),
              void 0 !== t.stencilZPass && (i.stencilZPass = t.stencilZPass),
              void 0 !== t.wireframe && (i.wireframe = t.wireframe),
              void 0 !== t.wireframeLinewidth &&
                (i.wireframeLinewidth = t.wireframeLinewidth),
              void 0 !== t.wireframeLinecap &&
                (i.wireframeLinecap = t.wireframeLinecap),
              void 0 !== t.wireframeLinejoin &&
                (i.wireframeLinejoin = t.wireframeLinejoin),
              void 0 !== t.rotation && (i.rotation = t.rotation),
              1 !== t.linewidth && (i.linewidth = t.linewidth),
              void 0 !== t.dashSize && (i.dashSize = t.dashSize),
              void 0 !== t.gapSize && (i.gapSize = t.gapSize),
              void 0 !== t.scale && (i.scale = t.scale),
              void 0 !== t.polygonOffset && (i.polygonOffset = t.polygonOffset),
              void 0 !== t.polygonOffsetFactor &&
                (i.polygonOffsetFactor = t.polygonOffsetFactor),
              void 0 !== t.polygonOffsetUnits &&
                (i.polygonOffsetUnits = t.polygonOffsetUnits),
              void 0 !== t.skinning && (i.skinning = t.skinning),
              void 0 !== t.morphTargets && (i.morphTargets = t.morphTargets),
              void 0 !== t.morphNormals && (i.morphNormals = t.morphNormals),
              void 0 !== t.dithering && (i.dithering = t.dithering),
              void 0 !== t.alphaToCoverage &&
                (i.alphaToCoverage = t.alphaToCoverage),
              void 0 !== t.premultipliedAlpha &&
                (i.premultipliedAlpha = t.premultipliedAlpha),
              void 0 !== t.vertexTangents &&
                (i.vertexTangents = t.vertexTangents),
              void 0 !== t.visible && (i.visible = t.visible),
              void 0 !== t.toneMapped && (i.toneMapped = t.toneMapped),
              void 0 !== t.userData && (i.userData = t.userData),
              void 0 !== t.vertexColors &&
                ("number" == typeof t.vertexColors
                  ? (i.vertexColors = t.vertexColors > 0)
                  : (i.vertexColors = t.vertexColors)),
              void 0 !== t.uniforms)
            )
              for (const e in t.uniforms) {
                const r = t.uniforms[e];
                switch (((i.uniforms[e] = {}), r.type)) {
                  case "t":
                    i.uniforms[e].value = n(r.value);
                    break;
                  case "c":
                    i.uniforms[e].value = new tn().setHex(r.value);
                    break;
                  case "v2":
                    i.uniforms[e].value = new vt().fromArray(r.value);
                    break;
                  case "v3":
                    i.uniforms[e].value = new Lt().fromArray(r.value);
                    break;
                  case "v4":
                    i.uniforms[e].value = new St().fromArray(r.value);
                    break;
                  case "m3":
                    i.uniforms[e].value = new yt().fromArray(r.value);
                    break;
                  case "m4":
                    i.uniforms[e].value = new se().fromArray(r.value);
                    break;
                  default:
                    i.uniforms[e].value = r.value;
                }
              }
            if (
              (void 0 !== t.defines && (i.defines = t.defines),
              void 0 !== t.vertexShader && (i.vertexShader = t.vertexShader),
              void 0 !== t.fragmentShader &&
                (i.fragmentShader = t.fragmentShader),
              void 0 !== t.extensions)
            )
              for (const e in t.extensions) i.extensions[e] = t.extensions[e];
            if (
              (void 0 !== t.shading && (i.flatShading = 1 === t.shading),
              void 0 !== t.size && (i.size = t.size),
              void 0 !== t.sizeAttenuation &&
                (i.sizeAttenuation = t.sizeAttenuation),
              void 0 !== t.map && (i.map = n(t.map)),
              void 0 !== t.matcap && (i.matcap = n(t.matcap)),
              void 0 !== t.alphaMap && (i.alphaMap = n(t.alphaMap)),
              void 0 !== t.bumpMap && (i.bumpMap = n(t.bumpMap)),
              void 0 !== t.bumpScale && (i.bumpScale = t.bumpScale),
              void 0 !== t.normalMap && (i.normalMap = n(t.normalMap)),
              void 0 !== t.normalMapType && (i.normalMapType = t.normalMapType),
              void 0 !== t.normalScale)
            ) {
              let e = t.normalScale;
              !1 === Array.isArray(e) && (e = [e, e]),
                (i.normalScale = new vt().fromArray(e));
            }
            return (
              void 0 !== t.displacementMap &&
                (i.displacementMap = n(t.displacementMap)),
              void 0 !== t.displacementScale &&
                (i.displacementScale = t.displacementScale),
              void 0 !== t.displacementBias &&
                (i.displacementBias = t.displacementBias),
              void 0 !== t.roughnessMap && (i.roughnessMap = n(t.roughnessMap)),
              void 0 !== t.metalnessMap && (i.metalnessMap = n(t.metalnessMap)),
              void 0 !== t.emissiveMap && (i.emissiveMap = n(t.emissiveMap)),
              void 0 !== t.emissiveIntensity &&
                (i.emissiveIntensity = t.emissiveIntensity),
              void 0 !== t.specularMap && (i.specularMap = n(t.specularMap)),
              void 0 !== t.envMap && (i.envMap = n(t.envMap)),
              void 0 !== t.envMapIntensity &&
                (i.envMapIntensity = t.envMapIntensity),
              void 0 !== t.reflectivity && (i.reflectivity = t.reflectivity),
              void 0 !== t.refractionRatio &&
                (i.refractionRatio = t.refractionRatio),
              void 0 !== t.lightMap && (i.lightMap = n(t.lightMap)),
              void 0 !== t.lightMapIntensity &&
                (i.lightMapIntensity = t.lightMapIntensity),
              void 0 !== t.aoMap && (i.aoMap = n(t.aoMap)),
              void 0 !== t.aoMapIntensity &&
                (i.aoMapIntensity = t.aoMapIntensity),
              void 0 !== t.gradientMap && (i.gradientMap = n(t.gradientMap)),
              void 0 !== t.clearcoatMap && (i.clearcoatMap = n(t.clearcoatMap)),
              void 0 !== t.clearcoatRoughnessMap &&
                (i.clearcoatRoughnessMap = n(t.clearcoatRoughnessMap)),
              void 0 !== t.clearcoatNormalMap &&
                (i.clearcoatNormalMap = n(t.clearcoatNormalMap)),
              void 0 !== t.clearcoatNormalScale &&
                (i.clearcoatNormalScale = new vt().fromArray(
                  t.clearcoatNormalScale
                )),
              void 0 !== t.transmission && (i.transmission = t.transmission),
              void 0 !== t.transmissionMap &&
                (i.transmissionMap = n(t.transmissionMap)),
              i
            );
          }
          setTextures(t) {
            return (this.textures = t), this;
          }
        }
        class rc {
          static decodeText(t) {
            if ("undefined" != typeof TextDecoder)
              return new TextDecoder().decode(t);
            let e = "";
            for (let n = 0, i = t.length; n < i; n++)
              e += String.fromCharCode(t[n]);
            try {
              return decodeURIComponent(escape(e));
            } catch (t) {
              return e;
            }
          }
          static extractUrlBase(t) {
            const e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1);
          }
        }
        class sc extends En {
          constructor() {
            super(),
              (this.type = "InstancedBufferGeometry"),
              (this.instanceCount = 1 / 0);
          }
          copy(t) {
            return super.copy(t), (this.instanceCount = t.instanceCount), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          toJSON() {
            const t = super.toJSON(this);
            return (
              (t.instanceCount = this.instanceCount),
              (t.isInstancedBufferGeometry = !0),
              t
            );
          }
        }
        sc.prototype.isInstancedBufferGeometry = !0;
        class ac extends sn {
          constructor(t, e, n, i) {
            "number" == typeof n &&
              ((i = n),
              (n = !1),
              console.error(
                "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."
              )),
              super(t, e, n),
              (this.meshPerAttribute = i || 1);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          toJSON() {
            const t = super.toJSON();
            return (
              (t.meshPerAttribute = this.meshPerAttribute),
              (t.isInstancedBufferAttribute = !0),
              t
            );
          }
        }
        ac.prototype.isInstancedBufferAttribute = !0;
        class oc extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              s = new cl(r.manager);
            s.setPath(r.path),
              s.setRequestHeader(r.requestHeader),
              s.setWithCredentials(r.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    e(r.parse(JSON.parse(n)));
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i
              );
          }
          parse(t) {
            const e = {},
              n = {};
            function i(t, i) {
              if (void 0 !== e[i]) return e[i];
              const r = t.interleavedBuffers[i],
                s = (function (t, e) {
                  if (void 0 !== n[e]) return n[e];
                  const i = t.arrayBuffers[e],
                    r = new Uint32Array(i).buffer;
                  return (n[e] = r), r;
                })(t, r.buffer),
                a = yn(r.type, s),
                o = new Es(a, r.stride);
              return (o.uuid = r.uuid), (e[i] = o), o;
            }
            const r = t.isInstancedBufferGeometry ? new sc() : new En(),
              s = t.data.index;
            if (void 0 !== s) {
              const t = yn(s.type, s.array);
              r.setIndex(new sn(t, 1));
            }
            const a = t.data.attributes;
            for (const e in a) {
              const n = a[e];
              let s;
              if (n.isInterleavedBufferAttribute) {
                const e = i(t.data, n.data);
                s = new Ls(e, n.itemSize, n.offset, n.normalized);
              } else {
                const t = yn(n.type, n.array);
                s = new (n.isInstancedBufferAttribute ? ac : sn)(
                  t,
                  n.itemSize,
                  n.normalized
                );
              }
              void 0 !== n.name && (s.name = n.name),
                void 0 !== n.usage && s.setUsage(n.usage),
                void 0 !== n.updateRange &&
                  ((s.updateRange.offset = n.updateRange.offset),
                  (s.updateRange.count = n.updateRange.count)),
                r.setAttribute(e, s);
            }
            const o = t.data.morphAttributes;
            if (o)
              for (const e in o) {
                const n = o[e],
                  s = [];
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = n[e];
                  let a;
                  if (r.isInterleavedBufferAttribute) {
                    const e = i(t.data, r.data);
                    a = new Ls(e, r.itemSize, r.offset, r.normalized);
                  } else {
                    const t = yn(r.type, r.array);
                    a = new sn(t, r.itemSize, r.normalized);
                  }
                  void 0 !== r.name && (a.name = r.name), s.push(a);
                }
                r.morphAttributes[e] = s;
              }
            t.data.morphTargetsRelative && (r.morphTargetsRelative = !0);
            const l = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== l)
              for (let t = 0, e = l.length; t !== e; ++t) {
                const e = l[t];
                r.addGroup(e.start, e.count, e.materialIndex);
              }
            const c = t.data.boundingSphere;
            if (void 0 !== c) {
              const t = new Lt();
              void 0 !== c.center && t.fromArray(c.center),
                (r.boundingSphere = new Jt(t, c.radius));
            }
            return (
              t.name && (r.name = t.name),
              t.userData && (r.userData = t.userData),
              r
            );
          }
        }
        const lc = {
            UVMapping: i,
            CubeReflectionMapping: r,
            CubeRefractionMapping: s,
            EquirectangularReflectionMapping: a,
            EquirectangularRefractionMapping: o,
            CubeUVReflectionMapping: l,
            CubeUVRefractionMapping: c,
          },
          cc = {
            RepeatWrapping: h,
            ClampToEdgeWrapping: u,
            MirroredRepeatWrapping: d,
          },
          hc = {
            NearestFilter: p,
            NearestMipmapNearestFilter: m,
            NearestMipmapLinearFilter: f,
            LinearFilter: g,
            LinearMipmapNearestFilter: v,
            LinearMipmapLinearFilter: y,
          };
        class uc extends ol {
          constructor(t) {
            super(t),
              "undefined" == typeof createImageBitmap &&
                console.warn(
                  "THREE.ImageBitmapLoader: createImageBitmap() not supported."
                ),
              "undefined" == typeof fetch &&
                console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
              (this.options = { premultiplyAlpha: "none" });
          }
          setOptions(t) {
            return (this.options = t), this;
          }
          load(t, e, n, i) {
            void 0 === t && (t = ""),
              void 0 !== this.path && (t = this.path + t),
              (t = this.manager.resolveURL(t));
            const r = this,
              s = rl.get(t);
            if (void 0 !== s)
              return (
                r.manager.itemStart(t),
                setTimeout(function () {
                  e && e(s), r.manager.itemEnd(t);
                }, 0),
                s
              );
            const a = {};
            (a.credentials =
              "anonymous" === this.crossOrigin ? "same-origin" : "include"),
              (a.headers = this.requestHeader),
              fetch(t, a)
                .then(function (t) {
                  return t.blob();
                })
                .then(function (t) {
                  return createImageBitmap(
                    t,
                    Object.assign(r.options, { colorSpaceConversion: "none" })
                  );
                })
                .then(function (n) {
                  rl.add(t, n), e && e(n), r.manager.itemEnd(t);
                })
                .catch(function (e) {
                  i && i(e), r.manager.itemError(t), r.manager.itemEnd(t);
                }),
              r.manager.itemStart(t);
          }
        }
        uc.prototype.isImageBitmapLoader = !0;
        class dc {
          constructor() {
            (this.type = "ShapePath"),
              (this.color = new tn()),
              (this.subPaths = []),
              (this.currentPath = null);
          }
          moveTo(t, e) {
            return (
              (this.currentPath = new Bl()),
              this.subPaths.push(this.currentPath),
              this.currentPath.moveTo(t, e),
              this
            );
          }
          lineTo(t, e) {
            return this.currentPath.lineTo(t, e), this;
          }
          quadraticCurveTo(t, e, n, i) {
            return this.currentPath.quadraticCurveTo(t, e, n, i), this;
          }
          bezierCurveTo(t, e, n, i, r, s) {
            return this.currentPath.bezierCurveTo(t, e, n, i, r, s), this;
          }
          splineThru(t) {
            return this.currentPath.splineThru(t), this;
          }
          toShapes(t, e) {
            function n(t) {
              const e = [];
              for (let n = 0, i = t.length; n < i; n++) {
                const i = t[n],
                  r = new zl();
                (r.curves = i.curves), e.push(r);
              }
              return e;
            }
            function i(t, e) {
              const n = e.length;
              let i = !1;
              for (let r = n - 1, s = 0; s < n; r = s++) {
                let n = e[r],
                  a = e[s],
                  o = a.x - n.x,
                  l = a.y - n.y;
                if (Math.abs(l) > Number.EPSILON) {
                  if (
                    (l < 0 && ((n = e[s]), (o = -o), (a = e[r]), (l = -l)),
                    t.y < n.y || t.y > a.y)
                  )
                    continue;
                  if (t.y === n.y) {
                    if (t.x === n.x) return !0;
                  } else {
                    const e = l * (t.x - n.x) - o * (t.y - n.y);
                    if (0 === e) return !0;
                    if (e < 0) continue;
                    i = !i;
                  }
                } else {
                  if (t.y !== n.y) continue;
                  if ((a.x <= t.x && t.x <= n.x) || (n.x <= t.x && t.x <= a.x))
                    return !0;
                }
              }
              return i;
            }
            const r = po.isClockWise,
              s = this.subPaths;
            if (0 === s.length) return [];
            if (!0 === e) return n(s);
            let a, o, l;
            const c = [];
            if (1 === s.length)
              return (
                (o = s[0]), (l = new zl()), (l.curves = o.curves), c.push(l), c
              );
            let h = !r(s[0].getPoints());
            h = t ? !h : h;
            const u = [],
              d = [];
            let p,
              m,
              f = [],
              g = 0;
            (d[g] = void 0), (f[g] = []);
            for (let e = 0, n = s.length; e < n; e++)
              (o = s[e]),
                (p = o.getPoints()),
                (a = r(p)),
                (a = t ? !a : a),
                a
                  ? (!h && d[g] && g++,
                    (d[g] = { s: new zl(), p: p }),
                    (d[g].s.curves = o.curves),
                    h && g++,
                    (f[g] = []))
                  : f[g].push({ h: o, p: p[0] });
            if (!d[0]) return n(s);
            if (d.length > 1) {
              let t = !1;
              const e = [];
              for (let t = 0, e = d.length; t < e; t++) u[t] = [];
              for (let n = 0, r = d.length; n < r; n++) {
                const r = f[n];
                for (let s = 0; s < r.length; s++) {
                  const a = r[s];
                  let o = !0;
                  for (let r = 0; r < d.length; r++)
                    i(a.p, d[r].p) &&
                      (n !== r && e.push({ froms: n, tos: r, hole: s }),
                      o ? ((o = !1), u[r].push(a)) : (t = !0));
                  o && u[n].push(a);
                }
              }
              e.length > 0 && (t || (f = u));
            }
            for (let t = 0, e = d.length; t < e; t++) {
              (l = d[t].s), c.push(l), (m = f[t]);
              for (let t = 0, e = m.length; t < e; t++) l.holes.push(m[t].h);
            }
            return c;
          }
        }
        class pc {
          constructor(t) {
            (this.type = "Font"), (this.data = t);
          }
          generateShapes(t, e = 100) {
            const n = [],
              i = (function (t, e, n) {
                const i = Array.from(t),
                  r = e / n.resolution,
                  s =
                    (n.boundingBox.yMax -
                      n.boundingBox.yMin +
                      n.underlineThickness) *
                    r,
                  a = [];
                let o = 0,
                  l = 0;
                for (let t = 0; t < i.length; t++) {
                  const e = i[t];
                  if ("\n" === e) (o = 0), (l -= s);
                  else {
                    const t = mc(e, r, o, l, n);
                    (o += t.offsetX), a.push(t.path);
                  }
                }
                return a;
              })(t, e, this.data);
            for (let t = 0, e = i.length; t < e; t++)
              Array.prototype.push.apply(n, i[t].toShapes());
            return n;
          }
        }
        function mc(t, e, n, i, r) {
          const s = r.glyphs[t] || r.glyphs["?"];
          if (!s)
            return void console.error(
              'THREE.Font: character "' +
                t +
                '" does not exists in font family ' +
                r.familyName +
                "."
            );
          const a = new dc();
          let o, l, c, h, u, d, p, m;
          if (s.o) {
            const t = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
            for (let r = 0, s = t.length; r < s; ) {
              switch (t[r++]) {
                case "m":
                  (o = t[r++] * e + n), (l = t[r++] * e + i), a.moveTo(o, l);
                  break;
                case "l":
                  (o = t[r++] * e + n), (l = t[r++] * e + i), a.lineTo(o, l);
                  break;
                case "q":
                  (c = t[r++] * e + n),
                    (h = t[r++] * e + i),
                    (u = t[r++] * e + n),
                    (d = t[r++] * e + i),
                    a.quadraticCurveTo(u, d, c, h);
                  break;
                case "b":
                  (c = t[r++] * e + n),
                    (h = t[r++] * e + i),
                    (u = t[r++] * e + n),
                    (d = t[r++] * e + i),
                    (p = t[r++] * e + n),
                    (m = t[r++] * e + i),
                    a.bezierCurveTo(u, d, p, m, c, h);
              }
            }
          }
          return { offsetX: s.ha * e, path: a };
        }
        pc.prototype.isFont = !0;
        let fc;
        const gc = {
          getContext: function () {
            return (
              void 0 === fc &&
                (fc = new (window.AudioContext || window.webkitAudioContext)()),
              fc
            );
          },
          setContext: function (t) {
            fc = t;
          },
        };
        class vc extends ol {
          constructor(t) {
            super(t);
          }
          load(t, e, n, i) {
            const r = this,
              s = new cl(this.manager);
            s.setResponseType("arraybuffer"),
              s.setPath(this.path),
              s.setRequestHeader(this.requestHeader),
              s.setWithCredentials(this.withCredentials),
              s.load(
                t,
                function (n) {
                  try {
                    const t = n.slice(0);
                    gc.getContext().decodeAudioData(t, function (t) {
                      e(t);
                    });
                  } catch (e) {
                    i ? i(e) : console.error(e), r.manager.itemError(t);
                  }
                },
                n,
                i
              );
          }
        }
        class yc extends nc {
          constructor(t, e, n = 1) {
            super(void 0, n);
            const i = new tn().set(t),
              r = new tn().set(e),
              s = new Lt(i.r, i.g, i.b),
              a = new Lt(r.r, r.g, r.b),
              o = Math.sqrt(Math.PI),
              l = o * Math.sqrt(0.75);
            this.sh.coefficients[0].copy(s).add(a).multiplyScalar(o),
              this.sh.coefficients[1].copy(s).sub(a).multiplyScalar(l);
          }
        }
        yc.prototype.isHemisphereLightProbe = !0;
        class xc extends nc {
          constructor(t, e = 1) {
            super(void 0, e);
            const n = new tn().set(t);
            this.sh.coefficients[0]
              .set(n.r, n.g, n.b)
              .multiplyScalar(2 * Math.sqrt(Math.PI));
          }
        }
        xc.prototype.isAmbientLightProbe = !0;
        const _c = new se(),
          wc = new se();
        class bc {
          constructor(t = !0) {
            (this.autoStart = t),
              (this.startTime = 0),
              (this.oldTime = 0),
              (this.elapsedTime = 0),
              (this.running = !1);
          }
          start() {
            (this.startTime = Mc()),
              (this.oldTime = this.startTime),
              (this.elapsedTime = 0),
              (this.running = !0);
          }
          stop() {
            this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
          }
          getElapsedTime() {
            return this.getDelta(), this.elapsedTime;
          }
          getDelta() {
            let t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
              const e = Mc();
              (t = (e - this.oldTime) / 1e3),
                (this.oldTime = e),
                (this.elapsedTime += t);
            }
            return t;
          }
        }
        function Mc() {
          return ("undefined" == typeof performance ? Date : performance).now();
        }
        const Sc = new Lt(),
          Tc = new At(),
          Ec = new Lt(),
          Ac = new Lt();
        class Lc extends Ce {
          constructor(t) {
            super(),
              (this.type = "Audio"),
              (this.listener = t),
              (this.context = t.context),
              (this.gain = this.context.createGain()),
              this.gain.connect(t.getInput()),
              (this.autoplay = !1),
              (this.buffer = null),
              (this.detune = 0),
              (this.loop = !1),
              (this.loopStart = 0),
              (this.loopEnd = 0),
              (this.offset = 0),
              (this.duration = void 0),
              (this.playbackRate = 1),
              (this.isPlaying = !1),
              (this.hasPlaybackControl = !0),
              (this.source = null),
              (this.sourceType = "empty"),
              (this._startedAt = 0),
              (this._progress = 0),
              (this._connected = !1),
              (this.filters = []);
          }
          getOutput() {
            return this.gain;
          }
          setNodeSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "audioNode"),
              (this.source = t),
              this.connect(),
              this
            );
          }
          setMediaElementSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaNode"),
              (this.source = this.context.createMediaElementSource(t)),
              this.connect(),
              this
            );
          }
          setMediaStreamSource(t) {
            return (
              (this.hasPlaybackControl = !1),
              (this.sourceType = "mediaStreamNode"),
              (this.source = this.context.createMediaStreamSource(t)),
              this.connect(),
              this
            );
          }
          setBuffer(t) {
            return (
              (this.buffer = t),
              (this.sourceType = "buffer"),
              this.autoplay && this.play(),
              this
            );
          }
          play(t = 0) {
            if (!0 === this.isPlaying)
              return void console.warn(
                "THREE.Audio: Audio is already playing."
              );
            if (!1 === this.hasPlaybackControl)
              return void console.warn(
                "THREE.Audio: this Audio has no playback control."
              );
            this._startedAt = this.context.currentTime + t;
            const e = this.context.createBufferSource();
            return (
              (e.buffer = this.buffer),
              (e.loop = this.loop),
              (e.loopStart = this.loopStart),
              (e.loopEnd = this.loopEnd),
              (e.onended = this.onEnded.bind(this)),
              e.start(
                this._startedAt,
                this._progress + this.offset,
                this.duration
              ),
              (this.isPlaying = !0),
              (this.source = e),
              this.setDetune(this.detune),
              this.setPlaybackRate(this.playbackRate),
              this.connect()
            );
          }
          pause() {
            if (!1 !== this.hasPlaybackControl)
              return (
                !0 === this.isPlaying &&
                  ((this._progress +=
                    Math.max(this.context.currentTime - this._startedAt, 0) *
                    this.playbackRate),
                  !0 === this.loop &&
                    (this._progress =
                      this._progress % (this.duration || this.buffer.duration)),
                  this.source.stop(),
                  (this.source.onended = null),
                  (this.isPlaying = !1)),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          stop() {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this._progress = 0),
                this.source.stop(),
                (this.source.onended = null),
                (this.isPlaying = !1),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          connect() {
            if (this.filters.length > 0) {
              this.source.connect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].connect(this.filters[t]);
              this.filters[this.filters.length - 1].connect(this.getOutput());
            } else this.source.connect(this.getOutput());
            return (this._connected = !0), this;
          }
          disconnect() {
            if (this.filters.length > 0) {
              this.source.disconnect(this.filters[0]);
              for (let t = 1, e = this.filters.length; t < e; t++)
                this.filters[t - 1].disconnect(this.filters[t]);
              this.filters[this.filters.length - 1].disconnect(
                this.getOutput()
              );
            } else this.source.disconnect(this.getOutput());
            return (this._connected = !1), this;
          }
          getFilters() {
            return this.filters;
          }
          setFilters(t) {
            return (
              t || (t = []),
              !0 === this._connected
                ? (this.disconnect(),
                  (this.filters = t.slice()),
                  this.connect())
                : (this.filters = t.slice()),
              this
            );
          }
          setDetune(t) {
            if (((this.detune = t), void 0 !== this.source.detune))
              return (
                !0 === this.isPlaying &&
                  this.source.detune.setTargetAtTime(
                    this.detune,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
          }
          getDetune() {
            return this.detune;
          }
          getFilter() {
            return this.getFilters()[0];
          }
          setFilter(t) {
            return this.setFilters(t ? [t] : []);
          }
          setPlaybackRate(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.playbackRate = t),
                !0 === this.isPlaying &&
                  this.source.playbackRate.setTargetAtTime(
                    this.playbackRate,
                    this.context.currentTime,
                    0.01
                  ),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          getPlaybackRate() {
            return this.playbackRate;
          }
          onEnded() {
            this.isPlaying = !1;
          }
          getLoop() {
            return !1 === this.hasPlaybackControl
              ? (console.warn(
                  "THREE.Audio: this Audio has no playback control."
                ),
                !1)
              : this.loop;
          }
          setLoop(t) {
            if (!1 !== this.hasPlaybackControl)
              return (
                (this.loop = t),
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this
              );
            console.warn("THREE.Audio: this Audio has no playback control.");
          }
          setLoopStart(t) {
            return (this.loopStart = t), this;
          }
          setLoopEnd(t) {
            return (this.loopEnd = t), this;
          }
          getVolume() {
            return this.gain.gain.value;
          }
          setVolume(t) {
            return (
              this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01),
              this
            );
          }
        }
        const Rc = new Lt(),
          Cc = new At(),
          Pc = new Lt(),
          Dc = new Lt();
        class Ic {
          constructor(t, e = 2048) {
            (this.analyser = t.context.createAnalyser()),
              (this.analyser.fftSize = e),
              (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
              t.getOutput().connect(this.analyser);
          }
          getFrequencyData() {
            return this.analyser.getByteFrequencyData(this.data), this.data;
          }
          getAverageFrequency() {
            let t = 0;
            const e = this.getFrequencyData();
            for (let n = 0; n < e.length; n++) t += e[n];
            return t / e.length;
          }
        }
        class Nc {
          constructor(t, e, n) {
            let i, r, s;
            switch (((this.binding = t), (this.valueSize = n), e)) {
              case "quaternion":
                (i = this._slerp),
                  (r = this._slerpAdditive),
                  (s = this._setAdditiveIdentityQuaternion),
                  (this.buffer = new Float64Array(6 * n)),
                  (this._workIndex = 5);
                break;
              case "string":
              case "bool":
                (i = this._select),
                  (r = this._select),
                  (s = this._setAdditiveIdentityOther),
                  (this.buffer = new Array(5 * n));
                break;
              default:
                (i = this._lerp),
                  (r = this._lerpAdditive),
                  (s = this._setAdditiveIdentityNumeric),
                  (this.buffer = new Float64Array(5 * n));
            }
            (this._mixBufferRegion = i),
              (this._mixBufferRegionAdditive = r),
              (this._setIdentity = s),
              (this._origIndex = 3),
              (this._addIndex = 4),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              (this.useCount = 0),
              (this.referenceCount = 0);
          }
          accumulate(t, e) {
            const n = this.buffer,
              i = this.valueSize,
              r = t * i + i;
            let s = this.cumulativeWeight;
            if (0 === s) {
              for (let t = 0; t !== i; ++t) n[r + t] = n[t];
              s = e;
            } else {
              s += e;
              const t = e / s;
              this._mixBufferRegion(n, r, 0, t, i);
            }
            this.cumulativeWeight = s;
          }
          accumulateAdditive(t) {
            const e = this.buffer,
              n = this.valueSize,
              i = n * this._addIndex;
            0 === this.cumulativeWeightAdditive && this._setIdentity(),
              this._mixBufferRegionAdditive(e, i, 0, t, n),
              (this.cumulativeWeightAdditive += t);
          }
          apply(t) {
            const e = this.valueSize,
              n = this.buffer,
              i = t * e + e,
              r = this.cumulativeWeight,
              s = this.cumulativeWeightAdditive,
              a = this.binding;
            if (
              ((this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0),
              r < 1)
            ) {
              const t = e * this._origIndex;
              this._mixBufferRegion(n, i, t, 1 - r, e);
            }
            s > 0 &&
              this._mixBufferRegionAdditive(n, i, this._addIndex * e, 1, e);
            for (let t = e, r = e + e; t !== r; ++t)
              if (n[t] !== n[t + e]) {
                a.setValue(n, i);
                break;
              }
          }
          saveOriginalState() {
            const t = this.binding,
              e = this.buffer,
              n = this.valueSize,
              i = n * this._origIndex;
            t.getValue(e, i);
            for (let t = n, r = i; t !== r; ++t) e[t] = e[i + (t % n)];
            this._setIdentity(),
              (this.cumulativeWeight = 0),
              (this.cumulativeWeightAdditive = 0);
          }
          restoreOriginalState() {
            const t = 3 * this.valueSize;
            this.binding.setValue(this.buffer, t);
          }
          _setAdditiveIdentityNumeric() {
            const t = this._addIndex * this.valueSize,
              e = t + this.valueSize;
            for (let n = t; n < e; n++) this.buffer[n] = 0;
          }
          _setAdditiveIdentityQuaternion() {
            this._setAdditiveIdentityNumeric(),
              (this.buffer[this._addIndex * this.valueSize + 3] = 1);
          }
          _setAdditiveIdentityOther() {
            const t = this._origIndex * this.valueSize,
              e = this._addIndex * this.valueSize;
            for (let n = 0; n < this.valueSize; n++)
              this.buffer[e + n] = this.buffer[t + n];
          }
          _select(t, e, n, i, r) {
            if (i >= 0.5) for (let i = 0; i !== r; ++i) t[e + i] = t[n + i];
          }
          _slerp(t, e, n, i) {
            At.slerpFlat(t, e, t, e, t, n, i);
          }
          _slerpAdditive(t, e, n, i, r) {
            const s = this._workIndex * r;
            At.multiplyQuaternionsFlat(t, s, t, e, t, n),
              At.slerpFlat(t, e, t, e, t, s, i);
          }
          _lerp(t, e, n, i, r) {
            const s = 1 - i;
            for (let a = 0; a !== r; ++a) {
              const r = e + a;
              t[r] = t[r] * s + t[n + a] * i;
            }
          }
          _lerpAdditive(t, e, n, i, r) {
            for (let s = 0; s !== r; ++s) {
              const r = e + s;
              t[r] = t[r] + t[n + s] * i;
            }
          }
        }
        const Bc = "\\[\\]\\.:\\/",
          zc = new RegExp("[\\[\\]\\.:\\/]", "g"),
          Fc = "[^\\[\\]\\.:\\/]",
          Oc = "[^" + Bc.replace("\\.", "") + "]",
          Hc = /((?:WC+[\/:])*)/.source.replace("WC", Fc),
          Gc = /(WCOD+)?/.source.replace("WCOD", Oc),
          Uc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Fc),
          kc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Fc),
          Vc = new RegExp("^" + Hc + Gc + Uc + kc + "$"),
          Wc = ["material", "materials", "bones"];
        class jc {
          constructor(t, e, n) {
            (this.path = e),
              (this.parsedPath = n || jc.parseTrackName(e)),
              (this.node = jc.findNode(t, this.parsedPath.nodeName) || t),
              (this.rootNode = t),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
          static create(t, e, n) {
            return t && t.isAnimationObjectGroup
              ? new jc.Composite(t, e, n)
              : new jc(t, e, n);
          }
          static sanitizeNodeName(t) {
            return t.replace(/\s/g, "_").replace(zc, "");
          }
          static parseTrackName(t) {
            const e = Vc.exec(t);
            if (!e)
              throw new Error("PropertyBinding: Cannot parse trackName: " + t);
            const n = {
                nodeName: e[2],
                objectName: e[3],
                objectIndex: e[4],
                propertyName: e[5],
                propertyIndex: e[6],
              },
              i = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== i && -1 !== i) {
              const t = n.nodeName.substring(i + 1);
              -1 !== Wc.indexOf(t) &&
                ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
              throw new Error(
                "PropertyBinding: can not parse propertyName from trackName: " +
                  t
              );
            return n;
          }
          static findNode(t, e) {
            if (
              !e ||
              "" === e ||
              "." === e ||
              -1 === e ||
              e === t.name ||
              e === t.uuid
            )
              return t;
            if (t.skeleton) {
              const n = t.skeleton.getBoneByName(e);
              if (void 0 !== n) return n;
            }
            if (t.children) {
              const n = function (t) {
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    if (r.name === e || r.uuid === e) return r;
                    const s = n(r.children);
                    if (s) return s;
                  }
                  return null;
                },
                i = n(t.children);
              if (i) return i;
            }
            return null;
          }
          _getValue_unavailable() {}
          _setValue_unavailable() {}
          _getValue_direct(t, e) {
            t[e] = this.node[this.propertyName];
          }
          _getValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
          }
          _getValue_arrayElement(t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex];
          }
          _getValue_toArray(t, e) {
            this.resolvedProperty.toArray(t, e);
          }
          _setValue_direct(t, e) {
            this.targetObject[this.propertyName] = t[e];
          }
          _setValue_direct_setNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_array(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
          }
          _setValue_array_setNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.needsUpdate = !0;
          }
          _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
            const n = this.resolvedProperty;
            for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
          _setValue_arrayElement(t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          }
          _setValue_arrayElement_setNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _setValue_fromArray(t, e) {
            this.resolvedProperty.fromArray(t, e);
          }
          _setValue_fromArray_setNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.needsUpdate = !0);
          }
          _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
          _getValue_unbound(t, e) {
            this.bind(), this.getValue(t, e);
          }
          _setValue_unbound(t, e) {
            this.bind(), this.setValue(t, e);
          }
          bind() {
            let t = this.node;
            const e = this.parsedPath,
              n = e.objectName,
              i = e.propertyName;
            let r = e.propertyIndex;
            if (
              (t ||
                ((t = jc.findNode(this.rootNode, e.nodeName) || this.rootNode),
                (this.node = t)),
              (this.getValue = this._getValue_unavailable),
              (this.setValue = this._setValue_unavailable),
              !t)
            )
              return void console.error(
                "THREE.PropertyBinding: Trying to update node for track: " +
                  this.path +
                  " but it wasn't found."
              );
            if (n) {
              let i = e.objectIndex;
              switch (n) {
                case "materials":
                  if (!t.material)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                      this
                    );
                  if (!t.material.materials)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                      this
                    );
                  t = t.material.materials;
                  break;
                case "bones":
                  if (!t.skeleton)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                      this
                    );
                  t = t.skeleton.bones;
                  for (let e = 0; e < t.length; e++)
                    if (t[e].name === i) {
                      i = e;
                      break;
                    }
                  break;
                default:
                  if (void 0 === t[n])
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                      this
                    );
                  t = t[n];
              }
              if (void 0 !== i) {
                if (void 0 === t[i])
                  return void console.error(
                    "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                    this,
                    t
                  );
                t = t[i];
              }
            }
            const s = t[i];
            if (void 0 === s) {
              const n = e.nodeName;
              return void console.error(
                "THREE.PropertyBinding: Trying to update property for track: " +
                  n +
                  "." +
                  i +
                  " but it wasn't found.",
                t
              );
            }
            let a = this.Versioning.None;
            (this.targetObject = t),
              void 0 !== t.needsUpdate
                ? (a = this.Versioning.NeedsUpdate)
                : void 0 !== t.matrixWorldNeedsUpdate &&
                  (a = this.Versioning.MatrixWorldNeedsUpdate);
            let o = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === i) {
                if (!t.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this
                  );
                if (!t.geometry.isBufferGeometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",
                    this
                  );
                if (!t.geometry.morphAttributes)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                    this
                  );
                void 0 !== t.morphTargetDictionary[r] &&
                  (r = t.morphTargetDictionary[r]);
              }
              (o = this.BindingType.ArrayElement),
                (this.resolvedProperty = s),
                (this.propertyIndex = r);
            } else void 0 !== s.fromArray && void 0 !== s.toArray ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = s)) : Array.isArray(s) ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = s)) : (this.propertyName = i);
            (this.getValue = this.GetterByBindingType[o]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
          }
          unbind() {
            (this.node = null),
              (this.getValue = this._getValue_unbound),
              (this.setValue = this._setValue_unbound);
          }
        }
        (jc.Composite = class {
          constructor(t, e, n) {
            const i = n || jc.parseTrackName(e);
            (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
          }
          getValue(t, e) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_,
              i = this._bindings[n];
            void 0 !== i && i.getValue(t, e);
          }
          setValue(t, e) {
            const n = this._bindings;
            for (
              let i = this._targetGroup.nCachedObjects_, r = n.length;
              i !== r;
              ++i
            )
              n[i].setValue(t, e);
          }
          bind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].bind();
          }
          unbind() {
            const t = this._bindings;
            for (
              let e = this._targetGroup.nCachedObjects_, n = t.length;
              e !== n;
              ++e
            )
              t[e].unbind();
          }
        }),
          (jc.prototype.BindingType = {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3,
          }),
          (jc.prototype.Versioning = {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2,
          }),
          (jc.prototype.GetterByBindingType = [
            jc.prototype._getValue_direct,
            jc.prototype._getValue_array,
            jc.prototype._getValue_arrayElement,
            jc.prototype._getValue_toArray,
          ]),
          (jc.prototype.SetterByBindingTypeAndVersioning = [
            [
              jc.prototype._setValue_direct,
              jc.prototype._setValue_direct_setNeedsUpdate,
              jc.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
            ],
            [
              jc.prototype._setValue_array,
              jc.prototype._setValue_array_setNeedsUpdate,
              jc.prototype._setValue_array_setMatrixWorldNeedsUpdate,
            ],
            [
              jc.prototype._setValue_arrayElement,
              jc.prototype._setValue_arrayElement_setNeedsUpdate,
              jc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
            ],
            [
              jc.prototype._setValue_fromArray,
              jc.prototype._setValue_fromArray_setNeedsUpdate,
              jc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
            ],
          ]);
        class qc {
          constructor() {
            (this.uuid = ct()),
              (this._objects = Array.prototype.slice.call(arguments)),
              (this.nCachedObjects_ = 0);
            const t = {};
            this._indicesByUUID = t;
            for (let e = 0, n = arguments.length; e !== n; ++e)
              t[arguments[e].uuid] = e;
            (this._paths = []),
              (this._parsedPaths = []),
              (this._bindings = []),
              (this._bindingsIndicesByPath = {});
            const e = this;
            this.stats = {
              objects: {
                get total() {
                  return e._objects.length;
                },
                get inUse() {
                  return this.total - e.nCachedObjects_;
                },
              },
              get bindingsPerObject() {
                return e._bindings.length;
              },
            };
          }
          add() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._paths,
              i = this._parsedPaths,
              r = this._bindings,
              s = r.length;
            let a,
              o = t.length,
              l = this.nCachedObjects_;
            for (let c = 0, h = arguments.length; c !== h; ++c) {
              const h = arguments[c],
                u = h.uuid;
              let d = e[u];
              if (void 0 === d) {
                (d = o++), (e[u] = d), t.push(h);
                for (let t = 0, e = s; t !== e; ++t)
                  r[t].push(new jc(h, n[t], i[t]));
              } else if (d < l) {
                a = t[d];
                const o = --l,
                  c = t[o];
                (e[c.uuid] = d), (t[d] = c), (e[u] = o), (t[o] = h);
                for (let t = 0, e = s; t !== e; ++t) {
                  const e = r[t],
                    s = e[o];
                  let a = e[d];
                  (e[d] = s),
                    void 0 === a && (a = new jc(h, n[t], i[t])),
                    (e[o] = a);
                }
              } else
                t[d] !== a &&
                  console.error(
                    "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
                  );
            }
            this.nCachedObjects_ = l;
          }
          remove() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length;
            let r = this.nCachedObjects_;
            for (let s = 0, a = arguments.length; s !== a; ++s) {
              const a = arguments[s],
                o = a.uuid,
                l = e[o];
              if (void 0 !== l && l >= r) {
                const s = r++,
                  c = t[s];
                (e[c.uuid] = l), (t[l] = c), (e[o] = s), (t[s] = a);
                for (let t = 0, e = i; t !== e; ++t) {
                  const e = n[t],
                    i = e[s],
                    r = e[l];
                  (e[l] = i), (e[s] = r);
                }
              }
            }
            this.nCachedObjects_ = r;
          }
          uncache() {
            const t = this._objects,
              e = this._indicesByUUID,
              n = this._bindings,
              i = n.length;
            let r = this.nCachedObjects_,
              s = t.length;
            for (let a = 0, o = arguments.length; a !== o; ++a) {
              const o = arguments[a].uuid,
                l = e[o];
              if (void 0 !== l)
                if ((delete e[o], l < r)) {
                  const a = --r,
                    o = t[a],
                    c = --s,
                    h = t[c];
                  (e[o.uuid] = l),
                    (t[l] = o),
                    (e[h.uuid] = a),
                    (t[a] = h),
                    t.pop();
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t],
                      i = e[a],
                      r = e[c];
                    (e[l] = i), (e[a] = r), e.pop();
                  }
                } else {
                  const r = --s,
                    a = t[r];
                  r > 0 && (e[a.uuid] = l), (t[l] = a), t.pop();
                  for (let t = 0, e = i; t !== e; ++t) {
                    const e = n[t];
                    (e[l] = e[r]), e.pop();
                  }
                }
            }
            this.nCachedObjects_ = r;
          }
          subscribe_(t, e) {
            const n = this._bindingsIndicesByPath;
            let i = n[t];
            const r = this._bindings;
            if (void 0 !== i) return r[i];
            const s = this._paths,
              a = this._parsedPaths,
              o = this._objects,
              l = o.length,
              c = this.nCachedObjects_,
              h = new Array(l);
            (i = r.length), (n[t] = i), s.push(t), a.push(e), r.push(h);
            for (let n = c, i = o.length; n !== i; ++n) {
              const i = o[n];
              h[n] = new jc(i, t, e);
            }
            return h;
          }
          unsubscribe_(t) {
            const e = this._bindingsIndicesByPath,
              n = e[t];
            if (void 0 !== n) {
              const i = this._paths,
                r = this._parsedPaths,
                s = this._bindings,
                a = s.length - 1,
                o = s[a];
              (e[t[a]] = n),
                (s[n] = o),
                s.pop(),
                (r[n] = r[a]),
                r.pop(),
                (i[n] = i[a]),
                i.pop();
            }
          }
        }
        qc.prototype.isAnimationObjectGroup = !0;
        class Xc {
          constructor(t, e, n = null, i = e.blendMode) {
            (this._mixer = t),
              (this._clip = e),
              (this._localRoot = n),
              (this.blendMode = i);
            const r = e.tracks,
              s = r.length,
              a = new Array(s),
              o = { endingStart: k, endingEnd: k };
            for (let t = 0; t !== s; ++t) {
              const e = r[t].createInterpolant(null);
              (a[t] = e), (e.settings = o);
            }
            (this._interpolantSettings = o),
              (this._interpolants = a),
              (this._propertyBindings = new Array(s)),
              (this._cacheIndex = null),
              (this._byClipCacheIndex = null),
              (this._timeScaleInterpolant = null),
              (this._weightInterpolant = null),
              (this.loop = 2201),
              (this._loopCount = -1),
              (this._startTime = null),
              (this.time = 0),
              (this.timeScale = 1),
              (this._effectiveTimeScale = 1),
              (this.weight = 1),
              (this._effectiveWeight = 1),
              (this.repetitions = 1 / 0),
              (this.paused = !1),
              (this.enabled = !0),
              (this.clampWhenFinished = !1),
              (this.zeroSlopeAtStart = !0),
              (this.zeroSlopeAtEnd = !0);
          }
          play() {
            return this._mixer._activateAction(this), this;
          }
          stop() {
            return this._mixer._deactivateAction(this), this.reset();
          }
          reset() {
            return (
              (this.paused = !1),
              (this.enabled = !0),
              (this.time = 0),
              (this._loopCount = -1),
              (this._startTime = null),
              this.stopFading().stopWarping()
            );
          }
          isRunning() {
            return (
              this.enabled &&
              !this.paused &&
              0 !== this.timeScale &&
              null === this._startTime &&
              this._mixer._isActiveAction(this)
            );
          }
          isScheduled() {
            return this._mixer._isActiveAction(this);
          }
          startAt(t) {
            return (this._startTime = t), this;
          }
          setLoop(t, e) {
            return (this.loop = t), (this.repetitions = e), this;
          }
          setEffectiveWeight(t) {
            return (
              (this.weight = t),
              (this._effectiveWeight = this.enabled ? t : 0),
              this.stopFading()
            );
          }
          getEffectiveWeight() {
            return this._effectiveWeight;
          }
          fadeIn(t) {
            return this._scheduleFading(t, 0, 1);
          }
          fadeOut(t) {
            return this._scheduleFading(t, 1, 0);
          }
          crossFadeFrom(t, e, n) {
            if ((t.fadeOut(e), this.fadeIn(e), n)) {
              const n = this._clip.duration,
                i = t._clip.duration,
                r = i / n,
                s = n / i;
              t.warp(1, r, e), this.warp(s, 1, e);
            }
            return this;
          }
          crossFadeTo(t, e, n) {
            return t.crossFadeFrom(this, e, n);
          }
          stopFading() {
            const t = this._weightInterpolant;
            return (
              null !== t &&
                ((this._weightInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          setEffectiveTimeScale(t) {
            return (
              (this.timeScale = t),
              (this._effectiveTimeScale = this.paused ? 0 : t),
              this.stopWarping()
            );
          }
          getEffectiveTimeScale() {
            return this._effectiveTimeScale;
          }
          setDuration(t) {
            return (
              (this.timeScale = this._clip.duration / t), this.stopWarping()
            );
          }
          syncWith(t) {
            return (
              (this.time = t.time),
              (this.timeScale = t.timeScale),
              this.stopWarping()
            );
          }
          halt(t) {
            return this.warp(this._effectiveTimeScale, 0, t);
          }
          warp(t, e, n) {
            const i = this._mixer,
              r = i.time,
              s = this.timeScale;
            let a = this._timeScaleInterpolant;
            null === a &&
              ((a = i._lendControlInterpolant()),
              (this._timeScaleInterpolant = a));
            const o = a.parameterPositions,
              l = a.sampleValues;
            return (
              (o[0] = r), (o[1] = r + n), (l[0] = t / s), (l[1] = e / s), this
            );
          }
          stopWarping() {
            const t = this._timeScaleInterpolant;
            return (
              null !== t &&
                ((this._timeScaleInterpolant = null),
                this._mixer._takeBackControlInterpolant(t)),
              this
            );
          }
          getMixer() {
            return this._mixer;
          }
          getClip() {
            return this._clip;
          }
          getRoot() {
            return this._localRoot || this._mixer._root;
          }
          _update(t, e, n, i) {
            if (!this.enabled) return void this._updateWeight(t);
            const r = this._startTime;
            if (null !== r) {
              const i = (t - r) * n;
              if (i < 0 || 0 === n) return;
              (this._startTime = null), (e = n * i);
            }
            e *= this._updateTimeScale(t);
            const s = this._updateTime(e),
              a = this._updateWeight(t);
            if (a > 0) {
              const t = this._interpolants,
                e = this._propertyBindings;
              switch (this.blendMode) {
                case q:
                  for (let n = 0, i = t.length; n !== i; ++n)
                    t[n].evaluate(s), e[n].accumulateAdditive(a);
                  break;
                case j:
                default:
                  for (let n = 0, r = t.length; n !== r; ++n)
                    t[n].evaluate(s), e[n].accumulate(i, a);
              }
            }
          }
          _updateWeight(t) {
            let e = 0;
            if (this.enabled) {
              e = this.weight;
              const n = this._weightInterpolant;
              if (null !== n) {
                const i = n.evaluate(t)[0];
                (e *= i),
                  t > n.parameterPositions[1] &&
                    (this.stopFading(), 0 === i && (this.enabled = !1));
              }
            }
            return (this._effectiveWeight = e), e;
          }
          _updateTimeScale(t) {
            let e = 0;
            if (!this.paused) {
              e = this.timeScale;
              const n = this._timeScaleInterpolant;
              if (null !== n) {
                (e *= n.evaluate(t)[0]),
                  t > n.parameterPositions[1] &&
                    (this.stopWarping(),
                    0 === e ? (this.paused = !0) : (this.timeScale = e));
              }
            }
            return (this._effectiveTimeScale = e), e;
          }
          _updateTime(t) {
            const e = this._clip.duration,
              n = this.loop;
            let i = this.time + t,
              r = this._loopCount;
            const s = 2202 === n;
            if (0 === t) return -1 === r ? i : s && 1 == (1 & r) ? e - i : i;
            if (2200 === n) {
              -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
              t: {
                if (i >= e) i = e;
                else {
                  if (!(i < 0)) {
                    this.time = i;
                    break t;
                  }
                  i = 0;
                }
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: t < 0 ? -1 : 1,
                  });
              }
            } else {
              if (
                (-1 === r &&
                  (t >= 0
                    ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                    : this._setEndings(0 === this.repetitions, !0, s)),
                i >= e || i < 0)
              ) {
                const n = Math.floor(i / e);
                (i -= e * n), (r += Math.abs(n));
                const a = this.repetitions - r;
                if (a <= 0)
                  this.clampWhenFinished
                    ? (this.paused = !0)
                    : (this.enabled = !1),
                    (i = t > 0 ? e : 0),
                    (this.time = i),
                    this._mixer.dispatchEvent({
                      type: "finished",
                      action: this,
                      direction: t > 0 ? 1 : -1,
                    });
                else {
                  if (1 === a) {
                    const e = t < 0;
                    this._setEndings(e, !e, s);
                  } else this._setEndings(!1, !1, s);
                  (this._loopCount = r),
                    (this.time = i),
                    this._mixer.dispatchEvent({
                      type: "loop",
                      action: this,
                      loopDelta: n,
                    });
                }
              } else this.time = i;
              if (s && 1 == (1 & r)) return e - i;
            }
            return i;
          }
          _setEndings(t, e, n) {
            const i = this._interpolantSettings;
            n
              ? ((i.endingStart = V), (i.endingEnd = V))
              : ((i.endingStart = t ? (this.zeroSlopeAtStart ? V : k) : W),
                (i.endingEnd = e ? (this.zeroSlopeAtEnd ? V : k) : W));
          }
          _scheduleFading(t, e, n) {
            const i = this._mixer,
              r = i.time;
            let s = this._weightInterpolant;
            null === s &&
              ((s = i._lendControlInterpolant()),
              (this._weightInterpolant = s));
            const a = s.parameterPositions,
              o = s.sampleValues;
            return (a[0] = r), (o[0] = e), (a[1] = r + t), (o[1] = n), this;
          }
        }
        class Yc extends rt {
          constructor(t) {
            super(),
              (this._root = t),
              this._initMemoryManager(),
              (this._accuIndex = 0),
              (this.time = 0),
              (this.timeScale = 1);
          }
          _bindAction(t, e) {
            const n = t._localRoot || this._root,
              i = t._clip.tracks,
              r = i.length,
              s = t._propertyBindings,
              a = t._interpolants,
              o = n.uuid,
              l = this._bindingsByRootAndName;
            let c = l[o];
            void 0 === c && ((c = {}), (l[o] = c));
            for (let t = 0; t !== r; ++t) {
              const r = i[t],
                l = r.name;
              let h = c[l];
              if (void 0 !== h) s[t] = h;
              else {
                if (((h = s[t]), void 0 !== h)) {
                  null === h._cacheIndex &&
                    (++h.referenceCount, this._addInactiveBinding(h, o, l));
                  continue;
                }
                const i = e && e._propertyBindings[t].binding.parsedPath;
                (h = new Nc(
                  jc.create(n, l, i),
                  r.ValueTypeName,
                  r.getValueSize()
                )),
                  ++h.referenceCount,
                  this._addInactiveBinding(h, o, l),
                  (s[t] = h);
              }
              a[t].resultBuffer = h.buffer;
            }
          }
          _activateAction(t) {
            if (!this._isActiveAction(t)) {
              if (null === t._cacheIndex) {
                const e = (t._localRoot || this._root).uuid,
                  n = t._clip.uuid,
                  i = this._actionsByClip[n];
                this._bindAction(t, i && i.knownActions[0]),
                  this._addInactiveAction(t, n, e);
              }
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == n.useCount++ &&
                  (this._lendBinding(n), n.saveOriginalState());
              }
              this._lendAction(t);
            }
          }
          _deactivateAction(t) {
            if (this._isActiveAction(t)) {
              const e = t._propertyBindings;
              for (let t = 0, n = e.length; t !== n; ++t) {
                const n = e[t];
                0 == --n.useCount &&
                  (n.restoreOriginalState(), this._takeBackBinding(n));
              }
              this._takeBackAction(t);
            }
          }
          _initMemoryManager() {
            (this._actions = []),
              (this._nActiveActions = 0),
              (this._actionsByClip = {}),
              (this._bindings = []),
              (this._nActiveBindings = 0),
              (this._bindingsByRootAndName = {}),
              (this._controlInterpolants = []),
              (this._nActiveControlInterpolants = 0);
            const t = this;
            this.stats = {
              actions: {
                get total() {
                  return t._actions.length;
                },
                get inUse() {
                  return t._nActiveActions;
                },
              },
              bindings: {
                get total() {
                  return t._bindings.length;
                },
                get inUse() {
                  return t._nActiveBindings;
                },
              },
              controlInterpolants: {
                get total() {
                  return t._controlInterpolants.length;
                },
                get inUse() {
                  return t._nActiveControlInterpolants;
                },
              },
            };
          }
          _isActiveAction(t) {
            const e = t._cacheIndex;
            return null !== e && e < this._nActiveActions;
          }
          _addInactiveAction(t, e, n) {
            const i = this._actions,
              r = this._actionsByClip;
            let s = r[e];
            if (void 0 === s)
              (s = { knownActions: [t], actionByRoot: {} }),
                (t._byClipCacheIndex = 0),
                (r[e] = s);
            else {
              const e = s.knownActions;
              (t._byClipCacheIndex = e.length), e.push(t);
            }
            (t._cacheIndex = i.length), i.push(t), (s.actionByRoot[n] = t);
          }
          _removeInactiveAction(t) {
            const e = this._actions,
              n = e[e.length - 1],
              i = t._cacheIndex;
            (n._cacheIndex = i), (e[i] = n), e.pop(), (t._cacheIndex = null);
            const r = t._clip.uuid,
              s = this._actionsByClip,
              a = s[r],
              o = a.knownActions,
              l = o[o.length - 1],
              c = t._byClipCacheIndex;
            (l._byClipCacheIndex = c),
              (o[c] = l),
              o.pop(),
              (t._byClipCacheIndex = null);
            delete a.actionByRoot[(t._localRoot || this._root).uuid],
              0 === o.length && delete s[r],
              this._removeInactiveBindingsForAction(t);
          }
          _removeInactiveBindingsForAction(t) {
            const e = t._propertyBindings;
            for (let t = 0, n = e.length; t !== n; ++t) {
              const n = e[t];
              0 == --n.referenceCount && this._removeInactiveBinding(n);
            }
          }
          _lendAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = this._nActiveActions++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _takeBackAction(t) {
            const e = this._actions,
              n = t._cacheIndex,
              i = --this._nActiveActions,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _addInactiveBinding(t, e, n) {
            const i = this._bindingsByRootAndName,
              r = this._bindings;
            let s = i[e];
            void 0 === s && ((s = {}), (i[e] = s)),
              (s[n] = t),
              (t._cacheIndex = r.length),
              r.push(t);
          }
          _removeInactiveBinding(t) {
            const e = this._bindings,
              n = t.binding,
              i = n.rootNode.uuid,
              r = n.path,
              s = this._bindingsByRootAndName,
              a = s[i],
              o = e[e.length - 1],
              l = t._cacheIndex;
            (o._cacheIndex = l),
              (e[l] = o),
              e.pop(),
              delete a[r],
              0 === Object.keys(a).length && delete s[i];
          }
          _lendBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = this._nActiveBindings++,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _takeBackBinding(t) {
            const e = this._bindings,
              n = t._cacheIndex,
              i = --this._nActiveBindings,
              r = e[i];
            (t._cacheIndex = i), (e[i] = t), (r._cacheIndex = n), (e[n] = r);
          }
          _lendControlInterpolant() {
            const t = this._controlInterpolants,
              e = this._nActiveControlInterpolants++;
            let n = t[e];
            return (
              void 0 === n &&
                ((n = new qo(
                  new Float32Array(2),
                  new Float32Array(2),
                  1,
                  this._controlInterpolantsResultBuffer
                )),
                (n.__cacheIndex = e),
                (t[e] = n)),
              n
            );
          }
          _takeBackControlInterpolant(t) {
            const e = this._controlInterpolants,
              n = t.__cacheIndex,
              i = --this._nActiveControlInterpolants,
              r = e[i];
            (t.__cacheIndex = i), (e[i] = t), (r.__cacheIndex = n), (e[n] = r);
          }
          clipAction(t, e, n) {
            const i = e || this._root,
              r = i.uuid;
            let s = "string" == typeof t ? nl.findByName(i, t) : t;
            const a = null !== s ? s.uuid : t,
              o = this._actionsByClip[a];
            let l = null;
            if (
              (void 0 === n && (n = null !== s ? s.blendMode : j), void 0 !== o)
            ) {
              const t = o.actionByRoot[r];
              if (void 0 !== t && t.blendMode === n) return t;
              (l = o.knownActions[0]), null === s && (s = l._clip);
            }
            if (null === s) return null;
            const c = new Xc(this, s, e, n);
            return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
          }
          existingAction(t, e) {
            const n = e || this._root,
              i = n.uuid,
              r = "string" == typeof t ? nl.findByName(n, t) : t,
              s = r ? r.uuid : t,
              a = this._actionsByClip[s];
            return (void 0 !== a && a.actionByRoot[i]) || null;
          }
          stopAllAction() {
            const t = this._actions;
            for (let e = this._nActiveActions - 1; e >= 0; --e) t[e].stop();
            return this;
          }
          update(t) {
            t *= this.timeScale;
            const e = this._actions,
              n = this._nActiveActions,
              i = (this.time += t),
              r = Math.sign(t),
              s = (this._accuIndex ^= 1);
            for (let a = 0; a !== n; ++a) {
              e[a]._update(i, t, r, s);
            }
            const a = this._bindings,
              o = this._nActiveBindings;
            for (let t = 0; t !== o; ++t) a[t].apply(s);
            return this;
          }
          setTime(t) {
            this.time = 0;
            for (let t = 0; t < this._actions.length; t++)
              this._actions[t].time = 0;
            return this.update(t);
          }
          getRoot() {
            return this._root;
          }
          uncacheClip(t) {
            const e = this._actions,
              n = t.uuid,
              i = this._actionsByClip,
              r = i[n];
            if (void 0 !== r) {
              const t = r.knownActions;
              for (let n = 0, i = t.length; n !== i; ++n) {
                const i = t[n];
                this._deactivateAction(i);
                const r = i._cacheIndex,
                  s = e[e.length - 1];
                (i._cacheIndex = null),
                  (i._byClipCacheIndex = null),
                  (s._cacheIndex = r),
                  (e[r] = s),
                  e.pop(),
                  this._removeInactiveBindingsForAction(i);
              }
              delete i[n];
            }
          }
          uncacheRoot(t) {
            const e = t.uuid,
              n = this._actionsByClip;
            for (const t in n) {
              const i = n[t].actionByRoot[e];
              void 0 !== i &&
                (this._deactivateAction(i), this._removeInactiveAction(i));
            }
            const i = this._bindingsByRootAndName[e];
            if (void 0 !== i)
              for (const t in i) {
                const e = i[t];
                e.restoreOriginalState(), this._removeInactiveBinding(e);
              }
          }
          uncacheAction(t, e) {
            const n = this.existingAction(t, e);
            null !== n &&
              (this._deactivateAction(n), this._removeInactiveAction(n));
          }
        }
        Yc.prototype._controlInterpolantsResultBuffer = new Float32Array(1);
        class Zc {
          constructor(t) {
            "string" == typeof t &&
              (console.warn(
                "THREE.Uniform: Type parameter is no longer needed."
              ),
              (t = arguments[1])),
              (this.value = t);
          }
          clone() {
            return new Zc(
              void 0 === this.value.clone ? this.value : this.value.clone()
            );
          }
        }
        class Jc extends Es {
          constructor(t, e, n = 1) {
            super(t, e), (this.meshPerAttribute = n || 1);
          }
          copy(t) {
            return (
              super.copy(t), (this.meshPerAttribute = t.meshPerAttribute), this
            );
          }
          clone(t) {
            const e = super.clone(t);
            return (e.meshPerAttribute = this.meshPerAttribute), e;
          }
          toJSON(t) {
            const e = super.toJSON(t);
            return (
              (e.isInstancedInterleavedBuffer = !0),
              (e.meshPerAttribute = this.meshPerAttribute),
              e
            );
          }
        }
        Jc.prototype.isInstancedInterleavedBuffer = !0;
        class Qc {
          constructor(t, e, n, i, r) {
            (this.buffer = t),
              (this.type = e),
              (this.itemSize = n),
              (this.elementSize = i),
              (this.count = r),
              (this.version = 0);
          }
          set needsUpdate(t) {
            !0 === t && this.version++;
          }
          setBuffer(t) {
            return (this.buffer = t), this;
          }
          setType(t, e) {
            return (this.type = t), (this.elementSize = e), this;
          }
          setItemSize(t) {
            return (this.itemSize = t), this;
          }
          setCount(t) {
            return (this.count = t), this;
          }
        }
        Qc.prototype.isGLBufferAttribute = !0;
        function Kc(t, e) {
          return t.distance - e.distance;
        }
        function $c(t, e, n, i) {
          if ((t.layers.test(e.layers) && t.raycast(e, n), !0 === i)) {
            const i = t.children;
            for (let t = 0, r = i.length; t < r; t++) $c(i[t], e, n, !0);
          }
        }
        const th = new vt();
        class eh {
          constructor(t = new vt(1 / 0, 1 / 0), e = new vt(-1 / 0, -1 / 0)) {
            (this.min = t), (this.max = e);
          }
          set(t, e) {
            return this.min.copy(t), this.max.copy(e), this;
          }
          setFromPoints(t) {
            this.makeEmpty();
            for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
            return this;
          }
          setFromCenterAndSize(t, e) {
            const n = th.copy(e).multiplyScalar(0.5);
            return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
          }
          clone() {
            return new this.constructor().copy(this);
          }
          copy(t) {
            return this.min.copy(t.min), this.max.copy(t.max), this;
          }
          makeEmpty() {
            return (
              (this.min.x = this.min.y = 1 / 0),
              (this.max.x = this.max.y = -1 / 0),
              this
            );
          }
          isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y;
          }
          getCenter(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Box2: .getCenter() target is now required"
                ),
                (t = new vt())),
              this.isEmpty()
                ? t.set(0, 0)
                : t.addVectors(this.min, this.max).multiplyScalar(0.5)
            );
          }
          getSize(t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Box2: .getSize() target is now required"),
                (t = new vt())),
              this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
            );
          }
          expandByPoint(t) {
            return this.min.min(t), this.max.max(t), this;
          }
          expandByVector(t) {
            return this.min.sub(t), this.max.add(t), this;
          }
          expandByScalar(t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this;
          }
          containsPoint(t) {
            return !(
              t.x < this.min.x ||
              t.x > this.max.x ||
              t.y < this.min.y ||
              t.y > this.max.y
            );
          }
          containsBox(t) {
            return (
              this.min.x <= t.min.x &&
              t.max.x <= this.max.x &&
              this.min.y <= t.min.y &&
              t.max.y <= this.max.y
            );
          }
          getParameter(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box2: .getParameter() target is now required"
                ),
                (e = new vt())),
              e.set(
                (t.x - this.min.x) / (this.max.x - this.min.x),
                (t.y - this.min.y) / (this.max.y - this.min.y)
              )
            );
          }
          intersectsBox(t) {
            return !(
              t.max.x < this.min.x ||
              t.min.x > this.max.x ||
              t.max.y < this.min.y ||
              t.min.y > this.max.y
            );
          }
          clampPoint(t, e) {
            return (
              void 0 === e &&
                (console.warn(
                  "THREE.Box2: .clampPoint() target is now required"
                ),
                (e = new vt())),
              e.copy(t).clamp(this.min, this.max)
            );
          }
          distanceToPoint(t) {
            return th.copy(t).clamp(this.min, this.max).sub(t).length();
          }
          intersect(t) {
            return this.min.max(t.min), this.max.min(t.max), this;
          }
          union(t) {
            return this.min.min(t.min), this.max.max(t.max), this;
          }
          translate(t) {
            return this.min.add(t), this.max.add(t), this;
          }
          equals(t) {
            return t.min.equals(this.min) && t.max.equals(this.max);
          }
        }
        eh.prototype.isBox2 = !0;
        const nh = new Lt(),
          ih = new Lt();
        class rh {
          constructor(t = new Lt(), e = new Lt()) {
            (this.start = t), (this.end = e);
          }
          set(t, e) {
            return this.start.copy(t), this.end.copy(e), this;
          }
          copy(t) {
            return this.start.copy(t.start), this.end.copy(t.end), this;
          }
          getCenter(t) {
            return (
              void 0 === t &&
                (console.warn(
                  "THREE.Line3: .getCenter() target is now required"
                ),
                (t = new Lt())),
              t.addVectors(this.start, this.end).multiplyScalar(0.5)
            );
          }
          delta(t) {
            return (
              void 0 === t &&
                (console.warn("THREE.Line3: .delta() target is now required"),
                (t = new Lt())),
              t.subVectors(this.end, this.start)
            );
          }
          distanceSq() {
            return this.start.distanceToSquared(this.end);
          }
          distance() {
            return this.start.distanceTo(this.end);
          }
          at(t, e) {
            return (
              void 0 === e &&
                (console.warn("THREE.Line3: .at() target is now required"),
                (e = new Lt())),
              this.delta(e).multiplyScalar(t).add(this.start)
            );
          }
          closestPointToPointParameter(t, e) {
            nh.subVectors(t, this.start), ih.subVectors(this.end, this.start);
            const n = ih.dot(ih);
            let i = ih.dot(nh) / n;
            return e && (i = ht(i, 0, 1)), i;
          }
          closestPointToPoint(t, e, n) {
            const i = this.closestPointToPointParameter(t, e);
            return (
              void 0 === n &&
                (console.warn(
                  "THREE.Line3: .closestPointToPoint() target is now required"
                ),
                (n = new Lt())),
              this.delta(n).multiplyScalar(i).add(this.start)
            );
          }
          applyMatrix4(t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
          }
          equals(t) {
            return t.start.equals(this.start) && t.end.equals(this.end);
          }
          clone() {
            return new this.constructor().copy(this);
          }
        }
        class sh extends Ce {
          constructor(t) {
            super(),
              (this.material = t),
              (this.render = function () {}),
              (this.hasPositions = !1),
              (this.hasNormals = !1),
              (this.hasColors = !1),
              (this.hasUvs = !1),
              (this.positionArray = null),
              (this.normalArray = null),
              (this.colorArray = null),
              (this.uvArray = null),
              (this.count = 0);
          }
        }
        sh.prototype.isImmediateRenderObject = !0;
        const ah = new Lt();
        const oh = new Lt(),
          lh = new se(),
          ch = new se();
        class hh extends ya {
          constructor(t) {
            const e = uh(t),
              n = new En(),
              i = [],
              r = [],
              s = new tn(0, 0, 1),
              a = new tn(0, 1, 0);
            for (let t = 0; t < e.length; t++) {
              const n = e[t];
              n.parent &&
                n.parent.isBone &&
                (i.push(0, 0, 0),
                i.push(0, 0, 0),
                r.push(s.r, s.g, s.b),
                r.push(a.r, a.g, a.b));
            }
            n.setAttribute("position", new mn(i, 3)),
              n.setAttribute("color", new mn(r, 3));
            super(
              n,
              new ca({
                vertexColors: !0,
                depthTest: !1,
                depthWrite: !1,
                toneMapped: !1,
                transparent: !0,
              })
            ),
              (this.type = "SkeletonHelper"),
              (this.isSkeletonHelper = !0),
              (this.root = t),
              (this.bones = e),
              (this.matrix = t.matrixWorld),
              (this.matrixAutoUpdate = !1);
          }
          updateMatrixWorld(t) {
            const e = this.bones,
              n = this.geometry,
              i = n.getAttribute("position");
            ch.copy(this.root.matrixWorld).invert();
            for (let t = 0, n = 0; t < e.length; t++) {
              const r = e[t];
              r.parent &&
                r.parent.isBone &&
                (lh.multiplyMatrices(ch, r.matrixWorld),
                oh.setFromMatrixPosition(lh),
                i.setXYZ(n, oh.x, oh.y, oh.z),
                lh.multiplyMatrices(ch, r.parent.matrixWorld),
                oh.setFromMatrixPosition(lh),
                i.setXYZ(n + 1, oh.x, oh.y, oh.z),
                (n += 2));
            }
            (n.getAttribute("position").needsUpdate = !0),
              super.updateMatrixWorld(t);
          }
        }
        function uh(t) {
          const e = [];
          t && t.isBone && e.push(t);
          for (let n = 0; n < t.children.length; n++)
            e.push.apply(e, uh(t.children[n]));
          return e;
        }
        const dh = new Lt(),
          ph = new tn(),
          mh = new tn();
        class fh extends ya {
          constructor(t = 10, e = 10, n = 4473924, i = 8947848) {
            (n = new tn(n)), (i = new tn(i));
            const r = e / 2,
              s = t / e,
              a = t / 2,
              o = [],
              l = [];
            for (let t = 0, c = 0, h = -a; t <= e; t++, h += s) {
              o.push(-a, 0, h, a, 0, h), o.push(h, 0, -a, h, 0, a);
              const e = t === r ? n : i;
              e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3),
                e.toArray(l, c),
                (c += 3);
            }
            const c = new En();
            c.setAttribute("position", new mn(o, 3)),
              c.setAttribute("color", new mn(l, 3));
            super(c, new ca({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "GridHelper");
          }
        }
        const gh = new Lt(),
          vh = new Lt(),
          yh = new Lt();
        const xh = new Lt(),
          _h = new Qn();
        function wh(t, e, n, i, r, s, a) {
          xh.set(r, s, a).unproject(i);
          const o = e[t];
          if (void 0 !== o) {
            const t = n.getAttribute("position");
            for (let e = 0, n = o.length; e < n; e++)
              t.setXYZ(o[e], xh.x, xh.y, xh.z);
          }
        }
        const bh = new Pt();
        class Mh extends ya {
          constructor(t, e = 16776960) {
            const n = new Uint16Array([
                0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                6, 3, 7,
              ]),
              i = new Float32Array(24),
              r = new En();
            r.setIndex(new sn(n, 1)),
              r.setAttribute("position", new sn(i, 3)),
              super(r, new ca({ color: e, toneMapped: !1 })),
              (this.object = t),
              (this.type = "BoxHelper"),
              (this.matrixAutoUpdate = !1),
              this.update();
          }
          update(t) {
            if (
              (void 0 !== t &&
                console.warn(
                  "THREE.BoxHelper: .update() has no longer arguments."
                ),
              void 0 !== this.object && bh.setFromObject(this.object),
              bh.isEmpty())
            )
              return;
            const e = bh.min,
              n = bh.max,
              i = this.geometry.attributes.position,
              r = i.array;
            (r[0] = n.x),
              (r[1] = n.y),
              (r[2] = n.z),
              (r[3] = e.x),
              (r[4] = n.y),
              (r[5] = n.z),
              (r[6] = e.x),
              (r[7] = e.y),
              (r[8] = n.z),
              (r[9] = n.x),
              (r[10] = e.y),
              (r[11] = n.z),
              (r[12] = n.x),
              (r[13] = n.y),
              (r[14] = e.z),
              (r[15] = e.x),
              (r[16] = n.y),
              (r[17] = e.z),
              (r[18] = e.x),
              (r[19] = e.y),
              (r[20] = e.z),
              (r[21] = n.x),
              (r[22] = e.y),
              (r[23] = e.z),
              (i.needsUpdate = !0),
              this.geometry.computeBoundingSphere();
          }
          setFromObject(t) {
            return (this.object = t), this.update(), this;
          }
          copy(t) {
            return (
              ya.prototype.copy.call(this, t), (this.object = t.object), this
            );
          }
        }
        const Sh = new Lt();
        let Th, Eh;
        class Ah extends ya {
          constructor(t = 1) {
            const e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
              n = new En();
            n.setAttribute("position", new mn(e, 3)),
              n.setAttribute(
                "color",
                new mn(
                  [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
                  3
                )
              );
            super(n, new ca({ vertexColors: !0, toneMapped: !1 })),
              (this.type = "AxesHelper");
          }
          dispose() {
            this.geometry.dispose(), this.material.dispose();
          }
        }
        const Lh = new Float32Array(1),
          Rh = new Int32Array(Lh.buffer);
        const Ch = Math.pow(2, 8),
          Ph = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
          Dh = 5 + Ph.length,
          Ih = 20,
          Nh = { [X]: 0, [Y]: 1, [J]: 2, [Q]: 3, [K]: 4, [$]: 5, [Z]: 6 },
          Bh = new en({ side: 1, depthWrite: !1, depthTest: !1 }),
          zh = new Wn(new qn(), Bh),
          Fh = new Jl(),
          { _lodPlanes: Oh, _sizeLods: Hh, _sigmas: Gh } = Yh(),
          Uh = new tn();
        let kh = null;
        const Vh = (1 + Math.sqrt(5)) / 2,
          Wh = 1 / Vh,
          jh = [
            new Lt(1, 1, 1),
            new Lt(-1, 1, 1),
            new Lt(1, 1, -1),
            new Lt(-1, 1, -1),
            new Lt(0, Vh, Wh),
            new Lt(0, Vh, -Wh),
            new Lt(Wh, 0, Vh),
            new Lt(-Wh, 0, Vh),
            new Lt(Vh, Wh, 0),
            new Lt(-Vh, Wh, 0),
          ];
        function qh(t) {
          const e = Math.max(t.r, t.g, t.b),
            n = Math.min(Math.max(Math.ceil(Math.log2(e)), -128), 127);
          t.multiplyScalar(Math.pow(2, -n));
          return (n + 128) / 255;
        }
        function Xh(t) {
          return (
            void 0 !== t &&
            t.type === x &&
            (t.encoding === X || t.encoding === Y || t.encoding === Z)
          );
        }
        function Yh() {
          const t = [],
            e = [],
            n = [];
          let i = 8;
          for (let r = 0; r < Dh; r++) {
            const s = Math.pow(2, i);
            e.push(s);
            let a = 1 / s;
            r > 4 ? (a = Ph[r - 8 + 4 - 1]) : 0 == r && (a = 0), n.push(a);
            const o = 1 / (s - 1),
              l = -o / 2,
              c = 1 + o / 2,
              h = [l, l, c, l, c, c, l, l, c, c, l, c],
              u = 6,
              d = 6,
              p = 3,
              m = 2,
              f = 1,
              g = new Float32Array(p * d * u),
              v = new Float32Array(m * d * u),
              y = new Float32Array(f * d * u);
            for (let t = 0; t < u; t++) {
              const e = ((t % 3) * 2) / 3 - 1,
                n = t > 2 ? 0 : -1,
                i = [
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n,
                  0,
                  e + 2 / 3,
                  n + 1,
                  0,
                  e,
                  n + 1,
                  0,
                ];
              g.set(i, p * d * t), v.set(h, m * d * t);
              const r = [t, t, t, t, t, t];
              y.set(r, f * d * t);
            }
            const x = new En();
            x.setAttribute("position", new sn(g, p)),
              x.setAttribute("uv", new sn(v, m)),
              x.setAttribute("faceIndex", new sn(y, f)),
              t.push(x),
              i > 4 && i--;
          }
          return { _lodPlanes: t, _sizeLods: e, _sigmas: n };
        }
        function Zh(t) {
          const e = new Tt(3 * Ch, 3 * Ch, t);
          return (
            (e.texture.mapping = l),
            (e.texture.name = "PMREM.cubeUv"),
            (e.scissorTest = !0),
            e
          );
        }
        function Jh(t, e, n, i, r) {
          t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
        }
        function Qh() {
          const t = new vt(1, 1);
          return new Io({
            name: "EquirectangularToCubeUV",
            uniforms: {
              envMap: { value: null },
              texelSize: { value: t },
              inputEncoding: { value: Nh[3e3] },
              outputEncoding: { value: Nh[3e3] },
            },
            vertexShader: $h(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${tu()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function Kh() {
          return new Io({
            name: "CubemapToCubeUV",
            uniforms: {
              envMap: { value: null },
              inputEncoding: { value: Nh[3e3] },
              outputEncoding: { value: Nh[3e3] },
            },
            vertexShader: $h(),
            fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${tu()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
            blending: 0,
            depthTest: !1,
            depthWrite: !1,
          });
        }
        function $h() {
          return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
        }
        function tu() {
          return "\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t";
        }
        (ml.create = function (t, e) {
          return (
            console.log("THREE.Curve.create() has been deprecated"),
            (t.prototype = Object.create(ml.prototype)),
            (t.prototype.constructor = t),
            (t.prototype.getPoint = e),
            t
          );
        }),
          (Bl.prototype.fromPoints = function (t) {
            return (
              console.warn(
                "THREE.Path: .fromPoints() has been renamed to .setFromPoints()."
              ),
              this.setFromPoints(t)
            );
          }),
          (fh.prototype.setColors = function () {
            console.error(
              "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead."
            );
          }),
          (hh.prototype.update = function () {
            console.error(
              "THREE.SkeletonHelper: update() no longer needs to be called."
            );
          }),
          (ol.prototype.extractUrlBase = function (t) {
            return (
              console.warn(
                "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."
              ),
              rc.extractUrlBase(t)
            );
          }),
          (ol.Handlers = {
            add: function () {
              console.error(
                "THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead."
              );
            },
            get: function () {
              console.error(
                "THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead."
              );
            },
          }),
          (eh.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Box2: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (eh.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Box2: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (eh.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (eh.prototype.size = function (t) {
            return (
              console.warn(
                "THREE.Box2: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          }),
          (Pt.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Box3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (Pt.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Box3: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (Pt.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (Pt.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          }),
          (Pt.prototype.size = function (t) {
            return (
              console.warn(
                "THREE.Box3: .size() has been renamed to .getSize()."
              ),
              this.getSize(t)
            );
          }),
          (Jt.prototype.empty = function () {
            return (
              console.warn(
                "THREE.Sphere: .empty() has been renamed to .isEmpty()."
              ),
              this.isEmpty()
            );
          }),
          (ai.prototype.setFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."
              ),
              this.setFromProjectionMatrix(t)
            );
          }),
          (rh.prototype.center = function (t) {
            return (
              console.warn(
                "THREE.Line3: .center() has been renamed to .getCenter()."
              ),
              this.getCenter(t)
            );
          }),
          (yt.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          }),
          (yt.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          }),
          (yt.prototype.multiplyVector3Array = function () {
            console.error(
              "THREE.Matrix3: .multiplyVector3Array() has been removed."
            );
          }),
          (yt.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."
              ),
              t.applyMatrix3(this)
            );
          }),
          (yt.prototype.applyToVector3Array = function () {
            console.error(
              "THREE.Matrix3: .applyToVector3Array() has been removed."
            );
          }),
          (yt.prototype.getInverse = function (t) {
            return (
              console.warn(
                "THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(t).invert()
            );
          }),
          (se.prototype.extractPosition = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."
              ),
              this.copyPosition(t)
            );
          }),
          (se.prototype.flattenToArrayOffset = function (t, e) {
            return (
              console.warn(
                "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."
              ),
              this.toArray(t, e)
            );
          }),
          (se.prototype.getPosition = function () {
            return (
              console.warn(
                "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."
              ),
              new Lt().setFromMatrixColumn(this, 3)
            );
          }),
          (se.prototype.setRotationFromQuaternion = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."
              ),
              this.makeRotationFromQuaternion(t)
            );
          }),
          (se.prototype.multiplyToArray = function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
          }),
          (se.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (se.prototype.multiplyVector4 = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (se.prototype.multiplyVector3Array = function () {
            console.error(
              "THREE.Matrix4: .multiplyVector3Array() has been removed."
            );
          }),
          (se.prototype.rotateAxis = function (t) {
            console.warn(
              "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."
            ),
              t.transformDirection(this);
          }),
          (se.prototype.crossVector = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (se.prototype.translate = function () {
            console.error("THREE.Matrix4: .translate() has been removed.");
          }),
          (se.prototype.rotateX = function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.");
          }),
          (se.prototype.rotateY = function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.");
          }),
          (se.prototype.rotateZ = function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.");
          }),
          (se.prototype.rotateByAxis = function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
          }),
          (se.prototype.applyToBufferAttribute = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."
              ),
              t.applyMatrix4(this)
            );
          }),
          (se.prototype.applyToVector3Array = function () {
            console.error(
              "THREE.Matrix4: .applyToVector3Array() has been removed."
            );
          }),
          (se.prototype.makeFrustum = function (t, e, n, i, r, s) {
            return (
              console.warn(
                "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
              ),
              this.makePerspective(t, e, i, n, r, s)
            );
          }),
          (se.prototype.getInverse = function (t) {
            return (
              console.warn(
                "THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."
              ),
              this.copy(t).invert()
            );
          }),
          (Ne.prototype.isIntersectionLine = function (t) {
            return (
              console.warn(
                "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."
              ),
              this.intersectsLine(t)
            );
          }),
          (At.prototype.multiplyVector3 = function (t) {
            return (
              console.warn(
                "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
              ),
              t.applyQuaternion(this)
            );
          }),
          (At.prototype.inverse = function () {
            return (
              console.warn(
                "THREE.Quaternion: .inverse() has been renamed to invert()."
              ),
              this.invert()
            );
          }),
          (re.prototype.isIntersectionBox = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."
              ),
              this.intersectsBox(t)
            );
          }),
          (re.prototype.isIntersectionPlane = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."
              ),
              this.intersectsPlane(t)
            );
          }),
          (re.prototype.isIntersectionSphere = function (t) {
            return (
              console.warn(
                "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."
              ),
              this.intersectsSphere(t)
            );
          }),
          (je.prototype.area = function () {
            return (
              console.warn(
                "THREE.Triangle: .area() has been renamed to .getArea()."
              ),
              this.getArea()
            );
          }),
          (je.prototype.barycoordFromPoint = function (t, e) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              this.getBarycoord(t, e)
            );
          }),
          (je.prototype.midpoint = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."
              ),
              this.getMidpoint(t)
            );
          }),
          (je.prototypenormal = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              this.getNormal(t)
            );
          }),
          (je.prototype.plane = function (t) {
            return (
              console.warn(
                "THREE.Triangle: .plane() has been renamed to .getPlane()."
              ),
              this.getPlane(t)
            );
          }),
          (je.barycoordFromPoint = function (t, e, n, i, r) {
            return (
              console.warn(
                "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."
              ),
              je.getBarycoord(t, e, n, i, r)
            );
          }),
          (je.normal = function (t, e, n, i) {
            return (
              console.warn(
                "THREE.Triangle: .normal() has been renamed to .getNormal()."
              ),
              je.getNormal(t, e, n, i)
            );
          }),
          (zl.prototype.extractAllPoints = function (t) {
            return (
              console.warn(
                "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."
              ),
              this.extractPoints(t)
            );
          }),
          (zl.prototype.extrude = function (t) {
            return (
              console.warn(
                "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."
              ),
              new go(this, t)
            );
          }),
          (zl.prototype.makeGeometry = function (t) {
            return (
              console.warn(
                "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."
              ),
              new Mo(this, t)
            );
          }),
          (vt.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (vt.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (vt.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (Lt.prototype.setEulerFromRotationMatrix = function () {
            console.error(
              "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
            );
          }),
          (Lt.prototype.setEulerFromQuaternion = function () {
            console.error(
              "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead."
            );
          }),
          (Lt.prototype.getPositionFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."
              ),
              this.setFromMatrixPosition(t)
            );
          }),
          (Lt.prototype.getScaleFromMatrix = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."
              ),
              this.setFromMatrixScale(t)
            );
          }),
          (Lt.prototype.getColumnFromMatrix = function (t, e) {
            return (
              console.warn(
                "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."
              ),
              this.setFromMatrixColumn(e, t)
            );
          }),
          (Lt.prototype.applyProjection = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."
              ),
              this.applyMatrix4(t)
            );
          }),
          (Lt.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (Lt.prototype.distanceToManhattan = function (t) {
            return (
              console.warn(
                "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."
              ),
              this.manhattanDistanceTo(t)
            );
          }),
          (Lt.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (St.prototype.fromAttribute = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."
              ),
              this.fromBufferAttribute(t, e, n)
            );
          }),
          (St.prototype.lengthManhattan = function () {
            return (
              console.warn(
                "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."
              ),
              this.manhattanLength()
            );
          }),
          (Ce.prototype.getChildByName = function (t) {
            return (
              console.warn(
                "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."
              ),
              this.getObjectByName(t)
            );
          }),
          (Ce.prototype.renderDepth = function () {
            console.warn(
              "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead."
            );
          }),
          (Ce.prototype.translate = function (t, e) {
            return (
              console.warn(
                "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."
              ),
              this.translateOnAxis(e, t)
            );
          }),
          (Ce.prototype.getWorldRotation = function () {
            console.error(
              "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
            );
          }),
          (Ce.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                "THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(Ce.prototype, {
            eulerOrder: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Object3D: .eulerOrder is now .rotation.order."
                  ),
                  this.rotation.order
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.Object3D: .eulerOrder is now .rotation.order."
                ),
                  (this.rotation.order = t);
              },
            },
            useQuaternion: {
              get: function () {
                console.warn(
                  "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                );
              },
              set: function () {
                console.warn(
                  "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default."
                );
              },
            },
          }),
          (Wn.prototype.setDrawMode = function () {
            console.error(
              "THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
            );
          }),
          Object.defineProperties(Wn.prototype, {
            drawMode: {
              get: function () {
                return (
                  console.error(
                    "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."
                  ),
                  0
                );
              },
              set: function () {
                console.error(
                  "THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary."
                );
              },
            },
          }),
          ($s.prototype.initBones = function () {
            console.error("THREE.SkinnedMesh: initBones() has been removed.");
          }),
          (Kn.prototype.setLens = function (t, e) {
            console.warn(
              "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
            ),
              void 0 !== e && (this.filmGauge = e),
              this.setFocalLength(t);
          }),
          Object.defineProperties(Fl.prototype, {
            onlyShadow: {
              set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.");
              },
            },
            shadowCameraFov: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraFov is now .shadow.camera.fov."
                ),
                  (this.shadow.camera.fov = t);
              },
            },
            shadowCameraLeft: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraLeft is now .shadow.camera.left."
                ),
                  (this.shadow.camera.left = t);
              },
            },
            shadowCameraRight: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraRight is now .shadow.camera.right."
                ),
                  (this.shadow.camera.right = t);
              },
            },
            shadowCameraTop: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraTop is now .shadow.camera.top."
                ),
                  (this.shadow.camera.top = t);
              },
            },
            shadowCameraBottom: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."
                ),
                  (this.shadow.camera.bottom = t);
              },
            },
            shadowCameraNear: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraNear is now .shadow.camera.near."
                ),
                  (this.shadow.camera.near = t);
              },
            },
            shadowCameraFar: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowCameraFar is now .shadow.camera.far."
                ),
                  (this.shadow.camera.far = t);
              },
            },
            shadowCameraVisible: {
              set: function () {
                console.warn(
                  "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
                );
              },
            },
            shadowBias: {
              set: function (t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                  (this.shadow.bias = t);
              },
            },
            shadowDarkness: {
              set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.");
              },
            },
            shadowMapWidth: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."
                ),
                  (this.shadow.mapSize.width = t);
              },
            },
            shadowMapHeight: {
              set: function (t) {
                console.warn(
                  "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."
                ),
                  (this.shadow.mapSize.height = t);
              },
            },
          }),
          Object.defineProperties(sn.prototype, {
            length: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferAttribute: .length has been deprecated. Use .count instead."
                  ),
                  this.array.length
                );
              },
            },
            dynamic: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                  ),
                  this.usage === nt
                );
              },
              set: function () {
                console.warn(
                  "THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."
                ),
                  this.setUsage(nt);
              },
            },
          }),
          (sn.prototype.setDynamic = function (t) {
            return (
              console.warn(
                "THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === t ? nt : et),
              this
            );
          }),
          (sn.prototype.copyIndicesArray = function () {
            console.error(
              "THREE.BufferAttribute: .copyIndicesArray() has been removed."
            );
          }),
          (sn.prototype.setArray = function () {
            console.error(
              "THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          }),
          (En.prototype.addIndex = function (t) {
            console.warn(
              "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."
            ),
              this.setIndex(t);
          }),
          (En.prototype.addAttribute = function (t, e) {
            return (
              console.warn(
                "THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."
              ),
              (e && e.isBufferAttribute) ||
              (e && e.isInterleavedBufferAttribute)
                ? "index" === t
                  ? (console.warn(
                      "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."
                    ),
                    this.setIndex(e),
                    this)
                  : this.setAttribute(t, e)
                : (console.warn(
                    "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."
                  ),
                  this.setAttribute(t, new sn(arguments[1], arguments[2])))
            );
          }),
          (En.prototype.addDrawCall = function (t, e, n) {
            void 0 !== n &&
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."
              ),
              console.warn(
                "THREE.BufferGeometry: .addDrawCall() is now .addGroup()."
              ),
              this.addGroup(t, e);
          }),
          (En.prototype.clearDrawCalls = function () {
            console.warn(
              "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."
            ),
              this.clearGroups();
          }),
          (En.prototype.computeOffsets = function () {
            console.warn(
              "THREE.BufferGeometry: .computeOffsets() has been removed."
            );
          }),
          (En.prototype.removeAttribute = function (t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."
              ),
              this.deleteAttribute(t)
            );
          }),
          (En.prototype.applyMatrix = function (t) {
            return (
              console.warn(
                "THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."
              ),
              this.applyMatrix4(t)
            );
          }),
          Object.defineProperties(En.prototype, {
            drawcalls: {
              get: function () {
                return (
                  console.error(
                    "THREE.BufferGeometry: .drawcalls has been renamed to .groups."
                  ),
                  this.groups
                );
              },
            },
            offsets: {
              get: function () {
                return (
                  console.warn(
                    "THREE.BufferGeometry: .offsets has been renamed to .groups."
                  ),
                  this.groups
                );
              },
            },
          }),
          (Es.prototype.setDynamic = function (t) {
            return (
              console.warn(
                "THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."
              ),
              this.setUsage(!0 === t ? nt : et),
              this
            );
          }),
          (Es.prototype.setArray = function () {
            console.error(
              "THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
            );
          }),
          (go.prototype.getArrays = function () {
            console.error(
              "THREE.ExtrudeGeometry: .getArrays() has been removed."
            );
          }),
          (go.prototype.addShapeList = function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShapeList() has been removed."
            );
          }),
          (go.prototype.addShape = function () {
            console.error(
              "THREE.ExtrudeGeometry: .addShape() has been removed."
            );
          }),
          (Ts.prototype.dispose = function () {
            console.error("THREE.Scene: .dispose() has been removed.");
          }),
          (Zc.prototype.onUpdate = function () {
            return (
              console.warn(
                "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."
              ),
              this
            );
          }),
          Object.defineProperties(Xe.prototype, {
            wrapAround: {
              get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.");
              },
              set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.");
              },
            },
            overdraw: {
              get: function () {
                console.warn("THREE.Material: .overdraw has been removed.");
              },
              set: function () {
                console.warn("THREE.Material: .overdraw has been removed.");
              },
            },
            wrapRGB: {
              get: function () {
                return (
                  console.warn("THREE.Material: .wrapRGB has been removed."),
                  new tn()
                );
              },
            },
            shading: {
              get: function () {
                console.error(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                );
              },
              set: function (t) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .shading has been removed. Use the boolean .flatShading instead."
                ),
                  (this.flatShading = 1 === t);
              },
            },
            stencilMask: {
              get: function () {
                return (
                  console.warn(
                    "THREE." +
                      this.type +
                      ": .stencilMask has been removed. Use .stencilFuncMask instead."
                  ),
                  this.stencilFuncMask
                );
              },
              set: function (t) {
                console.warn(
                  "THREE." +
                    this.type +
                    ": .stencilMask has been removed. Use .stencilFuncMask instead."
                ),
                  (this.stencilFuncMask = t);
              },
            },
          }),
          Object.defineProperties(Jn.prototype, {
            derivatives: {
              get: function () {
                return (
                  console.warn(
                    "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                  ),
                  this.extensions.derivatives
                );
              },
              set: function (t) {
                console.warn(
                  "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."
                ),
                  (this.extensions.derivatives = t);
              },
            },
          }),
          (ws.prototype.clearTarget = function (t, e, n, i) {
            console.warn(
              "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
            ),
              this.setRenderTarget(t),
              this.clear(e, n, i);
          }),
          (ws.prototype.animate = function (t) {
            console.warn(
              "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
            ),
              this.setAnimationLoop(t);
          }),
          (ws.prototype.getCurrentRenderTarget = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
              ),
              this.getRenderTarget()
            );
          }),
          (ws.prototype.getMaxAnisotropy = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
              ),
              this.capabilities.getMaxAnisotropy()
            );
          }),
          (ws.prototype.getPrecision = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
              ),
              this.capabilities.precision
            );
          }),
          (ws.prototype.resetGLState = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
              ),
              this.state.reset()
            );
          }),
          (ws.prototype.supportsFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
              ),
              this.extensions.get("OES_texture_float")
            );
          }),
          (ws.prototype.supportsHalfFloatTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
              ),
              this.extensions.get("OES_texture_half_float")
            );
          }),
          (ws.prototype.supportsStandardDerivatives = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
              ),
              this.extensions.get("OES_standard_derivatives")
            );
          }),
          (ws.prototype.supportsCompressedTextureS3TC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_s3tc")
            );
          }),
          (ws.prototype.supportsCompressedTexturePVRTC = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
              ),
              this.extensions.get("WEBGL_compressed_texture_pvrtc")
            );
          }),
          (ws.prototype.supportsBlendMinMax = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
              ),
              this.extensions.get("EXT_blend_minmax")
            );
          }),
          (ws.prototype.supportsVertexTextures = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
              ),
              this.capabilities.vertexTextures
            );
          }),
          (ws.prototype.supportsInstancedArrays = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
              ),
              this.extensions.get("ANGLE_instanced_arrays")
            );
          }),
          (ws.prototype.enableScissorTest = function (t) {
            console.warn(
              "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
            ),
              this.setScissorTest(t);
          }),
          (ws.prototype.initMaterial = function () {
            console.warn(
              "THREE.WebGLRenderer: .initMaterial() has been removed."
            );
          }),
          (ws.prototype.addPrePlugin = function () {
            console.warn(
              "THREE.WebGLRenderer: .addPrePlugin() has been removed."
            );
          }),
          (ws.prototype.addPostPlugin = function () {
            console.warn(
              "THREE.WebGLRenderer: .addPostPlugin() has been removed."
            );
          }),
          (ws.prototype.updateShadowMap = function () {
            console.warn(
              "THREE.WebGLRenderer: .updateShadowMap() has been removed."
            );
          }),
          (ws.prototype.setFaceCulling = function () {
            console.warn(
              "THREE.WebGLRenderer: .setFaceCulling() has been removed."
            );
          }),
          (ws.prototype.allocTextureUnit = function () {
            console.warn(
              "THREE.WebGLRenderer: .allocTextureUnit() has been removed."
            );
          }),
          (ws.prototype.setTexture = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture() has been removed."
            );
          }),
          (ws.prototype.setTexture2D = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTexture2D() has been removed."
            );
          }),
          (ws.prototype.setTextureCube = function () {
            console.warn(
              "THREE.WebGLRenderer: .setTextureCube() has been removed."
            );
          }),
          (ws.prototype.getActiveMipMapLevel = function () {
            return (
              console.warn(
                "THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."
              ),
              this.getActiveMipmapLevel()
            );
          }),
          Object.defineProperties(ws.prototype, {
            shadowMapEnabled: {
              get: function () {
                return this.shadowMap.enabled;
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
                ),
                  (this.shadowMap.enabled = t);
              },
            },
            shadowMapType: {
              get: function () {
                return this.shadowMap.type;
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
                ),
                  (this.shadowMap.type = t);
              },
            },
            shadowMapCullFace: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
                );
              },
            },
            context: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."
                  ),
                  this.getContext()
                );
              },
            },
            vr: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .vr has been renamed to .xr"
                  ),
                  this.xr
                );
              },
            },
            gammaInput: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                  ),
                  !1
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."
                );
              },
            },
            gammaOutput: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                  ),
                  !1
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."
                ),
                  (this.outputEncoding = !0 === t ? Y : X);
              },
            },
            toneMappingWhitePoint: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                  ),
                  1
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."
                );
              },
            },
          }),
          Object.defineProperties(us.prototype, {
            cullFace: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
                );
              },
            },
            renderReverseSided: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
                );
              },
            },
            renderSingleSided: {
              get: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                );
              },
              set: function () {
                console.warn(
                  "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
                );
              },
            },
          }),
          Object.defineProperties(Tt.prototype, {
            wrapS: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                  ),
                  this.texture.wrapS
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
                ),
                  (this.texture.wrapS = t);
              },
            },
            wrapT: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                  ),
                  this.texture.wrapT
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
                ),
                  (this.texture.wrapT = t);
              },
            },
            magFilter: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                  ),
                  this.texture.magFilter
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
                ),
                  (this.texture.magFilter = t);
              },
            },
            minFilter: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                  ),
                  this.texture.minFilter
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
                ),
                  (this.texture.minFilter = t);
              },
            },
            anisotropy: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                  ),
                  this.texture.anisotropy
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
                ),
                  (this.texture.anisotropy = t);
              },
            },
            offset: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                  ),
                  this.texture.offset
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .offset is now .texture.offset."
                ),
                  (this.texture.offset = t);
              },
            },
            repeat: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                  ),
                  this.texture.repeat
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
                ),
                  (this.texture.repeat = t);
              },
            },
            format: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .format is now .texture.format."
                  ),
                  this.texture.format
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .format is now .texture.format."
                ),
                  (this.texture.format = t);
              },
            },
            type: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .type is now .texture.type."
                  ),
                  this.texture.type
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .type is now .texture.type."
                ),
                  (this.texture.type = t);
              },
            },
            generateMipmaps: {
              get: function () {
                return (
                  console.warn(
                    "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                  ),
                  this.texture.generateMipmaps
                );
              },
              set: function (t) {
                console.warn(
                  "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
                ),
                  (this.texture.generateMipmaps = t);
              },
            },
          }),
          (Lc.prototype.load = function (t) {
            console.warn(
              "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
            );
            const e = this;
            return (
              new vc().load(t, function (t) {
                e.setBuffer(t);
              }),
              this
            );
          }),
          (Ic.prototype.getData = function () {
            return (
              console.warn(
                "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
              ),
              this.getFrequencyData()
            );
          }),
          (ti.prototype.updateCubeMap = function (t, e) {
            return (
              console.warn(
                "THREE.CubeCamera: .updateCubeMap() is now .update()."
              ),
              this.update(t, e)
            );
          }),
          (ti.prototype.clear = function (t, e, n, i) {
            return (
              console.warn(
                "THREE.CubeCamera: .clear() is now .renderTarget.clear()."
              ),
              this.renderTarget.clear(t, e, n, i)
            );
          }),
          (_t.crossOrigin = void 0),
          (_t.loadTexture = function (t, e, n, i) {
            console.warn(
              "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
            );
            const r = new pl();
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e), s;
          }),
          (_t.loadTextureCube = function (t, e, n, i) {
            console.warn(
              "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
            );
            const r = new ul();
            r.setCrossOrigin(this.crossOrigin);
            const s = r.load(t, n, void 0, i);
            return e && (s.mapping = e), s;
          }),
          (_t.loadCompressedTexture = function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
            );
          }),
          (_t.loadCompressedTextureCube = function () {
            console.error(
              "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
            );
          });
        const eu = {
          createMultiMaterialObject: function () {
            console.error(
              "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
            );
          },
          detach: function () {
            console.error(
              "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
            );
          },
          attach: function () {
            console.error(
              "THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js"
            );
          },
        };
        "undefined" != typeof __THREE_DEVTOOLS__ &&
          __THREE_DEVTOOLS__.dispatchEvent(
            new CustomEvent("register", { detail: { revision: e } })
          ),
          "undefined" != typeof window &&
            (window.__THREE__
              ? console.warn(
                  "WARNING: Multiple instances of Three.js being imported."
                )
              : (window.__THREE__ = e)),
          (t.ACESFilmicToneMapping = 4),
          (t.AddEquation = n),
          (t.AddOperation = 2),
          (t.AdditiveAnimationBlendMode = q),
          (t.AdditiveBlending = 2),
          (t.AlphaFormat = 1021),
          (t.AlwaysDepth = 1),
          (t.AlwaysStencilFunc = 519),
          (t.AmbientLight = $l),
          (t.AmbientLightProbe = xc),
          (t.AnimationClip = nl),
          (t.AnimationLoader = class extends ol {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new cl(this.manager);
              s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(this.withCredentials),
                s.load(
                  t,
                  function (n) {
                    try {
                      e(r.parse(JSON.parse(n)));
                    } catch (e) {
                      i ? i(e) : console.error(e), r.manager.itemError(t);
                    }
                  },
                  n,
                  i
                );
            }
            parse(t) {
              const e = [];
              for (let n = 0; n < t.length; n++) {
                const i = nl.parse(t[n]);
                e.push(i);
              }
              return e;
            }
          }),
          (t.AnimationMixer = Yc),
          (t.AnimationObjectGroup = qc),
          (t.AnimationUtils = Vo),
          (t.ArcCurve = gl),
          (t.ArrayCamera = fs),
          (t.ArrowHelper = class extends Ce {
            constructor(
              t = new Lt(0, 0, 1),
              e = new Lt(0, 0, 0),
              n = 1,
              i = 16776960,
              r = 0.2 * n,
              s = 0.2 * r
            ) {
              super(),
                (this.type = "ArrowHelper"),
                void 0 === Th &&
                  ((Th = new En()),
                  Th.setAttribute("position", new mn([0, 0, 0, 0, 1, 0], 3)),
                  (Eh = new Da(0, 0.5, 1, 5, 1)),
                  Eh.translate(0, -0.5, 0)),
                this.position.copy(e),
                (this.line = new fa(Th, new ca({ color: i, toneMapped: !1 }))),
                (this.line.matrixAutoUpdate = !1),
                this.add(this.line),
                (this.cone = new Wn(Eh, new en({ color: i, toneMapped: !1 }))),
                (this.cone.matrixAutoUpdate = !1),
                this.add(this.cone),
                this.setDirection(t),
                this.setLength(n, r, s);
            }
            setDirection(t) {
              if (t.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
              else if (t.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
              else {
                Sh.set(t.z, 0, -t.x).normalize();
                const e = Math.acos(t.y);
                this.quaternion.setFromAxisAngle(Sh, e);
              }
            }
            setLength(t, e = 0.2 * t, n = 0.2 * e) {
              this.line.scale.set(1, Math.max(1e-4, t - e), 1),
                this.line.updateMatrix(),
                this.cone.scale.set(n, e, n),
                (this.cone.position.y = t),
                this.cone.updateMatrix();
            }
            setColor(t) {
              this.line.material.color.set(t), this.cone.material.color.set(t);
            }
            copy(t) {
              return (
                super.copy(t, !1),
                this.line.copy(t.line),
                this.cone.copy(t.cone),
                this
              );
            }
          }),
          (t.Audio = Lc),
          (t.AudioAnalyser = Ic),
          (t.AudioContext = gc),
          (t.AudioListener = class extends Ce {
            constructor() {
              super(),
                (this.type = "AudioListener"),
                (this.context = gc.getContext()),
                (this.gain = this.context.createGain()),
                this.gain.connect(this.context.destination),
                (this.filter = null),
                (this.timeDelta = 0),
                (this._clock = new bc());
            }
            getInput() {
              return this.gain;
            }
            removeFilter() {
              return (
                null !== this.filter &&
                  (this.gain.disconnect(this.filter),
                  this.filter.disconnect(this.context.destination),
                  this.gain.connect(this.context.destination),
                  (this.filter = null)),
                this
              );
            }
            getFilter() {
              return this.filter;
            }
            setFilter(t) {
              return (
                null !== this.filter
                  ? (this.gain.disconnect(this.filter),
                    this.filter.disconnect(this.context.destination))
                  : this.gain.disconnect(this.context.destination),
                (this.filter = t),
                this.gain.connect(this.filter),
                this.filter.connect(this.context.destination),
                this
              );
            }
            getMasterVolume() {
              return this.gain.gain.value;
            }
            setMasterVolume(t) {
              return (
                this.gain.gain.setTargetAtTime(
                  t,
                  this.context.currentTime,
                  0.01
                ),
                this
              );
            }
            updateMatrixWorld(t) {
              super.updateMatrixWorld(t);
              const e = this.context.listener,
                n = this.up;
              if (
                ((this.timeDelta = this._clock.getDelta()),
                this.matrixWorld.decompose(Sc, Tc, Ec),
                Ac.set(0, 0, -1).applyQuaternion(Tc),
                e.positionX)
              ) {
                const t = this.context.currentTime + this.timeDelta;
                e.positionX.linearRampToValueAtTime(Sc.x, t),
                  e.positionY.linearRampToValueAtTime(Sc.y, t),
                  e.positionZ.linearRampToValueAtTime(Sc.z, t),
                  e.forwardX.linearRampToValueAtTime(Ac.x, t),
                  e.forwardY.linearRampToValueAtTime(Ac.y, t),
                  e.forwardZ.linearRampToValueAtTime(Ac.z, t),
                  e.upX.linearRampToValueAtTime(n.x, t),
                  e.upY.linearRampToValueAtTime(n.y, t),
                  e.upZ.linearRampToValueAtTime(n.z, t);
              } else
                e.setPosition(Sc.x, Sc.y, Sc.z),
                  e.setOrientation(Ac.x, Ac.y, Ac.z, n.x, n.y, n.z);
            }
          }),
          (t.AudioLoader = vc),
          (t.AxesHelper = Ah),
          (t.AxisHelper = function (t) {
            return (
              console.warn(
                "THREE.AxisHelper has been renamed to THREE.AxesHelper."
              ),
              new Ah(t)
            );
          }),
          (t.BackSide = 1),
          (t.BasicDepthPacking = 3200),
          (t.BasicShadowMap = 0),
          (t.BinaryTextureLoader = function (t) {
            return (
              console.warn(
                "THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."
              ),
              new dl(t)
            );
          }),
          (t.Bone = ta),
          (t.BooleanKeyframeTrack = Zo),
          (t.BoundingBoxHelper = function (t, e) {
            return (
              console.warn(
                "THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."
              ),
              new Mh(t, e)
            );
          }),
          (t.Box2 = eh),
          (t.Box3 = Pt),
          (t.Box3Helper = class extends ya {
            constructor(t, e = 16776960) {
              const n = new Uint16Array([
                  0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2,
                  6, 3, 7,
                ]),
                i = new En();
              i.setIndex(new sn(n, 1)),
                i.setAttribute(
                  "position",
                  new mn(
                    [
                      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1,
                      -1, -1, -1, -1, 1, -1, -1,
                    ],
                    3
                  )
                ),
                super(i, new ca({ color: e, toneMapped: !1 })),
                (this.box = t),
                (this.type = "Box3Helper"),
                this.geometry.computeBoundingSphere();
            }
            updateMatrixWorld(t) {
              const e = this.box;
              e.isEmpty() ||
                (e.getCenter(this.position),
                e.getSize(this.scale),
                this.scale.multiplyScalar(0.5),
                super.updateMatrixWorld(t));
            }
          }),
          (t.BoxBufferGeometry = qn),
          (t.BoxGeometry = qn),
          (t.BoxHelper = Mh),
          (t.BufferAttribute = sn),
          (t.BufferGeometry = En),
          (t.BufferGeometryLoader = oc),
          (t.ByteType = 1010),
          (t.Cache = rl),
          (t.Camera = Qn),
          (t.CameraHelper = class extends ya {
            constructor(t) {
              const e = new En(),
                n = new ca({
                  color: 16777215,
                  vertexColors: !0,
                  toneMapped: !1,
                }),
                i = [],
                r = [],
                s = {},
                a = new tn(16755200),
                o = new tn(16711680),
                l = new tn(43775),
                c = new tn(16777215),
                h = new tn(3355443);
              function u(t, e, n) {
                d(t, n), d(e, n);
              }
              function d(t, e) {
                i.push(0, 0, 0),
                  r.push(e.r, e.g, e.b),
                  void 0 === s[t] && (s[t] = []),
                  s[t].push(i.length / 3 - 1);
              }
              u("n1", "n2", a),
                u("n2", "n4", a),
                u("n4", "n3", a),
                u("n3", "n1", a),
                u("f1", "f2", a),
                u("f2", "f4", a),
                u("f4", "f3", a),
                u("f3", "f1", a),
                u("n1", "f1", a),
                u("n2", "f2", a),
                u("n3", "f3", a),
                u("n4", "f4", a),
                u("p", "n1", o),
                u("p", "n2", o),
                u("p", "n3", o),
                u("p", "n4", o),
                u("u1", "u2", l),
                u("u2", "u3", l),
                u("u3", "u1", l),
                u("c", "t", c),
                u("p", "c", h),
                u("cn1", "cn2", h),
                u("cn3", "cn4", h),
                u("cf1", "cf2", h),
                u("cf3", "cf4", h),
                e.setAttribute("position", new mn(i, 3)),
                e.setAttribute("color", new mn(r, 3)),
                super(e, n),
                (this.type = "CameraHelper"),
                (this.camera = t),
                this.camera.updateProjectionMatrix &&
                  this.camera.updateProjectionMatrix(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.pointMap = s),
                this.update();
            }
            update() {
              const t = this.geometry,
                e = this.pointMap;
              _h.projectionMatrixInverse.copy(
                this.camera.projectionMatrixInverse
              ),
                wh("c", e, t, _h, 0, 0, -1),
                wh("t", e, t, _h, 0, 0, 1),
                wh("n1", e, t, _h, -1, -1, -1),
                wh("n2", e, t, _h, 1, -1, -1),
                wh("n3", e, t, _h, -1, 1, -1),
                wh("n4", e, t, _h, 1, 1, -1),
                wh("f1", e, t, _h, -1, -1, 1),
                wh("f2", e, t, _h, 1, -1, 1),
                wh("f3", e, t, _h, -1, 1, 1),
                wh("f4", e, t, _h, 1, 1, 1),
                wh("u1", e, t, _h, 0.7, 1.1, -1),
                wh("u2", e, t, _h, -0.7, 1.1, -1),
                wh("u3", e, t, _h, 0, 2, -1),
                wh("cf1", e, t, _h, -1, 0, 1),
                wh("cf2", e, t, _h, 1, 0, 1),
                wh("cf3", e, t, _h, 0, -1, 1),
                wh("cf4", e, t, _h, 0, 1, 1),
                wh("cn1", e, t, _h, -1, 0, -1),
                wh("cn2", e, t, _h, 1, 0, -1),
                wh("cn3", e, t, _h, 0, -1, -1),
                wh("cn4", e, t, _h, 0, 1, -1),
                (t.getAttribute("position").needsUpdate = !0);
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
          }),
          (t.CanvasRenderer = function () {
            console.error("THREE.CanvasRenderer has been removed");
          }),
          (t.CanvasTexture = Ra),
          (t.CatmullRomCurve3 = bl),
          (t.CineonToneMapping = 3),
          (t.CircleBufferGeometry = Pa),
          (t.CircleGeometry = Pa),
          (t.ClampToEdgeWrapping = u),
          (t.Clock = bc),
          (t.Color = tn),
          (t.ColorKeyframeTrack = Jo),
          (t.CompressedTexture = La),
          (t.CompressedTextureLoader = class extends ol {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = [],
                a = new La(),
                o = new cl(this.manager);
              o.setPath(this.path),
                o.setResponseType("arraybuffer"),
                o.setRequestHeader(this.requestHeader),
                o.setWithCredentials(r.withCredentials);
              let l = 0;
              function c(c) {
                o.load(
                  t[c],
                  function (t) {
                    const n = r.parse(t, !0);
                    (s[c] = {
                      width: n.width,
                      height: n.height,
                      format: n.format,
                      mipmaps: n.mipmaps,
                    }),
                      (l += 1),
                      6 === l &&
                        (1 === n.mipmapCount && (a.minFilter = g),
                        (a.image = s),
                        (a.format = n.format),
                        (a.needsUpdate = !0),
                        e && e(a));
                  },
                  n,
                  i
                );
              }
              if (Array.isArray(t))
                for (let e = 0, n = t.length; e < n; ++e) c(e);
              else
                o.load(
                  t,
                  function (t) {
                    const n = r.parse(t, !0);
                    if (n.isCubemap) {
                      const t = n.mipmaps.length / n.mipmapCount;
                      for (let e = 0; e < t; e++) {
                        s[e] = { mipmaps: [] };
                        for (let t = 0; t < n.mipmapCount; t++)
                          s[e].mipmaps.push(n.mipmaps[e * n.mipmapCount + t]),
                            (s[e].format = n.format),
                            (s[e].width = n.width),
                            (s[e].height = n.height);
                      }
                      a.image = s;
                    } else
                      (a.image.width = n.width),
                        (a.image.height = n.height),
                        (a.mipmaps = n.mipmaps);
                    1 === n.mipmapCount && (a.minFilter = g),
                      (a.format = n.format),
                      (a.needsUpdate = !0),
                      e && e(a);
                  },
                  n,
                  i
                );
              return a;
            }
          }),
          (t.ConeBufferGeometry = Ia),
          (t.ConeGeometry = Ia),
          (t.CubeCamera = ti),
          (t.CubeReflectionMapping = r),
          (t.CubeRefractionMapping = s),
          (t.CubeTexture = ei),
          (t.CubeTextureLoader = ul),
          (t.CubeUVReflectionMapping = l),
          (t.CubeUVRefractionMapping = c),
          (t.CubicBezierCurve = El),
          (t.CubicBezierCurve3 = Al),
          (t.CubicInterpolant = jo),
          (t.CullFaceBack = 1),
          (t.CullFaceFront = 2),
          (t.CullFaceFrontBack = 3),
          (t.CullFaceNone = 0),
          (t.Curve = ml),
          (t.CurvePath = Nl),
          (t.CustomBlending = 5),
          (t.CustomToneMapping = 5),
          (t.CylinderBufferGeometry = Da),
          (t.CylinderGeometry = Da),
          (t.Cylindrical = class {
            constructor(t = 1, e = 0, n = 0) {
              return (this.radius = t), (this.theta = e), (this.y = n), this;
            }
            set(t, e, n) {
              return (this.radius = t), (this.theta = e), (this.y = n), this;
            }
            copy(t) {
              return (
                (this.radius = t.radius),
                (this.theta = t.theta),
                (this.y = t.y),
                this
              );
            }
            setFromVector3(t) {
              return this.setFromCartesianCoords(t.x, t.y, t.z);
            }
            setFromCartesianCoords(t, e, n) {
              return (
                (this.radius = Math.sqrt(t * t + n * n)),
                (this.theta = Math.atan2(t, n)),
                (this.y = e),
                this
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }),
          (t.DataTexture = ii),
          (t.DataTexture2DArray = Ai),
          (t.DataTexture3D = Li),
          (t.DataTextureLoader = dl),
          (t.DataUtils = class {
            static toHalfFloat(t) {
              Lh[0] = t;
              const e = Rh[0];
              let n = (e >> 16) & 32768,
                i = (e >> 12) & 2047;
              const r = (e >> 23) & 255;
              return r < 103
                ? n
                : r > 142
                ? ((n |= 31744), (n |= (255 == r ? 0 : 1) && 8388607 & e), n)
                : r < 113
                ? ((i |= 2048),
                  (n |= (i >> (114 - r)) + ((i >> (113 - r)) & 1)),
                  n)
                : ((n |= ((r - 112) << 10) | (i >> 1)), (n += 1 & i), n);
            }
          }),
          (t.DecrementStencilOp = 7683),
          (t.DecrementWrapStencilOp = 34056),
          (t.DefaultLoadingManager = al),
          (t.DepthFormat = A),
          (t.DepthStencilFormat = L),
          (t.DepthTexture = Ca),
          (t.DirectionalLight = Kl),
          (t.DirectionalLightHelper = class extends Ce {
            constructor(t, e, n) {
              super(),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n),
                void 0 === e && (e = 1);
              let i = new En();
              i.setAttribute(
                "position",
                new mn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
              );
              const r = new ca({ fog: !1, toneMapped: !1 });
              (this.lightPlane = new fa(i, r)),
                this.add(this.lightPlane),
                (i = new En()),
                i.setAttribute("position", new mn([0, 0, 0, 0, 0, 1], 3)),
                (this.targetLine = new fa(i, r)),
                this.add(this.targetLine),
                this.update();
            }
            dispose() {
              this.lightPlane.geometry.dispose(),
                this.lightPlane.material.dispose(),
                this.targetLine.geometry.dispose(),
                this.targetLine.material.dispose();
            }
            update() {
              gh.setFromMatrixPosition(this.light.matrixWorld),
                vh.setFromMatrixPosition(this.light.target.matrixWorld),
                yh.subVectors(vh, gh),
                this.lightPlane.lookAt(vh),
                void 0 !== this.color
                  ? (this.lightPlane.material.color.set(this.color),
                    this.targetLine.material.color.set(this.color))
                  : (this.lightPlane.material.color.copy(this.light.color),
                    this.targetLine.material.color.copy(this.light.color)),
                this.targetLine.lookAt(vh),
                (this.targetLine.scale.z = yh.length());
            }
          }),
          (t.DiscreteInterpolant = Xo),
          (t.DodecahedronBufferGeometry = Ba),
          (t.DodecahedronGeometry = Ba),
          (t.DoubleSide = 2),
          (t.DstAlphaFactor = 206),
          (t.DstColorFactor = 208),
          (t.DynamicBufferAttribute = function (t, e) {
            return (
              console.warn(
                "THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead."
              ),
              new sn(t, e).setUsage(nt)
            );
          }),
          (t.DynamicCopyUsage = 35050),
          (t.DynamicDrawUsage = nt),
          (t.DynamicReadUsage = 35049),
          (t.EdgesGeometry = Ga),
          (t.EdgesHelper = function (t, e) {
            return (
              console.warn(
                "THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."
              ),
              new ya(
                new Ga(t.geometry),
                new ca({ color: void 0 !== e ? e : 16777215 })
              )
            );
          }),
          (t.EllipseCurve = fl),
          (t.EqualDepth = 4),
          (t.EqualStencilFunc = 514),
          (t.EquirectangularReflectionMapping = a),
          (t.EquirectangularRefractionMapping = o),
          (t.Euler = fe),
          (t.EventDispatcher = rt),
          (t.ExtrudeBufferGeometry = go),
          (t.ExtrudeGeometry = go),
          (t.FaceColors = 1),
          (t.FileLoader = cl),
          (t.FlatShading = 1),
          (t.Float16BufferAttribute = pn),
          (t.Float32Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."
              ),
              new mn(t, e)
            );
          }),
          (t.Float32BufferAttribute = mn),
          (t.Float64Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."
              ),
              new fn(t, e)
            );
          }),
          (t.Float64BufferAttribute = fn),
          (t.FloatType = b),
          (t.Fog = Ss),
          (t.FogExp2 = Ms),
          (t.Font = pc),
          (t.FontLoader = class extends ol {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = new cl(this.manager);
              s.setPath(this.path),
                s.setRequestHeader(this.requestHeader),
                s.setWithCredentials(r.withCredentials),
                s.load(
                  t,
                  function (t) {
                    let n;
                    try {
                      n = JSON.parse(t);
                    } catch (e) {
                      console.warn(
                        "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."
                      ),
                        (n = JSON.parse(t.substring(65, t.length - 2)));
                    }
                    const i = r.parse(n);
                    e && e(i);
                  },
                  n,
                  i
                );
            }
            parse(t) {
              return new pc(t);
            }
          }),
          (t.FrontSide = 0),
          (t.Frustum = ai),
          (t.GLBufferAttribute = Qc),
          (t.GLSL1 = "100"),
          (t.GLSL3 = it),
          (t.GammaEncoding = Z),
          (t.GreaterDepth = 6),
          (t.GreaterEqualDepth = 5),
          (t.GreaterEqualStencilFunc = 518),
          (t.GreaterStencilFunc = 516),
          (t.GridHelper = fh),
          (t.Group = gs),
          (t.HalfFloatType = M),
          (t.HemisphereLight = Ol),
          (t.HemisphereLightHelper = class extends Ce {
            constructor(t, e, n) {
              super(),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = n);
              const i = new _o(e);
              i.rotateY(0.5 * Math.PI),
                (this.material = new en({
                  wireframe: !0,
                  fog: !1,
                  toneMapped: !1,
                })),
                void 0 === this.color && (this.material.vertexColors = !0);
              const r = i.getAttribute("position"),
                s = new Float32Array(3 * r.count);
              i.setAttribute("color", new sn(s, 3)),
                this.add(new Wn(i, this.material)),
                this.update();
            }
            dispose() {
              this.children[0].geometry.dispose(),
                this.children[0].material.dispose();
            }
            update() {
              const t = this.children[0];
              if (void 0 !== this.color) this.material.color.set(this.color);
              else {
                const e = t.geometry.getAttribute("color");
                ph.copy(this.light.color), mh.copy(this.light.groundColor);
                for (let t = 0, n = e.count; t < n; t++) {
                  const i = t < n / 2 ? ph : mh;
                  e.setXYZ(t, i.r, i.g, i.b);
                }
                e.needsUpdate = !0;
              }
              t.lookAt(
                dh.setFromMatrixPosition(this.light.matrixWorld).negate()
              );
            }
          }),
          (t.HemisphereLightProbe = yc),
          (t.IcosahedronBufferGeometry = yo),
          (t.IcosahedronGeometry = yo),
          (t.ImageBitmapLoader = uc),
          (t.ImageLoader = hl),
          (t.ImageUtils = _t),
          (t.ImmediateRenderObject = sh),
          (t.IncrementStencilOp = 7682),
          (t.IncrementWrapStencilOp = 34055),
          (t.InstancedBufferAttribute = ac),
          (t.InstancedBufferGeometry = sc),
          (t.InstancedInterleavedBuffer = Jc),
          (t.InstancedMesh = la),
          (t.Int16Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."
              ),
              new cn(t, e)
            );
          }),
          (t.Int16BufferAttribute = cn),
          (t.Int32Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."
              ),
              new un(t, e)
            );
          }),
          (t.Int32BufferAttribute = un),
          (t.Int8Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."
              ),
              new an(t, e)
            );
          }),
          (t.Int8BufferAttribute = an),
          (t.IntType = 1013),
          (t.InterleavedBuffer = Es),
          (t.InterleavedBufferAttribute = Ls),
          (t.Interpolant = Wo),
          (t.InterpolateDiscrete = H),
          (t.InterpolateLinear = G),
          (t.InterpolateSmooth = U),
          (t.InvertStencilOp = 5386),
          (t.JSONLoader = function () {
            console.error("THREE.JSONLoader has been removed.");
          }),
          (t.KeepStencilOp = tt),
          (t.KeyframeTrack = Yo),
          (t.LOD = Xs),
          (t.LatheBufferGeometry = xo),
          (t.LatheGeometry = xo),
          (t.Layers = ge),
          (t.LensFlare = function () {
            console.error(
              "THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js"
            );
          }),
          (t.LessDepth = 2),
          (t.LessEqualDepth = 3),
          (t.LessEqualStencilFunc = 515),
          (t.LessStencilFunc = 513),
          (t.Light = Fl),
          (t.LightProbe = nc),
          (t.Line = fa),
          (t.Line3 = rh),
          (t.LineBasicMaterial = ca),
          (t.LineCurve = Ll),
          (t.LineCurve3 = Rl),
          (t.LineDashedMaterial = Uo),
          (t.LineLoop = xa),
          (t.LinePieces = 1),
          (t.LineSegments = ya),
          (t.LineStrip = 0),
          (t.LinearEncoding = X),
          (t.LinearFilter = g),
          (t.LinearInterpolant = qo),
          (t.LinearMipMapLinearFilter = 1008),
          (t.LinearMipMapNearestFilter = 1007),
          (t.LinearMipmapLinearFilter = y),
          (t.LinearMipmapNearestFilter = v),
          (t.LinearToneMapping = 1),
          (t.Loader = ol),
          (t.LoaderUtils = rc),
          (t.LoadingManager = sl),
          (t.LogLuvEncoding = 3003),
          (t.LoopOnce = 2200),
          (t.LoopPingPong = 2202),
          (t.LoopRepeat = 2201),
          (t.LuminanceAlphaFormat = 1025),
          (t.LuminanceFormat = 1024),
          (t.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
          }),
          (t.Material = Xe),
          (t.MaterialLoader = ic),
          (t.Math = gt),
          (t.MathUtils = gt),
          (t.Matrix3 = yt),
          (t.Matrix4 = se),
          (t.MaxEquation = 104),
          (t.Mesh = Wn),
          (t.MeshBasicMaterial = en),
          (t.MeshDepthMaterial = cs),
          (t.MeshDistanceMaterial = hs),
          (t.MeshFaceMaterial = function (t) {
            return (
              console.warn(
                "THREE.MeshFaceMaterial has been removed. Use an Array instead."
              ),
              t
            );
          }),
          (t.MeshLambertMaterial = Ho),
          (t.MeshMatcapMaterial = Go),
          (t.MeshNormalMaterial = Oo),
          (t.MeshPhongMaterial = zo),
          (t.MeshPhysicalMaterial = Bo),
          (t.MeshStandardMaterial = No),
          (t.MeshToonMaterial = Fo),
          (t.MinEquation = 103),
          (t.MirroredRepeatWrapping = d),
          (t.MixOperation = 1),
          (t.MultiMaterial = function (t = []) {
            return (
              console.warn(
                "THREE.MultiMaterial has been removed. Use an Array instead."
              ),
              (t.isMultiMaterial = !0),
              (t.materials = t),
              (t.clone = function () {
                return t.slice();
              }),
              t
            );
          }),
          (t.MultiplyBlending = 4),
          (t.MultiplyOperation = 0),
          (t.NearestFilter = p),
          (t.NearestMipMapLinearFilter = 1005),
          (t.NearestMipMapNearestFilter = 1004),
          (t.NearestMipmapLinearFilter = f),
          (t.NearestMipmapNearestFilter = m),
          (t.NeverDepth = 0),
          (t.NeverStencilFunc = 512),
          (t.NoBlending = 0),
          (t.NoColors = 0),
          (t.NoToneMapping = 0),
          (t.NormalAnimationBlendMode = j),
          (t.NormalBlending = 1),
          (t.NotEqualDepth = 7),
          (t.NotEqualStencilFunc = 517),
          (t.NumberKeyframeTrack = Qo),
          (t.Object3D = Ce),
          (t.ObjectLoader = class extends ol {
            constructor(t) {
              super(t);
            }
            load(t, e, n, i) {
              const r = this,
                s = "" === this.path ? rc.extractUrlBase(t) : this.path;
              this.resourcePath = this.resourcePath || s;
              const a = new cl(this.manager);
              a.setPath(this.path),
                a.setRequestHeader(this.requestHeader),
                a.setWithCredentials(this.withCredentials),
                a.load(
                  t,
                  function (n) {
                    let s = null;
                    try {
                      s = JSON.parse(n);
                    } catch (e) {
                      return (
                        void 0 !== i && i(e),
                        void console.error(
                          "THREE:ObjectLoader: Can't parse " + t + ".",
                          e.message
                        )
                      );
                    }
                    const a = s.metadata;
                    void 0 !== a &&
                    void 0 !== a.type &&
                    "geometry" !== a.type.toLowerCase()
                      ? r.parse(s, e)
                      : console.error("THREE.ObjectLoader: Can't load " + t);
                  },
                  n,
                  i
                );
            }
            parse(t, e) {
              const n = this.parseAnimations(t.animations),
                i = this.parseShapes(t.shapes),
                r = this.parseGeometries(t.geometries, i),
                s = this.parseImages(t.images, function () {
                  void 0 !== e && e(l);
                }),
                a = this.parseTextures(t.textures, s),
                o = this.parseMaterials(t.materials, a),
                l = this.parseObject(t.object, r, o, n),
                c = this.parseSkeletons(t.skeletons, l);
              if ((this.bindSkeletons(l, c), void 0 !== e)) {
                let t = !1;
                for (const e in s)
                  if (s[e] instanceof HTMLImageElement) {
                    t = !0;
                    break;
                  }
                !1 === t && e(l);
              }
              return l;
            }
            parseShapes(t) {
              const e = {};
              if (void 0 !== t)
                for (let n = 0, i = t.length; n < i; n++) {
                  const i = new zl().fromJSON(t[n]);
                  e[i.uuid] = i;
                }
              return e;
            }
            parseSkeletons(t, e) {
              const n = {},
                i = {};
              if (
                (e.traverse(function (t) {
                  t.isBone && (i[t.uuid] = t);
                }),
                void 0 !== t)
              )
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = new ia().fromJSON(t[e], i);
                  n[r.uuid] = r;
                }
              return n;
            }
            parseGeometries(t, e) {
              const n = {};
              let i;
              if (void 0 !== t) {
                const r = new oc();
                for (let s = 0, a = t.length; s < a; s++) {
                  let a;
                  const o = t[s];
                  switch (o.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                      a = new Po[o.type](
                        o.width,
                        o.height,
                        o.widthSegments,
                        o.heightSegments
                      );
                      break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                      a = new Po[o.type](
                        o.width,
                        o.height,
                        o.depth,
                        o.widthSegments,
                        o.heightSegments,
                        o.depthSegments
                      );
                      break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                      a = new Po[o.type](
                        o.radius,
                        o.segments,
                        o.thetaStart,
                        o.thetaLength
                      );
                      break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                      a = new Po[o.type](
                        o.radiusTop,
                        o.radiusBottom,
                        o.height,
                        o.radialSegments,
                        o.heightSegments,
                        o.openEnded,
                        o.thetaStart,
                        o.thetaLength
                      );
                      break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                      a = new Po[o.type](
                        o.radius,
                        o.height,
                        o.radialSegments,
                        o.heightSegments,
                        o.openEnded,
                        o.thetaStart,
                        o.thetaLength
                      );
                      break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                      a = new Po[o.type](
                        o.radius,
                        o.widthSegments,
                        o.heightSegments,
                        o.phiStart,
                        o.phiLength,
                        o.thetaStart,
                        o.thetaLength
                      );
                      break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                      a = new Po[o.type](o.radius, o.detail);
                      break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                      a = new Po[o.type](
                        o.innerRadius,
                        o.outerRadius,
                        o.thetaSegments,
                        o.phiSegments,
                        o.thetaStart,
                        o.thetaLength
                      );
                      break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                      a = new Po[o.type](
                        o.radius,
                        o.tube,
                        o.radialSegments,
                        o.tubularSegments,
                        o.arc
                      );
                      break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                      a = new Po[o.type](
                        o.radius,
                        o.tube,
                        o.tubularSegments,
                        o.radialSegments,
                        o.p,
                        o.q
                      );
                      break;
                    case "TubeGeometry":
                    case "TubeBufferGeometry":
                      a = new Po[o.type](
                        new Il[o.path.type]().fromJSON(o.path),
                        o.tubularSegments,
                        o.radius,
                        o.radialSegments,
                        o.closed
                      );
                      break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                      a = new Po[o.type](
                        o.points,
                        o.segments,
                        o.phiStart,
                        o.phiLength
                      );
                      break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                      a = new Po[o.type](
                        o.vertices,
                        o.indices,
                        o.radius,
                        o.details
                      );
                      break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                      i = [];
                      for (let t = 0, n = o.shapes.length; t < n; t++) {
                        const n = e[o.shapes[t]];
                        i.push(n);
                      }
                      a = new Po[o.type](i, o.curveSegments);
                      break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                      i = [];
                      for (let t = 0, n = o.shapes.length; t < n; t++) {
                        const n = e[o.shapes[t]];
                        i.push(n);
                      }
                      const t = o.options.extrudePath;
                      void 0 !== t &&
                        (o.options.extrudePath = new Il[t.type]().fromJSON(t)),
                        (a = new Po[o.type](i, o.options));
                      break;
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                      a = r.parse(o);
                      break;
                    case "Geometry":
                      console.error(
                        'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.'
                      );
                      break;
                    default:
                      console.warn(
                        'THREE.ObjectLoader: Unsupported geometry type "' +
                          o.type +
                          '"'
                      );
                      continue;
                  }
                  (a.uuid = o.uuid),
                    void 0 !== o.name && (a.name = o.name),
                    !0 === a.isBufferGeometry &&
                      void 0 !== o.userData &&
                      (a.userData = o.userData),
                    (n[o.uuid] = a);
                }
              }
              return n;
            }
            parseMaterials(t, e) {
              const n = {},
                i = {};
              if (void 0 !== t) {
                const r = new ic();
                r.setTextures(e);
                for (let e = 0, s = t.length; e < s; e++) {
                  const s = t[e];
                  if ("MultiMaterial" === s.type) {
                    const t = [];
                    for (let e = 0; e < s.materials.length; e++) {
                      const i = s.materials[e];
                      void 0 === n[i.uuid] && (n[i.uuid] = r.parse(i)),
                        t.push(n[i.uuid]);
                    }
                    i[s.uuid] = t;
                  } else
                    void 0 === n[s.uuid] && (n[s.uuid] = r.parse(s)),
                      (i[s.uuid] = n[s.uuid]);
                }
              }
              return i;
            }
            parseAnimations(t) {
              const e = {};
              if (void 0 !== t)
                for (let n = 0; n < t.length; n++) {
                  const i = t[n],
                    r = nl.parse(i);
                  e[r.uuid] = r;
                }
              return e;
            }
            parseImages(t, e) {
              const n = this,
                i = {};
              let r;
              function s(t) {
                if ("string" == typeof t) {
                  const e = t;
                  return (function (t) {
                    return (
                      n.manager.itemStart(t),
                      r.load(
                        t,
                        function () {
                          n.manager.itemEnd(t);
                        },
                        void 0,
                        function () {
                          n.manager.itemError(t), n.manager.itemEnd(t);
                        }
                      )
                    );
                  })(
                    /^(\/\/)|([a-z]+:(\/\/)?)/i.test(e) ? e : n.resourcePath + e
                  );
                }
                return t.data
                  ? {
                      data: yn(t.type, t.data),
                      width: t.width,
                      height: t.height,
                    }
                  : null;
              }
              if (void 0 !== t && t.length > 0) {
                const n = new sl(e);
                (r = new hl(n)), r.setCrossOrigin(this.crossOrigin);
                for (let e = 0, n = t.length; e < n; e++) {
                  const n = t[e],
                    r = n.url;
                  if (Array.isArray(r)) {
                    i[n.uuid] = [];
                    for (let t = 0, e = r.length; t < e; t++) {
                      const e = s(r[t]);
                      null !== e &&
                        (e instanceof HTMLImageElement
                          ? i[n.uuid].push(e)
                          : i[n.uuid].push(new ii(e.data, e.width, e.height)));
                    }
                  } else {
                    const t = s(n.url);
                    null !== t && (i[n.uuid] = t);
                  }
                }
              }
              return i;
            }
            parseTextures(t, e) {
              function n(t, e) {
                return "number" == typeof t
                  ? t
                  : (console.warn(
                      "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
                      t
                    ),
                    e[t]);
              }
              const i = {};
              if (void 0 !== t)
                for (let r = 0, s = t.length; r < s; r++) {
                  const s = t[r];
                  let a;
                  void 0 === s.image &&
                    console.warn(
                      'THREE.ObjectLoader: No "image" specified for',
                      s.uuid
                    ),
                    void 0 === e[s.image] &&
                      console.warn(
                        "THREE.ObjectLoader: Undefined image",
                        s.image
                      );
                  const o = e[s.image];
                  Array.isArray(o)
                    ? ((a = new ei(o)), 6 === o.length && (a.needsUpdate = !0))
                    : ((a =
                        o && o.data
                          ? new ii(o.data, o.width, o.height)
                          : new bt(o)),
                      o && (a.needsUpdate = !0)),
                    (a.uuid = s.uuid),
                    void 0 !== s.name && (a.name = s.name),
                    void 0 !== s.mapping && (a.mapping = n(s.mapping, lc)),
                    void 0 !== s.offset && a.offset.fromArray(s.offset),
                    void 0 !== s.repeat && a.repeat.fromArray(s.repeat),
                    void 0 !== s.center && a.center.fromArray(s.center),
                    void 0 !== s.rotation && (a.rotation = s.rotation),
                    void 0 !== s.wrap &&
                      ((a.wrapS = n(s.wrap[0], cc)),
                      (a.wrapT = n(s.wrap[1], cc))),
                    void 0 !== s.format && (a.format = s.format),
                    void 0 !== s.type && (a.type = s.type),
                    void 0 !== s.encoding && (a.encoding = s.encoding),
                    void 0 !== s.minFilter &&
                      (a.minFilter = n(s.minFilter, hc)),
                    void 0 !== s.magFilter &&
                      (a.magFilter = n(s.magFilter, hc)),
                    void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy),
                    void 0 !== s.flipY && (a.flipY = s.flipY),
                    void 0 !== s.premultiplyAlpha &&
                      (a.premultiplyAlpha = s.premultiplyAlpha),
                    void 0 !== s.unpackAlignment &&
                      (a.unpackAlignment = s.unpackAlignment),
                    (i[s.uuid] = a);
                }
              return i;
            }
            parseObject(t, e, n, i) {
              let r, s, a;
              function o(t) {
                return (
                  void 0 === e[t] &&
                    console.warn("THREE.ObjectLoader: Undefined geometry", t),
                  e[t]
                );
              }
              function l(t) {
                if (void 0 !== t) {
                  if (Array.isArray(t)) {
                    const e = [];
                    for (let i = 0, r = t.length; i < r; i++) {
                      const r = t[i];
                      void 0 === n[r] &&
                        console.warn(
                          "THREE.ObjectLoader: Undefined material",
                          r
                        ),
                        e.push(n[r]);
                    }
                    return e;
                  }
                  return (
                    void 0 === n[t] &&
                      console.warn("THREE.ObjectLoader: Undefined material", t),
                    n[t]
                  );
                }
              }
              switch (t.type) {
                case "Scene":
                  (r = new Ts()),
                    void 0 !== t.background &&
                      Number.isInteger(t.background) &&
                      (r.background = new tn(t.background)),
                    void 0 !== t.fog &&
                      ("Fog" === t.fog.type
                        ? (r.fog = new Ss(t.fog.color, t.fog.near, t.fog.far))
                        : "FogExp2" === t.fog.type &&
                          (r.fog = new Ms(t.fog.color, t.fog.density)));
                  break;
                case "PerspectiveCamera":
                  (r = new Kn(t.fov, t.aspect, t.near, t.far)),
                    void 0 !== t.focus && (r.focus = t.focus),
                    void 0 !== t.zoom && (r.zoom = t.zoom),
                    void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge),
                    void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset),
                    void 0 !== t.view && (r.view = Object.assign({}, t.view));
                  break;
                case "OrthographicCamera":
                  (r = new Jl(t.left, t.right, t.top, t.bottom, t.near, t.far)),
                    void 0 !== t.zoom && (r.zoom = t.zoom),
                    void 0 !== t.view && (r.view = Object.assign({}, t.view));
                  break;
                case "AmbientLight":
                  r = new $l(t.color, t.intensity);
                  break;
                case "DirectionalLight":
                  r = new Kl(t.color, t.intensity);
                  break;
                case "PointLight":
                  r = new Zl(t.color, t.intensity, t.distance, t.decay);
                  break;
                case "RectAreaLight":
                  r = new tc(t.color, t.intensity, t.width, t.height);
                  break;
                case "SpotLight":
                  r = new Wl(
                    t.color,
                    t.intensity,
                    t.distance,
                    t.angle,
                    t.penumbra,
                    t.decay
                  );
                  break;
                case "HemisphereLight":
                  r = new Ol(t.color, t.groundColor, t.intensity);
                  break;
                case "LightProbe":
                  r = new nc().fromJSON(t);
                  break;
                case "SkinnedMesh":
                  (s = o(t.geometry)),
                    (a = l(t.material)),
                    (r = new $s(s, a)),
                    void 0 !== t.bindMode && (r.bindMode = t.bindMode),
                    void 0 !== t.bindMatrix &&
                      r.bindMatrix.fromArray(t.bindMatrix),
                    void 0 !== t.skeleton && (r.skeleton = t.skeleton);
                  break;
                case "Mesh":
                  (s = o(t.geometry)), (a = l(t.material)), (r = new Wn(s, a));
                  break;
                case "InstancedMesh":
                  (s = o(t.geometry)), (a = l(t.material));
                  const e = t.count,
                    n = t.instanceMatrix,
                    i = t.instanceColor;
                  (r = new la(s, a, e)),
                    (r.instanceMatrix = new sn(new Float32Array(n.array), 16)),
                    void 0 !== i &&
                      (r.instanceColor = new sn(
                        new Float32Array(i.array),
                        i.itemSize
                      ));
                  break;
                case "LOD":
                  r = new Xs();
                  break;
                case "Line":
                  r = new fa(o(t.geometry), l(t.material));
                  break;
                case "LineLoop":
                  r = new xa(o(t.geometry), l(t.material));
                  break;
                case "LineSegments":
                  r = new ya(o(t.geometry), l(t.material));
                  break;
                case "PointCloud":
                case "Points":
                  r = new Ta(o(t.geometry), l(t.material));
                  break;
                case "Sprite":
                  r = new Vs(l(t.material));
                  break;
                case "Group":
                  r = new gs();
                  break;
                case "Bone":
                  r = new ta();
                  break;
                default:
                  r = new Ce();
              }
              if (
                ((r.uuid = t.uuid),
                void 0 !== t.name && (r.name = t.name),
                void 0 !== t.matrix
                  ? (r.matrix.fromArray(t.matrix),
                    void 0 !== t.matrixAutoUpdate &&
                      (r.matrixAutoUpdate = t.matrixAutoUpdate),
                    r.matrixAutoUpdate &&
                      r.matrix.decompose(r.position, r.quaternion, r.scale))
                  : (void 0 !== t.position && r.position.fromArray(t.position),
                    void 0 !== t.rotation && r.rotation.fromArray(t.rotation),
                    void 0 !== t.quaternion &&
                      r.quaternion.fromArray(t.quaternion),
                    void 0 !== t.scale && r.scale.fromArray(t.scale)),
                void 0 !== t.castShadow && (r.castShadow = t.castShadow),
                void 0 !== t.receiveShadow &&
                  (r.receiveShadow = t.receiveShadow),
                t.shadow &&
                  (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias),
                  void 0 !== t.shadow.normalBias &&
                    (r.shadow.normalBias = t.shadow.normalBias),
                  void 0 !== t.shadow.radius &&
                    (r.shadow.radius = t.shadow.radius),
                  void 0 !== t.shadow.mapSize &&
                    r.shadow.mapSize.fromArray(t.shadow.mapSize),
                  void 0 !== t.shadow.camera &&
                    (r.shadow.camera = this.parseObject(t.shadow.camera))),
                void 0 !== t.visible && (r.visible = t.visible),
                void 0 !== t.frustumCulled &&
                  (r.frustumCulled = t.frustumCulled),
                void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder),
                void 0 !== t.userData && (r.userData = t.userData),
                void 0 !== t.layers && (r.layers.mask = t.layers),
                void 0 !== t.children)
              ) {
                const s = t.children;
                for (let t = 0; t < s.length; t++)
                  r.add(this.parseObject(s[t], e, n, i));
              }
              if (void 0 !== t.animations) {
                const e = t.animations;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t];
                  r.animations.push(i[n]);
                }
              }
              if ("LOD" === t.type) {
                void 0 !== t.autoUpdate && (r.autoUpdate = t.autoUpdate);
                const e = t.levels;
                for (let t = 0; t < e.length; t++) {
                  const n = e[t],
                    i = r.getObjectByProperty("uuid", n.object);
                  void 0 !== i && r.addLevel(i, n.distance);
                }
              }
              return r;
            }
            bindSkeletons(t, e) {
              0 !== Object.keys(e).length &&
                t.traverse(function (t) {
                  if (!0 === t.isSkinnedMesh && void 0 !== t.skeleton) {
                    const n = e[t.skeleton];
                    void 0 === n
                      ? console.warn(
                          "THREE.ObjectLoader: No skeleton found with UUID:",
                          t.skeleton
                        )
                      : t.bind(n, t.bindMatrix);
                  }
                });
            }
            setTexturePath(t) {
              return (
                console.warn(
                  "THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."
                ),
                this.setResourcePath(t)
              );
            }
          }),
          (t.ObjectSpaceNormalMap = 1),
          (t.OctahedronBufferGeometry = _o),
          (t.OctahedronGeometry = _o),
          (t.OneFactor = 201),
          (t.OneMinusDstAlphaFactor = 207),
          (t.OneMinusDstColorFactor = 209),
          (t.OneMinusSrcAlphaFactor = 205),
          (t.OneMinusSrcColorFactor = 203),
          (t.OrthographicCamera = Jl),
          (t.PCFShadowMap = 1),
          (t.PCFSoftShadowMap = 2),
          (t.PMREMGenerator = class {
            constructor(t) {
              (this._renderer = t),
                (this._pingPongRenderTarget = null),
                (this._blurMaterial = (function (t) {
                  const e = new Float32Array(t),
                    n = new Lt(0, 1, 0);
                  return new Io({
                    name: "SphericalGaussianBlur",
                    defines: { n: t },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: e },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: n },
                      inputEncoding: { value: Nh[3e3] },
                      outputEncoding: { value: Nh[3e3] },
                    },
                    vertexShader: $h(),
                    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${tu()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                })(Ih)),
                (this._equirectShader = null),
                (this._cubemapShader = null),
                this._compileMaterial(this._blurMaterial);
            }
            fromScene(t, e = 0, n = 0.1, i = 100) {
              kh = this._renderer.getRenderTarget();
              const r = this._allocateTargets();
              return (
                this._sceneToCubeUV(t, n, i, r),
                e > 0 && this._blur(r, 0, 0, e),
                this._applyPMREM(r),
                this._cleanup(r),
                r
              );
            }
            fromEquirectangular(t) {
              return this._fromTexture(t);
            }
            fromCubemap(t) {
              return this._fromTexture(t);
            }
            compileCubemapShader() {
              null === this._cubemapShader &&
                ((this._cubemapShader = Kh()),
                this._compileMaterial(this._cubemapShader));
            }
            compileEquirectangularShader() {
              null === this._equirectShader &&
                ((this._equirectShader = Qh()),
                this._compileMaterial(this._equirectShader));
            }
            dispose() {
              this._blurMaterial.dispose(),
                null !== this._cubemapShader && this._cubemapShader.dispose(),
                null !== this._equirectShader && this._equirectShader.dispose();
              for (let t = 0; t < Oh.length; t++) Oh[t].dispose();
            }
            _cleanup(t) {
              this._pingPongRenderTarget.dispose(),
                this._renderer.setRenderTarget(kh),
                (t.scissorTest = !1),
                Jh(t, 0, 0, t.width, t.height);
            }
            _fromTexture(t) {
              kh = this._renderer.getRenderTarget();
              const e = this._allocateTargets(t);
              return (
                this._textureToCubeUV(t, e),
                this._applyPMREM(e),
                this._cleanup(e),
                e
              );
            }
            _allocateTargets(t) {
              const e = {
                  magFilter: p,
                  minFilter: p,
                  generateMipmaps: !1,
                  type: x,
                  format: 1023,
                  encoding: Xh(t) ? t.encoding : J,
                  depthBuffer: !1,
                },
                n = Zh(e);
              return (
                (n.depthBuffer = !t), (this._pingPongRenderTarget = Zh(e)), n
              );
            }
            _compileMaterial(t) {
              const e = new Wn(Oh[0], t);
              this._renderer.compile(e, Fh);
            }
            _sceneToCubeUV(t, e, n, i) {
              const r = new Kn(90, 1, e, n),
                s = [1, -1, 1, 1, 1, 1],
                a = [1, 1, 1, -1, -1, -1],
                o = this._renderer,
                l = o.autoClear,
                c = o.outputEncoding,
                h = o.toneMapping;
              o.getClearColor(Uh),
                (o.toneMapping = 0),
                (o.outputEncoding = X),
                (o.autoClear = !1);
              let u = !1;
              const d = t.background;
              if (d) {
                if (d.isColor) {
                  Bh.color.copy(d).convertSRGBToLinear(), (t.background = null);
                  const e = qh(Bh.color);
                  (Bh.opacity = e), (u = !0);
                }
              } else {
                Bh.color.copy(Uh).convertSRGBToLinear();
                const t = qh(Bh.color);
                (Bh.opacity = t), (u = !0);
              }
              for (let e = 0; e < 6; e++) {
                const n = e % 3;
                0 == n
                  ? (r.up.set(0, s[e], 0), r.lookAt(a[e], 0, 0))
                  : 1 == n
                  ? (r.up.set(0, 0, s[e]), r.lookAt(0, a[e], 0))
                  : (r.up.set(0, s[e], 0), r.lookAt(0, 0, a[e])),
                  Jh(i, n * Ch, e > 2 ? Ch : 0, Ch, Ch),
                  o.setRenderTarget(i),
                  u && o.render(zh, r),
                  o.render(t, r);
              }
              (o.toneMapping = h), (o.outputEncoding = c), (o.autoClear = l);
            }
            _textureToCubeUV(t, e) {
              const n = this._renderer;
              t.isCubeTexture
                ? null == this._cubemapShader && (this._cubemapShader = Kh())
                : null == this._equirectShader && (this._equirectShader = Qh());
              const i = t.isCubeTexture
                  ? this._cubemapShader
                  : this._equirectShader,
                r = new Wn(Oh[0], i),
                s = i.uniforms;
              (s.envMap.value = t),
                t.isCubeTexture ||
                  s.texelSize.value.set(1 / t.image.width, 1 / t.image.height),
                (s.inputEncoding.value = Nh[t.encoding]),
                (s.outputEncoding.value = Nh[e.texture.encoding]),
                Jh(e, 0, 0, 3 * Ch, 2 * Ch),
                n.setRenderTarget(e),
                n.render(r, Fh);
            }
            _applyPMREM(t) {
              const e = this._renderer,
                n = e.autoClear;
              e.autoClear = !1;
              for (let e = 1; e < Dh; e++) {
                const n = Math.sqrt(Gh[e] * Gh[e] - Gh[e - 1] * Gh[e - 1]),
                  i = jh[(e - 1) % jh.length];
                this._blur(t, e - 1, e, n, i);
              }
              e.autoClear = n;
            }
            _blur(t, e, n, i, r) {
              const s = this._pingPongRenderTarget;
              this._halfBlur(t, s, e, n, i, "latitudinal", r),
                this._halfBlur(s, t, n, n, i, "longitudinal", r);
            }
            _halfBlur(t, e, n, i, r, s, a) {
              const o = this._renderer,
                l = this._blurMaterial;
              "latitudinal" !== s &&
                "longitudinal" !== s &&
                console.error(
                  "blur direction must be either latitudinal or longitudinal!"
                );
              const c = new Wn(Oh[i], l),
                h = l.uniforms,
                u = Hh[n] - 1,
                d = isFinite(r) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
                p = r / d,
                m = isFinite(r) ? 1 + Math.floor(3 * p) : Ih;
              m > Ih &&
                console.warn(
                  `sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to 20`
                );
              const f = [];
              let g = 0;
              for (let t = 0; t < Ih; ++t) {
                const e = t / p,
                  n = Math.exp((-e * e) / 2);
                f.push(n), 0 == t ? (g += n) : t < m && (g += 2 * n);
              }
              for (let t = 0; t < f.length; t++) f[t] = f[t] / g;
              (h.envMap.value = t.texture),
                (h.samples.value = m),
                (h.weights.value = f),
                (h.latitudinal.value = "latitudinal" === s),
                a && (h.poleAxis.value = a),
                (h.dTheta.value = d),
                (h.mipInt.value = 8 - n),
                (h.inputEncoding.value = Nh[t.texture.encoding]),
                (h.outputEncoding.value = Nh[t.texture.encoding]);
              const v = Hh[i];
              Jh(
                e,
                3 * Math.max(0, Ch - 2 * v),
                (0 === i ? 0 : 2 * Ch) + 2 * v * (i > 4 ? i - 8 + 4 : 0),
                3 * v,
                2 * v
              ),
                o.setRenderTarget(e),
                o.render(c, Fh);
            }
          }),
          (t.ParametricBufferGeometry = wo),
          (t.ParametricGeometry = wo),
          (t.Particle = function (t) {
            return (
              console.warn("THREE.Particle has been renamed to THREE.Sprite."),
              new Vs(t)
            );
          }),
          (t.ParticleBasicMaterial = function (t) {
            return (
              console.warn(
                "THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."
              ),
              new _a(t)
            );
          }),
          (t.ParticleSystem = function (t, e) {
            return (
              console.warn(
                "THREE.ParticleSystem has been renamed to THREE.Points."
              ),
              new Ta(t, e)
            );
          }),
          (t.ParticleSystemMaterial = function (t) {
            return (
              console.warn(
                "THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."
              ),
              new _a(t)
            );
          }),
          (t.Path = Bl),
          (t.PerspectiveCamera = Kn),
          (t.Plane = Ne),
          (t.PlaneBufferGeometry = ci),
          (t.PlaneGeometry = ci),
          (t.PlaneHelper = class extends fa {
            constructor(t, e = 1, n = 16776960) {
              const i = n,
                r = new En();
              r.setAttribute(
                "position",
                new mn(
                  [
                    1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1,
                    1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0,
                  ],
                  3
                )
              ),
                r.computeBoundingSphere(),
                super(r, new ca({ color: i, toneMapped: !1 })),
                (this.type = "PlaneHelper"),
                (this.plane = t),
                (this.size = e);
              const s = new En();
              s.setAttribute(
                "position",
                new mn(
                  [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],
                  3
                )
              ),
                s.computeBoundingSphere(),
                this.add(
                  new Wn(
                    s,
                    new en({
                      color: i,
                      opacity: 0.2,
                      transparent: !0,
                      depthWrite: !1,
                      toneMapped: !1,
                    })
                  )
                );
            }
            updateMatrixWorld(t) {
              let e = -this.plane.constant;
              Math.abs(e) < 1e-8 && (e = 1e-8),
                this.scale.set(0.5 * this.size, 0.5 * this.size, e),
                (this.children[0].material.side = e < 0 ? 1 : 0),
                this.lookAt(this.plane.normal),
                super.updateMatrixWorld(t);
            }
          }),
          (t.PointCloud = function (t, e) {
            return (
              console.warn(
                "THREE.PointCloud has been renamed to THREE.Points."
              ),
              new Ta(t, e)
            );
          }),
          (t.PointCloudMaterial = function (t) {
            return (
              console.warn(
                "THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."
              ),
              new _a(t)
            );
          }),
          (t.PointLight = Zl),
          (t.PointLightHelper = class extends Wn {
            constructor(t, e, n) {
              super(
                new So(e, 4, 2),
                new en({ wireframe: !0, fog: !1, toneMapped: !1 })
              ),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.color = n),
                (this.type = "PointLightHelper"),
                (this.matrix = this.light.matrixWorld),
                (this.matrixAutoUpdate = !1),
                this.update();
            }
            dispose() {
              this.geometry.dispose(), this.material.dispose();
            }
            update() {
              void 0 !== this.color
                ? this.material.color.set(this.color)
                : this.material.color.copy(this.light.color);
            }
          }),
          (t.Points = Ta),
          (t.PointsMaterial = _a),
          (t.PolarGridHelper = class extends ya {
            constructor(
              t = 10,
              e = 16,
              n = 8,
              i = 64,
              r = 4473924,
              s = 8947848
            ) {
              (r = new tn(r)), (s = new tn(s));
              const a = [],
                o = [];
              for (let n = 0; n <= e; n++) {
                const i = (n / e) * (2 * Math.PI),
                  l = Math.sin(i) * t,
                  c = Math.cos(i) * t;
                a.push(0, 0, 0), a.push(l, 0, c);
                const h = 1 & n ? r : s;
                o.push(h.r, h.g, h.b), o.push(h.r, h.g, h.b);
              }
              for (let e = 0; e <= n; e++) {
                const l = 1 & e ? r : s,
                  c = t - (t / n) * e;
                for (let t = 0; t < i; t++) {
                  let e = (t / i) * (2 * Math.PI),
                    n = Math.sin(e) * c,
                    r = Math.cos(e) * c;
                  a.push(n, 0, r),
                    o.push(l.r, l.g, l.b),
                    (e = ((t + 1) / i) * (2 * Math.PI)),
                    (n = Math.sin(e) * c),
                    (r = Math.cos(e) * c),
                    a.push(n, 0, r),
                    o.push(l.r, l.g, l.b);
                }
              }
              const l = new En();
              l.setAttribute("position", new mn(a, 3)),
                l.setAttribute("color", new mn(o, 3));
              super(l, new ca({ vertexColors: !0, toneMapped: !1 })),
                (this.type = "PolarGridHelper");
            }
          }),
          (t.PolyhedronBufferGeometry = Na),
          (t.PolyhedronGeometry = Na),
          (t.PositionalAudio = class extends Lc {
            constructor(t) {
              super(t),
                (this.panner = this.context.createPanner()),
                (this.panner.panningModel = "HRTF"),
                this.panner.connect(this.gain);
            }
            getOutput() {
              return this.panner;
            }
            getRefDistance() {
              return this.panner.refDistance;
            }
            setRefDistance(t) {
              return (this.panner.refDistance = t), this;
            }
            getRolloffFactor() {
              return this.panner.rolloffFactor;
            }
            setRolloffFactor(t) {
              return (this.panner.rolloffFactor = t), this;
            }
            getDistanceModel() {
              return this.panner.distanceModel;
            }
            setDistanceModel(t) {
              return (this.panner.distanceModel = t), this;
            }
            getMaxDistance() {
              return this.panner.maxDistance;
            }
            setMaxDistance(t) {
              return (this.panner.maxDistance = t), this;
            }
            setDirectionalCone(t, e, n) {
              return (
                (this.panner.coneInnerAngle = t),
                (this.panner.coneOuterAngle = e),
                (this.panner.coneOuterGain = n),
                this
              );
            }
            updateMatrixWorld(t) {
              if (
                (super.updateMatrixWorld(t),
                !0 === this.hasPlaybackControl && !1 === this.isPlaying)
              )
                return;
              this.matrixWorld.decompose(Rc, Cc, Pc),
                Dc.set(0, 0, 1).applyQuaternion(Cc);
              const e = this.panner;
              if (e.positionX) {
                const t = this.context.currentTime + this.listener.timeDelta;
                e.positionX.linearRampToValueAtTime(Rc.x, t),
                  e.positionY.linearRampToValueAtTime(Rc.y, t),
                  e.positionZ.linearRampToValueAtTime(Rc.z, t),
                  e.orientationX.linearRampToValueAtTime(Dc.x, t),
                  e.orientationY.linearRampToValueAtTime(Dc.y, t),
                  e.orientationZ.linearRampToValueAtTime(Dc.z, t);
              } else
                e.setPosition(Rc.x, Rc.y, Rc.z),
                  e.setOrientation(Dc.x, Dc.y, Dc.z);
            }
          }),
          (t.PropertyBinding = jc),
          (t.PropertyMixer = Nc),
          (t.QuadraticBezierCurve = Cl),
          (t.QuadraticBezierCurve3 = Pl),
          (t.Quaternion = At),
          (t.QuaternionKeyframeTrack = $o),
          (t.QuaternionLinearInterpolant = Ko),
          (t.REVISION = e),
          (t.RGBADepthPacking = 3201),
          (t.RGBAFormat = E),
          (t.RGBAIntegerFormat = 1033),
          (t.RGBA_ASTC_10x10_Format = 37819),
          (t.RGBA_ASTC_10x5_Format = 37816),
          (t.RGBA_ASTC_10x6_Format = 37817),
          (t.RGBA_ASTC_10x8_Format = 37818),
          (t.RGBA_ASTC_12x10_Format = 37820),
          (t.RGBA_ASTC_12x12_Format = 37821),
          (t.RGBA_ASTC_4x4_Format = 37808),
          (t.RGBA_ASTC_5x4_Format = 37809),
          (t.RGBA_ASTC_5x5_Format = 37810),
          (t.RGBA_ASTC_6x5_Format = 37811),
          (t.RGBA_ASTC_6x6_Format = 37812),
          (t.RGBA_ASTC_8x5_Format = 37813),
          (t.RGBA_ASTC_8x6_Format = 37814),
          (t.RGBA_ASTC_8x8_Format = 37815),
          (t.RGBA_BPTC_Format = 36492),
          (t.RGBA_ETC2_EAC_Format = O),
          (t.RGBA_PVRTC_2BPPV1_Format = z),
          (t.RGBA_PVRTC_4BPPV1_Format = B),
          (t.RGBA_S3TC_DXT1_Format = C),
          (t.RGBA_S3TC_DXT3_Format = P),
          (t.RGBA_S3TC_DXT5_Format = D),
          (t.RGBDEncoding = $),
          (t.RGBEEncoding = J),
          (t.RGBEFormat = 1023),
          (t.RGBFormat = T),
          (t.RGBIntegerFormat = 1032),
          (t.RGBM16Encoding = K),
          (t.RGBM7Encoding = Q),
          (t.RGB_ETC1_Format = 36196),
          (t.RGB_ETC2_Format = F),
          (t.RGB_PVRTC_2BPPV1_Format = N),
          (t.RGB_PVRTC_4BPPV1_Format = I),
          (t.RGB_S3TC_DXT1_Format = R),
          (t.RGFormat = 1030),
          (t.RGIntegerFormat = 1031),
          (t.RawShaderMaterial = Io),
          (t.Ray = re),
          (t.Raycaster = class {
            constructor(t, e, n = 0, i = 1 / 0) {
              (this.ray = new re(t, e)),
                (this.near = n),
                (this.far = i),
                (this.camera = null),
                (this.layers = new ge()),
                (this.params = {
                  Mesh: {},
                  Line: { threshold: 1 },
                  LOD: {},
                  Points: { threshold: 1 },
                  Sprite: {},
                });
            }
            set(t, e) {
              this.ray.set(t, e);
            }
            setFromCamera(t, e) {
              e && e.isPerspectiveCamera
                ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
                  this.ray.direction
                    .set(t.x, t.y, 0.5)
                    .unproject(e)
                    .sub(this.ray.origin)
                    .normalize(),
                  (this.camera = e))
                : e && e.isOrthographicCamera
                ? (this.ray.origin
                    .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
                    .unproject(e),
                  this.ray.direction
                    .set(0, 0, -1)
                    .transformDirection(e.matrixWorld),
                  (this.camera = e))
                : console.error(
                    "THREE.Raycaster: Unsupported camera type: " + e.type
                  );
            }
            intersectObject(t, e = !1, n = []) {
              return $c(t, this, n, e), n.sort(Kc), n;
            }
            intersectObjects(t, e = !1, n = []) {
              for (let i = 0, r = t.length; i < r; i++) $c(t[i], this, n, e);
              return n.sort(Kc), n;
            }
          }),
          (t.RectAreaLight = tc),
          (t.RedFormat = 1028),
          (t.RedIntegerFormat = 1029),
          (t.ReinhardToneMapping = 2),
          (t.RepeatWrapping = h),
          (t.ReplaceStencilOp = 7681),
          (t.ReverseSubtractEquation = 102),
          (t.RingBufferGeometry = bo),
          (t.RingGeometry = bo),
          (t.SRGB8_ALPHA8_ASTC_10x10_Format = 37851),
          (t.SRGB8_ALPHA8_ASTC_10x5_Format = 37848),
          (t.SRGB8_ALPHA8_ASTC_10x6_Format = 37849),
          (t.SRGB8_ALPHA8_ASTC_10x8_Format = 37850),
          (t.SRGB8_ALPHA8_ASTC_12x10_Format = 37852),
          (t.SRGB8_ALPHA8_ASTC_12x12_Format = 37853),
          (t.SRGB8_ALPHA8_ASTC_4x4_Format = 37840),
          (t.SRGB8_ALPHA8_ASTC_5x4_Format = 37841),
          (t.SRGB8_ALPHA8_ASTC_5x5_Format = 37842),
          (t.SRGB8_ALPHA8_ASTC_6x5_Format = 37843),
          (t.SRGB8_ALPHA8_ASTC_6x6_Format = 37844),
          (t.SRGB8_ALPHA8_ASTC_8x5_Format = 37845),
          (t.SRGB8_ALPHA8_ASTC_8x6_Format = 37846),
          (t.SRGB8_ALPHA8_ASTC_8x8_Format = 37847),
          (t.Scene = Ts),
          (t.SceneUtils = eu),
          (t.ShaderChunk = hi),
          (t.ShaderLib = di),
          (t.ShaderMaterial = Jn),
          (t.ShadowMaterial = Do),
          (t.Shape = zl),
          (t.ShapeBufferGeometry = Mo),
          (t.ShapeGeometry = Mo),
          (t.ShapePath = dc),
          (t.ShapeUtils = po),
          (t.ShortType = 1011),
          (t.Skeleton = ia),
          (t.SkeletonHelper = hh),
          (t.SkinnedMesh = $s),
          (t.SmoothShading = 2),
          (t.Sphere = Jt),
          (t.SphereBufferGeometry = So),
          (t.SphereGeometry = So),
          (t.Spherical = class {
            constructor(t = 1, e = 0, n = 0) {
              return (this.radius = t), (this.phi = e), (this.theta = n), this;
            }
            set(t, e, n) {
              return (this.radius = t), (this.phi = e), (this.theta = n), this;
            }
            copy(t) {
              return (
                (this.radius = t.radius),
                (this.phi = t.phi),
                (this.theta = t.theta),
                this
              );
            }
            makeSafe() {
              const t = 1e-6;
              return (
                (this.phi = Math.max(t, Math.min(Math.PI - t, this.phi))), this
              );
            }
            setFromVector3(t) {
              return this.setFromCartesianCoords(t.x, t.y, t.z);
            }
            setFromCartesianCoords(t, e, n) {
              return (
                (this.radius = Math.sqrt(t * t + e * e + n * n)),
                0 === this.radius
                  ? ((this.theta = 0), (this.phi = 0))
                  : ((this.theta = Math.atan2(t, n)),
                    (this.phi = Math.acos(ht(e / this.radius, -1, 1)))),
                this
              );
            }
            clone() {
              return new this.constructor().copy(this);
            }
          }),
          (t.SphericalHarmonics3 = ec),
          (t.SplineCurve = Dl),
          (t.SpotLight = Wl),
          (t.SpotLightHelper = class extends Ce {
            constructor(t, e) {
              super(),
                (this.light = t),
                this.light.updateMatrixWorld(),
                (this.matrix = t.matrixWorld),
                (this.matrixAutoUpdate = !1),
                (this.color = e);
              const n = new En(),
                i = [
                  0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0,
                  0, 0, 1, 1, 0, 0, 0, 0, -1, 1,
                ];
              for (let t = 0, e = 1, n = 32; t < n; t++, e++) {
                const r = (t / n) * Math.PI * 2,
                  s = (e / n) * Math.PI * 2;
                i.push(
                  Math.cos(r),
                  Math.sin(r),
                  1,
                  Math.cos(s),
                  Math.sin(s),
                  1
                );
              }
              n.setAttribute("position", new mn(i, 3));
              const r = new ca({ fog: !1, toneMapped: !1 });
              (this.cone = new ya(n, r)), this.add(this.cone), this.update();
            }
            dispose() {
              this.cone.geometry.dispose(), this.cone.material.dispose();
            }
            update() {
              this.light.updateMatrixWorld();
              const t = this.light.distance ? this.light.distance : 1e3,
                e = t * Math.tan(this.light.angle);
              this.cone.scale.set(e, e, t),
                ah.setFromMatrixPosition(this.light.target.matrixWorld),
                this.cone.lookAt(ah),
                void 0 !== this.color
                  ? this.cone.material.color.set(this.color)
                  : this.cone.material.color.copy(this.light.color);
            }
          }),
          (t.Sprite = Vs),
          (t.SpriteMaterial = Rs),
          (t.SrcAlphaFactor = 204),
          (t.SrcAlphaSaturateFactor = 210),
          (t.SrcColorFactor = 202),
          (t.StaticCopyUsage = 35046),
          (t.StaticDrawUsage = et),
          (t.StaticReadUsage = 35045),
          (t.StereoCamera = class {
            constructor() {
              (this.type = "StereoCamera"),
                (this.aspect = 1),
                (this.eyeSep = 0.064),
                (this.cameraL = new Kn()),
                this.cameraL.layers.enable(1),
                (this.cameraL.matrixAutoUpdate = !1),
                (this.cameraR = new Kn()),
                this.cameraR.layers.enable(2),
                (this.cameraR.matrixAutoUpdate = !1),
                (this._cache = {
                  focus: null,
                  fov: null,
                  aspect: null,
                  near: null,
                  far: null,
                  zoom: null,
                  eyeSep: null,
                });
            }
            update(t) {
              const e = this._cache;
              if (
                e.focus !== t.focus ||
                e.fov !== t.fov ||
                e.aspect !== t.aspect * this.aspect ||
                e.near !== t.near ||
                e.far !== t.far ||
                e.zoom !== t.zoom ||
                e.eyeSep !== this.eyeSep
              ) {
                (e.focus = t.focus),
                  (e.fov = t.fov),
                  (e.aspect = t.aspect * this.aspect),
                  (e.near = t.near),
                  (e.far = t.far),
                  (e.zoom = t.zoom),
                  (e.eyeSep = this.eyeSep);
                const n = t.projectionMatrix.clone(),
                  i = e.eyeSep / 2,
                  r = (i * e.near) / e.focus,
                  s = (e.near * Math.tan(ot * e.fov * 0.5)) / e.zoom;
                let a, o;
                (wc.elements[12] = -i),
                  (_c.elements[12] = i),
                  (a = -s * e.aspect + r),
                  (o = s * e.aspect + r),
                  (n.elements[0] = (2 * e.near) / (o - a)),
                  (n.elements[8] = (o + a) / (o - a)),
                  this.cameraL.projectionMatrix.copy(n),
                  (a = -s * e.aspect - r),
                  (o = s * e.aspect - r),
                  (n.elements[0] = (2 * e.near) / (o - a)),
                  (n.elements[8] = (o + a) / (o - a)),
                  this.cameraR.projectionMatrix.copy(n);
              }
              this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(wc),
                this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(_c);
            }
          }),
          (t.StreamCopyUsage = 35042),
          (t.StreamDrawUsage = 35040),
          (t.StreamReadUsage = 35041),
          (t.StringKeyframeTrack = tl),
          (t.SubtractEquation = 101),
          (t.SubtractiveBlending = 3),
          (t.TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }),
          (t.TangentSpaceNormalMap = 0),
          (t.TetrahedronBufferGeometry = To),
          (t.TetrahedronGeometry = To),
          (t.TextBufferGeometry = Eo),
          (t.TextGeometry = Eo),
          (t.Texture = bt),
          (t.TextureLoader = pl),
          (t.TorusBufferGeometry = Ao),
          (t.TorusGeometry = Ao),
          (t.TorusKnotBufferGeometry = Lo),
          (t.TorusKnotGeometry = Lo),
          (t.Triangle = je),
          (t.TriangleFanDrawMode = 2),
          (t.TriangleStripDrawMode = 1),
          (t.TrianglesDrawMode = 0),
          (t.TubeBufferGeometry = Ro),
          (t.TubeGeometry = Ro),
          (t.UVMapping = i),
          (t.Uint16Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."
              ),
              new hn(t, e)
            );
          }),
          (t.Uint16BufferAttribute = hn),
          (t.Uint32Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."
              ),
              new dn(t, e)
            );
          }),
          (t.Uint32BufferAttribute = dn),
          (t.Uint8Attribute = function (t, e) {
            return (
              console.warn(
                "THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."
              ),
              new on(t, e)
            );
          }),
          (t.Uint8BufferAttribute = on),
          (t.Uint8ClampedAttribute = function (t, e) {
            return (
              console.warn(
                "THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."
              ),
              new ln(t, e)
            );
          }),
          (t.Uint8ClampedBufferAttribute = ln),
          (t.Uniform = Zc),
          (t.UniformsLib = ui),
          (t.UniformsUtils = Zn),
          (t.UnsignedByteType = x),
          (t.UnsignedInt248Type = S),
          (t.UnsignedIntType = w),
          (t.UnsignedShort4444Type = 1017),
          (t.UnsignedShort5551Type = 1018),
          (t.UnsignedShort565Type = 1019),
          (t.UnsignedShortType = _),
          (t.VSMShadowMap = 3),
          (t.Vector2 = vt),
          (t.Vector3 = Lt),
          (t.Vector4 = St),
          (t.VectorKeyframeTrack = el),
          (t.Vertex = function (t, e, n) {
            return (
              console.warn(
                "THREE.Vertex has been removed. Use THREE.Vector3 instead."
              ),
              new Lt(t, e, n)
            );
          }),
          (t.VertexColors = 2),
          (t.VideoTexture = Aa),
          (t.WebGL1Renderer = bs),
          (t.WebGLCubeRenderTarget = ni),
          (t.WebGLMultisampleRenderTarget = Et),
          (t.WebGLRenderTarget = Tt),
          (t.WebGLRenderTargetCube = function (t, e, n) {
            return (
              console.warn(
                "THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options )."
              ),
              new ni(t, n)
            );
          }),
          (t.WebGLRenderer = ws),
          (t.WebGLUtils = ms),
          (t.WireframeGeometry = Co),
          (t.WireframeHelper = function (t, e) {
            return (
              console.warn(
                "THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."
              ),
              new ya(
                new Co(t.geometry),
                new ca({ color: void 0 !== e ? e : 16777215 })
              )
            );
          }),
          (t.WrapAroundEnding = W),
          (t.XHRLoader = function (t) {
            return (
              console.warn(
                "THREE.XHRLoader has been renamed to THREE.FileLoader."
              ),
              new cl(t)
            );
          }),
          (t.ZeroCurvatureEnding = k),
          (t.ZeroFactor = 200),
          (t.ZeroSlopeEnding = V),
          (t.ZeroStencilOp = 0),
          (t.sRGBEncoding = Y),
          Object.defineProperty(t, "__esModule", { value: !0 });
      });
    </script>
    <script>
      const __$G =
        typeof globalThis !== "undefined"
          ? globalThis
          : typeof window !== "undefined"
          ? window
          : typeof global !== "undefined"
          ? global
          : typeof self !== "undefined"
          ? self
          : {};
      (function (global, factory) {
        typeof exports === "object" && typeof module !== "undefined"
          ? factory(exports)
          : typeof define === "function" && define.amd
          ? define(["exports"], factory)
          : ((global =
              typeof globalThis !== "undefined" ? globalThis : global || self),
            factory((global.ethers = {})));
      })(this, function (exports) {
        "use strict";
        const version = "6.7.0";
        function checkType(value, type, name) {
          const types = type.split("|").map((t) => t.trim());
          for (let i = 0; i < types.length; i++) {
            switch (type) {
              case "any":
                return;
              case "bigint":
              case "boolean":
              case "number":
              case "string":
                if (typeof value === type) {
                  return;
                }
            }
          }
          const error = new Error(`invalid value for type ${type}`);
          error.code = "INVALID_ARGUMENT";
          error.argument = `value.${name}`;
          error.value = value;
          throw error;
        }
        async function resolveProperties(value) {
          const keys = Object.keys(value);
          const results = await Promise.all(
            keys.map((k) => Promise.resolve(value[k]))
          );
          return results.reduce((accum, v, index) => {
            accum[keys[index]] = v;
            return accum;
          }, {});
        }
        function defineProperties(target, values, types) {
          for (let key in values) {
            let value = values[key];
            const type = types ? types[key] : null;
            if (type) {
              checkType(value, type, key);
            }
            Object.defineProperty(target, key, {
              enumerable: true,
              value: value,
              writable: false,
            });
          }
        }
        function stringify$1(value) {
          if (value == null) {
            return "null";
          }
          if (Array.isArray(value)) {
            return "[ " + value.map(stringify$1).join(", ") + " ]";
          }
          if (value instanceof Uint8Array) {
            const HEX = "0123456789abcdef";
            let result = "0x";
            for (let i = 0; i < value.length; i++) {
              result += HEX[value[i] >> 4];
              result += HEX[value[i] & 15];
            }
            return result;
          }
          if (typeof value === "object" && typeof value.toJSON === "function") {
            return stringify$1(value.toJSON());
          }
          switch (typeof value) {
            case "boolean":
            case "symbol":
              return value.toString();
            case "bigint":
              return BigInt(value).toString();
            case "number":
              return value.toString();
            case "string":
              return JSON.stringify(value);
            case "object": {
              const keys = Object.keys(value);
              keys.sort();
              return (
                "{ " +
                keys
                  .map((k) => `${stringify$1(k)}: ${stringify$1(value[k])}`)
                  .join(", ") +
                " }"
              );
            }
          }
          return `[ COULD NOT SERIALIZE ]`;
        }
        function isError(error, code) {
          return error && error.code === code;
        }
        function isCallException(error) {
          return isError(error, "CALL_EXCEPTION");
        }
        function makeError(message, code, info) {
          {
            const details = [];
            if (info) {
              if ("message" in info || "code" in info || "name" in info) {
                throw new Error(
                  `value will overwrite populated values: ${stringify$1(info)}`
                );
              }
              for (const key in info) {
                const value = info[key];
                details.push(key + "=" + stringify$1(value));
              }
            }
            details.push(`code=${code}`);
            details.push(`version=${version}`);
            if (details.length) {
              message += " (" + details.join(", ") + ")";
            }
          }
          let error;
          switch (code) {
            case "INVALID_ARGUMENT":
              error = new TypeError(message);
              break;
            case "NUMERIC_FAULT":
            case "BUFFER_OVERRUN":
              error = new RangeError(message);
              break;
            default:
              error = new Error(message);
          }
          defineProperties(error, { code: code });
          if (info) {
            Object.assign(error, info);
          }
          return error;
        }
        function assert$1(check, message, code, info) {
          if (!check) {
            throw makeError(message, code, info);
          }
        }
        function assertArgument(check, message, name, value) {
          assert$1(check, message, "INVALID_ARGUMENT", {
            argument: name,
            value: value,
          });
        }
        function assertArgumentCount(count, expectedCount, message) {
          if (message == null) {
            message = "";
          }
          if (message) {
            message = ": " + message;
          }
          assert$1(
            count >= expectedCount,
            "missing arguemnt" + message,
            "MISSING_ARGUMENT",
            { count: count, expectedCount: expectedCount }
          );
          assert$1(
            count <= expectedCount,
            "too many arguemnts" + message,
            "UNEXPECTED_ARGUMENT",
            { count: count, expectedCount: expectedCount }
          );
        }
        const _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce(
          (accum, form) => {
            try {
              if ("test".normalize(form) !== "test") {
                throw new Error("bad");
              }
              if (form === "NFD") {
                const check = String.fromCharCode(233).normalize("NFD");
                const expected = String.fromCharCode(101, 769);
                if (check !== expected) {
                  throw new Error("broken");
                }
              }
              accum.push(form);
            } catch (error) {}
            return accum;
          },
          []
        );
        function assertNormalize(form) {
          assert$1(
            _normalizeForms.indexOf(form) >= 0,
            "platform missing String.prototype.normalize",
            "UNSUPPORTED_OPERATION",
            { operation: "String.prototype.normalize", info: { form: form } }
          );
        }
        function assertPrivate(givenGuard, guard, className) {
          if (className == null) {
            className = "";
          }
          if (givenGuard !== guard) {
            let method = className,
              operation = "new";
            if (className) {
              method += ".";
              operation += " " + className;
            }
            assert$1(
              false,
              `private constructor; use ${method}from* methods`,
              "UNSUPPORTED_OPERATION",
              { operation: operation }
            );
          }
        }
        function _getBytes(value, name, copy) {
          if (value instanceof Uint8Array) {
            if (copy) {
              return new Uint8Array(value);
            }
            return value;
          }
          if (
            typeof value === "string" &&
            value.match(/^0x([0-9a-f][0-9a-f])*$/i)
          ) {
            const result = new Uint8Array((value.length - 2) / 2);
            let offset = 2;
            for (let i = 0; i < result.length; i++) {
              result[i] = parseInt(value.substring(offset, offset + 2), 16);
              offset += 2;
            }
            return result;
          }
          assertArgument(
            false,
            "invalid BytesLike value",
            name || "value",
            value
          );
        }
        function getBytes(value, name) {
          return _getBytes(value, name, false);
        }
        function getBytesCopy(value, name) {
          return _getBytes(value, name, true);
        }
        function isHexString(value, length) {
          if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
            return false;
          }
          if (typeof length === "number" && value.length !== 2 + 2 * length) {
            return false;
          }
          if (length === true && value.length % 2 !== 0) {
            return false;
          }
          return true;
        }
        function isBytesLike(value) {
          return isHexString(value, true) || value instanceof Uint8Array;
        }
        const HexCharacters = "0123456789abcdef";
        function hexlify(data) {
          const bytes = getBytes(data);
          let result = "0x";
          for (let i = 0; i < bytes.length; i++) {
            const v = bytes[i];
            result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
          }
          return result;
        }
        function concat(datas) {
          return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
        }
        function dataLength(data) {
          if (isHexString(data, true)) {
            return (data.length - 2) / 2;
          }
          return getBytes(data).length;
        }
        function dataSlice(data, start, end) {
          const bytes = getBytes(data);
          if (end != null && end > bytes.length) {
            assert$1(
              false,
              "cannot slice beyond data bounds",
              "BUFFER_OVERRUN",
              { buffer: bytes, length: bytes.length, offset: end }
            );
          }
          return hexlify(
            bytes.slice(
              start == null ? 0 : start,
              end == null ? bytes.length : end
            )
          );
        }
        function stripZerosLeft(data) {
          let bytes = hexlify(data).substring(2);
          while (bytes.startsWith("00")) {
            bytes = bytes.substring(2);
          }
          return "0x" + bytes;
        }
        function zeroPad(data, length, left) {
          const bytes = getBytes(data);
          assert$1(
            length >= bytes.length,
            "padding exceeds data length",
            "BUFFER_OVERRUN",
            {
              buffer: new Uint8Array(bytes),
              length: length,
              offset: length + 1,
            }
          );
          const result = new Uint8Array(length);
          result.fill(0);
          if (left) {
            result.set(bytes, length - bytes.length);
          } else {
            result.set(bytes, 0);
          }
          return hexlify(result);
        }
        function zeroPadValue(data, length) {
          return zeroPad(data, length, true);
        }
        function zeroPadBytes(data, length) {
          return zeroPad(data, length, false);
        }
        const BN_0$a = BigInt(0);
        const BN_1$5 = BigInt(1);
        const maxValue = 9007199254740991;
        function fromTwos(_value, _width) {
          const value = getUint(_value, "value");
          const width = BigInt(getNumber(_width, "width"));
          assert$1(value >> width === BN_0$a, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: _value,
          });
          if (value >> (width - BN_1$5)) {
            const mask = (BN_1$5 << width) - BN_1$5;
            return -((~value & mask) + BN_1$5);
          }
          return value;
        }
        function toTwos(_value, _width) {
          let value = getBigInt(_value, "value");
          const width = BigInt(getNumber(_width, "width"));
          const limit = BN_1$5 << (width - BN_1$5);
          if (value < BN_0$a) {
            value = -value;
            assert$1(value <= limit, "too low", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: _value,
            });
            const mask = (BN_1$5 << width) - BN_1$5;
            return (~value & mask) + BN_1$5;
          } else {
            assert$1(value < limit, "too high", "NUMERIC_FAULT", {
              operation: "toTwos",
              fault: "overflow",
              value: _value,
            });
          }
          return value;
        }
        function mask(_value, _bits) {
          const value = getUint(_value, "value");
          const bits = BigInt(getNumber(_bits, "bits"));
          return value & ((BN_1$5 << bits) - BN_1$5);
        }
        function getBigInt(value, name) {
          switch (typeof value) {
            case "bigint":
              return value;
            case "number":
              assertArgument(
                Number.isInteger(value),
                "underflow",
                name || "value",
                value
              );
              assertArgument(
                value >= -maxValue && value <= maxValue,
                "overflow",
                name || "value",
                value
              );
              return BigInt(value);
            case "string":
              try {
                if (value === "") {
                  throw new Error("empty string");
                }
                if (value[0] === "-" && value[1] !== "-") {
                  return -BigInt(value.substring(1));
                }
                return BigInt(value);
              } catch (e) {
                assertArgument(
                  false,
                  `invalid BigNumberish string: ${e.message}`,
                  name || "value",
                  value
                );
              }
          }
          assertArgument(
            false,
            "invalid BigNumberish value",
            name || "value",
            value
          );
        }
        function getUint(value, name) {
          const result = getBigInt(value, name);
          assert$1(
            result >= BN_0$a,
            "unsigned value cannot be negative",
            "NUMERIC_FAULT",
            { fault: "overflow", operation: "getUint", value: value }
          );
          return result;
        }
        const Nibbles$1 = "0123456789abcdef";
        function toBigInt(value) {
          if (value instanceof Uint8Array) {
            let result = "0x0";
            for (const v of value) {
              result += Nibbles$1[v >> 4];
              result += Nibbles$1[v & 15];
            }
            return BigInt(result);
          }
          return getBigInt(value);
        }
        function getNumber(value, name) {
          switch (typeof value) {
            case "bigint":
              assertArgument(
                value >= -maxValue && value <= maxValue,
                "overflow",
                name || "value",
                value
              );
              return Number(value);
            case "number":
              assertArgument(
                Number.isInteger(value),
                "underflow",
                name || "value",
                value
              );
              assertArgument(
                value >= -maxValue && value <= maxValue,
                "overflow",
                name || "value",
                value
              );
              return value;
            case "string":
              try {
                if (value === "") {
                  throw new Error("empty string");
                }
                return getNumber(BigInt(value), name);
              } catch (e) {
                assertArgument(
                  false,
                  `invalid numeric string: ${e.message}`,
                  name || "value",
                  value
                );
              }
          }
          assertArgument(
            false,
            "invalid numeric value",
            name || "value",
            value
          );
        }
        function toNumber(value) {
          return getNumber(toBigInt(value));
        }
        function toBeHex(_value, _width) {
          const value = getUint(_value, "value");
          let result = value.toString(16);
          if (_width == null) {
            if (result.length % 2) {
              result = "0" + result;
            }
          } else {
            const width = getNumber(_width, "width");
            assert$1(
              width * 2 >= result.length,
              `value exceeds width (${width} bits)`,
              "NUMERIC_FAULT",
              { operation: "toBeHex", fault: "overflow", value: _value }
            );
            while (result.length < width * 2) {
              result = "0" + result;
            }
          }
          return "0x" + result;
        }
        function toBeArray(_value) {
          const value = getUint(_value, "value");
          if (value === BN_0$a) {
            return new Uint8Array([]);
          }
          let hex = value.toString(16);
          if (hex.length % 2) {
            hex = "0" + hex;
          }
          const result = new Uint8Array(hex.length / 2);
          for (let i = 0; i < result.length; i++) {
            const offset = i * 2;
            result[i] = parseInt(hex.substring(offset, offset + 2), 16);
          }
          return result;
        }
        function toQuantity(value) {
          let result = hexlify(
            isBytesLike(value) ? value : toBeArray(value)
          ).substring(2);
          while (result.startsWith("0")) {
            result = result.substring(1);
          }
          if (result === "") {
            result = "0";
          }
          return "0x" + result;
        }
        const Alphabet =
          "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
        let Lookup = null;
        function getAlpha(letter) {
          if (Lookup == null) {
            Lookup = {};
            for (let i = 0; i < Alphabet.length; i++) {
              Lookup[Alphabet[i]] = BigInt(i);
            }
          }
          const result = Lookup[letter];
          assertArgument(
            result != null,
            `invalid base58 value`,
            "letter",
            letter
          );
          return result;
        }
        const BN_0$9 = BigInt(0);
        const BN_58 = BigInt(58);
        function encodeBase58(_value) {
          let value = toBigInt(getBytes(_value));
          let result = "";
          while (value) {
            result = Alphabet[Number(value % BN_58)] + result;
            value /= BN_58;
          }
          return result;
        }
        function decodeBase58(value) {
          let result = BN_0$9;
          for (let i = 0; i < value.length; i++) {
            result *= BN_58;
            result += getAlpha(value[i]);
          }
          return result;
        }
        function decodeBase64(textData) {
          textData = atob(textData);
          const data = new Uint8Array(textData.length);
          for (let i = 0; i < textData.length; i++) {
            data[i] = textData.charCodeAt(i);
          }
          return getBytes(data);
        }
        function encodeBase64(_data) {
          const data = getBytes(_data);
          let textData = "";
          for (let i = 0; i < data.length; i++) {
            textData += String.fromCharCode(data[i]);
          }
          return btoa(textData);
        }
        class EventPayload {
          filter;
          emitter;
          #listener;
          constructor(emitter, listener, filter) {
            this.#listener = listener;
            defineProperties(this, { emitter: emitter, filter: filter });
          }
          async removeListener() {
            if (this.#listener == null) {
              return;
            }
            await this.emitter.off(this.filter, this.#listener);
          }
        }
        function errorFunc(reason, offset, bytes, output, badCodepoint) {
          assertArgument(
            false,
            `invalid codepoint at offset ${offset}; ${reason}`,
            "bytes",
            bytes
          );
        }
        function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
          if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
            let i = 0;
            for (let o = offset + 1; o < bytes.length; o++) {
              if (bytes[o] >> 6 !== 2) {
                break;
              }
              i++;
            }
            return i;
          }
          if (reason === "OVERRUN") {
            return bytes.length - offset - 1;
          }
          return 0;
        }
        function replaceFunc(reason, offset, bytes, output, badCodepoint) {
          if (reason === "OVERLONG") {
            assertArgument(
              typeof badCodepoint === "number",
              "invalid bad code point for replacement",
              "badCodepoint",
              badCodepoint
            );
            output.push(badCodepoint);
            return 0;
          }
          output.push(65533);
          return ignoreFunc(reason, offset, bytes);
        }
        const Utf8ErrorFuncs = Object.freeze({
          error: errorFunc,
          ignore: ignoreFunc,
          replace: replaceFunc,
        });
        function getUtf8CodePoints(_bytes, onError) {
          if (onError == null) {
            onError = Utf8ErrorFuncs.error;
          }
          const bytes = getBytes(_bytes, "bytes");
          const result = [];
          let i = 0;
          while (i < bytes.length) {
            const c = bytes[i++];
            if (c >> 7 === 0) {
              result.push(c);
              continue;
            }
            let extraLength = null;
            let overlongMask = null;
            if ((c & 224) === 192) {
              extraLength = 1;
              overlongMask = 127;
            } else if ((c & 240) === 224) {
              extraLength = 2;
              overlongMask = 2047;
            } else if ((c & 248) === 240) {
              extraLength = 3;
              overlongMask = 65535;
            } else {
              if ((c & 192) === 128) {
                i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
              } else {
                i += onError("BAD_PREFIX", i - 1, bytes, result);
              }
              continue;
            }
            if (i - 1 + extraLength >= bytes.length) {
              i += onError("OVERRUN", i - 1, bytes, result);
              continue;
            }
            let res = c & ((1 << (8 - extraLength - 1)) - 1);
            for (let j = 0; j < extraLength; j++) {
              let nextChar = bytes[i];
              if ((nextChar & 192) != 128) {
                i += onError("MISSING_CONTINUE", i, bytes, result);
                res = null;
                break;
              }
              res = (res << 6) | (nextChar & 63);
              i++;
            }
            if (res === null) {
              continue;
            }
            if (res > 1114111) {
              i += onError(
                "OUT_OF_RANGE",
                i - 1 - extraLength,
                bytes,
                result,
                res
              );
              continue;
            }
            if (res >= 55296 && res <= 57343) {
              i += onError(
                "UTF16_SURROGATE",
                i - 1 - extraLength,
                bytes,
                result,
                res
              );
              continue;
            }
            if (res <= overlongMask) {
              i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
              continue;
            }
            result.push(res);
          }
          return result;
        }
        function toUtf8Bytes(str, form) {
          if (form != null) {
            assertNormalize(form);
            str = str.normalize(form);
          }
          let result = [];
          for (let i = 0; i < str.length; i++) {
            const c = str.charCodeAt(i);
            if (c < 128) {
              result.push(c);
            } else if (c < 2048) {
              result.push((c >> 6) | 192);
              result.push((c & 63) | 128);
            } else if ((c & 64512) == 55296) {
              i++;
              const c2 = str.charCodeAt(i);
              assertArgument(
                i < str.length && (c2 & 64512) === 56320,
                "invalid surrogate pair",
                "str",
                str
              );
              const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
              result.push((pair >> 18) | 240);
              result.push(((pair >> 12) & 63) | 128);
              result.push(((pair >> 6) & 63) | 128);
              result.push((pair & 63) | 128);
            } else {
              result.push((c >> 12) | 224);
              result.push(((c >> 6) & 63) | 128);
              result.push((c & 63) | 128);
            }
          }
          return new Uint8Array(result);
        }
        function _toUtf8String(codePoints) {
          return codePoints
            .map((codePoint) => {
              if (codePoint <= 65535) {
                return String.fromCharCode(codePoint);
              }
              codePoint -= 65536;
              return String.fromCharCode(
                ((codePoint >> 10) & 1023) + 55296,
                (codePoint & 1023) + 56320
              );
            })
            .join("");
        }
        function toUtf8String(bytes, onError) {
          return _toUtf8String(getUtf8CodePoints(bytes, onError));
        }
        function toUtf8CodePoints(str, form) {
          return getUtf8CodePoints(toUtf8Bytes(str, form));
        }
        async function getUrl(req, _signal) {
          const protocol = req.url.split(":")[0].toLowerCase();
          assert$1(
            protocol === "http" || protocol === "https",
            `unsupported protocol ${protocol}`,
            "UNSUPPORTED_OPERATION",
            { info: { protocol: protocol }, operation: "request" }
          );
          assert$1(
            protocol === "https" ||
              !req.credentials ||
              req.allowInsecureAuthentication,
            "insecure authorized connections unsupported",
            "UNSUPPORTED_OPERATION",
            { operation: "request" }
          );
          let signal = undefined;
          if (_signal) {
            const controller = new AbortController();
            signal = controller.signal;
            _signal.addListener(() => {
              controller.abort();
            });
          }
          const init = {
            method: req.method,
            headers: new Headers(Array.from(req)),
            body: req.body || undefined,
            signal: signal,
          };
          const resp = await fetch(req.url, init);
          const headers = {};
          resp.headers.forEach((value, key) => {
            headers[key.toLowerCase()] = value;
          });
          const respBody = await resp.arrayBuffer();
          const body = respBody == null ? null : new Uint8Array(respBody);
          return {
            statusCode: resp.status,
            statusMessage: resp.statusText,
            headers: headers,
            body: body,
          };
        }
        const MAX_ATTEMPTS = 12;
        const SLOT_INTERVAL = 250;
        let getUrlFunc = getUrl;
        const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
        const reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
        let locked$5 = false;
        async function dataGatewayFunc(url, signal) {
          try {
            const match = url.match(reData);
            if (!match) {
              throw new Error("invalid data");
            }
            return new FetchResponse(
              200,
              "OK",
              { "content-type": match[1] || "text/plain" },
              match[2] ? decodeBase64(match[3]) : unpercent(match[3])
            );
          } catch (error) {
            return new FetchResponse(
              599,
              "BAD REQUEST (invalid data: URI)",
              {},
              null,
              new FetchRequest(url)
            );
          }
        }
        function getIpfsGatewayFunc(baseUrl) {
          async function gatewayIpfs(url, signal) {
            try {
              const match = url.match(reIpfs);
              if (!match) {
                throw new Error("invalid link");
              }
              return new FetchRequest(`${baseUrl}${match[2]}`);
            } catch (error) {
              return new FetchResponse(
                599,
                "BAD REQUEST (invalid IPFS URI)",
                {},
                null,
                new FetchRequest(url)
              );
            }
          }
          return gatewayIpfs;
        }
        const Gateways = {
          data: dataGatewayFunc,
          ipfs: getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/"),
        };
        const fetchSignals = new WeakMap();
        class FetchCancelSignal {
          #listeners;
          #cancelled;
          constructor(request) {
            this.#listeners = [];
            this.#cancelled = false;
            fetchSignals.set(request, () => {
              if (this.#cancelled) {
                return;
              }
              this.#cancelled = true;
              for (const listener of this.#listeners) {
                setTimeout(() => {
                  listener();
                }, 0);
              }
              this.#listeners = [];
            });
          }
          addListener(listener) {
            assert$1(
              !this.#cancelled,
              "singal already cancelled",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchCancelSignal.addCancelListener" }
            );
            this.#listeners.push(listener);
          }
          get cancelled() {
            return this.#cancelled;
          }
          checkSignal() {
            assert$1(!this.cancelled, "cancelled", "CANCELLED", {});
          }
        }
        function checkSignal(signal) {
          if (signal == null) {
            throw new Error("missing signal; should not happen");
          }
          signal.checkSignal();
          return signal;
        }
        class FetchRequest {
          #allowInsecure;
          #gzip;
          #headers;
          #method;
          #timeout;
          #url;
          #body;
          #bodyType;
          #creds;
          #preflight;
          #process;
          #retry;
          #signal;
          #throttle;
          get url() {
            return this.#url;
          }
          set url(url) {
            this.#url = String(url);
          }
          get body() {
            if (this.#body == null) {
              return null;
            }
            return new Uint8Array(this.#body);
          }
          set body(body) {
            if (body == null) {
              this.#body = undefined;
              this.#bodyType = undefined;
            } else if (typeof body === "string") {
              this.#body = toUtf8Bytes(body);
              this.#bodyType = "text/plain";
            } else if (body instanceof Uint8Array) {
              this.#body = body;
              this.#bodyType = "application/octet-stream";
            } else if (typeof body === "object") {
              this.#body = toUtf8Bytes(JSON.stringify(body));
              this.#bodyType = "application/json";
            } else {
              throw new Error("invalid body");
            }
          }
          hasBody() {
            return this.#body != null;
          }
          get method() {
            if (this.#method) {
              return this.#method;
            }
            if (this.hasBody()) {
              return "POST";
            }
            return "GET";
          }
          set method(method) {
            if (method == null) {
              method = "";
            }
            this.#method = String(method).toUpperCase();
          }
          get headers() {
            const headers = Object.assign({}, this.#headers);
            if (this.#creds) {
              headers["authorization"] = `Basic ${encodeBase64(
                toUtf8Bytes(this.#creds)
              )}`;
            }
            if (this.allowGzip) {
              headers["accept-encoding"] = "gzip";
            }
            if (headers["content-type"] == null && this.#bodyType) {
              headers["content-type"] = this.#bodyType;
            }
            if (this.body) {
              headers["content-length"] = String(this.body.length);
            }
            return headers;
          }
          getHeader(key) {
            return this.headers[key.toLowerCase()];
          }
          setHeader(key, value) {
            this.#headers[String(key).toLowerCase()] = String(value);
          }
          clearHeaders() {
            this.#headers = {};
          }
          [Symbol.iterator]() {
            const headers = this.headers;
            const keys = Object.keys(headers);
            let index = 0;
            return {
              next: () => {
                if (index < keys.length) {
                  const key = keys[index++];
                  return { value: [key, headers[key]], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          get credentials() {
            return this.#creds || null;
          }
          setCredentials(username, password) {
            assertArgument(
              !username.match(/:/),
              "invalid basic authentication username",
              "username",
              "[REDACTED]"
            );
            this.#creds = `${username}:${password}`;
          }
          get allowGzip() {
            return this.#gzip;
          }
          set allowGzip(value) {
            this.#gzip = !!value;
          }
          get allowInsecureAuthentication() {
            return !!this.#allowInsecure;
          }
          set allowInsecureAuthentication(value) {
            this.#allowInsecure = !!value;
          }
          get timeout() {
            return this.#timeout;
          }
          set timeout(timeout) {
            assertArgument(
              timeout >= 0,
              "timeout must be non-zero",
              "timeout",
              timeout
            );
            this.#timeout = timeout;
          }
          get preflightFunc() {
            return this.#preflight || null;
          }
          set preflightFunc(preflight) {
            this.#preflight = preflight;
          }
          get processFunc() {
            return this.#process || null;
          }
          set processFunc(process) {
            this.#process = process;
          }
          get retryFunc() {
            return this.#retry || null;
          }
          set retryFunc(retry) {
            this.#retry = retry;
          }
          constructor(url) {
            this.#url = String(url);
            this.#allowInsecure = false;
            this.#gzip = true;
            this.#headers = {};
            this.#method = "";
            this.#timeout = 3e5;
            this.#throttle = {
              slotInterval: SLOT_INTERVAL,
              maxAttempts: MAX_ATTEMPTS,
            };
          }
          toString() {
            return `<FetchRequest method=${JSON.stringify(
              this.method
            )} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
          }
          setThrottleParams(params) {
            if (params.slotInterval != null) {
              this.#throttle.slotInterval = params.slotInterval;
            }
            if (params.maxAttempts != null) {
              this.#throttle.maxAttempts = params.maxAttempts;
            }
          }
          async #send(attempt, expires, delay, _request, _response) {
            if (attempt >= this.#throttle.maxAttempts) {
              return _response.makeServerError("exceeded maximum retry limit");
            }
            assert$1(getTime$2() <= expires, "timeout", "TIMEOUT", {
              operation: "request.send",
              reason: "timeout",
              request: _request,
            });
            if (delay > 0) {
              await wait(delay);
            }
            let req = this.clone();
            const scheme = (req.url.split(":")[0] || "").toLowerCase();
            if (scheme in Gateways) {
              const result = await Gateways[scheme](
                req.url,
                checkSignal(_request.#signal)
              );
              if (result instanceof FetchResponse) {
                let response = result;
                if (this.processFunc) {
                  checkSignal(_request.#signal);
                  try {
                    response = await this.processFunc(req, response);
                  } catch (error) {
                    if (
                      error.throttle == null ||
                      typeof error.stall !== "number"
                    ) {
                      response
                        .makeServerError(
                          "error in post-processing function",
                          error
                        )
                        .assertOk();
                    }
                  }
                }
                return response;
              }
              req = result;
            }
            if (this.preflightFunc) {
              req = await this.preflightFunc(req);
            }
            const resp = await getUrlFunc(req, checkSignal(_request.#signal));
            let response = new FetchResponse(
              resp.statusCode,
              resp.statusMessage,
              resp.headers,
              resp.body,
              _request
            );
            if (response.statusCode === 301 || response.statusCode === 302) {
              try {
                const location = response.headers.location || "";
                return req
                  .redirect(location)
                  .#send(attempt + 1, expires, 0, _request, response);
              } catch (error) {}
              return response;
            } else if (response.statusCode === 429) {
              if (
                this.retryFunc == null ||
                (await this.retryFunc(req, response, attempt))
              ) {
                const retryAfter = response.headers["retry-after"];
                let delay =
                  this.#throttle.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, attempt));
                if (
                  typeof retryAfter === "string" &&
                  retryAfter.match(/^[1-9][0-9]*$/)
                ) {
                  delay = parseInt(retryAfter);
                }
                return req
                  .clone()
                  .#send(attempt + 1, expires, delay, _request, response);
              }
            }
            if (this.processFunc) {
              checkSignal(_request.#signal);
              try {
                response = await this.processFunc(req, response);
              } catch (error) {
                if (error.throttle == null || typeof error.stall !== "number") {
                  response
                    .makeServerError("error in post-processing function", error)
                    .assertOk();
                }
                let delay =
                  this.#throttle.slotInterval *
                  Math.trunc(Math.random() * Math.pow(2, attempt));
                if (error.stall >= 0) {
                  delay = error.stall;
                }
                return req
                  .clone()
                  .#send(attempt + 1, expires, delay, _request, response);
              }
            }
            return response;
          }
          send() {
            assert$1(
              this.#signal == null,
              "request already sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.send" }
            );
            this.#signal = new FetchCancelSignal(this);
            return this.#send(
              0,
              getTime$2() + this.timeout,
              0,
              this,
              new FetchResponse(0, "", {}, null, this)
            );
          }
          cancel() {
            assert$1(
              this.#signal != null,
              "request has not been sent",
              "UNSUPPORTED_OPERATION",
              { operation: "fetchRequest.cancel" }
            );
            const signal = fetchSignals.get(this);
            if (!signal) {
              throw new Error("missing signal; should not happen");
            }
            signal();
          }
          redirect(location) {
            const current = this.url.split(":")[0].toLowerCase();
            const target = location.split(":")[0].toLowerCase();
            assert$1(
              this.method === "GET" &&
                (current !== "https" || target !== "http") &&
                location.match(/^https?:/),
              `unsupported redirect`,
              "UNSUPPORTED_OPERATION",
              {
                operation: `redirect(${this.method} ${JSON.stringify(
                  this.url
                )} => ${JSON.stringify(location)})`,
              }
            );
            const req = new FetchRequest(location);
            req.method = "GET";
            req.allowGzip = this.allowGzip;
            req.timeout = this.timeout;
            req.#headers = Object.assign({}, this.#headers);
            if (this.#body) {
              req.#body = new Uint8Array(this.#body);
            }
            req.#bodyType = this.#bodyType;
            return req;
          }
          clone() {
            const clone = new FetchRequest(this.url);
            clone.#method = this.#method;
            if (this.#body) {
              clone.#body = this.#body;
            }
            clone.#bodyType = this.#bodyType;
            clone.#headers = Object.assign({}, this.#headers);
            clone.#creds = this.#creds;
            if (this.allowGzip) {
              clone.allowGzip = true;
            }
            clone.timeout = this.timeout;
            if (this.allowInsecureAuthentication) {
              clone.allowInsecureAuthentication = true;
            }
            clone.#preflight = this.#preflight;
            clone.#process = this.#process;
            clone.#retry = this.#retry;
            return clone;
          }
          static lockConfig() {
            locked$5 = true;
          }
          static getGateway(scheme) {
            return Gateways[scheme.toLowerCase()] || null;
          }
          static registerGateway(scheme, func) {
            scheme = scheme.toLowerCase();
            if (scheme === "http" || scheme === "https") {
              throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
            }
            if (locked$5) {
              throw new Error("gateways locked");
            }
            Gateways[scheme] = func;
          }
          static registerGetUrl(getUrl) {
            if (locked$5) {
              throw new Error("gateways locked");
            }
            getUrlFunc = getUrl;
          }
          static createDataGateway() {
            return dataGatewayFunc;
          }
          static createIpfsGatewayFunc(baseUrl) {
            return getIpfsGatewayFunc(baseUrl);
          }
        }
        class FetchResponse {
          #statusCode;
          #statusMessage;
          #headers;
          #body;
          #request;
          #error;
          toString() {
            return `<FetchResponse status=${
              this.statusCode
            } body=${this.#body ? hexlify(this.#body) : "null"}>`;
          }
          get statusCode() {
            return this.#statusCode;
          }
          get statusMessage() {
            return this.#statusMessage;
          }
          get headers() {
            return Object.assign({}, this.#headers);
          }
          get body() {
            return this.#body == null ? null : new Uint8Array(this.#body);
          }
          get bodyText() {
            try {
              return this.#body == null ? "" : toUtf8String(this.#body);
            } catch (error) {
              assert$1(
                false,
                "response body is not valid UTF-8 data",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyText", info: { response: this } }
              );
            }
          }
          get bodyJson() {
            try {
              return JSON.parse(this.bodyText);
            } catch (error) {
              assert$1(
                false,
                "response body is not valid JSON",
                "UNSUPPORTED_OPERATION",
                { operation: "bodyJson", info: { response: this } }
              );
            }
          }
          [Symbol.iterator]() {
            const headers = this.headers;
            const keys = Object.keys(headers);
            let index = 0;
            return {
              next: () => {
                if (index < keys.length) {
                  const key = keys[index++];
                  return { value: [key, headers[key]], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          constructor(statusCode, statusMessage, headers, body, request) {
            this.#statusCode = statusCode;
            this.#statusMessage = statusMessage;
            this.#headers = Object.keys(headers).reduce((accum, k) => {
              accum[k.toLowerCase()] = String(headers[k]);
              return accum;
            }, {});
            this.#body = body == null ? null : new Uint8Array(body);
            this.#request = request || null;
            this.#error = { message: "" };
          }
          makeServerError(message, error) {
            let statusMessage;
            if (!message) {
              message = `${this.statusCode} ${this.statusMessage}`;
              statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
            } else {
              statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
            }
            const response = new FetchResponse(
              599,
              statusMessage,
              this.headers,
              this.body,
              this.#request || undefined
            );
            response.#error = { message: message, error: error };
            return response;
          }
          throwThrottleError(message, stall) {
            if (stall == null) {
              stall = -1;
            } else {
              assertArgument(
                Number.isInteger(stall) && stall >= 0,
                "invalid stall timeout",
                "stall",
                stall
              );
            }
            const error = new Error(message || "throttling requests");
            defineProperties(error, { stall: stall, throttle: true });
            throw error;
          }
          getHeader(key) {
            return this.headers[key.toLowerCase()];
          }
          hasBody() {
            return this.#body != null;
          }
          get request() {
            return this.#request;
          }
          ok() {
            return (
              this.#error.message === "" &&
              this.statusCode >= 200 &&
              this.statusCode < 300
            );
          }
          assertOk() {
            if (this.ok()) {
              return;
            }
            let { message, error } = this.#error;
            if (message === "") {
              message = `server response ${this.statusCode} ${this.statusMessage}`;
            }
            assert$1(false, message, "SERVER_ERROR", {
              request: this.request || "unknown request",
              response: this,
              error: error,
            });
          }
        }
        function getTime$2() {
          return new Date().getTime();
        }
        function unpercent(value) {
          return toUtf8Bytes(
            value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
              return String.fromCharCode(parseInt(code, 16));
            })
          );
        }
        function wait(delay) {
          return new Promise((resolve) => setTimeout(resolve, delay));
        }
        const BN_N1 = BigInt(-1);
        const BN_0$8 = BigInt(0);
        const BN_1$4 = BigInt(1);
        const BN_5 = BigInt(5);
        const _guard$5 = {};
        let Zeros$1 = "0000";
        while (Zeros$1.length < 80) {
          Zeros$1 += Zeros$1;
        }
        function getTens(decimals) {
          let result = Zeros$1;
          while (result.length < decimals) {
            result += result;
          }
          return BigInt("1" + result.substring(0, decimals));
        }
        function checkValue(val, format, safeOp) {
          const width = BigInt(format.width);
          if (format.signed) {
            const limit = BN_1$4 << (width - BN_1$4);
            assert$1(
              safeOp == null || (val >= -limit && val < limit),
              "overflow",
              "NUMERIC_FAULT",
              { operation: safeOp, fault: "overflow", value: val }
            );
            if (val > BN_0$8) {
              val = fromTwos(mask(val, width), width);
            } else {
              val = -fromTwos(mask(-val, width), width);
            }
          } else {
            const limit = BN_1$4 << width;
            assert$1(
              safeOp == null || (val >= 0 && val < limit),
              "overflow",
              "NUMERIC_FAULT",
              { operation: safeOp, fault: "overflow", value: val }
            );
            val = ((val % limit) + limit) % limit & (limit - BN_1$4);
          }
          return val;
        }
        function getFormat(value) {
          if (typeof value === "number") {
            value = `fixed128x${value}`;
          }
          let signed = true;
          let width = 128;
          let decimals = 18;
          if (typeof value === "string") {
            if (value === "fixed");
            else if (value === "ufixed") {
              signed = false;
            } else {
              const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              assertArgument(match, "invalid fixed format", "format", value);
              signed = match[1] !== "u";
              width = parseInt(match[2]);
              decimals = parseInt(match[3]);
            }
          } else if (value) {
            const v = value;
            const check = (key, type, defaultValue) => {
              if (v[key] == null) {
                return defaultValue;
              }
              assertArgument(
                typeof v[key] === type,
                "invalid fixed format (" + key + " not " + type + ")",
                "format." + key,
                v[key]
              );
              return v[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
          }
          assertArgument(
            width % 8 === 0,
            "invalid FixedNumber width (not byte aligned)",
            "format.width",
            width
          );
          assertArgument(
            decimals <= 80,
            "invalid FixedNumber decimals (too large)",
            "format.decimals",
            decimals
          );
          const name =
            (signed ? "" : "u") +
            "fixed" +
            String(width) +
            "x" +
            String(decimals);
          return {
            signed: signed,
            width: width,
            decimals: decimals,
            name: name,
          };
        }
        function toString(val, decimals) {
          let negative = "";
          if (val < BN_0$8) {
            negative = "-";
            val *= BN_N1;
          }
          let str = val.toString();
          if (decimals === 0) {
            return negative + str;
          }
          while (str.length <= decimals) {
            str = Zeros$1 + str;
          }
          const index = str.length - decimals;
          str = str.substring(0, index) + "." + str.substring(index);
          while (str[0] === "0" && str[1] !== ".") {
            str = str.substring(1);
          }
          while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
            str = str.substring(0, str.length - 1);
          }
          return negative + str;
        }
        class FixedNumber {
          format;
          #format;
          #val;
          #tens;
          _value;
          constructor(guard, value, format) {
            assertPrivate(guard, _guard$5, "FixedNumber");
            this.#val = value;
            this.#format = format;
            const _value = toString(value, format.decimals);
            defineProperties(this, { format: format.name, _value: _value });
            this.#tens = getTens(format.decimals);
          }
          get signed() {
            return this.#format.signed;
          }
          get width() {
            return this.#format.width;
          }
          get decimals() {
            return this.#format.decimals;
          }
          get value() {
            return this.#val;
          }
          #checkFormat(other) {
            assertArgument(
              this.format === other.format,
              "incompatible format; use fixedNumber.toFormat",
              "other",
              other
            );
          }
          #checkValue(val, safeOp) {
            val = checkValue(val, this.#format, safeOp);
            return new FixedNumber(_guard$5, val, this.#format);
          }
          #add(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue(this.#val + o.#val, safeOp);
          }
          addUnsafe(other) {
            return this.#add(other);
          }
          add(other) {
            return this.#add(other, "add");
          }
          #sub(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue(this.#val - o.#val, safeOp);
          }
          subUnsafe(other) {
            return this.#sub(other);
          }
          sub(other) {
            return this.#sub(other, "sub");
          }
          #mul(o, safeOp) {
            this.#checkFormat(o);
            return this.#checkValue((this.#val * o.#val) / this.#tens, safeOp);
          }
          mulUnsafe(other) {
            return this.#mul(other);
          }
          mul(other) {
            return this.#mul(other, "mul");
          }
          mulSignal(other) {
            this.#checkFormat(other);
            const value = this.#val * other.#val;
            assert$1(
              value % this.#tens === BN_0$8,
              "precision lost during signalling mul",
              "NUMERIC_FAULT",
              { operation: "mulSignal", fault: "underflow", value: this }
            );
            return this.#checkValue(value / this.#tens, "mulSignal");
          }
          #div(o, safeOp) {
            assert$1(o.#val !== BN_0$8, "division by zero", "NUMERIC_FAULT", {
              operation: "div",
              fault: "divide-by-zero",
              value: this,
            });
            this.#checkFormat(o);
            return this.#checkValue((this.#val * this.#tens) / o.#val, safeOp);
          }
          divUnsafe(other) {
            return this.#div(other);
          }
          div(other) {
            return this.#div(other, "div");
          }
          divSignal(other) {
            assert$1(
              other.#val !== BN_0$8,
              "division by zero",
              "NUMERIC_FAULT",
              { operation: "div", fault: "divide-by-zero", value: this }
            );
            this.#checkFormat(other);
            const value = this.#val * this.#tens;
            assert$1(
              value % other.#val === BN_0$8,
              "precision lost during signalling div",
              "NUMERIC_FAULT",
              { operation: "divSignal", fault: "underflow", value: this }
            );
            return this.#checkValue(value / other.#val, "divSignal");
          }
          cmp(other) {
            let a = this.value,
              b = other.value;
            const delta = this.decimals - other.decimals;
            if (delta > 0) {
              b *= getTens(delta);
            } else if (delta < 0) {
              a *= getTens(-delta);
            }
            if (a < b) {
              return -1;
            }
            if (a > b) {
              return 1;
            }
            return 0;
          }
          eq(other) {
            return this.cmp(other) === 0;
          }
          lt(other) {
            return this.cmp(other) < 0;
          }
          lte(other) {
            return this.cmp(other) <= 0;
          }
          gt(other) {
            return this.cmp(other) > 0;
          }
          gte(other) {
            return this.cmp(other) >= 0;
          }
          floor() {
            let val = this.#val;
            if (this.#val < BN_0$8) {
              val -= this.#tens - BN_1$4;
            }
            val = (this.#val / this.#tens) * this.#tens;
            return this.#checkValue(val, "floor");
          }
          ceiling() {
            let val = this.#val;
            if (this.#val > BN_0$8) {
              val += this.#tens - BN_1$4;
            }
            val = (this.#val / this.#tens) * this.#tens;
            return this.#checkValue(val, "ceiling");
          }
          round(decimals) {
            if (decimals == null) {
              decimals = 0;
            }
            if (decimals >= this.decimals) {
              return this;
            }
            const delta = this.decimals - decimals;
            const bump = BN_5 * getTens(delta - 1);
            let value = this.value + bump;
            const tens = getTens(delta);
            value = (value / tens) * tens;
            checkValue(value, this.#format, "round");
            return new FixedNumber(_guard$5, value, this.#format);
          }
          isZero() {
            return this.#val === BN_0$8;
          }
          isNegative() {
            return this.#val < BN_0$8;
          }
          toString() {
            return this._value;
          }
          toUnsafeFloat() {
            return parseFloat(this.toString());
          }
          toFormat(format) {
            return FixedNumber.fromString(this.toString(), format);
          }
          static fromValue(_value, _decimals, _format) {
            const decimals = _decimals == null ? 0 : getNumber(_decimals);
            const format = getFormat(_format);
            let value = getBigInt(_value, "value");
            const delta = decimals - format.decimals;
            if (delta > 0) {
              const tens = getTens(delta);
              assert$1(
                value % tens === BN_0$8,
                "value loses precision for format",
                "NUMERIC_FAULT",
                { operation: "fromValue", fault: "underflow", value: _value }
              );
              value /= tens;
            } else if (delta < 0) {
              value *= getTens(-delta);
            }
            checkValue(value, format, "fromValue");
            return new FixedNumber(_guard$5, value, format);
          }
          static fromString(_value, _format) {
            const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
            assertArgument(
              match && match[2].length + match[3].length > 0,
              "invalid FixedNumber string value",
              "value",
              _value
            );
            const format = getFormat(_format);
            let whole = match[2] || "0",
              decimal = match[3] || "";
            while (decimal.length < format.decimals) {
              decimal += Zeros$1;
            }
            assert$1(
              decimal.substring(format.decimals).match(/^0*$/),
              "too many decimals for format",
              "NUMERIC_FAULT",
              { operation: "fromString", fault: "underflow", value: _value }
            );
            decimal = decimal.substring(0, format.decimals);
            const value = BigInt(match[1] + whole + decimal);
            checkValue(value, format, "fromString");
            return new FixedNumber(_guard$5, value, format);
          }
          static fromBytes(_value, _format) {
            let value = toBigInt(getBytes(_value, "value"));
            const format = getFormat(_format);
            if (format.signed) {
              value = fromTwos(value, format.width);
            }
            checkValue(value, format, "fromBytes");
            return new FixedNumber(_guard$5, value, format);
          }
        }
        function hexlifyByte(value) {
          let result = value.toString(16);
          while (result.length < 2) {
            result = "0" + result;
          }
          return "0x" + result;
        }
        function unarrayifyInteger(data, offset, length) {
          let result = 0;
          for (let i = 0; i < length; i++) {
            result = result * 256 + data[offset + i];
          }
          return result;
        }
        function _decodeChildren(data, offset, childOffset, length) {
          const result = [];
          while (childOffset < offset + 1 + length) {
            const decoded = _decode(data, childOffset);
            result.push(decoded.result);
            childOffset += decoded.consumed;
            assert$1(
              childOffset <= offset + 1 + length,
              "child data too short",
              "BUFFER_OVERRUN",
              { buffer: data, length: length, offset: offset }
            );
          }
          return { consumed: 1 + length, result: result };
        }
        function _decode(data, offset) {
          assert$1(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
            buffer: data,
            length: 0,
            offset: 1,
          });
          const checkOffset = (offset) => {
            assert$1(
              offset <= data.length,
              "data short segment too short",
              "BUFFER_OVERRUN",
              { buffer: data, length: data.length, offset: offset }
            );
          };
          if (data[offset] >= 248) {
            const lengthLength = data[offset] - 247;
            checkOffset(offset + 1 + lengthLength);
            const length = unarrayifyInteger(data, offset + 1, lengthLength);
            checkOffset(offset + 1 + lengthLength + length);
            return _decodeChildren(
              data,
              offset,
              offset + 1 + lengthLength,
              lengthLength + length
            );
          } else if (data[offset] >= 192) {
            const length = data[offset] - 192;
            checkOffset(offset + 1 + length);
            return _decodeChildren(data, offset, offset + 1, length);
          } else if (data[offset] >= 184) {
            const lengthLength = data[offset] - 183;
            checkOffset(offset + 1 + lengthLength);
            const length = unarrayifyInteger(data, offset + 1, lengthLength);
            checkOffset(offset + 1 + lengthLength + length);
            const result = hexlify(
              data.slice(
                offset + 1 + lengthLength,
                offset + 1 + lengthLength + length
              )
            );
            return { consumed: 1 + lengthLength + length, result: result };
          } else if (data[offset] >= 128) {
            const length = data[offset] - 128;
            checkOffset(offset + 1 + length);
            const result = hexlify(data.slice(offset + 1, offset + 1 + length));
            return { consumed: 1 + length, result: result };
          }
          return { consumed: 1, result: hexlifyByte(data[offset]) };
        }
        function decodeRlp(_data) {
          const data = getBytes(_data, "data");
          const decoded = _decode(data, 0);
          assertArgument(
            decoded.consumed === data.length,
            "unexpected junk after rlp payload",
            "data",
            _data
          );
          return decoded.result;
        }
        function arrayifyInteger(value) {
          const result = [];
          while (value) {
            result.unshift(value & 255);
            value >>= 8;
          }
          return result;
        }
        function _encode(object) {
          if (Array.isArray(object)) {
            let payload = [];
            object.forEach(function (child) {
              payload = payload.concat(_encode(child));
            });
            if (payload.length <= 55) {
              payload.unshift(192 + payload.length);
              return payload;
            }
            const length = arrayifyInteger(payload.length);
            length.unshift(247 + length.length);
            return length.concat(payload);
          }
          const data = Array.prototype.slice.call(getBytes(object, "object"));
          if (data.length === 1 && data[0] <= 127) {
            return data;
          } else if (data.length <= 55) {
            data.unshift(128 + data.length);
            return data;
          }
          const length = arrayifyInteger(data.length);
          length.unshift(183 + length.length);
          return length.concat(data);
        }
        const nibbles = "0123456789abcdef";
        function encodeRlp(object) {
          let result = "0x";
          for (const v of _encode(object)) {
            result += nibbles[v >> 4];
            result += nibbles[v & 15];
          }
          return result;
        }
        const names = [
          "wei",
          "kwei",
          "mwei",
          "gwei",
          "szabo",
          "finney",
          "ether",
        ];
        function formatUnits(value, unit) {
          let decimals = 18;
          if (typeof unit === "string") {
            const index = names.indexOf(unit);
            assertArgument(index >= 0, "invalid unit", "unit", unit);
            decimals = 3 * index;
          } else if (unit != null) {
            decimals = getNumber(unit, "unit");
          }
          return FixedNumber.fromValue(value, decimals, {
            decimals: decimals,
            width: 512,
          }).toString();
        }
        function parseUnits$1(value, unit) {
          assertArgument(
            typeof value === "string",
            "value must be a string",
            "value",
            value
          );
          let decimals = 18;
          if (typeof unit === "string") {
            const index = names.indexOf(unit);
            assertArgument(index >= 0, "invalid unit", "unit", unit);
            decimals = 3 * index;
          } else if (unit != null) {
            decimals = getNumber(unit, "unit");
          }
          return FixedNumber.fromString(value, {
            decimals: decimals,
            width: 512,
          }).value;
        }
        function formatEther(wei) {
          return formatUnits(wei, 18);
        }
        function parseEther(ether) {
          return parseUnits$1(ether, 18);
        }
        function uuidV4(randomBytes) {
          const bytes = getBytes(randomBytes, "randomBytes");
          bytes[6] = (bytes[6] & 15) | 64;
          bytes[8] = (bytes[8] & 63) | 128;
          const value = hexlify(bytes);
          return [
            value.substring(2, 10),
            value.substring(10, 14),
            value.substring(14, 18),
            value.substring(18, 22),
            value.substring(22, 34),
          ].join("-");
        }
        const WordSize = 32;
        const Padding = new Uint8Array(WordSize);
        const passProperties$1 = ["then"];
        const _guard$4 = {};
        function throwError(name, error) {
          const wrapped = new Error(
            `deferred error during ABI decoding triggered accessing ${name}`
          );
          wrapped.error = error;
          throw wrapped;
        }
        class Result extends Array {
          #names;
          constructor(...args) {
            const guard = args[0];
            let items = args[1];
            let names = (args[2] || []).slice();
            let wrap = true;
            if (guard !== _guard$4) {
              items = args;
              names = [];
              wrap = false;
            }
            super(items.length);
            items.forEach((item, index) => {
              this[index] = item;
            });
            const nameCounts = names.reduce((accum, name) => {
              if (typeof name === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
              }
              return accum;
            }, new Map());
            this.#names = Object.freeze(
              items.map((item, index) => {
                const name = names[index];
                if (name != null && nameCounts.get(name) === 1) {
                  return name;
                }
                return null;
              })
            );
            if (!wrap) {
              return;
            }
            Object.freeze(this);
            return new Proxy(this, {
              get: (target, prop, receiver) => {
                if (typeof prop === "string") {
                  if (prop.match(/^[0-9]+$/)) {
                    const index = getNumber(prop, "%index");
                    if (index < 0 || index >= this.length) {
                      throw new RangeError("out of result range");
                    }
                    const item = target[index];
                    if (item instanceof Error) {
                      throwError(`index ${index}`, item);
                    }
                    return item;
                  }
                  if (passProperties$1.indexOf(prop) >= 0) {
                    return Reflect.get(target, prop, receiver);
                  }
                  const value = target[prop];
                  if (value instanceof Function) {
                    return function (...args) {
                      return value.apply(
                        this === receiver ? target : this,
                        args
                      );
                    };
                  } else if (!(prop in target)) {
                    return target.getValue.apply(
                      this === receiver ? target : this,
                      [prop]
                    );
                  }
                }
                return Reflect.get(target, prop, receiver);
              },
            });
          }
          toArray() {
            const result = [];
            this.forEach((item, index) => {
              if (item instanceof Error) {
                throwError(`index ${index}`, item);
              }
              result.push(item);
            });
            return result;
          }
          toObject() {
            return this.#names.reduce((accum, name, index) => {
              assert$1(
                name != null,
                "value at index ${ index } unnamed",
                "UNSUPPORTED_OPERATION",
                { operation: "toObject()" }
              );
              if (!(name in accum)) {
                accum[name] = this.getValue(name);
              }
              return accum;
            }, {});
          }
          slice(start, end) {
            if (start == null) {
              start = 0;
            }
            if (start < 0) {
              start += this.length;
              if (start < 0) {
                start = 0;
              }
            }
            if (end == null) {
              end = this.length;
            }
            if (end < 0) {
              end += this.length;
              if (end < 0) {
                end = 0;
              }
            }
            if (end > this.length) {
              end = this.length;
            }
            const result = [],
              names = [];
            for (let i = start; i < end; i++) {
              result.push(this[i]);
              names.push(this.#names[i]);
            }
            return new Result(_guard$4, result, names);
          }
          filter(callback, thisArg) {
            const result = [],
              names = [];
            for (let i = 0; i < this.length; i++) {
              const item = this[i];
              if (item instanceof Error) {
                throwError(`index ${i}`, item);
              }
              if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(this.#names[i]);
              }
            }
            return new Result(_guard$4, result, names);
          }
          map(callback, thisArg) {
            const result = [];
            for (let i = 0; i < this.length; i++) {
              const item = this[i];
              if (item instanceof Error) {
                throwError(`index ${i}`, item);
              }
              result.push(callback.call(thisArg, item, i, this));
            }
            return result;
          }
          getValue(name) {
            const index = this.#names.indexOf(name);
            if (index === -1) {
              return undefined;
            }
            const value = this[index];
            if (value instanceof Error) {
              throwError(`property ${JSON.stringify(name)}`, value.error);
            }
            return value;
          }
          static fromItems(items, keys) {
            return new Result(_guard$4, items, keys);
          }
        }
        function checkResultErrors(result) {
          const errors = [];
          const checkErrors = function (path, object) {
            if (!Array.isArray(object)) {
              return;
            }
            for (let key in object) {
              const childPath = path.slice();
              childPath.push(key);
              try {
                checkErrors(childPath, object[key]);
              } catch (error) {
                errors.push({ path: childPath, error: error });
              }
            }
          };
          checkErrors([], result);
          return errors;
        }
        function getValue$1(value) {
          let bytes = toBeArray(value);
          assert$1(
            bytes.length <= WordSize,
            "value out-of-bounds",
            "BUFFER_OVERRUN",
            { buffer: bytes, length: WordSize, offset: bytes.length }
          );
          if (bytes.length !== WordSize) {
            bytes = getBytesCopy(
              concat([Padding.slice(bytes.length % WordSize), bytes])
            );
          }
          return bytes;
        }
        class Coder {
          name;
          type;
          localName;
          dynamic;
          constructor(name, type, localName, dynamic) {
            defineProperties(
              this,
              {
                name: name,
                type: type,
                localName: localName,
                dynamic: dynamic,
              },
              {
                name: "string",
                type: "string",
                localName: "string",
                dynamic: "boolean",
              }
            );
          }
          _throwError(message, value) {
            assertArgument(false, message, this.localName, value);
          }
        }
        class Writer {
          #data;
          #dataLength;
          constructor() {
            this.#data = [];
            this.#dataLength = 0;
          }
          get data() {
            return concat(this.#data);
          }
          get length() {
            return this.#dataLength;
          }
          #writeData(data) {
            this.#data.push(data);
            this.#dataLength += data.length;
            return data.length;
          }
          appendWriter(writer) {
            return this.#writeData(getBytesCopy(writer.data));
          }
          writeBytes(value) {
            let bytes = getBytesCopy(value);
            const paddingOffset = bytes.length % WordSize;
            if (paddingOffset) {
              bytes = getBytesCopy(
                concat([bytes, Padding.slice(paddingOffset)])
              );
            }
            return this.#writeData(bytes);
          }
          writeValue(value) {
            return this.#writeData(getValue$1(value));
          }
          writeUpdatableValue() {
            const offset = this.#data.length;
            this.#data.push(Padding);
            this.#dataLength += WordSize;
            return (value) => {
              this.#data[offset] = getValue$1(value);
            };
          }
        }
        class Reader {
          allowLoose;
          #data;
          #offset;
          constructor(data, allowLoose) {
            defineProperties(this, { allowLoose: !!allowLoose });
            this.#data = getBytesCopy(data);
            this.#offset = 0;
          }
          get data() {
            return hexlify(this.#data);
          }
          get dataLength() {
            return this.#data.length;
          }
          get consumed() {
            return this.#offset;
          }
          get bytes() {
            return new Uint8Array(this.#data);
          }
          #peekBytes(offset, length, loose) {
            let alignedLength = Math.ceil(length / WordSize) * WordSize;
            if (this.#offset + alignedLength > this.#data.length) {
              if (
                this.allowLoose &&
                loose &&
                this.#offset + length <= this.#data.length
              ) {
                alignedLength = length;
              } else {
                assert$1(false, "data out-of-bounds", "BUFFER_OVERRUN", {
                  buffer: getBytesCopy(this.#data),
                  length: this.#data.length,
                  offset: this.#offset + alignedLength,
                });
              }
            }
            return this.#data.slice(this.#offset, this.#offset + alignedLength);
          }
          subReader(offset) {
            return new Reader(
              this.#data.slice(this.#offset + offset),
              this.allowLoose
            );
          }
          readBytes(length, loose) {
            let bytes = this.#peekBytes(0, length, !!loose);
            this.#offset += bytes.length;
            return bytes.slice(0, length);
          }
          readValue() {
            return toBigInt(this.readBytes(WordSize));
          }
          readIndex() {
            return toNumber(this.readBytes(WordSize));
          }
        }
        function number(n) {
          if (!Number.isSafeInteger(n) || n < 0)
            throw new Error(`Wrong positive integer: ${n}`);
        }
        function bool(b) {
          if (typeof b !== "boolean")
            throw new Error(`Expected boolean, not ${b}`);
        }
        function bytes(b, ...lengths) {
          if (!(b instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
          if (lengths.length > 0 && !lengths.includes(b.length))
            throw new TypeError(
              `Expected Uint8Array of length ${lengths}, not of length=${b.length}`
            );
        }
        function hash(hash) {
          if (typeof hash !== "function" || typeof hash.create !== "function")
            throw new Error("Hash should be wrapped by utils.wrapConstructor");
          number(hash.outputLen);
          number(hash.blockLen);
        }
        function exists(instance, checkFinished = true) {
          if (instance.destroyed)
            throw new Error("Hash instance has been destroyed");
          if (checkFinished && instance.finished)
            throw new Error("Hash#digest() has already been called");
        }
        function output(out, instance) {
          bytes(out);
          const min = instance.outputLen;
          if (out.length < min) {
            throw new Error(
              `digestInto() expects output buffer of length at least ${min}`
            );
          }
        }
        const assert = {
          number: number,
          bool: bool,
          bytes: bytes,
          hash: hash,
          exists: exists,
          output: output,
        };
        const u32 = (arr) =>
          new Uint32Array(
            arr.buffer,
            arr.byteOffset,
            Math.floor(arr.byteLength / 4)
          );
        const createView = (arr) =>
          new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
        const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
        const isLE =
          new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
        if (!isLE)
          throw new Error("Non little-endian hardware is not supported");
        Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
        const nextTick = async () => {};
        async function asyncLoop(iters, tick, cb) {
          let ts = Date.now();
          for (let i = 0; i < iters; i++) {
            cb(i);
            const diff = Date.now() - ts;
            if (diff >= 0 && diff < tick) continue;
            await nextTick();
            ts += diff;
          }
        }
        function utf8ToBytes(str) {
          if (typeof str !== "string") {
            throw new TypeError(
              `utf8ToBytes expected string, got ${typeof str}`
            );
          }
          return new TextEncoder().encode(str);
        }
        function toBytes(data) {
          if (typeof data === "string") data = utf8ToBytes(data);
          if (!(data instanceof Uint8Array))
            throw new TypeError(
              `Expected input type is Uint8Array (got ${typeof data})`
            );
          return data;
        }
        class Hash {
          clone() {
            return this._cloneInto();
          }
        }
        const isPlainObject = (obj) =>
          Object.prototype.toString.call(obj) === "[object Object]" &&
          obj.constructor === Object;
        function checkOpts(defaults, opts) {
          if (
            opts !== undefined &&
            (typeof opts !== "object" || !isPlainObject(opts))
          )
            throw new TypeError("Options should be object or undefined");
          const merged = Object.assign(defaults, opts);
          return merged;
        }
        function wrapConstructor(hashConstructor) {
          const hashC = (message) =>
            hashConstructor().update(toBytes(message)).digest();
          const tmp = hashConstructor();
          hashC.outputLen = tmp.outputLen;
          hashC.blockLen = tmp.blockLen;
          hashC.create = () => hashConstructor();
          return hashC;
        }
        function wrapConstructorWithOpts(hashCons) {
          const hashC = (msg, opts) =>
            hashCons(opts).update(toBytes(msg)).digest();
          const tmp = hashCons({});
          hashC.outputLen = tmp.outputLen;
          hashC.blockLen = tmp.blockLen;
          hashC.create = (opts) => hashCons(opts);
          return hashC;
        }
        class HMAC extends Hash {
          constructor(hash, _key) {
            super();
            this.finished = false;
            this.destroyed = false;
            assert.hash(hash);
            const key = toBytes(_key);
            this.iHash = hash.create();
            if (!(this.iHash instanceof Hash))
              throw new TypeError(
                "Expected instance of class which extends utils.Hash"
              );
            const blockLen = (this.blockLen = this.iHash.blockLen);
            this.outputLen = this.iHash.outputLen;
            const pad = new Uint8Array(blockLen);
            pad.set(
              key.length > this.iHash.blockLen
                ? hash.create().update(key).digest()
                : key
            );
            for (let i = 0; i < pad.length; i++) pad[i] ^= 54;
            this.iHash.update(pad);
            this.oHash = hash.create();
            for (let i = 0; i < pad.length; i++) pad[i] ^= 54 ^ 92;
            this.oHash.update(pad);
            pad.fill(0);
          }
          update(buf) {
            assert.exists(this);
            this.iHash.update(buf);
            return this;
          }
          digestInto(out) {
            assert.exists(this);
            assert.bytes(out, this.outputLen);
            this.finished = true;
            this.iHash.digestInto(out);
            this.oHash.update(out);
            this.oHash.digestInto(out);
            this.destroy();
          }
          digest() {
            const out = new Uint8Array(this.oHash.outputLen);
            this.digestInto(out);
            return out;
          }
          _cloneInto(to) {
            to || (to = Object.create(Object.getPrototypeOf(this), {}));
            const { oHash, iHash, finished, destroyed, blockLen, outputLen } =
              this;
            to = to;
            to.finished = finished;
            to.destroyed = destroyed;
            to.blockLen = blockLen;
            to.outputLen = outputLen;
            to.oHash = oHash._cloneInto(to.oHash);
            to.iHash = iHash._cloneInto(to.iHash);
            return to;
          }
          destroy() {
            this.destroyed = true;
            this.oHash.destroy();
            this.iHash.destroy();
          }
        }
        const hmac = (hash, key, message) =>
          new HMAC(hash, key).update(message).digest();
        hmac.create = (hash, key) => new HMAC(hash, key);
        function pbkdf2Init(hash, _password, _salt, _opts) {
          assert.hash(hash);
          const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
          const { c, dkLen, asyncTick } = opts;
          assert.number(c);
          assert.number(dkLen);
          assert.number(asyncTick);
          if (c < 1) throw new Error("PBKDF2: iterations (c) should be >= 1");
          const password = toBytes(_password);
          const salt = toBytes(_salt);
          const DK = new Uint8Array(dkLen);
          const PRF = hmac.create(hash, password);
          const PRFSalt = PRF._cloneInto().update(salt);
          return {
            c: c,
            dkLen: dkLen,
            asyncTick: asyncTick,
            DK: DK,
            PRF: PRF,
            PRFSalt: PRFSalt,
          };
        }
        function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
          PRF.destroy();
          PRFSalt.destroy();
          if (prfW) prfW.destroy();
          u.fill(0);
          return DK;
        }
        function pbkdf2$1(hash, password, salt, opts) {
          const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(
            hash,
            password,
            salt,
            opts
          );
          let prfW;
          const arr = new Uint8Array(4);
          const view = createView(arr);
          const u = new Uint8Array(PRF.outputLen);
          for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
            const Ti = DK.subarray(pos, pos + PRF.outputLen);
            view.setInt32(0, ti, false);
            (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
            Ti.set(u.subarray(0, Ti.length));
            for (let ui = 1; ui < c; ui++) {
              PRF._cloneInto(prfW).update(u).digestInto(u);
              for (let i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
            }
          }
          return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
        }
        function setBigUint64(view, byteOffset, value, isLE) {
          if (typeof view.setBigUint64 === "function")
            return view.setBigUint64(byteOffset, value, isLE);
          const _32n = BigInt(32);
          const _u32_max = BigInt(4294967295);
          const wh = Number((value >> _32n) & _u32_max);
          const wl = Number(value & _u32_max);
          const h = isLE ? 4 : 0;
          const l = isLE ? 0 : 4;
          view.setUint32(byteOffset + h, wh, isLE);
          view.setUint32(byteOffset + l, wl, isLE);
        }
        class SHA2 extends Hash {
          constructor(blockLen, outputLen, padOffset, isLE) {
            super();
            this.blockLen = blockLen;
            this.outputLen = outputLen;
            this.padOffset = padOffset;
            this.isLE = isLE;
            this.finished = false;
            this.length = 0;
            this.pos = 0;
            this.destroyed = false;
            this.buffer = new Uint8Array(blockLen);
            this.view = createView(this.buffer);
          }
          update(data) {
            assert.exists(this);
            const { view, buffer, blockLen } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len; ) {
              const take = Math.min(blockLen - this.pos, len - pos);
              if (take === blockLen) {
                const dataView = createView(data);
                for (; blockLen <= len - pos; pos += blockLen)
                  this.process(dataView, pos);
                continue;
              }
              buffer.set(data.subarray(pos, pos + take), this.pos);
              this.pos += take;
              pos += take;
              if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
              }
            }
            this.length += data.length;
            this.roundClean();
            return this;
          }
          digestInto(out) {
            assert.exists(this);
            assert.output(out, this);
            this.finished = true;
            const { buffer, view, blockLen, isLE } = this;
            let { pos } = this;
            buffer[pos++] = 128;
            this.buffer.subarray(pos).fill(0);
            if (this.padOffset > blockLen - pos) {
              this.process(view, 0);
              pos = 0;
            }
            for (let i = pos; i < blockLen; i++) buffer[i] = 0;
            setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
            this.process(view, 0);
            const oview = createView(out);
            this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
          }
          digest() {
            const { buffer, outputLen } = this;
            this.digestInto(buffer);
            const res = buffer.slice(0, outputLen);
            this.destroy();
            return res;
          }
          _cloneInto(to) {
            to || (to = new this.constructor());
            to.set(...this.get());
            const { blockLen, buffer, length, finished, destroyed, pos } = this;
            to.length = length;
            to.pos = pos;
            to.finished = finished;
            to.destroyed = destroyed;
            if (length % blockLen) to.buffer.set(buffer);
            return to;
          }
        }
        const Chi = (a, b, c) => (a & b) ^ (~a & c);
        const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
        const SHA256_K = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
          2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
          1925078388, 2162078206, 2614888103, 3248222580, 3835390401,
          4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692,
          1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
          3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912,
          1294757372, 1396182291, 1695183700, 1986661051, 2177026350,
          2456956037, 2730485921, 2820302411, 3259730800, 3345764771,
          3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616,
          659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
          1955562222, 2024104815, 2227730452, 2361852424, 2428436474,
          2756734187, 3204031479, 3329325298,
        ]);
        const IV = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119,
          2600822924, 528734635, 1541459225,
        ]);
        const SHA256_W = new Uint32Array(64);
        class SHA256 extends SHA2 {
          constructor() {
            super(64, 32, 8, false);
            this.A = IV[0] | 0;
            this.B = IV[1] | 0;
            this.C = IV[2] | 0;
            this.D = IV[3] | 0;
            this.E = IV[4] | 0;
            this.F = IV[5] | 0;
            this.G = IV[6] | 0;
            this.H = IV[7] | 0;
          }
          get() {
            const { A, B, C, D, E, F, G, H } = this;
            return [A, B, C, D, E, F, G, H];
          }
          set(A, B, C, D, E, F, G, H) {
            this.A = A | 0;
            this.B = B | 0;
            this.C = C | 0;
            this.D = D | 0;
            this.E = E | 0;
            this.F = F | 0;
            this.G = G | 0;
            this.H = H | 0;
          }
          process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4)
              SHA256_W[i] = view.getUint32(offset, false);
            for (let i = 16; i < 64; i++) {
              const W15 = SHA256_W[i - 15];
              const W2 = SHA256_W[i - 2];
              const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);
              const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);
              SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
            }
            let { A, B, C, D, E, F, G, H } = this;
            for (let i = 0; i < 64; i++) {
              const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
              const T1 =
                (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
              const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
              const T2 = (sigma0 + Maj(A, B, C)) | 0;
              H = G;
              G = F;
              F = E;
              E = (D + T1) | 0;
              D = C;
              C = B;
              B = A;
              A = (T1 + T2) | 0;
            }
            A = (A + this.A) | 0;
            B = (B + this.B) | 0;
            C = (C + this.C) | 0;
            D = (D + this.D) | 0;
            E = (E + this.E) | 0;
            F = (F + this.F) | 0;
            G = (G + this.G) | 0;
            H = (H + this.H) | 0;
            this.set(A, B, C, D, E, F, G, H);
          }
          roundClean() {
            SHA256_W.fill(0);
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0);
            this.buffer.fill(0);
          }
        }
        const sha256$1 = wrapConstructor(() => new SHA256());
        const U32_MASK64 = BigInt(2 ** 32 - 1);
        const _32n = BigInt(32);
        function fromBig(n, le = false) {
          if (le)
            return {
              h: Number(n & U32_MASK64),
              l: Number((n >> _32n) & U32_MASK64),
            };
          return {
            h: Number((n >> _32n) & U32_MASK64) | 0,
            l: Number(n & U32_MASK64) | 0,
          };
        }
        function split(lst, le = false) {
          let Ah = new Uint32Array(lst.length);
          let Al = new Uint32Array(lst.length);
          for (let i = 0; i < lst.length; i++) {
            const { h, l } = fromBig(lst[i], le);
            [Ah[i], Al[i]] = [h, l];
          }
          return [Ah, Al];
        }
        const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
        const shrSH = (h, l, s) => h >>> s;
        const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
        const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
        const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
        const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
        const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
        const rotr32H = (h, l) => l;
        const rotr32L = (h, l) => h;
        const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
        const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
        const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
        const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
        function add(Ah, Al, Bh, Bl) {
          const l = (Al >>> 0) + (Bl >>> 0);
          return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
        }
        const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
        const add3H = (low, Ah, Bh, Ch) =>
          (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
        const add4L = (Al, Bl, Cl, Dl) =>
          (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
        const add4H = (low, Ah, Bh, Ch, Dh) =>
          (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
        const add5L = (Al, Bl, Cl, Dl, El) =>
          (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
        const add5H = (low, Ah, Bh, Ch, Dh, Eh) =>
          (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
        const u64 = {
          fromBig: fromBig,
          split: split,
          toBig: toBig,
          shrSH: shrSH,
          shrSL: shrSL,
          rotrSH: rotrSH,
          rotrSL: rotrSL,
          rotrBH: rotrBH,
          rotrBL: rotrBL,
          rotr32H: rotr32H,
          rotr32L: rotr32L,
          rotlSH: rotlSH,
          rotlSL: rotlSL,
          rotlBH: rotlBH,
          rotlBL: rotlBL,
          add: add,
          add3L: add3L,
          add3H: add3H,
          add4L: add4L,
          add4H: add4H,
          add5H: add5H,
          add5L: add5L,
        };
        const [SHA512_Kh, SHA512_Kl] = u64.split(
          [
            "0x428a2f98d728ae22",
            "0x7137449123ef65cd",
            "0xb5c0fbcfec4d3b2f",
            "0xe9b5dba58189dbbc",
            "0x3956c25bf348b538",
            "0x59f111f1b605d019",
            "0x923f82a4af194f9b",
            "0xab1c5ed5da6d8118",
            "0xd807aa98a3030242",
            "0x12835b0145706fbe",
            "0x243185be4ee4b28c",
            "0x550c7dc3d5ffb4e2",
            "0x72be5d74f27b896f",
            "0x80deb1fe3b1696b1",
            "0x9bdc06a725c71235",
            "0xc19bf174cf692694",
            "0xe49b69c19ef14ad2",
            "0xefbe4786384f25e3",
            "0x0fc19dc68b8cd5b5",
            "0x240ca1cc77ac9c65",
            "0x2de92c6f592b0275",
            "0x4a7484aa6ea6e483",
            "0x5cb0a9dcbd41fbd4",
            "0x76f988da831153b5",
            "0x983e5152ee66dfab",
            "0xa831c66d2db43210",
            "0xb00327c898fb213f",
            "0xbf597fc7beef0ee4",
            "0xc6e00bf33da88fc2",
            "0xd5a79147930aa725",
            "0x06ca6351e003826f",
            "0x142929670a0e6e70",
            "0x27b70a8546d22ffc",
            "0x2e1b21385c26c926",
            "0x4d2c6dfc5ac42aed",
            "0x53380d139d95b3df",
            "0x650a73548baf63de",
            "0x766a0abb3c77b2a8",
            "0x81c2c92e47edaee6",
            "0x92722c851482353b",
            "0xa2bfe8a14cf10364",
            "0xa81a664bbc423001",
            "0xc24b8b70d0f89791",
            "0xc76c51a30654be30",
            "0xd192e819d6ef5218",
            "0xd69906245565a910",
            "0xf40e35855771202a",
            "0x106aa07032bbd1b8",
            "0x19a4c116b8d2d0c8",
            "0x1e376c085141ab53",
            "0x2748774cdf8eeb99",
            "0x34b0bcb5e19b48a8",
            "0x391c0cb3c5c95a63",
            "0x4ed8aa4ae3418acb",
            "0x5b9cca4f7763e373",
            "0x682e6ff3d6b2b8a3",
            "0x748f82ee5defb2fc",
            "0x78a5636f43172f60",
            "0x84c87814a1f0ab72",
            "0x8cc702081a6439ec",
            "0x90befffa23631e28",
            "0xa4506cebde82bde9",
            "0xbef9a3f7b2c67915",
            "0xc67178f2e372532b",
            "0xca273eceea26619c",
            "0xd186b8c721c0c207",
            "0xeada7dd6cde0eb1e",
            "0xf57d4f7fee6ed178",
            "0x06f067aa72176fba",
            "0x0a637dc5a2c898a6",
            "0x113f9804bef90dae",
            "0x1b710b35131c471b",
            "0x28db77f523047d84",
            "0x32caab7b40c72493",
            "0x3c9ebe0a15c9bebc",
            "0x431d67c49c100d4c",
            "0x4cc5d4becb3e42b6",
            "0x597f299cfc657e2a",
            "0x5fcb6fab3ad6faec",
            "0x6c44198c4a475817",
          ].map((n) => BigInt(n))
        );
        const SHA512_W_H = new Uint32Array(80);
        const SHA512_W_L = new Uint32Array(80);
        class SHA512 extends SHA2 {
          constructor() {
            super(128, 64, 16, false);
            this.Ah = 1779033703 | 0;
            this.Al = 4089235720 | 0;
            this.Bh = 3144134277 | 0;
            this.Bl = 2227873595 | 0;
            this.Ch = 1013904242 | 0;
            this.Cl = 4271175723 | 0;
            this.Dh = 2773480762 | 0;
            this.Dl = 1595750129 | 0;
            this.Eh = 1359893119 | 0;
            this.El = 2917565137 | 0;
            this.Fh = 2600822924 | 0;
            this.Fl = 725511199 | 0;
            this.Gh = 528734635 | 0;
            this.Gl = 4215389547 | 0;
            this.Hh = 1541459225 | 0;
            this.Hl = 327033209 | 0;
          }
          get() {
            const {
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl,
            } = this;
            return [
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl,
            ];
          }
          set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
            this.Ah = Ah | 0;
            this.Al = Al | 0;
            this.Bh = Bh | 0;
            this.Bl = Bl | 0;
            this.Ch = Ch | 0;
            this.Cl = Cl | 0;
            this.Dh = Dh | 0;
            this.Dl = Dl | 0;
            this.Eh = Eh | 0;
            this.El = El | 0;
            this.Fh = Fh | 0;
            this.Fl = Fl | 0;
            this.Gh = Gh | 0;
            this.Gl = Gl | 0;
            this.Hh = Hh | 0;
            this.Hl = Hl | 0;
          }
          process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4) {
              SHA512_W_H[i] = view.getUint32(offset);
              SHA512_W_L[i] = view.getUint32((offset += 4));
            }
            for (let i = 16; i < 80; i++) {
              const W15h = SHA512_W_H[i - 15] | 0;
              const W15l = SHA512_W_L[i - 15] | 0;
              const s0h =
                u64.rotrSH(W15h, W15l, 1) ^
                u64.rotrSH(W15h, W15l, 8) ^
                u64.shrSH(W15h, W15l, 7);
              const s0l =
                u64.rotrSL(W15h, W15l, 1) ^
                u64.rotrSL(W15h, W15l, 8) ^
                u64.shrSL(W15h, W15l, 7);
              const W2h = SHA512_W_H[i - 2] | 0;
              const W2l = SHA512_W_L[i - 2] | 0;
              const s1h =
                u64.rotrSH(W2h, W2l, 19) ^
                u64.rotrBH(W2h, W2l, 61) ^
                u64.shrSH(W2h, W2l, 6);
              const s1l =
                u64.rotrSL(W2h, W2l, 19) ^
                u64.rotrBL(W2h, W2l, 61) ^
                u64.shrSL(W2h, W2l, 6);
              const SUMl = u64.add4L(
                s0l,
                s1l,
                SHA512_W_L[i - 7],
                SHA512_W_L[i - 16]
              );
              const SUMh = u64.add4H(
                SUMl,
                s0h,
                s1h,
                SHA512_W_H[i - 7],
                SHA512_W_H[i - 16]
              );
              SHA512_W_H[i] = SUMh | 0;
              SHA512_W_L[i] = SUMl | 0;
            }
            let {
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl,
            } = this;
            for (let i = 0; i < 80; i++) {
              const sigma1h =
                u64.rotrSH(Eh, El, 14) ^
                u64.rotrSH(Eh, El, 18) ^
                u64.rotrBH(Eh, El, 41);
              const sigma1l =
                u64.rotrSL(Eh, El, 14) ^
                u64.rotrSL(Eh, El, 18) ^
                u64.rotrBL(Eh, El, 41);
              const CHIh = (Eh & Fh) ^ (~Eh & Gh);
              const CHIl = (El & Fl) ^ (~El & Gl);
              const T1ll = u64.add5L(
                Hl,
                sigma1l,
                CHIl,
                SHA512_Kl[i],
                SHA512_W_L[i]
              );
              const T1h = u64.add5H(
                T1ll,
                Hh,
                sigma1h,
                CHIh,
                SHA512_Kh[i],
                SHA512_W_H[i]
              );
              const T1l = T1ll | 0;
              const sigma0h =
                u64.rotrSH(Ah, Al, 28) ^
                u64.rotrBH(Ah, Al, 34) ^
                u64.rotrBH(Ah, Al, 39);
              const sigma0l =
                u64.rotrSL(Ah, Al, 28) ^
                u64.rotrBL(Ah, Al, 34) ^
                u64.rotrBL(Ah, Al, 39);
              const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
              const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
              Hh = Gh | 0;
              Hl = Gl | 0;
              Gh = Fh | 0;
              Gl = Fl | 0;
              Fh = Eh | 0;
              Fl = El | 0;
              ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
              Dh = Ch | 0;
              Dl = Cl | 0;
              Ch = Bh | 0;
              Cl = Bl | 0;
              Bh = Ah | 0;
              Bl = Al | 0;
              const All = u64.add3L(T1l, sigma0l, MAJl);
              Ah = u64.add3H(All, T1h, sigma0h, MAJh);
              Al = All | 0;
            }
            ({ h: Ah, l: Al } = u64.add(
              this.Ah | 0,
              this.Al | 0,
              Ah | 0,
              Al | 0
            ));
            ({ h: Bh, l: Bl } = u64.add(
              this.Bh | 0,
              this.Bl | 0,
              Bh | 0,
              Bl | 0
            ));
            ({ h: Ch, l: Cl } = u64.add(
              this.Ch | 0,
              this.Cl | 0,
              Ch | 0,
              Cl | 0
            ));
            ({ h: Dh, l: Dl } = u64.add(
              this.Dh | 0,
              this.Dl | 0,
              Dh | 0,
              Dl | 0
            ));
            ({ h: Eh, l: El } = u64.add(
              this.Eh | 0,
              this.El | 0,
              Eh | 0,
              El | 0
            ));
            ({ h: Fh, l: Fl } = u64.add(
              this.Fh | 0,
              this.Fl | 0,
              Fh | 0,
              Fl | 0
            ));
            ({ h: Gh, l: Gl } = u64.add(
              this.Gh | 0,
              this.Gl | 0,
              Gh | 0,
              Gl | 0
            ));
            ({ h: Hh, l: Hl } = u64.add(
              this.Hh | 0,
              this.Hl | 0,
              Hh | 0,
              Hl | 0
            ));
            this.set(
              Ah,
              Al,
              Bh,
              Bl,
              Ch,
              Cl,
              Dh,
              Dl,
              Eh,
              El,
              Fh,
              Fl,
              Gh,
              Gl,
              Hh,
              Hl
            );
          }
          roundClean() {
            SHA512_W_H.fill(0);
            SHA512_W_L.fill(0);
          }
          destroy() {
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          }
        }
        class SHA512_256 extends SHA512 {
          constructor() {
            super();
            this.Ah = 573645204 | 0;
            this.Al = 4230739756 | 0;
            this.Bh = 2673172387 | 0;
            this.Bl = 3360449730 | 0;
            this.Ch = 596883563 | 0;
            this.Cl = 1867755857 | 0;
            this.Dh = 2520282905 | 0;
            this.Dl = 1497426621 | 0;
            this.Eh = 2519219938 | 0;
            this.El = 2827943907 | 0;
            this.Fh = 3193839141 | 0;
            this.Fl = 1401305490 | 0;
            this.Gh = 721525244 | 0;
            this.Gl = 746961066 | 0;
            this.Hh = 246885852 | 0;
            this.Hl = 2177182882 | 0;
            this.outputLen = 32;
          }
        }
        class SHA384 extends SHA512 {
          constructor() {
            super();
            this.Ah = 3418070365 | 0;
            this.Al = 3238371032 | 0;
            this.Bh = 1654270250 | 0;
            this.Bl = 914150663 | 0;
            this.Ch = 2438529370 | 0;
            this.Cl = 812702999 | 0;
            this.Dh = 355462360 | 0;
            this.Dl = 4144912697 | 0;
            this.Eh = 1731405415 | 0;
            this.El = 4290775857 | 0;
            this.Fh = 2394180231 | 0;
            this.Fl = 1750603025 | 0;
            this.Gh = 3675008525 | 0;
            this.Gl = 1694076839 | 0;
            this.Hh = 1203062813 | 0;
            this.Hl = 3204075428 | 0;
            this.outputLen = 48;
          }
        }
        const sha512$1 = wrapConstructor(() => new SHA512());
        wrapConstructor(() => new SHA512_256());
        wrapConstructor(() => new SHA384());
        function getGlobal$1() {
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          throw new Error("unable to locate global object");
        }
        const anyGlobal = getGlobal$1();
        const crypto$1 = anyGlobal.crypto || anyGlobal.msCrypto;
        function createHash(algo) {
          switch (algo) {
            case "sha256":
              return sha256$1.create();
            case "sha512":
              return sha512$1.create();
          }
          assertArgument(
            false,
            "invalid hashing algorithm name",
            "algorithm",
            algo
          );
        }
        function createHmac(_algo, key) {
          const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
          assertArgument(
            algo != null,
            "invalid hmac algorithm",
            "algorithm",
            _algo
          );
          return hmac.create(algo, key);
        }
        function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
          const algo = { sha256: sha256$1, sha512: sha512$1 }[_algo];
          assertArgument(
            algo != null,
            "invalid pbkdf2 algorithm",
            "algorithm",
            _algo
          );
          return pbkdf2$1(algo, password, salt, {
            c: iterations,
            dkLen: keylen,
          });
        }
        function randomBytes$1(length) {
          assert$1(
            crypto$1 != null,
            "platform does not support secure random numbers",
            "UNSUPPORTED_OPERATION",
            { operation: "randomBytes" }
          );
          assertArgument(
            Number.isInteger(length) && length > 0 && length <= 1024,
            "invalid length",
            "length",
            length
          );
          const result = new Uint8Array(length);
          crypto$1.getRandomValues(result);
          return result;
        }
        let locked$4 = false;
        const _computeHmac = function (algorithm, key, data) {
          return createHmac(algorithm, key).update(data).digest();
        };
        let __computeHmac = _computeHmac;
        function computeHmac(algorithm, _key, _data) {
          const key = getBytes(_key, "key");
          const data = getBytes(_data, "data");
          return hexlify(__computeHmac(algorithm, key, data));
        }
        computeHmac._ = _computeHmac;
        computeHmac.lock = function () {
          locked$4 = true;
        };
        computeHmac.register = function (func) {
          if (locked$4) {
            throw new Error("computeHmac is locked");
          }
          __computeHmac = func;
        };
        Object.freeze(computeHmac);
        const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
        const _0n$1 = BigInt(0);
        const _1n$1 = BigInt(1);
        const _2n$1 = BigInt(2);
        const _7n = BigInt(7);
        const _256n = BigInt(256);
        const _0x71n = BigInt(113);
        for (let round = 0, R = _1n$1, x = 1, y = 0; round < 24; round++) {
          [x, y] = [y, (2 * x + 3 * y) % 5];
          SHA3_PI.push(2 * (5 * y + x));
          SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
          let t = _0n$1;
          for (let j = 0; j < 7; j++) {
            R = ((R << _1n$1) ^ ((R >> _7n) * _0x71n)) % _256n;
            if (R & _2n$1) t ^= _1n$1 << ((_1n$1 << BigInt(j)) - _1n$1);
          }
          _SHA3_IOTA.push(t);
        }
        const [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);
        const rotlH = (h, l, s) =>
          s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);
        const rotlL = (h, l, s) =>
          s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);
        function keccakP(s, rounds = 24) {
          const B = new Uint32Array(5 * 2);
          for (let round = 24 - rounds; round < 24; round++) {
            for (let x = 0; x < 10; x++)
              B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
            for (let x = 0; x < 10; x += 2) {
              const idx1 = (x + 8) % 10;
              const idx0 = (x + 2) % 10;
              const B0 = B[idx0];
              const B1 = B[idx0 + 1];
              const Th = rotlH(B0, B1, 1) ^ B[idx1];
              const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
              for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
              }
            }
            let curH = s[2];
            let curL = s[3];
            for (let t = 0; t < 24; t++) {
              const shift = SHA3_ROTL[t];
              const Th = rotlH(curH, curL, shift);
              const Tl = rotlL(curH, curL, shift);
              const PI = SHA3_PI[t];
              curH = s[PI];
              curL = s[PI + 1];
              s[PI] = Th;
              s[PI + 1] = Tl;
            }
            for (let y = 0; y < 50; y += 10) {
              for (let x = 0; x < 10; x++) B[x] = s[y + x];
              for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
            }
            s[0] ^= SHA3_IOTA_H[round];
            s[1] ^= SHA3_IOTA_L[round];
          }
          B.fill(0);
        }
        class Keccak extends Hash {
          constructor(
            blockLen,
            suffix,
            outputLen,
            enableXOF = false,
            rounds = 24
          ) {
            super();
            this.blockLen = blockLen;
            this.suffix = suffix;
            this.outputLen = outputLen;
            this.enableXOF = enableXOF;
            this.rounds = rounds;
            this.pos = 0;
            this.posOut = 0;
            this.finished = false;
            this.destroyed = false;
            assert.number(outputLen);
            if (0 >= this.blockLen || this.blockLen >= 200)
              throw new Error("Sha3 supports only keccak-f1600 function");
            this.state = new Uint8Array(200);
            this.state32 = u32(this.state);
          }
          keccak() {
            keccakP(this.state32, this.rounds);
            this.posOut = 0;
            this.pos = 0;
          }
          update(data) {
            assert.exists(this);
            const { blockLen, state } = this;
            data = toBytes(data);
            const len = data.length;
            for (let pos = 0; pos < len; ) {
              const take = Math.min(blockLen - this.pos, len - pos);
              for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
              if (this.pos === blockLen) this.keccak();
            }
            return this;
          }
          finish() {
            if (this.finished) return;
            this.finished = true;
            const { state, suffix, pos, blockLen } = this;
            state[pos] ^= suffix;
            if ((suffix & 128) !== 0 && pos === blockLen - 1) this.keccak();
            state[blockLen - 1] ^= 128;
            this.keccak();
          }
          writeInto(out) {
            assert.exists(this, false);
            assert.bytes(out);
            this.finish();
            const bufferOut = this.state;
            const { blockLen } = this;
            for (let pos = 0, len = out.length; pos < len; ) {
              if (this.posOut >= blockLen) this.keccak();
              const take = Math.min(blockLen - this.posOut, len - pos);
              out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
              this.posOut += take;
              pos += take;
            }
            return out;
          }
          xofInto(out) {
            if (!this.enableXOF)
              throw new Error("XOF is not possible for this instance");
            return this.writeInto(out);
          }
          xof(bytes) {
            assert.number(bytes);
            return this.xofInto(new Uint8Array(bytes));
          }
          digestInto(out) {
            assert.output(out, this);
            if (this.finished) throw new Error("digest() was already called");
            this.writeInto(out);
            this.destroy();
            return out;
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen));
          }
          destroy() {
            this.destroyed = true;
            this.state.fill(0);
          }
          _cloneInto(to) {
            const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
            to ||
              (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
            to.state32.set(this.state32);
            to.pos = this.pos;
            to.posOut = this.posOut;
            to.finished = this.finished;
            to.rounds = rounds;
            to.suffix = suffix;
            to.outputLen = outputLen;
            to.enableXOF = enableXOF;
            to.destroyed = this.destroyed;
            return to;
          }
        }
        const gen = (suffix, blockLen, outputLen) =>
          wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
        gen(6, 144, 224 / 8);
        gen(6, 136, 256 / 8);
        gen(6, 104, 384 / 8);
        gen(6, 72, 512 / 8);
        gen(1, 144, 224 / 8);
        const keccak_256 = gen(1, 136, 256 / 8);
        gen(1, 104, 384 / 8);
        gen(1, 72, 512 / 8);
        const genShake = (suffix, blockLen, outputLen) =>
          wrapConstructorWithOpts(
            (opts = {}) =>
              new Keccak(
                blockLen,
                suffix,
                opts.dkLen === undefined ? outputLen : opts.dkLen,
                true
              )
          );
        genShake(31, 168, 128 / 8);
        genShake(31, 136, 256 / 8);
        let locked$3 = false;
        const _keccak256 = function (data) {
          return keccak_256(data);
        };
        let __keccak256 = _keccak256;
        function keccak256(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__keccak256(data));
        }
        keccak256._ = _keccak256;
        keccak256.lock = function () {
          locked$3 = true;
        };
        keccak256.register = function (func) {
          if (locked$3) {
            throw new TypeError("keccak256 is locked");
          }
          __keccak256 = func;
        };
        Object.freeze(keccak256);
        const Rho = new Uint8Array([
          7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
        ]);
        const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
        const Pi = Id.map((i) => (9 * i + 5) % 16);
        let idxL = [Id];
        let idxR = [Pi];
        for (let i = 0; i < 4; i++)
          for (let j of [idxL, idxR]) j.push(j[i].map((k) => Rho[k]));
        const shifts = [
          [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
          [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
          [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
          [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
          [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
        ].map((i) => new Uint8Array(i));
        const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
        const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
        const Kl = new Uint32Array([
          0, 1518500249, 1859775393, 2400959708, 2840853838,
        ]);
        const Kr = new Uint32Array([
          1352829926, 1548603684, 1836072691, 2053994217, 0,
        ]);
        const rotl$1 = (word, shift) =>
          (word << shift) | (word >>> (32 - shift));
        function f(group, x, y, z) {
          if (group === 0) return x ^ y ^ z;
          else if (group === 1) return (x & y) | (~x & z);
          else if (group === 2) return (x | ~y) ^ z;
          else if (group === 3) return (x & z) | (y & ~z);
          else return x ^ (y | ~z);
        }
        const BUF = new Uint32Array(16);
        class RIPEMD160 extends SHA2 {
          constructor() {
            super(64, 20, 8, true);
            this.h0 = 1732584193 | 0;
            this.h1 = 4023233417 | 0;
            this.h2 = 2562383102 | 0;
            this.h3 = 271733878 | 0;
            this.h4 = 3285377520 | 0;
          }
          get() {
            const { h0, h1, h2, h3, h4 } = this;
            return [h0, h1, h2, h3, h4];
          }
          set(h0, h1, h2, h3, h4) {
            this.h0 = h0 | 0;
            this.h1 = h1 | 0;
            this.h2 = h2 | 0;
            this.h3 = h3 | 0;
            this.h4 = h4 | 0;
          }
          process(view, offset) {
            for (let i = 0; i < 16; i++, offset += 4)
              BUF[i] = view.getUint32(offset, true);
            let al = this.h0 | 0,
              ar = al,
              bl = this.h1 | 0,
              br = bl,
              cl = this.h2 | 0,
              cr = cl,
              dl = this.h3 | 0,
              dr = dl,
              el = this.h4 | 0,
              er = el;
            for (let group = 0; group < 5; group++) {
              const rGroup = 4 - group;
              const hbl = Kl[group],
                hbr = Kr[group];
              const rl = idxL[group],
                rr = idxR[group];
              const sl = shiftsL[group],
                sr = shiftsR[group];
              for (let i = 0; i < 16; i++) {
                const tl =
                  (rotl$1(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) +
                    el) |
                  0;
                (al = el),
                  (el = dl),
                  (dl = rotl$1(cl, 10) | 0),
                  (cl = bl),
                  (bl = tl);
              }
              for (let i = 0; i < 16; i++) {
                const tr =
                  (rotl$1(
                    ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr,
                    sr[i]
                  ) +
                    er) |
                  0;
                (ar = er),
                  (er = dr),
                  (dr = rotl$1(cr, 10) | 0),
                  (cr = br),
                  (br = tr);
              }
            }
            this.set(
              (this.h1 + cl + dr) | 0,
              (this.h2 + dl + er) | 0,
              (this.h3 + el + ar) | 0,
              (this.h4 + al + br) | 0,
              (this.h0 + bl + cr) | 0
            );
          }
          roundClean() {
            BUF.fill(0);
          }
          destroy() {
            this.destroyed = true;
            this.buffer.fill(0);
            this.set(0, 0, 0, 0, 0);
          }
        }
        const ripemd160$1 = wrapConstructor(() => new RIPEMD160());
        let locked$2 = false;
        const _ripemd160 = function (data) {
          return ripemd160$1(data);
        };
        let __ripemd160 = _ripemd160;
        function ripemd160(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__ripemd160(data));
        }
        ripemd160._ = _ripemd160;
        ripemd160.lock = function () {
          locked$2 = true;
        };
        ripemd160.register = function (func) {
          if (locked$2) {
            throw new TypeError("ripemd160 is locked");
          }
          __ripemd160 = func;
        };
        Object.freeze(ripemd160);
        let locked$1 = false;
        const _pbkdf2 = function (password, salt, iterations, keylen, algo) {
          return pbkdf2Sync(password, salt, iterations, keylen, algo);
        };
        let __pbkdf2 = _pbkdf2;
        function pbkdf2(_password, _salt, iterations, keylen, algo) {
          const password = getBytes(_password, "password");
          const salt = getBytes(_salt, "salt");
          return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
        }
        pbkdf2._ = _pbkdf2;
        pbkdf2.lock = function () {
          locked$1 = true;
        };
        pbkdf2.register = function (func) {
          if (locked$1) {
            throw new Error("pbkdf2 is locked");
          }
          __pbkdf2 = func;
        };
        Object.freeze(pbkdf2);
        let locked = false;
        const _randomBytes = function (length) {
          return new Uint8Array(randomBytes$1(length));
        };
        let __randomBytes = _randomBytes;
        function randomBytes(length) {
          return __randomBytes(length);
        }
        randomBytes._ = _randomBytes;
        randomBytes.lock = function () {
          locked = true;
        };
        randomBytes.register = function (func) {
          if (locked) {
            throw new Error("randomBytes is locked");
          }
          __randomBytes = func;
        };
        Object.freeze(randomBytes);
        const rotl = (a, b) => (a << b) | (a >>> (32 - b));
        function XorAndSalsa(prev, pi, input, ii, out, oi) {
          let y00 = prev[pi++] ^ input[ii++],
            y01 = prev[pi++] ^ input[ii++];
          let y02 = prev[pi++] ^ input[ii++],
            y03 = prev[pi++] ^ input[ii++];
          let y04 = prev[pi++] ^ input[ii++],
            y05 = prev[pi++] ^ input[ii++];
          let y06 = prev[pi++] ^ input[ii++],
            y07 = prev[pi++] ^ input[ii++];
          let y08 = prev[pi++] ^ input[ii++],
            y09 = prev[pi++] ^ input[ii++];
          let y10 = prev[pi++] ^ input[ii++],
            y11 = prev[pi++] ^ input[ii++];
          let y12 = prev[pi++] ^ input[ii++],
            y13 = prev[pi++] ^ input[ii++];
          let y14 = prev[pi++] ^ input[ii++],
            y15 = prev[pi++] ^ input[ii++];
          let x00 = y00,
            x01 = y01,
            x02 = y02,
            x03 = y03,
            x04 = y04,
            x05 = y05,
            x06 = y06,
            x07 = y07,
            x08 = y08,
            x09 = y09,
            x10 = y10,
            x11 = y11,
            x12 = y12,
            x13 = y13,
            x14 = y14,
            x15 = y15;
          for (let i = 0; i < 8; i += 2) {
            x04 ^= rotl((x00 + x12) | 0, 7);
            x08 ^= rotl((x04 + x00) | 0, 9);
            x12 ^= rotl((x08 + x04) | 0, 13);
            x00 ^= rotl((x12 + x08) | 0, 18);
            x09 ^= rotl((x05 + x01) | 0, 7);
            x13 ^= rotl((x09 + x05) | 0, 9);
            x01 ^= rotl((x13 + x09) | 0, 13);
            x05 ^= rotl((x01 + x13) | 0, 18);
            x14 ^= rotl((x10 + x06) | 0, 7);
            x02 ^= rotl((x14 + x10) | 0, 9);
            x06 ^= rotl((x02 + x14) | 0, 13);
            x10 ^= rotl((x06 + x02) | 0, 18);
            x03 ^= rotl((x15 + x11) | 0, 7);
            x07 ^= rotl((x03 + x15) | 0, 9);
            x11 ^= rotl((x07 + x03) | 0, 13);
            x15 ^= rotl((x11 + x07) | 0, 18);
            x01 ^= rotl((x00 + x03) | 0, 7);
            x02 ^= rotl((x01 + x00) | 0, 9);
            x03 ^= rotl((x02 + x01) | 0, 13);
            x00 ^= rotl((x03 + x02) | 0, 18);
            x06 ^= rotl((x05 + x04) | 0, 7);
            x07 ^= rotl((x06 + x05) | 0, 9);
            x04 ^= rotl((x07 + x06) | 0, 13);
            x05 ^= rotl((x04 + x07) | 0, 18);
            x11 ^= rotl((x10 + x09) | 0, 7);
            x08 ^= rotl((x11 + x10) | 0, 9);
            x09 ^= rotl((x08 + x11) | 0, 13);
            x10 ^= rotl((x09 + x08) | 0, 18);
            x12 ^= rotl((x15 + x14) | 0, 7);
            x13 ^= rotl((x12 + x15) | 0, 9);
            x14 ^= rotl((x13 + x12) | 0, 13);
            x15 ^= rotl((x14 + x13) | 0, 18);
          }
          out[oi++] = (y00 + x00) | 0;
          out[oi++] = (y01 + x01) | 0;
          out[oi++] = (y02 + x02) | 0;
          out[oi++] = (y03 + x03) | 0;
          out[oi++] = (y04 + x04) | 0;
          out[oi++] = (y05 + x05) | 0;
          out[oi++] = (y06 + x06) | 0;
          out[oi++] = (y07 + x07) | 0;
          out[oi++] = (y08 + x08) | 0;
          out[oi++] = (y09 + x09) | 0;
          out[oi++] = (y10 + x10) | 0;
          out[oi++] = (y11 + x11) | 0;
          out[oi++] = (y12 + x12) | 0;
          out[oi++] = (y13 + x13) | 0;
          out[oi++] = (y14 + x14) | 0;
          out[oi++] = (y15 + x15) | 0;
        }
        function BlockMix(input, ii, out, oi, r) {
          let head = oi + 0;
          let tail = oi + 16 * r;
          for (let i = 0; i < 16; i++)
            out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
          for (let i = 0; i < r; i++, head += 16, ii += 16) {
            XorAndSalsa(out, tail, input, ii, out, head);
            if (i > 0) tail += 16;
            XorAndSalsa(out, head, input, (ii += 16), out, tail);
          }
        }
        function scryptInit(password, salt, _opts) {
          const opts = checkOpts(
            { dkLen: 32, asyncTick: 10, maxmem: 1024 ** 3 + 1024 },
            _opts
          );
          const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
          assert.number(N);
          assert.number(r);
          assert.number(p);
          assert.number(dkLen);
          assert.number(asyncTick);
          assert.number(maxmem);
          if (onProgress !== undefined && typeof onProgress !== "function")
            throw new Error("progressCb should be function");
          const blockSize = 128 * r;
          const blockSize32 = blockSize / 4;
          if (
            N <= 1 ||
            (N & (N - 1)) !== 0 ||
            N >= 2 ** (blockSize / 8) ||
            N > 2 ** 32
          ) {
            throw new Error(
              "Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32"
            );
          }
          if (p < 0 || p > ((2 ** 32 - 1) * 32) / blockSize) {
            throw new Error(
              "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)"
            );
          }
          if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
            throw new Error(
              "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32"
            );
          }
          const memUsed = blockSize * (N + p);
          if (memUsed > maxmem) {
            throw new Error(
              `Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`
            );
          }
          const B = pbkdf2$1(sha256$1, password, salt, {
            c: 1,
            dkLen: blockSize * p,
          });
          const B32 = u32(B);
          const V = u32(new Uint8Array(blockSize * N));
          const tmp = u32(new Uint8Array(blockSize));
          let blockMixCb = () => {};
          if (onProgress) {
            const totalBlockMix = 2 * N * p;
            const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
            let blockMixCnt = 0;
            blockMixCb = () => {
              blockMixCnt++;
              if (
                onProgress &&
                (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)
              )
                onProgress(blockMixCnt / totalBlockMix);
            };
          }
          return {
            N: N,
            r: r,
            p: p,
            dkLen: dkLen,
            blockSize32: blockSize32,
            V: V,
            B32: B32,
            B: B,
            tmp: tmp,
            blockMixCb: blockMixCb,
            asyncTick: asyncTick,
          };
        }
        function scryptOutput(password, dkLen, B, V, tmp) {
          const res = pbkdf2$1(sha256$1, password, B, { c: 1, dkLen: dkLen });
          B.fill(0);
          V.fill(0);
          tmp.fill(0);
          return res;
        }
        function scrypt$1(password, salt, opts) {
          const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } =
            scryptInit(password, salt, opts);
          for (let pi = 0; pi < p; pi++) {
            const Pi = blockSize32 * pi;
            for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i];
            for (let i = 0, pos = 0; i < N - 1; i++) {
              BlockMix(V, pos, V, (pos += blockSize32), r);
              blockMixCb();
            }
            BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
            blockMixCb();
            for (let i = 0; i < N; i++) {
              const j = B32[Pi + blockSize32 - 16] % N;
              for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
              BlockMix(tmp, 0, B32, Pi, r);
              blockMixCb();
            }
          }
          return scryptOutput(password, dkLen, B, V, tmp);
        }
        async function scryptAsync(password, salt, opts) {
          const {
            N,
            r,
            p,
            dkLen,
            blockSize32,
            V,
            B32,
            B,
            tmp,
            blockMixCb,
            asyncTick,
          } = scryptInit(password, salt, opts);
          for (let pi = 0; pi < p; pi++) {
            const Pi = blockSize32 * pi;
            for (let i = 0; i < blockSize32; i++) V[i] = B32[Pi + i];
            let pos = 0;
            await asyncLoop(N - 1, asyncTick, (i) => {
              BlockMix(V, pos, V, (pos += blockSize32), r);
              blockMixCb();
            });
            BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
            blockMixCb();
            await asyncLoop(N, asyncTick, (i) => {
              const j = B32[Pi + blockSize32 - 16] % N;
              for (let k = 0; k < blockSize32; k++)
                tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
              BlockMix(tmp, 0, B32, Pi, r);
              blockMixCb();
            });
          }
          return scryptOutput(password, dkLen, B, V, tmp);
        }
        let lockedSync = false,
          lockedAsync = false;
        const _scryptAsync = async function (
          passwd,
          salt,
          N,
          r,
          p,
          dkLen,
          onProgress
        ) {
          return await scryptAsync(passwd, salt, {
            N: N,
            r: r,
            p: p,
            dkLen: dkLen,
            onProgress: onProgress,
          });
        };
        const _scryptSync = function (passwd, salt, N, r, p, dkLen) {
          return scrypt$1(passwd, salt, { N: N, r: r, p: p, dkLen: dkLen });
        };
        let __scryptAsync = _scryptAsync;
        let __scryptSync = _scryptSync;
        async function scrypt(_passwd, _salt, N, r, p, dkLen, progress) {
          const passwd = getBytes(_passwd, "passwd");
          const salt = getBytes(_salt, "salt");
          return hexlify(
            await __scryptAsync(passwd, salt, N, r, p, dkLen, progress)
          );
        }
        scrypt._ = _scryptAsync;
        scrypt.lock = function () {
          lockedAsync = true;
        };
        scrypt.register = function (func) {
          if (lockedAsync) {
            throw new Error("scrypt is locked");
          }
          __scryptAsync = func;
        };
        Object.freeze(scrypt);
        function scryptSync(_passwd, _salt, N, r, p, dkLen) {
          const passwd = getBytes(_passwd, "passwd");
          const salt = getBytes(_salt, "salt");
          return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
        }
        scryptSync._ = _scryptSync;
        scryptSync.lock = function () {
          lockedSync = true;
        };
        scryptSync.register = function (func) {
          if (lockedSync) {
            throw new Error("scryptSync is locked");
          }
          __scryptSync = func;
        };
        Object.freeze(scryptSync);
        const _sha256 = function (data) {
          return createHash("sha256").update(data).digest();
        };
        const _sha512 = function (data) {
          return createHash("sha512").update(data).digest();
        };
        let __sha256 = _sha256;
        let __sha512 = _sha512;
        let locked256 = false,
          locked512 = false;
        function sha256(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__sha256(data));
        }
        sha256._ = _sha256;
        sha256.lock = function () {
          locked256 = true;
        };
        sha256.register = function (func) {
          if (locked256) {
            throw new Error("sha256 is locked");
          }
          __sha256 = func;
        };
        Object.freeze(sha256);
        function sha512(_data) {
          const data = getBytes(_data, "data");
          return hexlify(__sha512(data));
        }
        sha512._ = _sha512;
        sha512.lock = function () {
          locked512 = true;
        };
        sha512.register = function (func) {
          if (locked512) {
            throw new Error("sha512 is locked");
          }
          __sha512 = func;
        };
        Object.freeze(sha256);
        var _nodeResolve_empty = {};
        var nodeCrypto = Object.freeze({
          __proto__: null,
          default: _nodeResolve_empty,
        });
        const _0n = BigInt(0);
        const _1n = BigInt(1);
        const _2n = BigInt(2);
        const _3n = BigInt(3);
        const _8n = BigInt(8);
        const CURVE = Object.freeze({
          a: _0n,
          b: BigInt(7),
          P: BigInt(
            "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
          ),
          n: BigInt(
            "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
          ),
          h: _1n,
          Gx: BigInt(
            "55066263022277343669578718895168534326250603453777594175500187360389116729240"
          ),
          Gy: BigInt(
            "32670510020758816978083085130507043184471273380659243275938904335757337482424"
          ),
          beta: BigInt(
            "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
          ),
        });
        const divNearest = (a, b) => (a + b / _2n) / b;
        const endo = {
          beta: BigInt(
            "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
          ),
          splitScalar(k) {
            const { n } = CURVE;
            const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
            const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
            const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
            const b2 = a1;
            const POW_2_128 = BigInt("0x100000000000000000000000000000000");
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = mod(k - c1 * a1 - c2 * a2, n);
            let k2 = mod(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg) k1 = n - k1;
            if (k2neg) k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
              throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
            }
            return { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 };
          },
        };
        const fieldLen = 32;
        const groupLen = 32;
        const hashLen = 32;
        const compressedLen = fieldLen + 1;
        const uncompressedLen = 2 * fieldLen + 1;
        function weierstrass(x) {
          const { a, b } = CURVE;
          const x2 = mod(x * x);
          const x3 = mod(x2 * x);
          return mod(x3 + a * x + b);
        }
        const USE_ENDOMORPHISM = CURVE.a === _0n;
        class ShaError extends Error {
          constructor(message) {
            super(message);
          }
        }
        function assertJacPoint(other) {
          if (!(other instanceof JacobianPoint))
            throw new TypeError("JacobianPoint expected");
        }
        class JacobianPoint {
          constructor(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
          }
          static fromAffine(p) {
            if (!(p instanceof Point)) {
              throw new TypeError("JacobianPoint#fromAffine: expected Point");
            }
            if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;
            return new JacobianPoint(p.x, p.y, _1n);
          }
          static toAffineBatch(points) {
            const toInv = invertBatch(points.map((p) => p.z));
            return points.map((p, i) => p.toAffine(toInv[i]));
          }
          static normalizeZ(points) {
            return JacobianPoint.toAffineBatch(points).map(
              JacobianPoint.fromAffine
            );
          }
          equals(other) {
            assertJacPoint(other);
            const { x: X1, y: Y1, z: Z1 } = this;
            const { x: X2, y: Y2, z: Z2 } = other;
            const Z1Z1 = mod(Z1 * Z1);
            const Z2Z2 = mod(Z2 * Z2);
            const U1 = mod(X1 * Z2Z2);
            const U2 = mod(X2 * Z1Z1);
            const S1 = mod(mod(Y1 * Z2) * Z2Z2);
            const S2 = mod(mod(Y2 * Z1) * Z1Z1);
            return U1 === U2 && S1 === S2;
          }
          negate() {
            return new JacobianPoint(this.x, mod(-this.y), this.z);
          }
          double() {
            const { x: X1, y: Y1, z: Z1 } = this;
            const A = mod(X1 * X1);
            const B = mod(Y1 * Y1);
            const C = mod(B * B);
            const x1b = X1 + B;
            const D = mod(_2n * (mod(x1b * x1b) - A - C));
            const E = mod(_3n * A);
            const F = mod(E * E);
            const X3 = mod(F - _2n * D);
            const Y3 = mod(E * (D - X3) - _8n * C);
            const Z3 = mod(_2n * Y1 * Z1);
            return new JacobianPoint(X3, Y3, Z3);
          }
          add(other) {
            assertJacPoint(other);
            const { x: X1, y: Y1, z: Z1 } = this;
            const { x: X2, y: Y2, z: Z2 } = other;
            if (X2 === _0n || Y2 === _0n) return this;
            if (X1 === _0n || Y1 === _0n) return other;
            const Z1Z1 = mod(Z1 * Z1);
            const Z2Z2 = mod(Z2 * Z2);
            const U1 = mod(X1 * Z2Z2);
            const U2 = mod(X2 * Z1Z1);
            const S1 = mod(mod(Y1 * Z2) * Z2Z2);
            const S2 = mod(mod(Y2 * Z1) * Z1Z1);
            const H = mod(U2 - U1);
            const r = mod(S2 - S1);
            if (H === _0n) {
              if (r === _0n) {
                return this.double();
              } else {
                return JacobianPoint.ZERO;
              }
            }
            const HH = mod(H * H);
            const HHH = mod(H * HH);
            const V = mod(U1 * HH);
            const X3 = mod(r * r - HHH - _2n * V);
            const Y3 = mod(r * (V - X3) - S1 * HHH);
            const Z3 = mod(Z1 * Z2 * H);
            return new JacobianPoint(X3, Y3, Z3);
          }
          subtract(other) {
            return this.add(other.negate());
          }
          multiplyUnsafe(scalar) {
            const P0 = JacobianPoint.ZERO;
            if (typeof scalar === "bigint" && scalar === _0n) return P0;
            let n = normalizeScalar(scalar);
            if (n === _1n) return this;
            if (!USE_ENDOMORPHISM) {
              let p = P0;
              let d = this;
              while (n > _0n) {
                if (n & _1n) p = p.add(d);
                d = d.double();
                n >>= _1n;
              }
              return p;
            }
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = P0;
            let k2p = P0;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
              if (k1 & _1n) k1p = k1p.add(d);
              if (k2 & _1n) k2p = k2p.add(d);
              d = d.double();
              k1 >>= _1n;
              k2 >>= _1n;
            }
            if (k1neg) k1p = k1p.negate();
            if (k2neg) k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
            return k1p.add(k2p);
          }
          precomputeWindow(W) {
            const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
            const points = [];
            let p = this;
            let base = p;
            for (let window = 0; window < windows; window++) {
              base = p;
              points.push(base);
              for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
              }
              p = base.double();
            }
            return points;
          }
          wNAF(n, affinePoint) {
            if (!affinePoint && this.equals(JacobianPoint.BASE))
              affinePoint = Point.BASE;
            const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
            if (256 % W) {
              throw new Error(
                "Point#wNAF: Invalid precomputation window, must be power of 2"
              );
            }
            let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
            if (!precomputes) {
              precomputes = this.precomputeWindow(W);
              if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
              }
            }
            let p = JacobianPoint.ZERO;
            let f = JacobianPoint.BASE;
            const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
            const windowSize = 2 ** (W - 1);
            const mask = BigInt(2 ** W - 1);
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
              const offset = window * windowSize;
              let wbits = Number(n & mask);
              n >>= shiftBy;
              if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
              }
              const offset1 = offset;
              const offset2 = offset + Math.abs(wbits) - 1;
              const cond1 = window % 2 !== 0;
              const cond2 = wbits < 0;
              if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
              } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
              }
            }
            return { p: p, f: f };
          }
          multiply(scalar, affinePoint) {
            let n = normalizeScalar(scalar);
            let point;
            let fake;
            if (USE_ENDOMORPHISM) {
              const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
              let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
              let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
              k1p = constTimeNegate(k1neg, k1p);
              k2p = constTimeNegate(k2neg, k2p);
              k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
              point = k1p.add(k2p);
              fake = f1p.add(f2p);
            } else {
              const { p, f } = this.wNAF(n, affinePoint);
              point = p;
              fake = f;
            }
            return JacobianPoint.normalizeZ([point, fake])[0];
          }
          toAffine(invZ) {
            const { x, y, z } = this;
            const is0 = this.equals(JacobianPoint.ZERO);
            if (invZ == null) invZ = is0 ? _8n : invert(z);
            const iz1 = invZ;
            const iz2 = mod(iz1 * iz1);
            const iz3 = mod(iz2 * iz1);
            const ax = mod(x * iz2);
            const ay = mod(y * iz3);
            const zz = mod(z * iz1);
            if (is0) return Point.ZERO;
            if (zz !== _1n) throw new Error("invZ was invalid");
            return new Point(ax, ay);
          }
        }
        JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
        JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
        function constTimeNegate(condition, item) {
          const neg = item.negate();
          return condition ? neg : item;
        }
        const pointPrecomputes = new WeakMap();
        class Point {
          constructor(x, y) {
            this.x = x;
            this.y = y;
          }
          _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
          }
          hasEvenY() {
            return this.y % _2n === _0n;
          }
          static fromCompressedHex(bytes) {
            const isShort = bytes.length === 32;
            const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrass(x);
            let y = sqrtMod(y2);
            const isYOdd = (y & _1n) === _1n;
            if (isShort) {
              if (isYOdd) y = mod(-y);
            } else {
              const isFirstByteOdd = (bytes[0] & 1) === 1;
              if (isFirstByteOdd !== isYOdd) y = mod(-y);
            }
            const point = new Point(x, y);
            point.assertValidity();
            return point;
          }
          static fromUncompressedHex(bytes) {
            const x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
            const y = bytesToNumber(
              bytes.subarray(fieldLen + 1, fieldLen * 2 + 1)
            );
            const point = new Point(x, y);
            point.assertValidity();
            return point;
          }
          static fromHex(hex) {
            const bytes = ensureBytes(hex);
            const len = bytes.length;
            const header = bytes[0];
            if (len === fieldLen) return this.fromCompressedHex(bytes);
            if (len === compressedLen && (header === 2 || header === 3)) {
              return this.fromCompressedHex(bytes);
            }
            if (len === uncompressedLen && header === 4)
              return this.fromUncompressedHex(bytes);
            throw new Error(
              `Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`
            );
          }
          static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normalizePrivateKey(privateKey));
          }
          static fromSignature(msgHash, signature, recovery) {
            const { r, s } = normalizeSignature(signature);
            if (![0, 1, 2, 3].includes(recovery))
              throw new Error("Cannot recover: invalid recovery bit");
            const h = truncateHash(ensureBytes(msgHash));
            const { n } = CURVE;
            const radj = recovery === 2 || recovery === 3 ? r + n : r;
            const rinv = invert(radj, n);
            const u1 = mod(-h * rinv, n);
            const u2 = mod(s * rinv, n);
            const prefix = recovery & 1 ? "03" : "02";
            const R = Point.fromHex(prefix + numTo32bStr(radj));
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
            if (!Q)
              throw new Error("Cannot recover signature: point at infinify");
            Q.assertValidity();
            return Q;
          }
          toRawBytes(isCompressed = false) {
            return hexToBytes(this.toHex(isCompressed));
          }
          toHex(isCompressed = false) {
            const x = numTo32bStr(this.x);
            if (isCompressed) {
              const prefix = this.hasEvenY() ? "02" : "03";
              return `${prefix}${x}`;
            } else {
              return `04${x}${numTo32bStr(this.y)}`;
            }
          }
          toHexX() {
            return this.toHex(true).slice(2);
          }
          toRawX() {
            return this.toRawBytes(true).slice(1);
          }
          assertValidity() {
            const msg = "Point is not on elliptic curve";
            const { x, y } = this;
            if (!isValidFieldElement(x) || !isValidFieldElement(y))
              throw new Error(msg);
            const left = mod(y * y);
            const right = weierstrass(x);
            if (mod(left - right) !== _0n) throw new Error(msg);
          }
          equals(other) {
            return this.x === other.x && this.y === other.y;
          }
          negate() {
            return new Point(this.x, mod(-this.y));
          }
          double() {
            return JacobianPoint.fromAffine(this).double().toAffine();
          }
          add(other) {
            return JacobianPoint.fromAffine(this)
              .add(JacobianPoint.fromAffine(other))
              .toAffine();
          }
          subtract(other) {
            return this.add(other.negate());
          }
          multiply(scalar) {
            return JacobianPoint.fromAffine(this)
              .multiply(scalar, this)
              .toAffine();
          }
          multiplyAndAddUnsafe(Q, a, b) {
            const P = JacobianPoint.fromAffine(this);
            const aP =
              a === _0n || a === _1n || this !== Point.BASE
                ? P.multiplyUnsafe(a)
                : P.multiply(a);
            const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
            const sum = aP.add(bQ);
            return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
          }
        }
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
        Point.ZERO = new Point(_0n, _0n);
        function sliceDER(s) {
          return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
        }
        function parseDERInt(data) {
          if (data.length < 2 || data[0] !== 2) {
            throw new Error(
              `Invalid signature integer tag: ${bytesToHex(data)}`
            );
          }
          const len = data[1];
          const res = data.subarray(2, len + 2);
          if (!len || res.length !== len) {
            throw new Error(`Invalid signature integer: wrong length`);
          }
          if (res[0] === 0 && res[1] <= 127) {
            throw new Error("Invalid signature integer: trailing length");
          }
          return { data: bytesToNumber(res), left: data.subarray(len + 2) };
        }
        function parseDERSignature(data) {
          if (data.length < 2 || data[0] != 48) {
            throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
          }
          if (data[1] !== data.length - 2) {
            throw new Error("Invalid signature: incorrect length");
          }
          const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
          const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
          if (rBytesLeft.length) {
            throw new Error(
              `Invalid signature: left bytes after parsing: ${bytesToHex(
                rBytesLeft
              )}`
            );
          }
          return { r: r, s: s };
        }
        let Signature$1 = class Signature {
          constructor(r, s) {
            this.r = r;
            this.s = s;
            this.assertValidity();
          }
          static fromCompact(hex) {
            const arr = hex instanceof Uint8Array;
            const name = "Signature.fromCompact";
            if (typeof hex !== "string" && !arr)
              throw new TypeError(`${name}: Expected string or Uint8Array`);
            const str = arr ? bytesToHex(hex) : hex;
            if (str.length !== 128)
              throw new Error(`${name}: Expected 64-byte hex`);
            return new Signature(
              hexToNumber(str.slice(0, 64)),
              hexToNumber(str.slice(64, 128))
            );
          }
          static fromDER(hex) {
            const arr = hex instanceof Uint8Array;
            if (typeof hex !== "string" && !arr)
              throw new TypeError(
                `Signature.fromDER: Expected string or Uint8Array`
              );
            const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
            return new Signature(r, s);
          }
          static fromHex(hex) {
            return this.fromDER(hex);
          }
          assertValidity() {
            const { r, s } = this;
            if (!isWithinCurveOrder(r))
              throw new Error("Invalid Signature: r must be 0 < r < n");
            if (!isWithinCurveOrder(s))
              throw new Error("Invalid Signature: s must be 0 < s < n");
          }
          hasHighS() {
            const HALF = CURVE.n >> _1n;
            return this.s > HALF;
          }
          normalizeS() {
            return this.hasHighS()
              ? new Signature(this.r, mod(-this.s, CURVE.n))
              : this;
          }
          toDERRawBytes() {
            return hexToBytes(this.toDERHex());
          }
          toDERHex() {
            const sHex = sliceDER(numberToHexUnpadded(this.s));
            const rHex = sliceDER(numberToHexUnpadded(this.r));
            const sHexL = sHex.length / 2;
            const rHexL = rHex.length / 2;
            const sLen = numberToHexUnpadded(sHexL);
            const rLen = numberToHexUnpadded(rHexL);
            const length = numberToHexUnpadded(rHexL + sHexL + 4);
            return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
          }
          toRawBytes() {
            return this.toDERRawBytes();
          }
          toHex() {
            return this.toDERHex();
          }
          toCompactRawBytes() {
            return hexToBytes(this.toCompactHex());
          }
          toCompactHex() {
            return numTo32bStr(this.r) + numTo32bStr(this.s);
          }
        };
        function concatBytes(...arrays) {
          if (!arrays.every((b) => b instanceof Uint8Array))
            throw new Error("Uint8Array list expected");
          if (arrays.length === 1) return arrays[0];
          const length = arrays.reduce((a, arr) => a + arr.length, 0);
          const result = new Uint8Array(length);
          for (let i = 0, pad = 0; i < arrays.length; i++) {
            const arr = arrays[i];
            result.set(arr, pad);
            pad += arr.length;
          }
          return result;
        }
        const hexes = Array.from({ length: 256 }, (v, i) =>
          i.toString(16).padStart(2, "0")
        );
        function bytesToHex(uint8a) {
          if (!(uint8a instanceof Uint8Array))
            throw new Error("Expected Uint8Array");
          let hex = "";
          for (let i = 0; i < uint8a.length; i++) {
            hex += hexes[uint8a[i]];
          }
          return hex;
        }
        const POW_2_256 = BigInt(
          "0x10000000000000000000000000000000000000000000000000000000000000000"
        );
        function numTo32bStr(num) {
          if (typeof num !== "bigint") throw new Error("Expected bigint");
          if (!(_0n <= num && num < POW_2_256))
            throw new Error("Expected number 0 <= n < 2^256");
          return num.toString(16).padStart(64, "0");
        }
        function numTo32b(num) {
          const b = hexToBytes(numTo32bStr(num));
          if (b.length !== 32) throw new Error("Error: expected 32 bytes");
          return b;
        }
        function numberToHexUnpadded(num) {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        }
        function hexToNumber(hex) {
          if (typeof hex !== "string") {
            throw new TypeError(
              "hexToNumber: expected string, got " + typeof hex
            );
          }
          return BigInt(`0x${hex}`);
        }
        function hexToBytes(hex) {
          if (typeof hex !== "string") {
            throw new TypeError(
              "hexToBytes: expected string, got " + typeof hex
            );
          }
          if (hex.length % 2)
            throw new Error(
              "hexToBytes: received invalid unpadded hex" + hex.length
            );
          const array = new Uint8Array(hex.length / 2);
          for (let i = 0; i < array.length; i++) {
            const j = i * 2;
            const hexByte = hex.slice(j, j + 2);
            const byte = Number.parseInt(hexByte, 16);
            if (Number.isNaN(byte) || byte < 0)
              throw new Error("Invalid byte sequence");
            array[i] = byte;
          }
          return array;
        }
        function bytesToNumber(bytes) {
          return hexToNumber(bytesToHex(bytes));
        }
        function ensureBytes(hex) {
          return hex instanceof Uint8Array
            ? Uint8Array.from(hex)
            : hexToBytes(hex);
        }
        function normalizeScalar(num) {
          if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
            return BigInt(num);
          if (typeof num === "bigint" && isWithinCurveOrder(num)) return num;
          throw new TypeError(
            "Expected valid private scalar: 0 < scalar < curve.n"
          );
        }
        function mod(a, b = CURVE.P) {
          const result = a % b;
          return result >= _0n ? result : b + result;
        }
        function pow2(x, power) {
          const { P } = CURVE;
          let res = x;
          while (power-- > _0n) {
            res *= res;
            res %= P;
          }
          return res;
        }
        function sqrtMod(x) {
          const { P } = CURVE;
          const _6n = BigInt(6);
          const _11n = BigInt(11);
          const _22n = BigInt(22);
          const _23n = BigInt(23);
          const _44n = BigInt(44);
          const _88n = BigInt(88);
          const b2 = (x * x * x) % P;
          const b3 = (b2 * b2 * x) % P;
          const b6 = (pow2(b3, _3n) * b3) % P;
          const b9 = (pow2(b6, _3n) * b3) % P;
          const b11 = (pow2(b9, _2n) * b2) % P;
          const b22 = (pow2(b11, _11n) * b11) % P;
          const b44 = (pow2(b22, _22n) * b22) % P;
          const b88 = (pow2(b44, _44n) * b44) % P;
          const b176 = (pow2(b88, _88n) * b88) % P;
          const b220 = (pow2(b176, _44n) * b44) % P;
          const b223 = (pow2(b220, _3n) * b3) % P;
          const t1 = (pow2(b223, _23n) * b22) % P;
          const t2 = (pow2(t1, _6n) * b2) % P;
          const rt = pow2(t2, _2n);
          const xc = (rt * rt) % P;
          if (xc !== x) throw new Error("Cannot find square root");
          return rt;
        }
        function invert(number, modulo = CURVE.P) {
          if (number === _0n || modulo <= _0n) {
            throw new Error(
              `invert: expected positive integers, got n=${number} mod=${modulo}`
            );
          }
          let a = mod(number, modulo);
          let b = modulo;
          let x = _0n,
            u = _1n;
          while (a !== _0n) {
            const q = b / a;
            const r = b % a;
            const m = x - u * q;
            (b = a), (a = r), (x = u), (u = m);
          }
          const gcd = b;
          if (gcd !== _1n) throw new Error("invert: does not exist");
          return mod(x, modulo);
        }
        function invertBatch(nums, p = CURVE.P) {
          const scratch = new Array(nums.length);
          const lastMultiplied = nums.reduce((acc, num, i) => {
            if (num === _0n) return acc;
            scratch[i] = acc;
            return mod(acc * num, p);
          }, _1n);
          const inverted = invert(lastMultiplied, p);
          nums.reduceRight((acc, num, i) => {
            if (num === _0n) return acc;
            scratch[i] = mod(acc * scratch[i], p);
            return mod(acc * num, p);
          }, inverted);
          return scratch;
        }
        function bits2int_2(bytes) {
          const delta = bytes.length * 8 - groupLen * 8;
          const num = bytesToNumber(bytes);
          return delta > 0 ? num >> BigInt(delta) : num;
        }
        function truncateHash(hash, truncateOnly = false) {
          const h = bits2int_2(hash);
          if (truncateOnly) return h;
          const { n } = CURVE;
          return h >= n ? h - n : h;
        }
        let _sha256Sync;
        let _hmacSha256Sync;
        class HmacDrbg {
          constructor(hashLen, qByteLen) {
            this.hashLen = hashLen;
            this.qByteLen = qByteLen;
            if (typeof hashLen !== "number" || hashLen < 2)
              throw new Error("hashLen must be a number");
            if (typeof qByteLen !== "number" || qByteLen < 2)
              throw new Error("qByteLen must be a number");
            this.v = new Uint8Array(hashLen).fill(1);
            this.k = new Uint8Array(hashLen).fill(0);
            this.counter = 0;
          }
          hmac(...values) {
            return utils.hmacSha256(this.k, ...values);
          }
          hmacSync(...values) {
            return _hmacSha256Sync(this.k, ...values);
          }
          checkSync() {
            if (typeof _hmacSha256Sync !== "function")
              throw new ShaError("hmacSha256Sync needs to be set");
          }
          incr() {
            if (this.counter >= 1e3)
              throw new Error(
                "Tried 1,000 k values for sign(), all were invalid"
              );
            this.counter += 1;
          }
          async reseed(seed = new Uint8Array()) {
            this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
            this.v = await this.hmac(this.v);
            if (seed.length === 0) return;
            this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
            this.v = await this.hmac(this.v);
          }
          reseedSync(seed = new Uint8Array()) {
            this.checkSync();
            this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
            this.v = this.hmacSync(this.v);
            if (seed.length === 0) return;
            this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
            this.v = this.hmacSync(this.v);
          }
          async generate() {
            this.incr();
            let len = 0;
            const out = [];
            while (len < this.qByteLen) {
              this.v = await this.hmac(this.v);
              const sl = this.v.slice();
              out.push(sl);
              len += this.v.length;
            }
            return concatBytes(...out);
          }
          generateSync() {
            this.checkSync();
            this.incr();
            let len = 0;
            const out = [];
            while (len < this.qByteLen) {
              this.v = this.hmacSync(this.v);
              const sl = this.v.slice();
              out.push(sl);
              len += this.v.length;
            }
            return concatBytes(...out);
          }
        }
        function isWithinCurveOrder(num) {
          return _0n < num && num < CURVE.n;
        }
        function isValidFieldElement(num) {
          return _0n < num && num < CURVE.P;
        }
        function kmdToSig(kBytes, m, d, lowS = true) {
          const { n } = CURVE;
          const k = truncateHash(kBytes, true);
          if (!isWithinCurveOrder(k)) return;
          const kinv = invert(k, n);
          const q = Point.BASE.multiply(k);
          const r = mod(q.x, n);
          if (r === _0n) return;
          const s = mod(kinv * mod(m + d * r, n), n);
          if (s === _0n) return;
          let sig = new Signature$1(r, s);
          let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
          if (lowS && sig.hasHighS()) {
            sig = sig.normalizeS();
            recovery ^= 1;
          }
          return { sig: sig, recovery: recovery };
        }
        function normalizePrivateKey(key) {
          let num;
          if (typeof key === "bigint") {
            num = key;
          } else if (
            typeof key === "number" &&
            Number.isSafeInteger(key) &&
            key > 0
          ) {
            num = BigInt(key);
          } else if (typeof key === "string") {
            if (key.length !== 2 * groupLen)
              throw new Error("Expected 32 bytes of private key");
            num = hexToNumber(key);
          } else if (key instanceof Uint8Array) {
            if (key.length !== groupLen)
              throw new Error("Expected 32 bytes of private key");
            num = bytesToNumber(key);
          } else {
            throw new TypeError("Expected valid private key");
          }
          if (!isWithinCurveOrder(num))
            throw new Error("Expected private key: 0 < key < n");
          return num;
        }
        function normalizePublicKey(publicKey) {
          if (publicKey instanceof Point) {
            publicKey.assertValidity();
            return publicKey;
          } else {
            return Point.fromHex(publicKey);
          }
        }
        function normalizeSignature(signature) {
          if (signature instanceof Signature$1) {
            signature.assertValidity();
            return signature;
          }
          try {
            return Signature$1.fromDER(signature);
          } catch (error) {
            return Signature$1.fromCompact(signature);
          }
        }
        function getPublicKey(privateKey, isCompressed = false) {
          return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
        }
        function recoverPublicKey(
          msgHash,
          signature,
          recovery,
          isCompressed = false
        ) {
          return Point.fromSignature(msgHash, signature, recovery).toRawBytes(
            isCompressed
          );
        }
        function isProbPub(item) {
          const arr = item instanceof Uint8Array;
          const str = typeof item === "string";
          const len = (arr || str) && item.length;
          if (arr) return len === compressedLen || len === uncompressedLen;
          if (str)
            return len === compressedLen * 2 || len === uncompressedLen * 2;
          if (item instanceof Point) return true;
          return false;
        }
        function getSharedSecret(privateA, publicB, isCompressed = false) {
          if (isProbPub(privateA))
            throw new TypeError(
              "getSharedSecret: first arg must be private key"
            );
          if (!isProbPub(publicB))
            throw new TypeError(
              "getSharedSecret: second arg must be public key"
            );
          const b = normalizePublicKey(publicB);
          b.assertValidity();
          return b
            .multiply(normalizePrivateKey(privateA))
            .toRawBytes(isCompressed);
        }
        function bits2int(bytes) {
          const slice =
            bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
          return bytesToNumber(slice);
        }
        function bits2octets(bytes) {
          const z1 = bits2int(bytes);
          const z2 = mod(z1, CURVE.n);
          return int2octets(z2 < _0n ? z1 : z2);
        }
        function int2octets(num) {
          return numTo32b(num);
        }
        function initSigArgs(msgHash, privateKey, extraEntropy) {
          if (msgHash == null)
            throw new Error(
              `sign: expected valid message hash, not "${msgHash}"`
            );
          const h1 = ensureBytes(msgHash);
          const d = normalizePrivateKey(privateKey);
          const seedArgs = [int2octets(d), bits2octets(h1)];
          if (extraEntropy != null) {
            if (extraEntropy === true)
              extraEntropy = utils.randomBytes(fieldLen);
            const e = ensureBytes(extraEntropy);
            if (e.length !== fieldLen)
              throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
            seedArgs.push(e);
          }
          const seed = concatBytes(...seedArgs);
          const m = bits2int(h1);
          return { seed: seed, m: m, d: d };
        }
        function finalizeSig(recSig, opts) {
          const { sig, recovery } = recSig;
          const { der, recovered } = Object.assign(
            { canonical: true, der: true },
            opts
          );
          const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
          return recovered ? [hashed, recovery] : hashed;
        }
        function signSync(msgHash, privKey, opts = {}) {
          const { seed, m, d } = initSigArgs(
            msgHash,
            privKey,
            opts.extraEntropy
          );
          const drbg = new HmacDrbg(hashLen, groupLen);
          drbg.reseedSync(seed);
          let sig;
          while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
            drbg.reseedSync();
          return finalizeSig(sig, opts);
        }
        Point.BASE._setWindowSize(8);
        const crypto = {
          node: nodeCrypto,
          web:
            typeof self === "object" && "crypto" in self
              ? self.crypto
              : undefined,
        };
        const TAGGED_HASH_PREFIXES = {};
        const utils = {
          bytesToHex: bytesToHex,
          hexToBytes: hexToBytes,
          concatBytes: concatBytes,
          mod: mod,
          invert: invert,
          isValidPrivateKey(privateKey) {
            try {
              normalizePrivateKey(privateKey);
              return true;
            } catch (error) {
              return false;
            }
          },
          _bigintTo32Bytes: numTo32b,
          _normalizePrivateKey: normalizePrivateKey,
          hashToPrivateKey: (hash) => {
            hash = ensureBytes(hash);
            const minLen = groupLen + 8;
            if (hash.length < minLen || hash.length > 1024) {
              throw new Error(
                `Expected valid bytes of private key as per FIPS 186`
              );
            }
            const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
            return numTo32b(num);
          },
          randomBytes: (bytesLength = 32) => {
            if (crypto.web) {
              return crypto.web.getRandomValues(new Uint8Array(bytesLength));
            } else if (crypto.node) {
              const { randomBytes } = crypto.node;
              return Uint8Array.from(randomBytes(bytesLength));
            } else {
              throw new Error(
                "The environment doesn't have randomBytes function"
              );
            }
          },
          randomPrivateKey: () =>
            utils.hashToPrivateKey(utils.randomBytes(groupLen + 8)),
          precompute(windowSize = 8, point = Point.BASE) {
            const cached =
              point === Point.BASE ? point : new Point(point.x, point.y);
            cached._setWindowSize(windowSize);
            cached.multiply(_3n);
            return cached;
          },
          sha256: async (...messages) => {
            if (crypto.web) {
              const buffer = await crypto.web.subtle.digest(
                "SHA-256",
                concatBytes(...messages)
              );
              return new Uint8Array(buffer);
            } else if (crypto.node) {
              const { createHash } = crypto.node;
              const hash = createHash("sha256");
              messages.forEach((m) => hash.update(m));
              return Uint8Array.from(hash.digest());
            } else {
              throw new Error("The environment doesn't have sha256 function");
            }
          },
          hmacSha256: async (key, ...messages) => {
            if (crypto.web) {
              const ckey = await crypto.web.subtle.importKey(
                "raw",
                key,
                { name: "HMAC", hash: { name: "SHA-256" } },
                false,
                ["sign"]
              );
              const message = concatBytes(...messages);
              const buffer = await crypto.web.subtle.sign(
                "HMAC",
                ckey,
                message
              );
              return new Uint8Array(buffer);
            } else if (crypto.node) {
              const { createHmac } = crypto.node;
              const hash = createHmac("sha256", key);
              messages.forEach((m) => hash.update(m));
              return Uint8Array.from(hash.digest());
            } else {
              throw new Error(
                "The environment doesn't have hmac-sha256 function"
              );
            }
          },
          sha256Sync: undefined,
          hmacSha256Sync: undefined,
          taggedHash: async (tag, ...messages) => {
            let tagP = TAGGED_HASH_PREFIXES[tag];
            if (tagP === undefined) {
              const tagH = await utils.sha256(
                Uint8Array.from(tag, (c) => c.charCodeAt(0))
              );
              tagP = concatBytes(tagH, tagH);
              TAGGED_HASH_PREFIXES[tag] = tagP;
            }
            return utils.sha256(tagP, ...messages);
          },
          taggedHashSync: (tag, ...messages) => {
            if (typeof _sha256Sync !== "function")
              throw new ShaError("sha256Sync is undefined, you need to set it");
            let tagP = TAGGED_HASH_PREFIXES[tag];
            if (tagP === undefined) {
              const tagH = _sha256Sync(
                Uint8Array.from(tag, (c) => c.charCodeAt(0))
              );
              tagP = concatBytes(tagH, tagH);
              TAGGED_HASH_PREFIXES[tag] = tagP;
            }
            return _sha256Sync(tagP, ...messages);
          },
          _JacobianPoint: JacobianPoint,
        };
        Object.defineProperties(utils, {
          sha256Sync: {
            configurable: false,
            get() {
              return _sha256Sync;
            },
            set(val) {
              if (!_sha256Sync) _sha256Sync = val;
            },
          },
          hmacSha256Sync: {
            configurable: false,
            get() {
              return _hmacSha256Sync;
            },
            set(val) {
              if (!_hmacSha256Sync) _hmacSha256Sync = val;
            },
          },
        });
        const ZeroAddress = "0x0000000000000000000000000000000000000000";
        const ZeroHash =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        const N$1 = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        );
        const WeiPerEther = BigInt("1000000000000000000");
        const MaxUint256 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        const MinInt256 =
          BigInt(
            "0x8000000000000000000000000000000000000000000000000000000000000000"
          ) * BigInt(-1);
        const MaxInt256 = BigInt(
          "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        const EtherSymbol = "";
        const MessagePrefix = "Ethereum Signed Message:\n";
        const BN_0$7 = BigInt(0);
        const BN_1$3 = BigInt(1);
        const BN_2$3 = BigInt(2);
        const BN_27$1 = BigInt(27);
        const BN_28$1 = BigInt(28);
        const BN_35$1 = BigInt(35);
        const _guard$3 = {};
        function toUint256(value) {
          return zeroPadValue(toBeArray(value), 32);
        }
        class Signature {
          #r;
          #s;
          #v;
          #networkV;
          get r() {
            return this.#r;
          }
          set r(value) {
            assertArgument(
              dataLength(value) === 32,
              "invalid r",
              "value",
              value
            );
            this.#r = hexlify(value);
          }
          get s() {
            return this.#s;
          }
          set s(_value) {
            assertArgument(
              dataLength(_value) === 32,
              "invalid s",
              "value",
              _value
            );
            const value = hexlify(_value);
            assertArgument(
              parseInt(value.substring(0, 3)) < 8,
              "non-canonical s",
              "value",
              value
            );
            this.#s = value;
          }
          get v() {
            return this.#v;
          }
          set v(value) {
            const v = getNumber(value, "value");
            assertArgument(v === 27 || v === 28, "invalid v", "v", value);
            this.#v = v;
          }
          get networkV() {
            return this.#networkV;
          }
          get legacyChainId() {
            const v = this.networkV;
            if (v == null) {
              return null;
            }
            return Signature.getChainId(v);
          }
          get yParity() {
            return this.v === 27 ? 0 : 1;
          }
          get yParityAndS() {
            const yParityAndS = getBytes(this.s);
            if (this.yParity) {
              yParityAndS[0] |= 128;
            }
            return hexlify(yParityAndS);
          }
          get compactSerialized() {
            return concat([this.r, this.yParityAndS]);
          }
          get serialized() {
            return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
          }
          constructor(guard, r, s, v) {
            assertPrivate(guard, _guard$3, "Signature");
            this.#r = r;
            this.#s = s;
            this.#v = v;
            this.#networkV = null;
          }
          [Symbol.for("nodejs.util.inspect.custom")]() {
            return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
          }
          clone() {
            const clone = new Signature(_guard$3, this.r, this.s, this.v);
            if (this.networkV) {
              clone.#networkV = this.networkV;
            }
            return clone;
          }
          toJSON() {
            const networkV = this.networkV;
            return {
              _type: "signature",
              networkV: networkV != null ? networkV.toString() : null,
              r: this.r,
              s: this.s,
              v: this.v,
            };
          }
          static getChainId(v) {
            const bv = getBigInt(v, "v");
            if (bv == BN_27$1 || bv == BN_28$1) {
              return BN_0$7;
            }
            assertArgument(bv >= BN_35$1, "invalid EIP-155 v", "v", v);
            return (bv - BN_35$1) / BN_2$3;
          }
          static getChainIdV(chainId, v) {
            return getBigInt(chainId) * BN_2$3 + BigInt(35 + v - 27);
          }
          static getNormalizedV(v) {
            const bv = getBigInt(v);
            if (bv === BN_0$7 || bv === BN_27$1) {
              return 27;
            }
            if (bv === BN_1$3 || bv === BN_28$1) {
              return 28;
            }
            assertArgument(bv >= BN_35$1, "invalid v", "v", v);
            return bv & BN_1$3 ? 27 : 28;
          }
          static from(sig) {
            function assertError(check, message) {
              assertArgument(check, message, "signature", sig);
            }
            if (sig == null) {
              return new Signature(_guard$3, ZeroHash, ZeroHash, 27);
            }
            if (typeof sig === "string") {
              const bytes = getBytes(sig, "signature");
              if (bytes.length === 64) {
                const r = hexlify(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                const v = s[0] & 128 ? 28 : 27;
                s[0] &= 127;
                return new Signature(_guard$3, r, hexlify(s), v);
              }
              if (bytes.length === 65) {
                const r = hexlify(bytes.slice(0, 32));
                const s = bytes.slice(32, 64);
                assertError((s[0] & 128) === 0, "non-canonical s");
                const v = Signature.getNormalizedV(bytes[64]);
                return new Signature(_guard$3, r, hexlify(s), v);
              }
              assertError(false, "invalid raw signature length");
            }
            if (sig instanceof Signature) {
              return sig.clone();
            }
            const _r = sig.r;
            assertError(_r != null, "missing r");
            const r = toUint256(_r);
            const s = (function (s, yParityAndS) {
              if (s != null) {
                return toUint256(s);
              }
              if (yParityAndS != null) {
                assertError(
                  isHexString(yParityAndS, 32),
                  "invalid yParityAndS"
                );
                const bytes = getBytes(yParityAndS);
                bytes[0] &= 127;
                return hexlify(bytes);
              }
              assertError(false, "missing s");
            })(sig.s, sig.yParityAndS);
            assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
            const { networkV, v } = (function (_v, yParityAndS, yParity) {
              if (_v != null) {
                const v = getBigInt(_v);
                return {
                  networkV: v >= BN_35$1 ? v : undefined,
                  v: Signature.getNormalizedV(v),
                };
              }
              if (yParityAndS != null) {
                assertError(
                  isHexString(yParityAndS, 32),
                  "invalid yParityAndS"
                );
                return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
              }
              if (yParity != null) {
                switch (getNumber(yParity, "sig.yParity")) {
                  case 0:
                    return { v: 27 };
                  case 1:
                    return { v: 28 };
                }
                assertError(false, "invalid yParity");
              }
              assertError(false, "missing v");
            })(sig.v, sig.yParityAndS, sig.yParity);
            const result = new Signature(_guard$3, r, s, v);
            if (networkV) {
              result.#networkV = networkV;
            }
            assertError(
              sig.yParity == null ||
                getNumber(sig.yParity, "sig.yParity") === result.yParity,
              "yParity mismatch"
            );
            assertError(
              sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS,
              "yParityAndS mismatch"
            );
            return result;
          }
        }
        utils.hmacSha256Sync = function (key, ...messages) {
          return getBytes(computeHmac("sha256", key, concat(messages)));
        };
        class SigningKey {
          #privateKey;
          constructor(privateKey) {
            assertArgument(
              dataLength(privateKey) === 32,
              "invalid private key",
              "privateKey",
              "[REDACTED]"
            );
            this.#privateKey = hexlify(privateKey);
          }
          get privateKey() {
            return this.#privateKey;
          }
          get publicKey() {
            return SigningKey.computePublicKey(this.#privateKey);
          }
          get compressedPublicKey() {
            return SigningKey.computePublicKey(this.#privateKey, true);
          }
          sign(digest) {
            assertArgument(
              dataLength(digest) === 32,
              "invalid digest length",
              "digest",
              digest
            );
            const [sigDer, recid] = signSync(
              getBytesCopy(digest),
              getBytesCopy(this.#privateKey),
              { recovered: true, canonical: true }
            );
            const sig = Signature$1.fromHex(sigDer);
            return Signature.from({
              r: toBeHex("0x" + sig.r.toString(16), 32),
              s: toBeHex("0x" + sig.s.toString(16), 32),
              v: recid ? 28 : 27,
            });
          }
          computeSharedSecret(other) {
            const pubKey = SigningKey.computePublicKey(other);
            return hexlify(
              getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey))
            );
          }
          static computePublicKey(key, compressed) {
            let bytes = getBytes(key, "key");
            if (bytes.length === 32) {
              const pubKey = getPublicKey(bytes, !!compressed);
              return hexlify(pubKey);
            }
            if (bytes.length === 64) {
              const pub = new Uint8Array(65);
              pub[0] = 4;
              pub.set(bytes, 1);
              bytes = pub;
            }
            const point = Point.fromHex(bytes);
            return hexlify(point.toRawBytes(compressed));
          }
          static recoverPublicKey(digest, signature) {
            assertArgument(
              dataLength(digest) === 32,
              "invalid digest length",
              "digest",
              digest
            );
            const sig = Signature.from(signature);
            const der = Signature$1.fromCompact(
              getBytesCopy(concat([sig.r, sig.s]))
            ).toDERRawBytes();
            const pubKey = recoverPublicKey(
              getBytesCopy(digest),
              der,
              sig.yParity
            );
            assertArgument(
              pubKey != null,
              "invalid signautre for digest",
              "signature",
              signature
            );
            return hexlify(pubKey);
          }
          static addPoints(p0, p1, compressed) {
            const pub0 = Point.fromHex(
              SigningKey.computePublicKey(p0).substring(2)
            );
            const pub1 = Point.fromHex(
              SigningKey.computePublicKey(p1).substring(2)
            );
            return "0x" + pub0.add(pub1).toHex(!!compressed);
          }
        }
        function lock() {
          computeHmac.lock();
          keccak256.lock();
          pbkdf2.lock();
          randomBytes.lock();
          ripemd160.lock();
          scrypt.lock();
          scryptSync.lock();
          sha256.lock();
          sha512.lock();
          randomBytes.lock();
        }
        const BN_0$6 = BigInt(0);
        const BN_36 = BigInt(36);
        function getChecksumAddress(address) {
          address = address.toLowerCase();
          const chars = address.substring(2).split("");
          const expanded = new Uint8Array(40);
          for (let i = 0; i < 40; i++) {
            expanded[i] = chars[i].charCodeAt(0);
          }
          const hashed = getBytes(keccak256(expanded));
          for (let i = 0; i < 40; i += 2) {
            if (hashed[i >> 1] >> 4 >= 8) {
              chars[i] = chars[i].toUpperCase();
            }
            if ((hashed[i >> 1] & 15) >= 8) {
              chars[i + 1] = chars[i + 1].toUpperCase();
            }
          }
          return "0x" + chars.join("");
        }
        const ibanLookup = {};
        for (let i = 0; i < 10; i++) {
          ibanLookup[String(i)] = String(i);
        }
        for (let i = 0; i < 26; i++) {
          ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
        }
        const safeDigits = 15;
        function ibanChecksum(address) {
          address = address.toUpperCase();
          address = address.substring(4) + address.substring(0, 2) + "00";
          let expanded = address
            .split("")
            .map((c) => {
              return ibanLookup[c];
            })
            .join("");
          while (expanded.length >= safeDigits) {
            let block = expanded.substring(0, safeDigits);
            expanded =
              (parseInt(block, 10) % 97) + expanded.substring(block.length);
          }
          let checksum = String(98 - (parseInt(expanded, 10) % 97));
          while (checksum.length < 2) {
            checksum = "0" + checksum;
          }
          return checksum;
        }
        const Base36 = (function () {
          const result = {};
          for (let i = 0; i < 36; i++) {
            const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
            result[key] = BigInt(i);
          }
          return result;
        })();
        function fromBase36(value) {
          value = value.toLowerCase();
          let result = BN_0$6;
          for (let i = 0; i < value.length; i++) {
            result = result * BN_36 + Base36[value[i]];
          }
          return result;
        }
        function getAddress(address) {
          assertArgument(
            typeof address === "string",
            "invalid address",
            "address",
            address
          );
          if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
            if (!address.startsWith("0x")) {
              address = "0x" + address;
            }
            const result = getChecksumAddress(address);
            assertArgument(
              !address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) ||
                result === address,
              "bad address checksum",
              "address",
              address
            );
            return result;
          }
          if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
            assertArgument(
              address.substring(2, 4) === ibanChecksum(address),
              "bad icap checksum",
              "address",
              address
            );
            let result = fromBase36(address.substring(4)).toString(16);
            while (result.length < 40) {
              result = "0" + result;
            }
            return getChecksumAddress("0x" + result);
          }
          assertArgument(false, "invalid address", "address", address);
        }
        function getIcapAddress(address) {
          let base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
          while (base36.length < 30) {
            base36 = "0" + base36;
          }
          return "XE" + ibanChecksum("XE00" + base36) + base36;
        }
        function getCreateAddress(tx) {
          const from = getAddress(tx.from);
          const nonce = getBigInt(tx.nonce, "tx.nonce");
          let nonceHex = nonce.toString(16);
          if (nonceHex === "0") {
            nonceHex = "0x";
          } else if (nonceHex.length % 2) {
            nonceHex = "0x0" + nonceHex;
          } else {
            nonceHex = "0x" + nonceHex;
          }
          return getAddress(
            dataSlice(keccak256(encodeRlp([from, nonceHex])), 12)
          );
        }
        function getCreate2Address(_from, _salt, _initCodeHash) {
          const from = getAddress(_from);
          const salt = getBytes(_salt, "salt");
          const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
          assertArgument(
            salt.length === 32,
            "salt must be 32 bytes",
            "salt",
            _salt
          );
          assertArgument(
            initCodeHash.length === 32,
            "initCodeHash must be 32 bytes",
            "initCodeHash",
            _initCodeHash
          );
          return getAddress(
            dataSlice(keccak256(concat(["0xff", from, salt, initCodeHash])), 12)
          );
        }
        function isAddressable(value) {
          return value && typeof value.getAddress === "function";
        }
        function isAddress(value) {
          try {
            getAddress(value);
            return true;
          } catch (error) {}
          return false;
        }
        async function checkAddress(target, promise) {
          const result = await promise;
          if (
            result == null ||
            result === "0x0000000000000000000000000000000000000000"
          ) {
            assert$1(
              typeof target !== "string",
              "unconfigured name",
              "UNCONFIGURED_NAME",
              { value: target }
            );
            assertArgument(
              false,
              "invalid AddressLike value; did not resolve to a value address",
              "target",
              target
            );
          }
          return getAddress(result);
        }
        function resolveAddress(target, resolver) {
          if (typeof target === "string") {
            if (target.match(/^0x[0-9a-f]{40}$/i)) {
              return getAddress(target);
            }
            assert$1(
              resolver != null,
              "ENS resolution requires a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "resolveName" }
            );
            return checkAddress(target, resolver.resolveName(target));
          } else if (isAddressable(target)) {
            return checkAddress(target, target.getAddress());
          } else if (target && typeof target.then === "function") {
            return checkAddress(target, target);
          }
          assertArgument(
            false,
            "unsupported addressable value",
            "target",
            target
          );
        }
        const _gaurd = {};
        function n(value, width) {
          let signed = false;
          if (width < 0) {
            signed = true;
            width *= -1;
          }
          return new Typed(_gaurd, `${signed ? "" : "u"}int${width}`, value, {
            signed: signed,
            width: width,
          });
        }
        function b(value, size) {
          return new Typed(_gaurd, `bytes${size ? size : ""}`, value, {
            size: size,
          });
        }
        const _typedSymbol = Symbol.for("_ethers_typed");
        class Typed {
          type;
          value;
          #options;
          _typedSymbol;
          constructor(gaurd, type, value, options) {
            if (options == null) {
              options = null;
            }
            assertPrivate(_gaurd, gaurd, "Typed");
            defineProperties(this, {
              _typedSymbol: _typedSymbol,
              type: type,
              value: value,
            });
            this.#options = options;
            this.format();
          }
          format() {
            if (this.type === "array") {
              throw new Error("");
            } else if (this.type === "dynamicArray") {
              throw new Error("");
            } else if (this.type === "tuple") {
              return `tuple(${this.value.map((v) => v.format()).join(",")})`;
            }
            return this.type;
          }
          defaultValue() {
            return 0;
          }
          minValue() {
            return 0;
          }
          maxValue() {
            return 0;
          }
          isBigInt() {
            return !!this.type.match(/^u?int[0-9]+$/);
          }
          isData() {
            return this.type.startsWith("bytes");
          }
          isString() {
            return this.type === "string";
          }
          get tupleName() {
            if (this.type !== "tuple") {
              throw TypeError("not a tuple");
            }
            return this.#options;
          }
          get arrayLength() {
            if (this.type !== "array") {
              throw TypeError("not an array");
            }
            if (this.#options === true) {
              return -1;
            }
            if (this.#options === false) {
              return this.value.length;
            }
            return null;
          }
          static from(type, value) {
            return new Typed(_gaurd, type, value);
          }
          static uint8(v) {
            return n(v, 8);
          }
          static uint16(v) {
            return n(v, 16);
          }
          static uint24(v) {
            return n(v, 24);
          }
          static uint32(v) {
            return n(v, 32);
          }
          static uint40(v) {
            return n(v, 40);
          }
          static uint48(v) {
            return n(v, 48);
          }
          static uint56(v) {
            return n(v, 56);
          }
          static uint64(v) {
            return n(v, 64);
          }
          static uint72(v) {
            return n(v, 72);
          }
          static uint80(v) {
            return n(v, 80);
          }
          static uint88(v) {
            return n(v, 88);
          }
          static uint96(v) {
            return n(v, 96);
          }
          static uint104(v) {
            return n(v, 104);
          }
          static uint112(v) {
            return n(v, 112);
          }
          static uint120(v) {
            return n(v, 120);
          }
          static uint128(v) {
            return n(v, 128);
          }
          static uint136(v) {
            return n(v, 136);
          }
          static uint144(v) {
            return n(v, 144);
          }
          static uint152(v) {
            return n(v, 152);
          }
          static uint160(v) {
            return n(v, 160);
          }
          static uint168(v) {
            return n(v, 168);
          }
          static uint176(v) {
            return n(v, 176);
          }
          static uint184(v) {
            return n(v, 184);
          }
          static uint192(v) {
            return n(v, 192);
          }
          static uint200(v) {
            return n(v, 200);
          }
          static uint208(v) {
            return n(v, 208);
          }
          static uint216(v) {
            return n(v, 216);
          }
          static uint224(v) {
            return n(v, 224);
          }
          static uint232(v) {
            return n(v, 232);
          }
          static uint240(v) {
            return n(v, 240);
          }
          static uint248(v) {
            return n(v, 248);
          }
          static uint256(v) {
            return n(v, 256);
          }
          static uint(v) {
            return n(v, 256);
          }
          static int8(v) {
            return n(v, -8);
          }
          static int16(v) {
            return n(v, -16);
          }
          static int24(v) {
            return n(v, -24);
          }
          static int32(v) {
            return n(v, -32);
          }
          static int40(v) {
            return n(v, -40);
          }
          static int48(v) {
            return n(v, -48);
          }
          static int56(v) {
            return n(v, -56);
          }
          static int64(v) {
            return n(v, -64);
          }
          static int72(v) {
            return n(v, -72);
          }
          static int80(v) {
            return n(v, -80);
          }
          static int88(v) {
            return n(v, -88);
          }
          static int96(v) {
            return n(v, -96);
          }
          static int104(v) {
            return n(v, -104);
          }
          static int112(v) {
            return n(v, -112);
          }
          static int120(v) {
            return n(v, -120);
          }
          static int128(v) {
            return n(v, -128);
          }
          static int136(v) {
            return n(v, -136);
          }
          static int144(v) {
            return n(v, -144);
          }
          static int152(v) {
            return n(v, -152);
          }
          static int160(v) {
            return n(v, -160);
          }
          static int168(v) {
            return n(v, -168);
          }
          static int176(v) {
            return n(v, -176);
          }
          static int184(v) {
            return n(v, -184);
          }
          static int192(v) {
            return n(v, -192);
          }
          static int200(v) {
            return n(v, -200);
          }
          static int208(v) {
            return n(v, -208);
          }
          static int216(v) {
            return n(v, -216);
          }
          static int224(v) {
            return n(v, -224);
          }
          static int232(v) {
            return n(v, -232);
          }
          static int240(v) {
            return n(v, -240);
          }
          static int248(v) {
            return n(v, -248);
          }
          static int256(v) {
            return n(v, -256);
          }
          static int(v) {
            return n(v, -256);
          }
          static bytes1(v) {
            return b(v, 1);
          }
          static bytes2(v) {
            return b(v, 2);
          }
          static bytes3(v) {
            return b(v, 3);
          }
          static bytes4(v) {
            return b(v, 4);
          }
          static bytes5(v) {
            return b(v, 5);
          }
          static bytes6(v) {
            return b(v, 6);
          }
          static bytes7(v) {
            return b(v, 7);
          }
          static bytes8(v) {
            return b(v, 8);
          }
          static bytes9(v) {
            return b(v, 9);
          }
          static bytes10(v) {
            return b(v, 10);
          }
          static bytes11(v) {
            return b(v, 11);
          }
          static bytes12(v) {
            return b(v, 12);
          }
          static bytes13(v) {
            return b(v, 13);
          }
          static bytes14(v) {
            return b(v, 14);
          }
          static bytes15(v) {
            return b(v, 15);
          }
          static bytes16(v) {
            return b(v, 16);
          }
          static bytes17(v) {
            return b(v, 17);
          }
          static bytes18(v) {
            return b(v, 18);
          }
          static bytes19(v) {
            return b(v, 19);
          }
          static bytes20(v) {
            return b(v, 20);
          }
          static bytes21(v) {
            return b(v, 21);
          }
          static bytes22(v) {
            return b(v, 22);
          }
          static bytes23(v) {
            return b(v, 23);
          }
          static bytes24(v) {
            return b(v, 24);
          }
          static bytes25(v) {
            return b(v, 25);
          }
          static bytes26(v) {
            return b(v, 26);
          }
          static bytes27(v) {
            return b(v, 27);
          }
          static bytes28(v) {
            return b(v, 28);
          }
          static bytes29(v) {
            return b(v, 29);
          }
          static bytes30(v) {
            return b(v, 30);
          }
          static bytes31(v) {
            return b(v, 31);
          }
          static bytes32(v) {
            return b(v, 32);
          }
          static address(v) {
            return new Typed(_gaurd, "address", v);
          }
          static bool(v) {
            return new Typed(_gaurd, "bool", !!v);
          }
          static bytes(v) {
            return new Typed(_gaurd, "bytes", v);
          }
          static string(v) {
            return new Typed(_gaurd, "string", v);
          }
          static array(v, dynamic) {
            throw new Error("not implemented yet");
          }
          static tuple(v, name) {
            throw new Error("not implemented yet");
          }
          static overrides(v) {
            return new Typed(_gaurd, "overrides", Object.assign({}, v));
          }
          static isTyped(value) {
            return (
              value &&
              typeof value === "object" &&
              "_typedSymbol" in value &&
              value._typedSymbol === _typedSymbol
            );
          }
          static dereference(value, type) {
            if (Typed.isTyped(value)) {
              if (value.type !== type) {
                throw new Error(
                  `invalid type: expecetd ${type}, got ${value.type}`
                );
              }
              return value.value;
            }
            return value;
          }
        }
        class AddressCoder extends Coder {
          constructor(localName) {
            super("address", "address", localName, false);
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000";
          }
          encode(writer, _value) {
            let value = Typed.dereference(_value, "string");
            try {
              value = getAddress(value);
            } catch (error) {
              return this._throwError(error.message, _value);
            }
            return writer.writeValue(value);
          }
          decode(reader) {
            return getAddress(toBeHex(reader.readValue(), 20));
          }
        }
        class AnonymousCoder extends Coder {
          coder;
          constructor(coder) {
            super(coder.name, coder.type, "_", coder.dynamic);
            this.coder = coder;
          }
          defaultValue() {
            return this.coder.defaultValue();
          }
          encode(writer, value) {
            return this.coder.encode(writer, value);
          }
          decode(reader) {
            return this.coder.decode(reader);
          }
        }
        function pack(writer, coders, values) {
          let arrayValues = [];
          if (Array.isArray(values)) {
            arrayValues = values;
          } else if (values && typeof values === "object") {
            let unique = {};
            arrayValues = coders.map((coder) => {
              const name = coder.localName;
              assert$1(
                name,
                "cannot encode object for signature with missing names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: coder }, value: values }
              );
              assert$1(
                !unique[name],
                "cannot encode object for signature with duplicate names",
                "INVALID_ARGUMENT",
                { argument: "values", info: { coder: coder }, value: values }
              );
              unique[name] = true;
              return values[name];
            });
          } else {
            assertArgument(false, "invalid tuple value", "tuple", values);
          }
          assertArgument(
            coders.length === arrayValues.length,
            "types/value length mismatch",
            "tuple",
            values
          );
          let staticWriter = new Writer();
          let dynamicWriter = new Writer();
          let updateFuncs = [];
          coders.forEach((coder, index) => {
            let value = arrayValues[index];
            if (coder.dynamic) {
              let dynamicOffset = dynamicWriter.length;
              coder.encode(dynamicWriter, value);
              let updateFunc = staticWriter.writeUpdatableValue();
              updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
              });
            } else {
              coder.encode(staticWriter, value);
            }
          });
          updateFuncs.forEach((func) => {
            func(staticWriter.length);
          });
          let length = writer.appendWriter(staticWriter);
          length += writer.appendWriter(dynamicWriter);
          return length;
        }
        function unpack(reader, coders) {
          let values = [];
          let keys = [];
          let baseReader = reader.subReader(0);
          coders.forEach((coder) => {
            let value = null;
            if (coder.dynamic) {
              let offset = reader.readIndex();
              let offsetReader = baseReader.subReader(offset);
              try {
                value = coder.decode(offsetReader);
              } catch (error) {
                if (isError(error, "BUFFER_OVERRUN")) {
                  throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
              }
            } else {
              try {
                value = coder.decode(reader);
              } catch (error) {
                if (isError(error, "BUFFER_OVERRUN")) {
                  throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
              }
            }
            if (value == undefined) {
              throw new Error("investigate");
            }
            values.push(value);
            keys.push(coder.localName || null);
          });
          return Result.fromItems(values, keys);
        }
        class ArrayCoder extends Coder {
          coder;
          length;
          constructor(coder, length, localName) {
            const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
            const dynamic = length === -1 || coder.dynamic;
            super("array", type, localName, dynamic);
            defineProperties(this, { coder: coder, length: length });
          }
          defaultValue() {
            const defaultChild = this.coder.defaultValue();
            const result = [];
            for (let i = 0; i < this.length; i++) {
              result.push(defaultChild);
            }
            return result;
          }
          encode(writer, _value) {
            const value = Typed.dereference(_value, "array");
            if (!Array.isArray(value)) {
              this._throwError("expected array value", value);
            }
            let count = this.length;
            if (count === -1) {
              count = value.length;
              writer.writeValue(value.length);
            }
            assertArgumentCount(
              value.length,
              count,
              "coder array" + (this.localName ? " " + this.localName : "")
            );
            let coders = [];
            for (let i = 0; i < value.length; i++) {
              coders.push(this.coder);
            }
            return pack(writer, coders, value);
          }
          decode(reader) {
            let count = this.length;
            if (count === -1) {
              count = reader.readIndex();
              assert$1(
                count * WordSize <= reader.dataLength,
                "insufficient data length",
                "BUFFER_OVERRUN",
                {
                  buffer: reader.bytes,
                  offset: count * WordSize,
                  length: reader.dataLength,
                }
              );
            }
            let coders = [];
            for (let i = 0; i < count; i++) {
              coders.push(new AnonymousCoder(this.coder));
            }
            return unpack(reader, coders);
          }
        }
        class BooleanCoder extends Coder {
          constructor(localName) {
            super("bool", "bool", localName, false);
          }
          defaultValue() {
            return false;
          }
          encode(writer, _value) {
            const value = Typed.dereference(_value, "bool");
            return writer.writeValue(value ? 1 : 0);
          }
          decode(reader) {
            return !!reader.readValue();
          }
        }
        class DynamicBytesCoder extends Coder {
          constructor(type, localName) {
            super(type, type, localName, true);
          }
          defaultValue() {
            return "0x";
          }
          encode(writer, value) {
            value = getBytesCopy(value);
            let length = writer.writeValue(value.length);
            length += writer.writeBytes(value);
            return length;
          }
          decode(reader) {
            return reader.readBytes(reader.readIndex(), true);
          }
        }
        class BytesCoder extends DynamicBytesCoder {
          constructor(localName) {
            super("bytes", localName);
          }
          decode(reader) {
            return hexlify(super.decode(reader));
          }
        }
        class FixedBytesCoder extends Coder {
          size;
          constructor(size, localName) {
            let name = "bytes" + String(size);
            super(name, name, localName, false);
            defineProperties(this, { size: size }, { size: "number" });
          }
          defaultValue() {
            return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(
              0,
              2 + this.size * 2
            );
          }
          encode(writer, _value) {
            let data = getBytesCopy(Typed.dereference(_value, this.type));
            if (data.length !== this.size) {
              this._throwError("incorrect data length", _value);
            }
            return writer.writeBytes(data);
          }
          decode(reader) {
            return hexlify(reader.readBytes(this.size));
          }
        }
        const Empty = new Uint8Array([]);
        class NullCoder extends Coder {
          constructor(localName) {
            super("null", "", localName, false);
          }
          defaultValue() {
            return null;
          }
          encode(writer, value) {
            if (value != null) {
              this._throwError("not null", value);
            }
            return writer.writeBytes(Empty);
          }
          decode(reader) {
            reader.readBytes(0);
            return null;
          }
        }
        const BN_0$5 = BigInt(0);
        const BN_1$2 = BigInt(1);
        const BN_MAX_UINT256$1 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        class NumberCoder extends Coder {
          size;
          signed;
          constructor(size, signed, localName) {
            const name = (signed ? "int" : "uint") + size * 8;
            super(name, name, localName, false);
            defineProperties(
              this,
              { size: size, signed: signed },
              { size: "number", signed: "boolean" }
            );
          }
          defaultValue() {
            return 0;
          }
          encode(writer, _value) {
            let value = getBigInt(Typed.dereference(_value, this.type));
            let maxUintValue = mask(BN_MAX_UINT256$1, WordSize * 8);
            if (this.signed) {
              let bounds = mask(maxUintValue, this.size * 8 - 1);
              if (value > bounds || value < -(bounds + BN_1$2)) {
                this._throwError("value out-of-bounds", _value);
              }
              value = toTwos(value, 8 * WordSize);
            } else if (
              value < BN_0$5 ||
              value > mask(maxUintValue, this.size * 8)
            ) {
              this._throwError("value out-of-bounds", _value);
            }
            return writer.writeValue(value);
          }
          decode(reader) {
            let value = mask(reader.readValue(), this.size * 8);
            if (this.signed) {
              value = fromTwos(value, this.size * 8);
            }
            return value;
          }
        }
        class StringCoder extends DynamicBytesCoder {
          constructor(localName) {
            super("string", localName);
          }
          defaultValue() {
            return "";
          }
          encode(writer, _value) {
            return super.encode(
              writer,
              toUtf8Bytes(Typed.dereference(_value, "string"))
            );
          }
          decode(reader) {
            return toUtf8String(super.decode(reader));
          }
        }
        class TupleCoder extends Coder {
          coders;
          constructor(coders, localName) {
            let dynamic = false;
            const types = [];
            coders.forEach((coder) => {
              if (coder.dynamic) {
                dynamic = true;
              }
              types.push(coder.type);
            });
            const type = "tuple(" + types.join(",") + ")";
            super("tuple", type, localName, dynamic);
            defineProperties(this, { coders: Object.freeze(coders.slice()) });
          }
          defaultValue() {
            const values = [];
            this.coders.forEach((coder) => {
              values.push(coder.defaultValue());
            });
            const uniqueNames = this.coders.reduce((accum, coder) => {
              const name = coder.localName;
              if (name) {
                if (!accum[name]) {
                  accum[name] = 0;
                }
                accum[name]++;
              }
              return accum;
            }, {});
            this.coders.forEach((coder, index) => {
              let name = coder.localName;
              if (!name || uniqueNames[name] !== 1) {
                return;
              }
              if (name === "length") {
                name = "_length";
              }
              if (values[name] != null) {
                return;
              }
              values[name] = values[index];
            });
            return Object.freeze(values);
          }
          encode(writer, _value) {
            const value = Typed.dereference(_value, "tuple");
            return pack(writer, this.coders, value);
          }
          decode(reader) {
            return unpack(reader, this.coders);
          }
        }
        function id(value) {
          return keccak256(toUtf8Bytes(value));
        }
        function decode_arithmetic(bytes) {
          let pos = 0;
          function u16() {
            return (bytes[pos++] << 8) | bytes[pos++];
          }
          let symbol_count = u16();
          let total = 1;
          let acc = [0, 1];
          for (let i = 1; i < symbol_count; i++) {
            acc.push((total += u16()));
          }
          let skip = u16();
          let pos_payload = pos;
          pos += skip;
          let read_width = 0;
          let read_buffer = 0;
          function read_bit() {
            if (read_width == 0) {
              read_buffer = (read_buffer << 8) | bytes[pos++];
              read_width = 8;
            }
            return (read_buffer >> --read_width) & 1;
          }
          const N = 31;
          const FULL = 2 ** N;
          const HALF = FULL >>> 1;
          const QRTR = HALF >> 1;
          const MASK = FULL - 1;
          let register = 0;
          for (let i = 0; i < N; i++) register = (register << 1) | read_bit();
          let symbols = [];
          let low = 0;
          let range = FULL;
          while (true) {
            let value = Math.floor(((register - low + 1) * total - 1) / range);
            let start = 0;
            let end = symbol_count;
            while (end - start > 1) {
              let mid = (start + end) >>> 1;
              if (value < acc[mid]) {
                end = mid;
              } else {
                start = mid;
              }
            }
            if (start == 0) break;
            symbols.push(start);
            let a = low + Math.floor((range * acc[start]) / total);
            let b = low + Math.floor((range * acc[start + 1]) / total) - 1;
            while (((a ^ b) & HALF) == 0) {
              register = ((register << 1) & MASK) | read_bit();
              a = (a << 1) & MASK;
              b = ((b << 1) & MASK) | 1;
            }
            while (a & ~b & QRTR) {
              register =
                (register & HALF) |
                ((register << 1) & (MASK >>> 1)) |
                read_bit();
              a = (a << 1) ^ HALF;
              b = ((b ^ HALF) << 1) | HALF | 1;
            }
            low = a;
            range = 1 + b - a;
          }
          let offset = symbol_count - 4;
          return symbols.map((x) => {
            switch (x - offset) {
              case 3:
                return (
                  offset +
                  65792 +
                  ((bytes[pos_payload++] << 16) |
                    (bytes[pos_payload++] << 8) |
                    bytes[pos_payload++])
                );
              case 2:
                return (
                  offset +
                  256 +
                  ((bytes[pos_payload++] << 8) | bytes[pos_payload++])
                );
              case 1:
                return offset + bytes[pos_payload++];
              default:
                return x - 1;
            }
          });
        }
        function read_payload(v) {
          let pos = 0;
          return () => v[pos++];
        }
        function read_compressed_payload(s) {
          return read_payload(decode_arithmetic(unsafe_atob(s)));
        }
        function unsafe_atob(s) {
          let lookup = [];
          [
            ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
          ].forEach((c, i) => (lookup[c.charCodeAt(0)] = i));
          let n = s.length;
          let ret = new Uint8Array((6 * n) >> 3);
          for (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
            carry = (carry << 6) | lookup[s.charCodeAt(i)];
            width += 6;
            if (width >= 8) {
              ret[pos++] = carry >> (width -= 8);
            }
          }
          return ret;
        }
        function signed(i) {
          return i & 1 ? ~i >> 1 : i >> 1;
        }
        function read_deltas(n, next) {
          let v = Array(n);
          for (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
          return v;
        }
        function read_sorted(next, prev = 0) {
          let ret = [];
          while (true) {
            let x = next();
            let n = next();
            if (!n) break;
            prev += x;
            for (let i = 0; i < n; i++) {
              ret.push(prev + i);
            }
            prev += n + 1;
          }
          return ret;
        }
        function read_sorted_arrays(next) {
          return read_array_while(() => {
            let v = read_sorted(next);
            if (v.length) return v;
          });
        }
        function read_mapped(next) {
          let ret = [];
          while (true) {
            let w = next();
            if (w == 0) break;
            ret.push(read_linear_table(w, next));
          }
          while (true) {
            let w = next() - 1;
            if (w < 0) break;
            ret.push(read_replacement_table(w, next));
          }
          return ret.flat();
        }
        function read_array_while(next) {
          let v = [];
          while (true) {
            let x = next(v.length);
            if (!x) break;
            v.push(x);
          }
          return v;
        }
        function read_transposed(n, w, next) {
          let m = Array(n)
            .fill()
            .map(() => []);
          for (let i = 0; i < w; i++) {
            read_deltas(n, next).forEach((x, j) => m[j].push(x));
          }
          return m;
        }
        function read_linear_table(w, next) {
          let dx = 1 + next();
          let dy = next();
          let vN = read_array_while(next);
          let m = read_transposed(vN.length, 1 + w, next);
          return m.flatMap((v, i) => {
            let [x, ...ys] = v;
            return Array(vN[i])
              .fill()
              .map((_, j) => {
                let j_dy = j * dy;
                return [x + j * dx, ys.map((y) => y + j_dy)];
              });
          });
        }
        function read_replacement_table(w, next) {
          let n = 1 + next();
          let m = read_transposed(n, 1 + w, next);
          return m.map((v) => [v[0], v.slice(1)]);
        }
        var r$1 = read_compressed_payload(
          "AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE"
        );
        const FENCED = new Map([
          [8217, "apostrophe"],
          [8260, "fraction slash"],
          [12539, "middle dot"],
        ]);
        const NSM_MAX = 4;
        function hex_cp(cp) {
          return cp.toString(16).toUpperCase().padStart(2, "0");
        }
        function quote_cp(cp) {
          return `{${hex_cp(cp)}}`;
        }
        function explode_cp(s) {
          let cps = [];
          for (let pos = 0, len = s.length; pos < len; ) {
            let cp = s.codePointAt(pos);
            pos += cp < 65536 ? 1 : 2;
            cps.push(cp);
          }
          return cps;
        }
        function str_from_cps(cps) {
          const chunk = 4096;
          let len = cps.length;
          if (len < chunk) return String.fromCodePoint(...cps);
          let buf = [];
          for (let i = 0; i < len; ) {
            buf.push(String.fromCodePoint(...cps.slice(i, (i += chunk))));
          }
          return buf.join("");
        }
        var r = read_compressed_payload(
          "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g"
        );
        function unpack_cc(packed) {
          return (packed >> 24) & 255;
        }
        function unpack_cp(packed) {
          return packed & 16777215;
        }
        const SHIFTED_RANK = new Map(
          read_sorted_arrays(r).flatMap((v, i) =>
            v.map((x) => [x, (i + 1) << 24])
          )
        );
        const EXCLUSIONS = new Set(read_sorted(r));
        const DECOMP = new Map();
        const RECOMP = new Map();
        for (let [cp, cps] of read_mapped(r)) {
          if (!EXCLUSIONS.has(cp) && cps.length == 2) {
            let [a, b] = cps;
            let bucket = RECOMP.get(a);
            if (!bucket) {
              bucket = new Map();
              RECOMP.set(a, bucket);
            }
            bucket.set(b, cp);
          }
          DECOMP.set(cp, cps.reverse());
        }
        const S0 = 44032;
        const L0 = 4352;
        const V0 = 4449;
        const T0 = 4519;
        const L_COUNT = 19;
        const V_COUNT = 21;
        const T_COUNT = 28;
        const N_COUNT = V_COUNT * T_COUNT;
        const S_COUNT = L_COUNT * N_COUNT;
        const S1 = S0 + S_COUNT;
        const L1 = L0 + L_COUNT;
        const V1 = V0 + V_COUNT;
        const T1$1 = T0 + T_COUNT;
        function is_hangul(cp) {
          return cp >= S0 && cp < S1;
        }
        function compose_pair(a, b) {
          if (a >= L0 && a < L1 && b >= V0 && b < V1) {
            return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
          } else if (
            is_hangul(a) &&
            b > T0 &&
            b < T1$1 &&
            (a - S0) % T_COUNT == 0
          ) {
            return a + (b - T0);
          } else {
            let recomp = RECOMP.get(a);
            if (recomp) {
              recomp = recomp.get(b);
              if (recomp) {
                return recomp;
              }
            }
            return -1;
          }
        }
        function decomposed(cps) {
          let ret = [];
          let buf = [];
          let check_order = false;
          function add(cp) {
            let cc = SHIFTED_RANK.get(cp);
            if (cc) {
              check_order = true;
              cp |= cc;
            }
            ret.push(cp);
          }
          for (let cp of cps) {
            while (true) {
              if (cp < 128) {
                ret.push(cp);
              } else if (is_hangul(cp)) {
                let s_index = cp - S0;
                let l_index = (s_index / N_COUNT) | 0;
                let v_index = ((s_index % N_COUNT) / T_COUNT) | 0;
                let t_index = s_index % T_COUNT;
                add(L0 + l_index);
                add(V0 + v_index);
                if (t_index > 0) add(T0 + t_index);
              } else {
                let mapped = DECOMP.get(cp);
                if (mapped) {
                  buf.push(...mapped);
                } else {
                  add(cp);
                }
              }
              if (!buf.length) break;
              cp = buf.pop();
            }
          }
          if (check_order && ret.length > 1) {
            let prev_cc = unpack_cc(ret[0]);
            for (let i = 1; i < ret.length; i++) {
              let cc = unpack_cc(ret[i]);
              if (cc == 0 || prev_cc <= cc) {
                prev_cc = cc;
                continue;
              }
              let j = i - 1;
              while (true) {
                let tmp = ret[j + 1];
                ret[j + 1] = ret[j];
                ret[j] = tmp;
                if (!j) break;
                prev_cc = unpack_cc(ret[--j]);
                if (prev_cc <= cc) break;
              }
              prev_cc = unpack_cc(ret[i]);
            }
          }
          return ret;
        }
        function composed_from_decomposed(v) {
          let ret = [];
          let stack = [];
          let prev_cp = -1;
          let prev_cc = 0;
          for (let packed of v) {
            let cc = unpack_cc(packed);
            let cp = unpack_cp(packed);
            if (prev_cp == -1) {
              if (cc == 0) {
                prev_cp = cp;
              } else {
                ret.push(cp);
              }
            } else if (prev_cc > 0 && prev_cc >= cc) {
              if (cc == 0) {
                ret.push(prev_cp, ...stack);
                stack.length = 0;
                prev_cp = cp;
              } else {
                stack.push(cp);
              }
              prev_cc = cc;
            } else {
              let composed = compose_pair(prev_cp, cp);
              if (composed >= 0) {
                prev_cp = composed;
              } else if (prev_cc == 0 && cc == 0) {
                ret.push(prev_cp);
                prev_cp = cp;
              } else {
                stack.push(cp);
                prev_cc = cc;
              }
            }
          }
          if (prev_cp >= 0) {
            ret.push(prev_cp, ...stack);
          }
          return ret;
        }
        function nfd(cps) {
          return decomposed(cps).map(unpack_cp);
        }
        function nfc(cps) {
          return composed_from_decomposed(decomposed(cps));
        }
        const FE0F = 65039;
        const STOP_CH = ".";
        const UNIQUE_PH = 1;
        const HYPHEN = 45;
        function read_set() {
          return new Set(read_sorted(r$1));
        }
        const MAPPED = new Map(read_mapped(r$1));
        const IGNORED = read_set();
        const CM = read_set();
        const NSM = new Set(
          read_sorted(r$1).map(
            function (i) {
              return this[i];
            },
            [...CM]
          )
        );
        const ESCAPE = read_set();
        read_set();
        const CHUNKS = read_sorted_arrays(r$1);
        function read_chunked() {
          return new Set(
            [read_sorted(r$1).map((i) => CHUNKS[i]), read_sorted(r$1)].flat(2)
          );
        }
        const UNRESTRICTED = r$1();
        const GROUPS = read_array_while((i) => {
          let N = read_array_while(r$1).map((x) => x + 96);
          if (N.length) {
            let R = i >= UNRESTRICTED;
            N[0] -= 32;
            N = str_from_cps(N);
            if (R) N = `Restricted[${N}]`;
            let P = read_chunked();
            let Q = read_chunked();
            let V = [...P, ...Q].sort((a, b) => a - b);
            let M = !r$1();
            return { N: N, P: P, M: M, R: R, V: new Set(V) };
          }
        });
        const WHOLE_VALID = read_set();
        const WHOLE_MAP = new Map();
        [...WHOLE_VALID, ...read_set()]
          .sort((a, b) => a - b)
          .map((cp, i, v) => {
            let d = r$1();
            let w = (v[i] = d ? v[i - d] : { V: [], M: new Map() });
            w.V.push(cp);
            if (!WHOLE_VALID.has(cp)) {
              WHOLE_MAP.set(cp, w);
            }
          });
        for (let { V, M } of new Set(WHOLE_MAP.values())) {
          let recs = [];
          for (let cp of V) {
            let gs = GROUPS.filter((g) => g.V.has(cp));
            let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
            if (!rec) {
              rec = { G: new Set(), V: [] };
              recs.push(rec);
            }
            rec.V.push(cp);
            gs.forEach((g) => rec.G.add(g));
          }
          let union = recs.flatMap(({ G }) => [...G]);
          for (let { G, V } of recs) {
            let complement = new Set(union.filter((g) => !G.has(g)));
            for (let cp of V) {
              M.set(cp, complement);
            }
          }
        }
        let union = new Set();
        let multi = new Set();
        for (let g of GROUPS) {
          for (let cp of g.V) {
            (union.has(cp) ? multi : union).add(cp);
          }
        }
        for (let cp of union) {
          if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
            WHOLE_MAP.set(cp, UNIQUE_PH);
          }
        }
        const VALID = new Set([...union, ...nfd(union)]);
        const EMOJI_SORTED = read_sorted(r$1);
        const EMOJI_ROOT = read_emoji_trie([]);
        function read_emoji_trie(cps) {
          let B = read_array_while(() => {
            let keys = read_sorted(r$1).map((i) => EMOJI_SORTED[i]);
            if (keys.length) return read_emoji_trie(keys);
          }).sort((a, b) => b.Q.size - a.Q.size);
          let temp = r$1();
          let V = temp % 3;
          temp = (temp / 3) | 0;
          let F = temp & 1;
          temp >>= 1;
          let S = temp & 1;
          let C = temp & 2;
          return { B: B, V: V, F: F, S: S, C: C, Q: new Set(cps) };
        }
        class Emoji extends Array {
          get is_emoji() {
            return true;
          }
        }
        function safe_str_from_cps(cps, quoter = quote_cp) {
          let buf = [];
          if (is_combining_mark(cps[0])) buf.push("");
          let prev = 0;
          let n = cps.length;
          for (let i = 0; i < n; i++) {
            let cp = cps[i];
            if (should_escape(cp)) {
              buf.push(str_from_cps(cps.slice(prev, i)));
              buf.push(quoter(cp));
              prev = i + 1;
            }
          }
          buf.push(str_from_cps(cps.slice(prev, n)));
          return buf.join("");
        }
        function quoted_cp(cp) {
          return (
            (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) +
            quote_cp(cp)
          );
        }
        function bidi_qq(s) {
          return `"${s}"\u200E`;
        }
        function check_label_extension(cps) {
          if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
            throw new Error("invalid label extension");
          }
        }
        function check_leading_underscore(cps) {
          const UNDERSCORE = 95;
          for (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {
            if (cps[--i] !== UNDERSCORE) {
              throw new Error("underscore allowed only at start");
            }
          }
        }
        function check_fenced(cps) {
          let cp = cps[0];
          let prev = FENCED.get(cp);
          if (prev) throw error_placement(`leading ${prev}`);
          let n = cps.length;
          let last = -1;
          for (let i = 1; i < n; i++) {
            cp = cps[i];
            let match = FENCED.get(cp);
            if (match) {
              if (last == i) throw error_placement(`${prev} + ${match}`);
              last = i + 1;
              prev = match;
            }
          }
          if (last == n) throw error_placement(`trailing ${prev}`);
        }
        function is_combining_mark(cp) {
          return CM.has(cp);
        }
        function should_escape(cp) {
          return ESCAPE.has(cp);
        }
        function ens_normalize(name) {
          return flatten(ens_split(name));
        }
        function ens_split(name, preserve_emoji) {
          let offset = 0;
          return name.split(STOP_CH).map((label) => {
            let input = explode_cp(label);
            let info = { input: input, offset: offset };
            offset += input.length + 1;
            let norm;
            try {
              let tokens = (info.tokens = process(input, nfc));
              let token_count = tokens.length;
              let type;
              if (!token_count) {
                throw new Error(`empty label`);
              } else {
                let chars = tokens[0];
                let emoji = token_count > 1 || chars.is_emoji;
                if (!emoji && chars.every((cp) => cp < 128)) {
                  norm = chars;
                  check_leading_underscore(norm);
                  check_label_extension(norm);
                  type = "ASCII";
                } else {
                  if (emoji) {
                    info.emoji = true;
                    chars = tokens.flatMap((x) => (x.is_emoji ? [] : x));
                  }
                  norm = tokens.flatMap((x) =>
                    !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x
                  );
                  check_leading_underscore(norm);
                  if (!chars.length) {
                    type = "Emoji";
                  } else {
                    if (CM.has(norm[0]))
                      throw error_placement("leading combining mark");
                    for (let i = 1; i < token_count; i++) {
                      let cps = tokens[i];
                      if (!cps.is_emoji && CM.has(cps[0])) {
                        throw error_placement(
                          `emoji + combining mark: "${str_from_cps(
                            tokens[i - 1]
                          )} + ${safe_str_from_cps([cps[0]])}"`
                        );
                      }
                    }
                    check_fenced(norm);
                    let unique = [...new Set(chars)];
                    let [g] = determine_group(unique);
                    check_group(g, chars);
                    check_whole(g, unique);
                    type = g.N;
                  }
                }
              }
              info.type = type;
            } catch (err) {
              info.error = err;
            }
            info.output = norm;
            return info;
          });
        }
        function check_whole(group, unique) {
          let maker;
          let shared = [];
          for (let cp of unique) {
            let whole = WHOLE_MAP.get(cp);
            if (whole === UNIQUE_PH) return;
            if (whole) {
              let set = whole.M.get(cp);
              maker = maker ? maker.filter((g) => set.has(g)) : [...set];
              if (!maker.length) return;
            } else {
              shared.push(cp);
            }
          }
          if (maker) {
            for (let g of maker) {
              if (shared.every((cp) => g.V.has(cp))) {
                throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
              }
            }
          }
        }
        function determine_group(unique) {
          let groups = GROUPS;
          for (let cp of unique) {
            let gs = groups.filter((g) => g.V.has(cp));
            if (!gs.length) {
              if (groups === GROUPS) {
                throw error_disallowed(cp);
              } else {
                throw error_group_member(groups[0], cp);
              }
            }
            groups = gs;
            if (gs.length == 1) break;
          }
          return groups;
        }
        function flatten(split) {
          return split
            .map(({ input, error, output }) => {
              if (error) {
                let msg = error.message;
                throw new Error(
                  split.length == 1
                    ? msg
                    : `Invalid label ${bidi_qq(
                        safe_str_from_cps(input)
                      )}: ${msg}`
                );
              }
              return str_from_cps(output);
            })
            .join(STOP_CH);
        }
        function error_disallowed(cp) {
          return new Error(`disallowed character: ${quoted_cp(cp)}`);
        }
        function error_group_member(g, cp) {
          let quoted = quoted_cp(cp);
          let gg = GROUPS.find((g) => g.P.has(cp));
          if (gg) {
            quoted = `${gg.N} ${quoted}`;
          }
          return new Error(`illegal mixture: ${g.N} + ${quoted}`);
        }
        function error_placement(where) {
          return new Error(`illegal placement: ${where}`);
        }
        function check_group(g, cps) {
          let { V, M } = g;
          for (let cp of cps) {
            if (!V.has(cp)) {
              throw error_group_member(g, cp);
            }
          }
          if (M) {
            let decomposed = nfd(cps);
            for (let i = 1, e = decomposed.length; i < e; i++) {
              if (NSM.has(decomposed[i])) {
                let j = i + 1;
                for (let cp; j < e && NSM.has((cp = decomposed[j])); j++) {
                  for (let k = i; k < j; k++) {
                    if (decomposed[k] == cp) {
                      throw new Error(
                        `non-spacing marks: repeated ${quoted_cp(cp)}`
                      );
                    }
                  }
                }
                if (j - i > NSM_MAX) {
                  throw new Error(
                    `non-spacing marks: too many ${bidi_qq(
                      safe_str_from_cps(decomposed.slice(i - 1, j))
                    )} (${j - i}/${NSM_MAX})`
                  );
                }
                i = j;
              }
            }
          }
        }
        function process(input, nf) {
          let ret = [];
          let chars = [];
          input = input.slice().reverse();
          while (input.length) {
            let emoji = consume_emoji_reversed(input);
            if (emoji) {
              if (chars.length) {
                ret.push(nf(chars));
                chars = [];
              }
              ret.push(emoji);
            } else {
              let cp = input.pop();
              if (VALID.has(cp)) {
                chars.push(cp);
              } else {
                let cps = MAPPED.get(cp);
                if (cps) {
                  chars.push(...cps);
                } else if (!IGNORED.has(cp)) {
                  throw error_disallowed(cp);
                }
              }
            }
          }
          if (chars.length) {
            ret.push(nf(chars));
          }
          return ret;
        }
        function filter_fe0f(cps) {
          return cps.filter((cp) => cp != FE0F);
        }
        function consume_emoji_reversed(cps, eaten) {
          let node = EMOJI_ROOT;
          let emoji;
          let saved;
          let stack = [];
          let pos = cps.length;
          if (eaten) eaten.length = 0;
          while (pos) {
            let cp = cps[--pos];
            node = node.B.find((x) => x.Q.has(cp));
            if (!node) break;
            if (node.S) {
              saved = cp;
            } else if (node.C) {
              if (cp === saved) break;
            }
            stack.push(cp);
            if (node.F) {
              stack.push(FE0F);
              if (pos > 0 && cps[pos - 1] == FE0F) pos--;
            }
            if (node.V) {
              emoji = conform_emoji_copy(stack, node);
              if (eaten) eaten.push(...cps.slice(pos).reverse());
              cps.length = pos;
            }
          }
          return emoji;
        }
        function conform_emoji_copy(cps, node) {
          let copy = Emoji.from(cps);
          if (node.V == 2) copy.splice(1, 1);
          return copy;
        }
        const Zeros = new Uint8Array(32);
        Zeros.fill(0);
        function checkComponent(comp) {
          assertArgument(
            comp.length !== 0,
            "invalid ENS name; empty component",
            "comp",
            comp
          );
          return comp;
        }
        function ensNameSplit(name) {
          const bytes = toUtf8Bytes(ensNormalize(name));
          const comps = [];
          if (name.length === 0) {
            return comps;
          }
          let last = 0;
          for (let i = 0; i < bytes.length; i++) {
            const d = bytes[i];
            if (d === 46) {
              comps.push(checkComponent(bytes.slice(last, i)));
              last = i + 1;
            }
          }
          assertArgument(
            last < bytes.length,
            "invalid ENS name; empty component",
            "name",
            name
          );
          comps.push(checkComponent(bytes.slice(last)));
          return comps;
        }
        function ensNormalize(name) {
          try {
            return ens_normalize(name);
          } catch (error) {
            assertArgument(
              false,
              `invalid ENS name (${error.message})`,
              "name",
              name
            );
          }
        }
        function isValidName(name) {
          try {
            return ensNameSplit(name).length !== 0;
          } catch (error) {}
          return false;
        }
        function namehash(name) {
          assertArgument(
            typeof name === "string",
            "invalid ENS name; not a string",
            "name",
            name
          );
          let result = Zeros;
          const comps = ensNameSplit(name);
          while (comps.length) {
            result = keccak256(concat([result, keccak256(comps.pop())]));
          }
          return hexlify(result);
        }
        function dnsEncode(name) {
          return (
            hexlify(
              concat(
                ensNameSplit(name).map((comp) => {
                  if (comp.length > 63) {
                    throw new Error(
                      "invalid DNS encoded entry; length exceeds 63 bytes"
                    );
                  }
                  const bytes = new Uint8Array(comp.length + 1);
                  bytes.set(comp, 1);
                  bytes[0] = bytes.length - 1;
                  return bytes;
                })
              )
            ) + "00"
          );
        }
        function accessSetify(addr, storageKeys) {
          return {
            address: getAddress(addr),
            storageKeys: storageKeys.map((storageKey, index) => {
              assertArgument(
                isHexString(storageKey, 32),
                "invalid slot",
                `storageKeys[${index}]`,
                storageKey
              );
              return storageKey.toLowerCase();
            }),
          };
        }
        function accessListify(value) {
          if (Array.isArray(value)) {
            return value.map((set, index) => {
              if (Array.isArray(set)) {
                assertArgument(
                  set.length === 2,
                  "invalid slot set",
                  `value[${index}]`,
                  set
                );
                return accessSetify(set[0], set[1]);
              }
              assertArgument(
                set != null && typeof set === "object",
                "invalid address-slot set",
                "value",
                value
              );
              return accessSetify(set.address, set.storageKeys);
            });
          }
          assertArgument(
            value != null && typeof value === "object",
            "invalid access list",
            "value",
            value
          );
          const result = Object.keys(value).map((addr) => {
            const storageKeys = value[addr].reduce((accum, storageKey) => {
              accum[storageKey] = true;
              return accum;
            }, {});
            return accessSetify(addr, Object.keys(storageKeys).sort());
          });
          result.sort((a, b) => a.address.localeCompare(b.address));
          return result;
        }
        function computeAddress(key) {
          let pubkey;
          if (typeof key === "string") {
            pubkey = SigningKey.computePublicKey(key, false);
          } else {
            pubkey = key.publicKey;
          }
          return getAddress(
            keccak256("0x" + pubkey.substring(4)).substring(26)
          );
        }
        function recoverAddress(digest, signature) {
          return computeAddress(SigningKey.recoverPublicKey(digest, signature));
        }
        const BN_0$4 = BigInt(0);
        const BN_2$2 = BigInt(2);
        const BN_27 = BigInt(27);
        const BN_28 = BigInt(28);
        const BN_35 = BigInt(35);
        const BN_MAX_UINT = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        function handleAddress(value) {
          if (value === "0x") {
            return null;
          }
          return getAddress(value);
        }
        function handleAccessList(value, param) {
          try {
            return accessListify(value);
          } catch (error) {
            assertArgument(false, error.message, param, value);
          }
        }
        function handleNumber(_value, param) {
          if (_value === "0x") {
            return 0;
          }
          return getNumber(_value, param);
        }
        function handleUint(_value, param) {
          if (_value === "0x") {
            return BN_0$4;
          }
          const value = getBigInt(_value, param);
          assertArgument(
            value <= BN_MAX_UINT,
            "value exceeds uint size",
            param,
            value
          );
          return value;
        }
        function formatNumber(_value, name) {
          const value = getBigInt(_value, "value");
          const result = toBeArray(value);
          assertArgument(
            result.length <= 32,
            `value too large`,
            `tx.${name}`,
            value
          );
          return result;
        }
        function formatAccessList(value) {
          return accessListify(value).map((set) => [
            set.address,
            set.storageKeys,
          ]);
        }
        function _parseLegacy(data) {
          const fields = decodeRlp(data);
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 9 || fields.length === 6),
            "invalid field count for legacy transaction",
            "data",
            data
          );
          const tx = {
            type: 0,
            nonce: handleNumber(fields[0], "nonce"),
            gasPrice: handleUint(fields[1], "gasPrice"),
            gasLimit: handleUint(fields[2], "gasLimit"),
            to: handleAddress(fields[3]),
            value: handleUint(fields[4], "value"),
            data: hexlify(fields[5]),
            chainId: BN_0$4,
          };
          if (fields.length === 6) {
            return tx;
          }
          const v = handleUint(fields[6], "v");
          const r = handleUint(fields[7], "r");
          const s = handleUint(fields[8], "s");
          if (r === BN_0$4 && s === BN_0$4) {
            tx.chainId = v;
          } else {
            let chainId = (v - BN_35) / BN_2$2;
            if (chainId < BN_0$4) {
              chainId = BN_0$4;
            }
            tx.chainId = chainId;
            assertArgument(
              chainId !== BN_0$4 || v === BN_27 || v === BN_28,
              "non-canonical legacy v",
              "v",
              fields[6]
            );
            tx.signature = Signature.from({
              r: zeroPadValue(fields[7], 32),
              s: zeroPadValue(fields[8], 32),
              v: v,
            });
            tx.hash = keccak256(data);
          }
          return tx;
        }
        function _serializeLegacy(tx, sig) {
          const fields = [
            formatNumber(tx.nonce || 0, "nonce"),
            formatNumber(tx.gasPrice || 0, "gasPrice"),
            formatNumber(tx.gasLimit || 0, "gasLimit"),
            tx.to != null ? getAddress(tx.to) : "0x",
            formatNumber(tx.value || 0, "value"),
            tx.data || "0x",
          ];
          let chainId = BN_0$4;
          if (tx.chainId != BN_0$4) {
            chainId = getBigInt(tx.chainId, "tx.chainId");
            assertArgument(
              !sig || sig.networkV == null || sig.legacyChainId === chainId,
              "tx.chainId/sig.v mismatch",
              "sig",
              sig
            );
          } else if (tx.signature) {
            const legacy = tx.signature.legacyChainId;
            if (legacy != null) {
              chainId = legacy;
            }
          }
          if (!sig) {
            if (chainId !== BN_0$4) {
              fields.push(toBeArray(chainId));
              fields.push("0x");
              fields.push("0x");
            }
            return encodeRlp(fields);
          }
          let v = BigInt(27 + sig.yParity);
          if (chainId !== BN_0$4) {
            v = Signature.getChainIdV(chainId, sig.v);
          } else if (BigInt(sig.v) !== v) {
            assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
          }
          fields.push(toBeArray(v));
          fields.push(toBeArray(sig.r));
          fields.push(toBeArray(sig.s));
          return encodeRlp(fields);
        }
        function _parseEipSignature(tx, fields) {
          let yParity;
          try {
            yParity = handleNumber(fields[0], "yParity");
            if (yParity !== 0 && yParity !== 1) {
              throw new Error("bad yParity");
            }
          } catch (error) {
            assertArgument(false, "invalid yParity", "yParity", fields[0]);
          }
          const r = zeroPadValue(fields[1], 32);
          const s = zeroPadValue(fields[2], 32);
          const signature = Signature.from({ r: r, s: s, yParity: yParity });
          tx.signature = signature;
        }
        function _parseEip1559(data) {
          const fields = decodeRlp(getBytes(data).slice(1));
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 9 || fields.length === 12),
            "invalid field count for transaction type: 2",
            "data",
            hexlify(data)
          );
          const maxPriorityFeePerGas = handleUint(
            fields[2],
            "maxPriorityFeePerGas"
          );
          const maxFeePerGas = handleUint(fields[3], "maxFeePerGas");
          const tx = {
            type: 2,
            chainId: handleUint(fields[0], "chainId"),
            nonce: handleNumber(fields[1], "nonce"),
            maxPriorityFeePerGas: maxPriorityFeePerGas,
            maxFeePerGas: maxFeePerGas,
            gasPrice: null,
            gasLimit: handleUint(fields[4], "gasLimit"),
            to: handleAddress(fields[5]),
            value: handleUint(fields[6], "value"),
            data: hexlify(fields[7]),
            accessList: handleAccessList(fields[8], "accessList"),
          };
          if (fields.length === 9) {
            return tx;
          }
          tx.hash = keccak256(data);
          _parseEipSignature(tx, fields.slice(9));
          return tx;
        }
        function _serializeEip1559(tx, sig) {
          const fields = [
            formatNumber(tx.chainId || 0, "chainId"),
            formatNumber(tx.nonce || 0, "nonce"),
            formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
            formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
            formatNumber(tx.gasLimit || 0, "gasLimit"),
            tx.to != null ? getAddress(tx.to) : "0x",
            formatNumber(tx.value || 0, "value"),
            tx.data || "0x",
            formatAccessList(tx.accessList || []),
          ];
          if (sig) {
            fields.push(formatNumber(sig.yParity, "yParity"));
            fields.push(toBeArray(sig.r));
            fields.push(toBeArray(sig.s));
          }
          return concat(["0x02", encodeRlp(fields)]);
        }
        function _parseEip2930(data) {
          const fields = decodeRlp(getBytes(data).slice(1));
          assertArgument(
            Array.isArray(fields) &&
              (fields.length === 8 || fields.length === 11),
            "invalid field count for transaction type: 1",
            "data",
            hexlify(data)
          );
          const tx = {
            type: 1,
            chainId: handleUint(fields[0], "chainId"),
            nonce: handleNumber(fields[1], "nonce"),
            gasPrice: handleUint(fields[2], "gasPrice"),
            gasLimit: handleUint(fields[3], "gasLimit"),
            to: handleAddress(fields[4]),
            value: handleUint(fields[5], "value"),
            data: hexlify(fields[6]),
            accessList: handleAccessList(fields[7], "accessList"),
          };
          if (fields.length === 8) {
            return tx;
          }
          tx.hash = keccak256(data);
          _parseEipSignature(tx, fields.slice(8));
          return tx;
        }
        function _serializeEip2930(tx, sig) {
          const fields = [
            formatNumber(tx.chainId || 0, "chainId"),
            formatNumber(tx.nonce || 0, "nonce"),
            formatNumber(tx.gasPrice || 0, "gasPrice"),
            formatNumber(tx.gasLimit || 0, "gasLimit"),
            tx.to != null ? getAddress(tx.to) : "0x",
            formatNumber(tx.value || 0, "value"),
            tx.data || "0x",
            formatAccessList(tx.accessList || []),
          ];
          if (sig) {
            fields.push(formatNumber(sig.yParity, "recoveryParam"));
            fields.push(toBeArray(sig.r));
            fields.push(toBeArray(sig.s));
          }
          return concat(["0x01", encodeRlp(fields)]);
        }
        class Transaction {
          #type;
          #to;
          #data;
          #nonce;
          #gasLimit;
          #gasPrice;
          #maxPriorityFeePerGas;
          #maxFeePerGas;
          #value;
          #chainId;
          #sig;
          #accessList;
          get type() {
            return this.#type;
          }
          set type(value) {
            switch (value) {
              case null:
                this.#type = null;
                break;
              case 0:
              case "legacy":
                this.#type = 0;
                break;
              case 1:
              case "berlin":
              case "eip-2930":
                this.#type = 1;
                break;
              case 2:
              case "london":
              case "eip-1559":
                this.#type = 2;
                break;
              default:
                assertArgument(
                  false,
                  "unsupported transaction type",
                  "type",
                  value
                );
            }
          }
          get typeName() {
            switch (this.type) {
              case 0:
                return "legacy";
              case 1:
                return "eip-2930";
              case 2:
                return "eip-1559";
            }
            return null;
          }
          get to() {
            return this.#to;
          }
          set to(value) {
            this.#to = value == null ? null : getAddress(value);
          }
          get nonce() {
            return this.#nonce;
          }
          set nonce(value) {
            this.#nonce = getNumber(value, "value");
          }
          get gasLimit() {
            return this.#gasLimit;
          }
          set gasLimit(value) {
            this.#gasLimit = getBigInt(value);
          }
          get gasPrice() {
            const value = this.#gasPrice;
            if (value == null && (this.type === 0 || this.type === 1)) {
              return BN_0$4;
            }
            return value;
          }
          set gasPrice(value) {
            this.#gasPrice =
              value == null ? null : getBigInt(value, "gasPrice");
          }
          get maxPriorityFeePerGas() {
            const value = this.#maxPriorityFeePerGas;
            if (value == null) {
              if (this.type === 2) {
                return BN_0$4;
              }
              return null;
            }
            return value;
          }
          set maxPriorityFeePerGas(value) {
            this.#maxPriorityFeePerGas =
              value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
          }
          get maxFeePerGas() {
            const value = this.#maxFeePerGas;
            if (value == null) {
              if (this.type === 2) {
                return BN_0$4;
              }
              return null;
            }
            return value;
          }
          set maxFeePerGas(value) {
            this.#maxFeePerGas =
              value == null ? null : getBigInt(value, "maxFeePerGas");
          }
          get data() {
            return this.#data;
          }
          set data(value) {
            this.#data = hexlify(value);
          }
          get value() {
            return this.#value;
          }
          set value(value) {
            this.#value = getBigInt(value, "value");
          }
          get chainId() {
            return this.#chainId;
          }
          set chainId(value) {
            this.#chainId = getBigInt(value);
          }
          get signature() {
            return this.#sig || null;
          }
          set signature(value) {
            this.#sig = value == null ? null : Signature.from(value);
          }
          get accessList() {
            const value = this.#accessList || null;
            if (value == null) {
              if (this.type === 1 || this.type === 2) {
                return [];
              }
              return null;
            }
            return value;
          }
          set accessList(value) {
            this.#accessList = value == null ? null : accessListify(value);
          }
          constructor() {
            this.#type = null;
            this.#to = null;
            this.#nonce = 0;
            this.#gasLimit = BigInt(0);
            this.#gasPrice = null;
            this.#maxPriorityFeePerGas = null;
            this.#maxFeePerGas = null;
            this.#data = "0x";
            this.#value = BigInt(0);
            this.#chainId = BigInt(0);
            this.#sig = null;
            this.#accessList = null;
          }
          get hash() {
            if (this.signature == null) {
              return null;
            }
            return keccak256(this.serialized);
          }
          get unsignedHash() {
            return keccak256(this.unsignedSerialized);
          }
          get from() {
            if (this.signature == null) {
              return null;
            }
            return recoverAddress(this.unsignedHash, this.signature);
          }
          get fromPublicKey() {
            if (this.signature == null) {
              return null;
            }
            return SigningKey.recoverPublicKey(
              this.unsignedHash,
              this.signature
            );
          }
          isSigned() {
            return this.signature != null;
          }
          get serialized() {
            assert$1(
              this.signature != null,
              "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            );
            switch (this.inferType()) {
              case 0:
                return _serializeLegacy(this, this.signature);
              case 1:
                return _serializeEip2930(this, this.signature);
              case 2:
                return _serializeEip1559(this, this.signature);
            }
            assert$1(
              false,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: ".serialized" }
            );
          }
          get unsignedSerialized() {
            switch (this.inferType()) {
              case 0:
                return _serializeLegacy(this);
              case 1:
                return _serializeEip2930(this);
              case 2:
                return _serializeEip1559(this);
            }
            assert$1(
              false,
              "unsupported transaction type",
              "UNSUPPORTED_OPERATION",
              { operation: ".unsignedSerialized" }
            );
          }
          inferType() {
            return this.inferTypes().pop();
          }
          inferTypes() {
            const hasGasPrice = this.gasPrice != null;
            const hasFee =
              this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
            const hasAccessList = this.accessList != null;
            if (
              this.maxFeePerGas != null &&
              this.maxPriorityFeePerGas != null
            ) {
              assert$1(
                this.maxFeePerGas >= this.maxPriorityFeePerGas,
                "priorityFee cannot be more than maxFee",
                "BAD_DATA",
                { value: this }
              );
            }
            assert$1(
              !hasFee || (this.type !== 0 && this.type !== 1),
              "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas",
              "BAD_DATA",
              { value: this }
            );
            assert$1(
              this.type !== 0 || !hasAccessList,
              "legacy transaction cannot have accessList",
              "BAD_DATA",
              { value: this }
            );
            const types = [];
            if (this.type != null) {
              types.push(this.type);
            } else {
              if (hasFee) {
                types.push(2);
              } else if (hasGasPrice) {
                types.push(1);
                if (!hasAccessList) {
                  types.push(0);
                }
              } else if (hasAccessList) {
                types.push(1);
                types.push(2);
              } else {
                types.push(0);
                types.push(1);
                types.push(2);
              }
            }
            types.sort();
            return types;
          }
          isLegacy() {
            return this.type === 0;
          }
          isBerlin() {
            return this.type === 1;
          }
          isLondon() {
            return this.type === 2;
          }
          clone() {
            return Transaction.from(this);
          }
          toJSON() {
            const s = (v) => {
              if (v == null) {
                return null;
              }
              return v.toString();
            };
            return {
              type: this.type,
              to: this.to,
              data: this.data,
              nonce: this.nonce,
              gasLimit: s(this.gasLimit),
              gasPrice: s(this.gasPrice),
              maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
              maxFeePerGas: s(this.maxFeePerGas),
              value: s(this.value),
              chainId: s(this.chainId),
              sig: this.signature ? this.signature.toJSON() : null,
              accessList: this.accessList,
            };
          }
          static from(tx) {
            if (tx == null) {
              return new Transaction();
            }
            if (typeof tx === "string") {
              const payload = getBytes(tx);
              if (payload[0] >= 127) {
                return Transaction.from(_parseLegacy(payload));
              }
              switch (payload[0]) {
                case 1:
                  return Transaction.from(_parseEip2930(payload));
                case 2:
                  return Transaction.from(_parseEip1559(payload));
              }
              assert$1(
                false,
                "unsupported transaction type",
                "UNSUPPORTED_OPERATION",
                { operation: "from" }
              );
            }
            const result = new Transaction();
            if (tx.type != null) {
              result.type = tx.type;
            }
            if (tx.to != null) {
              result.to = tx.to;
            }
            if (tx.nonce != null) {
              result.nonce = tx.nonce;
            }
            if (tx.gasLimit != null) {
              result.gasLimit = tx.gasLimit;
            }
            if (tx.gasPrice != null) {
              result.gasPrice = tx.gasPrice;
            }
            if (tx.maxPriorityFeePerGas != null) {
              result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
            }
            if (tx.maxFeePerGas != null) {
              result.maxFeePerGas = tx.maxFeePerGas;
            }
            if (tx.data != null) {
              result.data = tx.data;
            }
            if (tx.value != null) {
              result.value = tx.value;
            }
            if (tx.chainId != null) {
              result.chainId = tx.chainId;
            }
            if (tx.signature != null) {
              result.signature = Signature.from(tx.signature);
            }
            if (tx.accessList != null) {
              result.accessList = tx.accessList;
            }
            if (tx.hash != null) {
              assertArgument(
                result.isSigned(),
                "unsigned transaction cannot define hash",
                "tx",
                tx
              );
              assertArgument(
                result.hash === tx.hash,
                "hash mismatch",
                "tx",
                tx
              );
            }
            if (tx.from != null) {
              assertArgument(
                result.isSigned(),
                "unsigned transaction cannot define from",
                "tx",
                tx
              );
              assertArgument(
                result.from.toLowerCase() === (tx.from || "").toLowerCase(),
                "from mismatch",
                "tx",
                tx
              );
            }
            return result;
          }
        }
        function hashMessage(message) {
          if (typeof message === "string") {
            message = toUtf8Bytes(message);
          }
          return keccak256(
            concat([
              toUtf8Bytes(MessagePrefix),
              toUtf8Bytes(String(message.length)),
              message,
            ])
          );
        }
        function verifyMessage(message, sig) {
          const digest = hashMessage(message);
          return recoverAddress(digest, sig);
        }
        const regexBytes = new RegExp("^bytes([0-9]+)$");
        const regexNumber = new RegExp("^(u?int)([0-9]*)$");
        const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
        function _pack(type, value, isArray) {
          switch (type) {
            case "address":
              if (isArray) {
                return getBytes(zeroPadValue(value, 32));
              }
              return getBytes(getAddress(value));
            case "string":
              return toUtf8Bytes(value);
            case "bytes":
              return getBytes(value);
            case "bool":
              value = !!value ? "0x01" : "0x00";
              if (isArray) {
                return getBytes(zeroPadValue(value, 32));
              }
              return getBytes(value);
          }
          let match = type.match(regexNumber);
          if (match) {
            let signed = match[1] === "int";
            let size = parseInt(match[2] || "256");
            assertArgument(
              (!match[2] || match[2] === String(size)) &&
                size % 8 === 0 &&
                size !== 0 &&
                size <= 256,
              "invalid number type",
              "type",
              type
            );
            if (isArray) {
              size = 256;
            }
            if (signed) {
              value = toTwos(value, size);
            }
            return getBytes(zeroPadValue(toBeArray(value), size / 8));
          }
          match = type.match(regexBytes);
          if (match) {
            const size = parseInt(match[1]);
            assertArgument(
              String(size) === match[1] && size !== 0 && size <= 32,
              "invalid bytes type",
              "type",
              type
            );
            assertArgument(
              dataLength(value) === size,
              `invalid value for ${type}`,
              "value",
              value
            );
            if (isArray) {
              return getBytes(zeroPadBytes(value, 32));
            }
            return value;
          }
          match = type.match(regexArray);
          if (match && Array.isArray(value)) {
            const baseType = match[1];
            const count = parseInt(match[2] || String(value.length));
            assertArgument(
              count === value.length,
              `invalid array length for ${type}`,
              "value",
              value
            );
            const result = [];
            value.forEach(function (value) {
              result.push(_pack(baseType, value, true));
            });
            return getBytes(concat(result));
          }
          assertArgument(false, "invalid type", "type", type);
        }
        function solidityPacked(types, values) {
          assertArgument(
            types.length === values.length,
            "wrong number of values; expected ${ types.length }",
            "values",
            values
          );
          const tight = [];
          types.forEach(function (type, index) {
            tight.push(_pack(type, values[index]));
          });
          return hexlify(concat(tight));
        }
        function solidityPackedKeccak256(types, values) {
          return keccak256(solidityPacked(types, values));
        }
        function solidityPackedSha256(types, values) {
          return sha256(solidityPacked(types, values));
        }
        const padding = new Uint8Array(32);
        padding.fill(0);
        const BN__1 = BigInt(-1);
        const BN_0$3 = BigInt(0);
        const BN_1$1 = BigInt(1);
        const BN_MAX_UINT256 = BigInt(
          "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
        );
        function hexPadRight(value) {
          const bytes = getBytes(value);
          const padOffset = bytes.length % 32;
          if (padOffset) {
            return concat([bytes, padding.slice(padOffset)]);
          }
          return hexlify(bytes);
        }
        const hexTrue = toBeHex(BN_1$1, 32);
        const hexFalse = toBeHex(BN_0$3, 32);
        const domainFieldTypes = {
          name: "string",
          version: "string",
          chainId: "uint256",
          verifyingContract: "address",
          salt: "bytes32",
        };
        const domainFieldNames = [
          "name",
          "version",
          "chainId",
          "verifyingContract",
          "salt",
        ];
        function checkString(key) {
          return function (value) {
            assertArgument(
              typeof value === "string",
              `invalid domain value for ${JSON.stringify(key)}`,
              `domain.${key}`,
              value
            );
            return value;
          };
        }
        const domainChecks = {
          name: checkString("name"),
          version: checkString("version"),
          chainId: function (_value) {
            const value = getBigInt(_value, "domain.chainId");
            assertArgument(
              value >= 0,
              "invalid chain ID",
              "domain.chainId",
              _value
            );
            if (Number.isSafeInteger(value)) {
              return Number(value);
            }
            return toQuantity(value);
          },
          verifyingContract: function (value) {
            try {
              return getAddress(value).toLowerCase();
            } catch (error) {}
            assertArgument(
              false,
              `invalid domain value "verifyingContract"`,
              "domain.verifyingContract",
              value
            );
          },
          salt: function (value) {
            const bytes = getBytes(value, "domain.salt");
            assertArgument(
              bytes.length === 32,
              `invalid domain value "salt"`,
              "domain.salt",
              value
            );
            return hexlify(bytes);
          },
        };
        function getBaseEncoder(type) {
          {
            const match = type.match(/^(u?)int(\d*)$/);
            if (match) {
              const signed = match[1] === "";
              const width = parseInt(match[2] || "256");
              assertArgument(
                width % 8 === 0 &&
                  width !== 0 &&
                  width <= 256 &&
                  (match[2] == null || match[2] === String(width)),
                "invalid numeric width",
                "type",
                type
              );
              const boundsUpper = mask(
                BN_MAX_UINT256,
                signed ? width - 1 : width
              );
              const boundsLower = signed
                ? (boundsUpper + BN_1$1) * BN__1
                : BN_0$3;
              return function (_value) {
                const value = getBigInt(_value, "value");
                assertArgument(
                  value >= boundsLower && value <= boundsUpper,
                  `value out-of-bounds for ${type}`,
                  "value",
                  value
                );
                return toBeHex(signed ? toTwos(value, 256) : value, 32);
              };
            }
          }
          {
            const match = type.match(/^bytes(\d+)$/);
            if (match) {
              const width = parseInt(match[1]);
              assertArgument(
                width !== 0 && width <= 32 && match[1] === String(width),
                "invalid bytes width",
                "type",
                type
              );
              return function (value) {
                const bytes = getBytes(value);
                assertArgument(
                  bytes.length === width,
                  `invalid length for ${type}`,
                  "value",
                  value
                );
                return hexPadRight(value);
              };
            }
          }
          switch (type) {
            case "address":
              return function (value) {
                return zeroPadValue(getAddress(value), 32);
              };
            case "bool":
              return function (value) {
                return !value ? hexFalse : hexTrue;
              };
            case "bytes":
              return function (value) {
                return keccak256(value);
              };
            case "string":
              return function (value) {
                return id(value);
              };
          }
          return null;
        }
        function encodeType(name, fields) {
          return `${name}(${fields.map(({ name, type }) => type + " " + name).join(",")})`;
        }
        class TypedDataEncoder {
          primaryType;
          #types;
          get types() {
            return JSON.parse(this.#types);
          }
          #fullTypes;
          #encoderCache;
          constructor(types) {
            this.#types = JSON.stringify(types);
            this.#fullTypes = new Map();
            this.#encoderCache = new Map();
            const links = new Map();
            const parents = new Map();
            const subtypes = new Map();
            Object.keys(types).forEach((type) => {
              links.set(type, new Set());
              parents.set(type, []);
              subtypes.set(type, new Set());
            });
            for (const name in types) {
              const uniqueNames = new Set();
              for (const field of types[name]) {
                assertArgument(
                  !uniqueNames.has(field.name),
                  `duplicate variable name ${JSON.stringify(
                    field.name
                  )} in ${JSON.stringify(name)}`,
                  "types",
                  types
                );
                uniqueNames.add(field.name);
                const baseType =
                  field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
                assertArgument(
                  baseType !== name,
                  `circular type reference to ${JSON.stringify(baseType)}`,
                  "types",
                  types
                );
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                  continue;
                }
                assertArgument(
                  parents.has(baseType),
                  `unknown type ${JSON.stringify(baseType)}`,
                  "types",
                  types
                );
                parents.get(baseType).push(name);
                links.get(name).add(baseType);
              }
            }
            const primaryTypes = Array.from(parents.keys()).filter(
              (n) => parents.get(n).length === 0
            );
            assertArgument(
              primaryTypes.length !== 0,
              "missing primary type",
              "types",
              types
            );
            assertArgument(
              primaryTypes.length === 1,
              `ambiguous primary types or unused types: ${primaryTypes
                .map((t) => JSON.stringify(t))
                .join(", ")}`,
              "types",
              types
            );
            defineProperties(this, { primaryType: primaryTypes[0] });
            function checkCircular(type, found) {
              assertArgument(
                !found.has(type),
                `circular type reference to ${JSON.stringify(type)}`,
                "types",
                types
              );
              found.add(type);
              for (const child of links.get(type)) {
                if (!parents.has(child)) {
                  continue;
                }
                checkCircular(child, found);
                for (const subtype of found) {
                  subtypes.get(subtype).add(child);
                }
              }
              found.delete(type);
            }
            checkCircular(this.primaryType, new Set());
            for (const [name, set] of subtypes) {
              const st = Array.from(set);
              st.sort();
              this.#fullTypes.set(
                name,
                encodeType(name, types[name]) +
                  st.map((t) => encodeType(t, types[t])).join("")
              );
            }
          }
          getEncoder(type) {
            let encoder = this.#encoderCache.get(type);
            if (!encoder) {
              encoder = this.#getEncoder(type);
              this.#encoderCache.set(type, encoder);
            }
            return encoder;
          }
          #getEncoder(type) {
            {
              const encoder = getBaseEncoder(type);
              if (encoder) {
                return encoder;
              }
            }
            const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (match) {
              const subtype = match[1];
              const subEncoder = this.getEncoder(subtype);
              return (value) => {
                assertArgument(
                  !match[3] || parseInt(match[3]) === value.length,
                  `array length mismatch; expected length ${parseInt(
                    match[3]
                  )}`,
                  "value",
                  value
                );
                let result = value.map(subEncoder);
                if (this.#fullTypes.has(subtype)) {
                  result = result.map(keccak256);
                }
                return keccak256(concat(result));
              };
            }
            const fields = this.types[type];
            if (fields) {
              const encodedType = id(this.#fullTypes.get(type));
              return (value) => {
                const values = fields.map(({ name, type }) => {
                  const result = this.getEncoder(type)(value[name]);
                  if (this.#fullTypes.has(type)) {
                    return keccak256(result);
                  }
                  return result;
                });
                values.unshift(encodedType);
                return concat(values);
              };
            }
            assertArgument(false, `unknown type: ${type}`, "type", type);
          }
          encodeType(name) {
            const result = this.#fullTypes.get(name);
            assertArgument(
              result,
              `unknown type: ${JSON.stringify(name)}`,
              "name",
              name
            );
            return result;
          }
          encodeData(type, value) {
            return this.getEncoder(type)(value);
          }
          hashStruct(name, value) {
            return keccak256(this.encodeData(name, value));
          }
          encode(value) {
            return this.encodeData(this.primaryType, value);
          }
          hash(value) {
            return this.hashStruct(this.primaryType, value);
          }
          _visit(type, value, callback) {
            {
              const encoder = getBaseEncoder(type);
              if (encoder) {
                return callback(type, value);
              }
            }
            const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
            if (match) {
              assertArgument(
                !match[3] || parseInt(match[3]) === value.length,
                `array length mismatch; expected length ${parseInt(match[3])}`,
                "value",
                value
              );
              return value.map((v) => this._visit(match[1], v, callback));
            }
            const fields = this.types[type];
            if (fields) {
              return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
              }, {});
            }
            assertArgument(false, `unknown type: ${type}`, "type", type);
          }
          visit(value, callback) {
            return this._visit(this.primaryType, value, callback);
          }
          static from(types) {
            return new TypedDataEncoder(types);
          }
          static getPrimaryType(types) {
            return TypedDataEncoder.from(types).primaryType;
          }
          static hashStruct(name, types, value) {
            return TypedDataEncoder.from(types).hashStruct(name, value);
          }
          static hashDomain(domain) {
            const domainFields = [];
            for (const name in domain) {
              if (domain[name] == null) {
                continue;
              }
              const type = domainFieldTypes[name];
              assertArgument(
                type,
                `invalid typed-data domain key: ${JSON.stringify(name)}`,
                "domain",
                domain
              );
              domainFields.push({ name: name, type: type });
            }
            domainFields.sort((a, b) => {
              return (
                domainFieldNames.indexOf(a.name) -
                domainFieldNames.indexOf(b.name)
              );
            });
            return TypedDataEncoder.hashStruct(
              "EIP712Domain",
              { EIP712Domain: domainFields },
              domain
            );
          }
          static encode(domain, types, value) {
            return concat([
              "0x1901",
              TypedDataEncoder.hashDomain(domain),
              TypedDataEncoder.from(types).hash(value),
            ]);
          }
          static hash(domain, types, value) {
            return keccak256(TypedDataEncoder.encode(domain, types, value));
          }
          static async resolveNames(domain, types, value, resolveName) {
            domain = Object.assign({}, domain);
            for (const key in domain) {
              if (domain[key] == null) {
                delete domain[key];
              }
            }
            const ensCache = {};
            if (
              domain.verifyingContract &&
              !isHexString(domain.verifyingContract, 20)
            ) {
              ensCache[domain.verifyingContract] = "0x";
            }
            const encoder = TypedDataEncoder.from(types);
            encoder.visit(value, (type, value) => {
              if (type === "address" && !isHexString(value, 20)) {
                ensCache[value] = "0x";
              }
              return value;
            });
            for (const name in ensCache) {
              ensCache[name] = await resolveName(name);
            }
            if (
              domain.verifyingContract &&
              ensCache[domain.verifyingContract]
            ) {
              domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            value = encoder.visit(value, (type, value) => {
              if (type === "address" && ensCache[value]) {
                return ensCache[value];
              }
              return value;
            });
            return { domain: domain, value: value };
          }
          static getPayload(domain, types, value) {
            TypedDataEncoder.hashDomain(domain);
            const domainValues = {};
            const domainTypes = [];
            domainFieldNames.forEach((name) => {
              const value = domain[name];
              if (value == null) {
                return;
              }
              domainValues[name] = domainChecks[name](value);
              domainTypes.push({ name: name, type: domainFieldTypes[name] });
            });
            const encoder = TypedDataEncoder.from(types);
            const typesWithDomain = Object.assign({}, types);
            assertArgument(
              typesWithDomain.EIP712Domain == null,
              "types must not contain EIP712Domain type",
              "types.EIP712Domain",
              types
            );
            typesWithDomain.EIP712Domain = domainTypes;
            encoder.encode(value);
            return {
              types: typesWithDomain,
              domain: domainValues,
              primaryType: encoder.primaryType,
              message: encoder.visit(value, (type, value) => {
                if (type.match(/^bytes(\d*)/)) {
                  return hexlify(getBytes(value));
                }
                if (type.match(/^u?int/)) {
                  return getBigInt(value).toString();
                }
                switch (type) {
                  case "address":
                    return value.toLowerCase();
                  case "bool":
                    return !!value;
                  case "string":
                    assertArgument(
                      typeof value === "string",
                      "invalid string",
                      "value",
                      value
                    );
                    return value;
                }
                assertArgument(false, "unsupported type", "type", type);
              }),
            };
          }
        }
        function verifyTypedData(domain, types, value, signature) {
          return recoverAddress(
            TypedDataEncoder.hash(domain, types, value),
            signature
          );
        }
        function setify(items) {
          const result = new Set();
          items.forEach((k) => result.add(k));
          return Object.freeze(result);
        }
        const _kwVisibDeploy = "external public payable";
        const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
        const _kwVisib =
          "constant external internal payable private public pure view";
        const KwVisib = setify(_kwVisib.split(" "));
        const _kwTypes =
          "constructor error event fallback function receive struct";
        const KwTypes = setify(_kwTypes.split(" "));
        const _kwModifiers = "calldata memory storage payable indexed";
        const KwModifiers = setify(_kwModifiers.split(" "));
        const _kwOther = "tuple returns";
        const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(
          " "
        );
        const Keywords = setify(_keywords.split(" "));
        const SimpleTokens = {
          "(": "OPEN_PAREN",
          ")": "CLOSE_PAREN",
          "[": "OPEN_BRACKET",
          "]": "CLOSE_BRACKET",
          ",": "COMMA",
          "@": "AT",
        };
        const regexWhitespacePrefix = new RegExp("^(\\s*)");
        const regexNumberPrefix = new RegExp("^([0-9]+)");
        const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
        const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
        const regexType = new RegExp(
          "^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$"
        );
        class TokenString {
          #offset;
          #tokens;
          get offset() {
            return this.#offset;
          }
          get length() {
            return this.#tokens.length - this.#offset;
          }
          constructor(tokens) {
            this.#offset = 0;
            this.#tokens = tokens.slice();
          }
          clone() {
            return new TokenString(this.#tokens);
          }
          reset() {
            this.#offset = 0;
          }
          #subTokenString(from = 0, to = 0) {
            return new TokenString(
              this.#tokens.slice(from, to).map((t) => {
                return Object.freeze(
                  Object.assign({}, t, {
                    match: t.match - from,
                    linkBack: t.linkBack - from,
                    linkNext: t.linkNext - from,
                  })
                );
              })
            );
          }
          popKeyword(allowed) {
            const top = this.peek();
            if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
              throw new Error(`expected keyword ${top.text}`);
            }
            return this.pop().text;
          }
          popType(type) {
            if (this.peek().type !== type) {
              throw new Error(
                `expected ${type}; got ${JSON.stringify(this.peek())}`
              );
            }
            return this.pop().text;
          }
          popParen() {
            const top = this.peek();
            if (top.type !== "OPEN_PAREN") {
              throw new Error("bad start");
            }
            const result = this.#subTokenString(
              this.#offset + 1,
              top.match + 1
            );
            this.#offset = top.match + 1;
            return result;
          }
          popParams() {
            const top = this.peek();
            if (top.type !== "OPEN_PAREN") {
              throw new Error("bad start");
            }
            const result = [];
            while (this.#offset < top.match - 1) {
              const link = this.peek().linkNext;
              result.push(this.#subTokenString(this.#offset + 1, link));
              this.#offset = link;
            }
            this.#offset = top.match + 1;
            return result;
          }
          peek() {
            if (this.#offset >= this.#tokens.length) {
              throw new Error("out-of-bounds");
            }
            return this.#tokens[this.#offset];
          }
          peekKeyword(allowed) {
            const top = this.peekType("KEYWORD");
            return top != null && allowed.has(top) ? top : null;
          }
          peekType(type) {
            if (this.length === 0) {
              return null;
            }
            const top = this.peek();
            return top.type === type ? top.text : null;
          }
          pop() {
            const result = this.peek();
            this.#offset++;
            return result;
          }
          toString() {
            const tokens = [];
            for (let i = this.#offset; i < this.#tokens.length; i++) {
              const token = this.#tokens[i];
              tokens.push(`${token.type}:${token.text}`);
            }
            return `<TokenString ${tokens.join(" ")}>`;
          }
        }
        function lex(text) {
          const tokens = [];
          const throwError = (message) => {
            const token =
              offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
            throw new Error(`invalid token ${token} at ${offset}: ${message}`);
          };
          let brackets = [];
          let commas = [];
          let offset = 0;
          while (offset < text.length) {
            let cur = text.substring(offset);
            let match = cur.match(regexWhitespacePrefix);
            if (match) {
              offset += match[1].length;
              cur = text.substring(offset);
            }
            const token = {
              depth: brackets.length,
              linkBack: -1,
              linkNext: -1,
              match: -1,
              type: "",
              text: "",
              offset: offset,
              value: -1,
            };
            tokens.push(token);
            let type = SimpleTokens[cur[0]] || "";
            if (type) {
              token.type = type;
              token.text = cur[0];
              offset++;
              if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
              } else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                  throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                tokens[token.match].match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                tokens[token.linkBack].linkNext = tokens.length - 1;
              } else if (type === "COMMA") {
                token.linkBack = commas.pop();
                tokens[token.linkBack].linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
              } else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
              } else if (type === "CLOSE_BRACKET") {
                let suffix = tokens.pop().text;
                if (
                  tokens.length > 0 &&
                  tokens[tokens.length - 1].type === "NUMBER"
                ) {
                  const value = tokens.pop().text;
                  suffix = value + suffix;
                  tokens[tokens.length - 1].value = getNumber(value);
                }
                if (
                  tokens.length === 0 ||
                  tokens[tokens.length - 1].type !== "BRACKET"
                ) {
                  throw new Error("missing opening bracket");
                }
                tokens[tokens.length - 1].text += suffix;
              }
              continue;
            }
            match = cur.match(regexIdPrefix);
            if (match) {
              token.text = match[1];
              offset += token.text.length;
              if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
              }
              if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
              }
              token.type = "ID";
              continue;
            }
            match = cur.match(regexNumberPrefix);
            if (match) {
              token.text = match[1];
              token.type = "NUMBER";
              offset += token.text.length;
              continue;
            }
            throw new Error(
              `unexpected token ${JSON.stringify(cur[0])} at position ${offset}`
            );
          }
          return new TokenString(tokens.map((t) => Object.freeze(t)));
        }
        function allowSingle(set, allowed) {
          let included = [];
          for (const key in allowed.keys()) {
            if (set.has(key)) {
              included.push(key);
            }
          }
          if (included.length > 1) {
            throw new Error(`conflicting types: ${included.join(", ")}`);
          }
        }
        function consumeName(type, tokens) {
          if (tokens.peekKeyword(KwTypes)) {
            const keyword = tokens.pop().text;
            if (keyword !== type) {
              throw new Error(`expected ${type}, got ${keyword}`);
            }
          }
          return tokens.popType("ID");
        }
        function consumeKeywords(tokens, allowed) {
          const keywords = new Set();
          while (true) {
            const keyword = tokens.peekType("KEYWORD");
            if (keyword == null || (allowed && !allowed.has(keyword))) {
              break;
            }
            tokens.pop();
            if (keywords.has(keyword)) {
              throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
            }
            keywords.add(keyword);
          }
          return Object.freeze(keywords);
        }
        function consumeMutability(tokens) {
          let modifiers = consumeKeywords(tokens, KwVisib);
          allowSingle(
            modifiers,
            setify("constant payable nonpayable".split(" "))
          );
          allowSingle(
            modifiers,
            setify("pure view payable nonpayable".split(" "))
          );
          if (modifiers.has("view")) {
            return "view";
          }
          if (modifiers.has("pure")) {
            return "pure";
          }
          if (modifiers.has("payable")) {
            return "payable";
          }
          if (modifiers.has("nonpayable")) {
            return "nonpayable";
          }
          if (modifiers.has("constant")) {
            return "view";
          }
          return "nonpayable";
        }
        function consumeParams(tokens, allowIndexed) {
          return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
        }
        function consumeGas(tokens) {
          if (tokens.peekType("AT")) {
            tokens.pop();
            if (tokens.peekType("NUMBER")) {
              return getBigInt(tokens.pop().text);
            }
            throw new Error("invalid gas");
          }
          return null;
        }
        function consumeEoi(tokens) {
          if (tokens.length) {
            throw new Error(`unexpected tokens: ${tokens.toString()}`);
          }
        }
        const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
        function verifyBasicType(type) {
          const match = type.match(regexType);
          assertArgument(match, "invalid type", "type", type);
          if (type === "uint") {
            return "uint256";
          }
          if (type === "int") {
            return "int256";
          }
          if (match[2]) {
            const length = parseInt(match[2]);
            assertArgument(
              length !== 0 && length <= 32,
              "invalid bytes length",
              "type",
              type
            );
          } else if (match[3]) {
            const size = parseInt(match[3]);
            assertArgument(
              size !== 0 && size <= 256 && size % 8 === 0,
              "invalid numeric width",
              "type",
              type
            );
          }
          return type;
        }
        const _guard$2 = {};
        const internal$1 = Symbol.for("_ethers_internal");
        const ParamTypeInternal = "_ParamTypeInternal";
        const ErrorFragmentInternal = "_ErrorInternal";
        const EventFragmentInternal = "_EventInternal";
        const ConstructorFragmentInternal = "_ConstructorInternal";
        const FallbackFragmentInternal = "_FallbackInternal";
        const FunctionFragmentInternal = "_FunctionInternal";
        const StructFragmentInternal = "_StructInternal";
        class ParamType {
          name;
          type;
          baseType;
          indexed;
          components;
          arrayLength;
          arrayChildren;
          constructor(
            guard,
            name,
            type,
            baseType,
            indexed,
            components,
            arrayLength,
            arrayChildren
          ) {
            assertPrivate(guard, _guard$2, "ParamType");
            Object.defineProperty(this, internal$1, {
              value: ParamTypeInternal,
            });
            if (components) {
              components = Object.freeze(components.slice());
            }
            if (baseType === "array") {
              if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
              }
            } else if (arrayLength != null || arrayChildren != null) {
              throw new Error("");
            }
            if (baseType === "tuple") {
              if (components == null) {
                throw new Error("");
              }
            } else if (components != null) {
              throw new Error("");
            }
            defineProperties(this, {
              name: name,
              type: type,
              baseType: baseType,
              indexed: indexed,
              components: components,
              arrayLength: arrayLength,
              arrayChildren: arrayChildren,
            });
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              const name = this.name || "";
              if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${
                  this.arrayLength < 0 ? "" : String(this.arrayLength)
                }]`;
                return JSON.stringify(result);
              }
              const result = {
                type: this.baseType === "tuple" ? "tuple" : this.type,
                name: name,
              };
              if (typeof this.indexed === "boolean") {
                result.indexed = this.indexed;
              }
              if (this.isTuple()) {
                result.components = this.components.map((c) =>
                  JSON.parse(c.format(format))
                );
              }
              return JSON.stringify(result);
            }
            let result = "";
            if (this.isArray()) {
              result += this.arrayChildren.format(format);
              result += `[${
                this.arrayLength < 0 ? "" : String(this.arrayLength)
              }]`;
            } else {
              if (this.isTuple()) {
                if (format !== "sighash") {
                  result += this.type;
                }
                result +=
                  "(" +
                  this.components
                    .map((comp) => comp.format(format))
                    .join(format === "full" ? ", " : ",") +
                  ")";
              } else {
                result += this.type;
              }
            }
            if (format !== "sighash") {
              if (this.indexed === true) {
                result += " indexed";
              }
              if (format === "full" && this.name) {
                result += " " + this.name;
              }
            }
            return result;
          }
          isArray() {
            return this.baseType === "array";
          }
          isTuple() {
            return this.baseType === "tuple";
          }
          isIndexable() {
            return this.indexed != null;
          }
          walk(value, process) {
            if (this.isArray()) {
              if (!Array.isArray(value)) {
                throw new Error("invalid array value");
              }
              if (
                this.arrayLength !== -1 &&
                value.length !== this.arrayLength
              ) {
                throw new Error("array is wrong length");
              }
              const _this = this;
              return value.map((v) => _this.arrayChildren.walk(v, process));
            }
            if (this.isTuple()) {
              if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
              }
              if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
              }
              const _this = this;
              return value.map((v, i) => _this.components[i].walk(v, process));
            }
            return process(this.type, value);
          }
          #walkAsync(promises, value, process, setValue) {
            if (this.isArray()) {
              if (!Array.isArray(value)) {
                throw new Error("invalid array value");
              }
              if (
                this.arrayLength !== -1 &&
                value.length !== this.arrayLength
              ) {
                throw new Error("array is wrong length");
              }
              const childType = this.arrayChildren;
              const result = value.slice();
              result.forEach((value, index) => {
                childType.#walkAsync(promises, value, process, (value) => {
                  result[index] = value;
                });
              });
              setValue(result);
              return;
            }
            if (this.isTuple()) {
              const components = this.components;
              let result;
              if (Array.isArray(value)) {
                result = value.slice();
              } else {
                if (value == null || typeof value !== "object") {
                  throw new Error("invalid tuple value");
                }
                result = components.map((param) => {
                  if (!param.name) {
                    throw new Error(
                      "cannot use object value with unnamed components"
                    );
                  }
                  if (!(param.name in value)) {
                    throw new Error(
                      `missing value for component ${param.name}`
                    );
                  }
                  return value[param.name];
                });
              }
              if (result.length !== this.components.length) {
                throw new Error("array is wrong length");
              }
              result.forEach((value, index) => {
                components[index].#walkAsync(
                  promises,
                  value,
                  process,
                  (value) => {
                    result[index] = value;
                  }
                );
              });
              setValue(result);
              return;
            }
            const result = process(this.type, value);
            if (result.then) {
              promises.push(
                (async function () {
                  setValue(await result);
                })()
              );
            } else {
              setValue(result);
            }
          }
          async walkAsync(value, process) {
            const promises = [];
            const result = [value];
            this.#walkAsync(promises, value, process, (value) => {
              result[0] = value;
            });
            if (promises.length) {
              await Promise.all(promises);
            }
            return result[0];
          }
          static from(obj, allowIndexed) {
            if (ParamType.isParamType(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return ParamType.from(lex(obj), allowIndexed);
              } catch (error) {
                assertArgument(false, "invalid param type", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              let type = "",
                baseType = "";
              let comps = null;
              if (
                consumeKeywords(obj, setify(["tuple"])).has("tuple") ||
                obj.peekType("OPEN_PAREN")
              ) {
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
              } else {
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
              }
              let arrayChildren = null;
              let arrayLength = null;
              while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop();
                arrayChildren = new ParamType(
                  _guard$2,
                  "",
                  type,
                  baseType,
                  null,
                  comps,
                  arrayLength,
                  arrayChildren
                );
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
              }
              let indexed = null;
              const keywords = consumeKeywords(obj, KwModifiers);
              if (keywords.has("indexed")) {
                if (!allowIndexed) {
                  throw new Error("");
                }
                indexed = true;
              }
              const name = obj.peekType("ID") ? obj.pop().text : "";
              if (obj.length) {
                throw new Error("leftover tokens");
              }
              return new ParamType(
                _guard$2,
                name,
                type,
                baseType,
                indexed,
                comps,
                arrayLength,
                arrayChildren
              );
            }
            const name = obj.name;
            assertArgument(
              !name || (typeof name === "string" && name.match(regexId)),
              "invalid name",
              "obj.name",
              name
            );
            let indexed = obj.indexed;
            if (indexed != null) {
              assertArgument(
                allowIndexed,
                "parameter cannot be indexed",
                "obj.indexed",
                obj.indexed
              );
              indexed = !!indexed;
            }
            let type = obj.type;
            let arrayMatch = type.match(regexArrayType);
            if (arrayMatch) {
              const arrayLength = parseInt(arrayMatch[2] || "-1");
              const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components,
              });
              return new ParamType(
                _guard$2,
                name || "",
                type,
                "array",
                indexed,
                null,
                arrayLength,
                arrayChildren
              );
            }
            if (
              type === "tuple" ||
              type.startsWith("tuple(") ||
              type.startsWith("(")
            ) {
              const comps =
                obj.components != null
                  ? obj.components.map((c) => ParamType.from(c))
                  : null;
              const tuple = new ParamType(
                _guard$2,
                name || "",
                type,
                "tuple",
                indexed,
                comps,
                null,
                null
              );
              return tuple;
            }
            type = verifyBasicType(obj.type);
            return new ParamType(
              _guard$2,
              name || "",
              type,
              type,
              indexed,
              null,
              null,
              null
            );
          }
          static isParamType(value) {
            return value && value[internal$1] === ParamTypeInternal;
          }
        }
        class Fragment {
          type;
          inputs;
          constructor(guard, type, inputs) {
            assertPrivate(guard, _guard$2, "Fragment");
            inputs = Object.freeze(inputs.slice());
            defineProperties(this, { type: type, inputs: inputs });
          }
          static from(obj) {
            if (typeof obj === "string") {
              try {
                Fragment.from(JSON.parse(obj));
              } catch (e) {}
              return Fragment.from(lex(obj));
            }
            if (obj instanceof TokenString) {
              const type = obj.peekKeyword(KwTypes);
              switch (type) {
                case "constructor":
                  return ConstructorFragment.from(obj);
                case "error":
                  return ErrorFragment.from(obj);
                case "event":
                  return EventFragment.from(obj);
                case "fallback":
                case "receive":
                  return FallbackFragment.from(obj);
                case "function":
                  return FunctionFragment.from(obj);
                case "struct":
                  return StructFragment.from(obj);
              }
            } else if (typeof obj === "object") {
              switch (obj.type) {
                case "constructor":
                  return ConstructorFragment.from(obj);
                case "error":
                  return ErrorFragment.from(obj);
                case "event":
                  return EventFragment.from(obj);
                case "fallback":
                case "receive":
                  return FallbackFragment.from(obj);
                case "function":
                  return FunctionFragment.from(obj);
                case "struct":
                  return StructFragment.from(obj);
              }
              assert$1(
                false,
                `unsupported type: ${obj.type}`,
                "UNSUPPORTED_OPERATION",
                { operation: "Fragment.from" }
              );
            }
            assertArgument(false, "unsupported frgament object", "obj", obj);
          }
          static isConstructor(value) {
            return ConstructorFragment.isFragment(value);
          }
          static isError(value) {
            return ErrorFragment.isFragment(value);
          }
          static isEvent(value) {
            return EventFragment.isFragment(value);
          }
          static isFunction(value) {
            return FunctionFragment.isFragment(value);
          }
          static isStruct(value) {
            return StructFragment.isFragment(value);
          }
        }
        class NamedFragment extends Fragment {
          name;
          constructor(guard, type, name, inputs) {
            super(guard, type, inputs);
            assertArgument(
              typeof name === "string" && name.match(regexId),
              "invalid identifier",
              "name",
              name
            );
            inputs = Object.freeze(inputs.slice());
            defineProperties(this, { name: name });
          }
        }
        function joinParams(format, params) {
          return (
            "(" +
            params
              .map((p) => p.format(format))
              .join(format === "full" ? ", " : ",") +
            ")"
          );
        }
        class ErrorFragment extends NamedFragment {
          constructor(guard, name, inputs) {
            super(guard, "error", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: ErrorFragmentInternal,
            });
          }
          get selector() {
            return id(this.format("sighash")).substring(0, 10);
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) =>
                  JSON.parse(input.format(format))
                ),
              });
            }
            const result = [];
            if (format !== "sighash") {
              result.push("error");
            }
            result.push(this.name + joinParams(format, this.inputs));
            return result.join(" ");
          }
          static from(obj) {
            if (ErrorFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              return ErrorFragment.from(lex(obj));
            } else if (obj instanceof TokenString) {
              const name = consumeName("error", obj);
              const inputs = consumeParams(obj);
              consumeEoi(obj);
              return new ErrorFragment(_guard$2, name, inputs);
            }
            return new ErrorFragment(
              _guard$2,
              obj.name,
              obj.inputs ? obj.inputs.map(ParamType.from) : []
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === ErrorFragmentInternal;
          }
        }
        class EventFragment extends NamedFragment {
          anonymous;
          constructor(guard, name, inputs, anonymous) {
            super(guard, "event", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: EventFragmentInternal,
            });
            defineProperties(this, { anonymous: anonymous });
          }
          get topicHash() {
            return id(this.format("sighash"));
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
              });
            }
            const result = [];
            if (format !== "sighash") {
              result.push("event");
            }
            result.push(this.name + joinParams(format, this.inputs));
            if (format !== "sighash" && this.anonymous) {
              result.push("anonymous");
            }
            return result.join(" ");
          }
          static getTopicHash(name, params) {
            params = (params || []).map((p) => ParamType.from(p));
            const fragment = new EventFragment(_guard$2, name, params, false);
            return fragment.topicHash;
          }
          static from(obj) {
            if (EventFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return EventFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid event fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const name = consumeName("event", obj);
              const inputs = consumeParams(obj, true);
              const anonymous = !!consumeKeywords(
                obj,
                setify(["anonymous"])
              ).has("anonymous");
              consumeEoi(obj);
              return new EventFragment(_guard$2, name, inputs, anonymous);
            }
            return new EventFragment(
              _guard$2,
              obj.name,
              obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [],
              !!obj.anonymous
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === EventFragmentInternal;
          }
        }
        class ConstructorFragment extends Fragment {
          payable;
          gas;
          constructor(guard, type, inputs, payable, gas) {
            super(guard, type, inputs);
            Object.defineProperty(this, internal$1, {
              value: ConstructorFragmentInternal,
            });
            defineProperties(this, { payable: payable, gas: gas });
          }
          format(format) {
            assert$1(
              format != null && format !== "sighash",
              "cannot format a constructor for sighash",
              "UNSUPPORTED_OPERATION",
              { operation: "format(sighash)" }
            );
            if (format === "json") {
              return JSON.stringify({
                type: "constructor",
                stateMutability: this.payable ? "payable" : "undefined",
                payable: this.payable,
                gas: this.gas != null ? this.gas : undefined,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
              });
            }
            const result = [`constructor${joinParams(format, this.inputs)}`];
            result.push(this.payable ? "payable" : "nonpayable");
            if (this.gas != null) {
              result.push(`@${this.gas.toString()}`);
            }
            return result.join(" ");
          }
          static from(obj) {
            if (ConstructorFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return ConstructorFragment.from(lex(obj));
              } catch (error) {
                assertArgument(
                  false,
                  "invalid constuctor fragment",
                  "obj",
                  obj
                );
              }
            } else if (obj instanceof TokenString) {
              consumeKeywords(obj, setify(["constructor"]));
              const inputs = consumeParams(obj);
              const payable = !!consumeKeywords(obj, KwVisibDeploy).has(
                "payable"
              );
              const gas = consumeGas(obj);
              consumeEoi(obj);
              return new ConstructorFragment(
                _guard$2,
                "constructor",
                inputs,
                payable,
                gas
              );
            }
            return new ConstructorFragment(
              _guard$2,
              "constructor",
              obj.inputs ? obj.inputs.map(ParamType.from) : [],
              !!obj.payable,
              obj.gas != null ? obj.gas : null
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === ConstructorFragmentInternal;
          }
        }
        class FallbackFragment extends Fragment {
          payable;
          constructor(guard, inputs, payable) {
            super(guard, "fallback", inputs);
            Object.defineProperty(this, internal$1, {
              value: FallbackFragmentInternal,
            });
            defineProperties(this, { payable: payable });
          }
          format(format) {
            const type = this.inputs.length === 0 ? "receive" : "fallback";
            if (format === "json") {
              const stateMutability = this.payable ? "payable" : "nonpayable";
              return JSON.stringify({
                type: type,
                stateMutability: stateMutability,
              });
            }
            return `${type}()${this.payable ? " payable" : ""}`;
          }
          static from(obj) {
            if (FallbackFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return FallbackFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid fallback fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const errorObj = obj.toString();
              const topIsValid = obj.peekKeyword(
                setify(["fallback", "receive"])
              );
              assertArgument(
                topIsValid,
                "type must be fallback or receive",
                "obj",
                errorObj
              );
              const type = obj.popKeyword(setify(["fallback", "receive"]));
              if (type === "receive") {
                const inputs = consumeParams(obj);
                assertArgument(
                  inputs.length === 0,
                  `receive cannot have arguments`,
                  "obj.inputs",
                  inputs
                );
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard$2, [], true);
              }
              let inputs = consumeParams(obj);
              if (inputs.length) {
                assertArgument(
                  inputs.length === 1 && inputs[0].type === "bytes",
                  "invalid fallback inputs",
                  "obj.inputs",
                  inputs.map((i) => i.format("minimal")).join(", ")
                );
              } else {
                inputs = [ParamType.from("bytes")];
              }
              const mutability = consumeMutability(obj);
              assertArgument(
                mutability === "nonpayable" || mutability === "payable",
                "fallback cannot be constants",
                "obj.stateMutability",
                mutability
              );
              if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                assertArgument(
                  outputs.length === 1 && outputs[0].type === "bytes",
                  "invalid fallback outputs",
                  "obj.outputs",
                  outputs.map((i) => i.format("minimal")).join(", ")
                );
              }
              consumeEoi(obj);
              return new FallbackFragment(
                _guard$2,
                inputs,
                mutability === "payable"
              );
            }
            if (obj.type === "receive") {
              return new FallbackFragment(_guard$2, [], true);
            }
            if (obj.type === "fallback") {
              const inputs = [ParamType.from("bytes")];
              const payable = obj.stateMutability === "payable";
              return new FallbackFragment(_guard$2, inputs, payable);
            }
            assertArgument(false, "invalid fallback description", "obj", obj);
          }
          static isFragment(value) {
            return value && value[internal$1] === FallbackFragmentInternal;
          }
        }
        class FunctionFragment extends NamedFragment {
          constant;
          outputs;
          stateMutability;
          payable;
          gas;
          constructor(guard, name, stateMutability, inputs, outputs, gas) {
            super(guard, "function", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: FunctionFragmentInternal,
            });
            outputs = Object.freeze(outputs.slice());
            const constant =
              stateMutability === "view" || stateMutability === "pure";
            const payable = stateMutability === "payable";
            defineProperties(this, {
              constant: constant,
              gas: gas,
              outputs: outputs,
              payable: payable,
              stateMutability: stateMutability,
            });
          }
          get selector() {
            return id(this.format("sighash")).substring(0, 10);
          }
          format(format) {
            if (format == null) {
              format = "sighash";
            }
            if (format === "json") {
              return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability:
                  this.stateMutability !== "nonpayable"
                    ? this.stateMutability
                    : undefined,
                payable: this.payable,
                gas: this.gas != null ? this.gas : undefined,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
              });
            }
            const result = [];
            if (format !== "sighash") {
              result.push("function");
            }
            result.push(this.name + joinParams(format, this.inputs));
            if (format !== "sighash") {
              if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
              }
              if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
              }
              if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
              }
            }
            return result.join(" ");
          }
          static getSelector(name, params) {
            params = (params || []).map((p) => ParamType.from(p));
            const fragment = new FunctionFragment(
              _guard$2,
              name,
              "view",
              params,
              [],
              null
            );
            return fragment.selector;
          }
          static from(obj) {
            if (FunctionFragment.isFragment(obj)) {
              return obj;
            }
            if (typeof obj === "string") {
              try {
                return FunctionFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid function fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const name = consumeName("function", obj);
              const inputs = consumeParams(obj);
              const mutability = consumeMutability(obj);
              let outputs = [];
              if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
              }
              const gas = consumeGas(obj);
              consumeEoi(obj);
              return new FunctionFragment(
                _guard$2,
                name,
                mutability,
                inputs,
                outputs,
                gas
              );
            }
            let stateMutability = obj.stateMutability;
            if (stateMutability == null) {
              stateMutability = "payable";
              if (typeof obj.constant === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                  stateMutability = "payable";
                  if (typeof obj.payable === "boolean" && !obj.payable) {
                    stateMutability = "nonpayable";
                  }
                }
              } else if (typeof obj.payable === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
              }
            }
            return new FunctionFragment(
              _guard$2,
              obj.name,
              stateMutability,
              obj.inputs ? obj.inputs.map(ParamType.from) : [],
              obj.outputs ? obj.outputs.map(ParamType.from) : [],
              obj.gas != null ? obj.gas : null
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === FunctionFragmentInternal;
          }
        }
        class StructFragment extends NamedFragment {
          constructor(guard, name, inputs) {
            super(guard, "struct", name, inputs);
            Object.defineProperty(this, internal$1, {
              value: StructFragmentInternal,
            });
          }
          format() {
            throw new Error("@TODO");
          }
          static from(obj) {
            if (typeof obj === "string") {
              try {
                return StructFragment.from(lex(obj));
              } catch (error) {
                assertArgument(false, "invalid struct fragment", "obj", obj);
              }
            } else if (obj instanceof TokenString) {
              const name = consumeName("struct", obj);
              const inputs = consumeParams(obj);
              consumeEoi(obj);
              return new StructFragment(_guard$2, name, inputs);
            }
            return new StructFragment(
              _guard$2,
              obj.name,
              obj.inputs ? obj.inputs.map(ParamType.from) : []
            );
          }
          static isFragment(value) {
            return value && value[internal$1] === StructFragmentInternal;
          }
        }
        const PanicReasons$1 = new Map();
        PanicReasons$1.set(0, "GENERIC_PANIC");
        PanicReasons$1.set(1, "ASSERT_FALSE");
        PanicReasons$1.set(17, "OVERFLOW");
        PanicReasons$1.set(18, "DIVIDE_BY_ZERO");
        PanicReasons$1.set(33, "ENUM_RANGE_ERROR");
        PanicReasons$1.set(34, "BAD_STORAGE_DATA");
        PanicReasons$1.set(49, "STACK_UNDERFLOW");
        PanicReasons$1.set(50, "ARRAY_RANGE_ERROR");
        PanicReasons$1.set(65, "OUT_OF_MEMORY");
        PanicReasons$1.set(81, "UNINITIALIZED_FUNCTION_CALL");
        const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
        const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
        let defaultCoder = null;
        function getBuiltinCallException(action, tx, data, abiCoder) {
          let message = "missing revert data";
          let reason = null;
          const invocation = null;
          let revert = null;
          if (data) {
            message = "execution reverted";
            const bytes = getBytes(data);
            data = hexlify(data);
            if (bytes.length === 0) {
              message += " (no data present; likely require(false) occurred";
              reason = "require(false)";
            } else if (bytes.length % 32 !== 4) {
              message += " (could not decode reason; invalid data length)";
            } else if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
              try {
                reason = abiCoder.decode(["string"], bytes.slice(4))[0];
                revert = {
                  signature: "Error(string)",
                  name: "Error",
                  args: [reason],
                };
                message += `: ${JSON.stringify(reason)}`;
              } catch (error) {
                message += " (could not decode reason; invalid string data)";
              }
            } else if (hexlify(bytes.slice(0, 4)) === "0x4e487b71") {
              try {
                const code = Number(
                  abiCoder.decode(["uint256"], bytes.slice(4))[0]
                );
                revert = {
                  signature: "Panic(uint256)",
                  name: "Panic",
                  args: [code],
                };
                reason = `Panic due to ${
                  PanicReasons$1.get(code) || "UNKNOWN"
                }(${code})`;
                message += `: ${reason}`;
              } catch (error) {
                message += " (could not decode panic code)";
              }
            } else {
              message += " (unknown custom error)";
            }
          }
          const transaction = {
            to: tx.to ? getAddress(tx.to) : null,
            data: tx.data || "0x",
          };
          if (tx.from) {
            transaction.from = getAddress(tx.from);
          }
          return makeError(message, "CALL_EXCEPTION", {
            action: action,
            data: data,
            reason: reason,
            transaction: transaction,
            invocation: invocation,
            revert: revert,
          });
        }
        class AbiCoder {
          #getCoder(param) {
            if (param.isArray()) {
              return new ArrayCoder(
                this.#getCoder(param.arrayChildren),
                param.arrayLength,
                param.name
              );
            }
            if (param.isTuple()) {
              return new TupleCoder(
                param.components.map((c) => this.#getCoder(c)),
                param.name
              );
            }
            switch (param.baseType) {
              case "address":
                return new AddressCoder(param.name);
              case "bool":
                return new BooleanCoder(param.name);
              case "string":
                return new StringCoder(param.name);
              case "bytes":
                return new BytesCoder(param.name);
              case "":
                return new NullCoder(param.name);
            }
            let match = param.type.match(paramTypeNumber);
            if (match) {
              let size = parseInt(match[2] || "256");
              assertArgument(
                size !== 0 && size <= 256 && size % 8 === 0,
                "invalid " + match[1] + " bit length",
                "param",
                param
              );
              return new NumberCoder(size / 8, match[1] === "int", param.name);
            }
            match = param.type.match(paramTypeBytes);
            if (match) {
              let size = parseInt(match[1]);
              assertArgument(
                size !== 0 && size <= 32,
                "invalid bytes length",
                "param",
                param
              );
              return new FixedBytesCoder(size, param.name);
            }
            assertArgument(false, "invalid type", "type", param.type);
          }
          getDefaultValue(types) {
            const coders = types.map((type) =>
              this.#getCoder(ParamType.from(type))
            );
            const coder = new TupleCoder(coders, "_");
            return coder.defaultValue();
          }
          encode(types, values) {
            assertArgumentCount(
              values.length,
              types.length,
              "types/values length mismatch"
            );
            const coders = types.map((type) =>
              this.#getCoder(ParamType.from(type))
            );
            const coder = new TupleCoder(coders, "_");
            const writer = new Writer();
            coder.encode(writer, values);
            return writer.data;
          }
          decode(types, data, loose) {
            const coders = types.map((type) =>
              this.#getCoder(ParamType.from(type))
            );
            const coder = new TupleCoder(coders, "_");
            return coder.decode(new Reader(data, loose));
          }
          static defaultAbiCoder() {
            if (defaultCoder == null) {
              defaultCoder = new AbiCoder();
            }
            return defaultCoder;
          }
          static getBuiltinCallException(action, tx, data) {
            return getBuiltinCallException(
              action,
              tx,
              data,
              AbiCoder.defaultAbiCoder()
            );
          }
        }
        function encodeBytes32String(text) {
          const bytes = toUtf8Bytes(text);
          if (bytes.length > 31) {
            throw new Error("bytes32 string must be less than 32 bytes");
          }
          return zeroPadBytes(bytes, 32);
        }
        function decodeBytes32String(_bytes) {
          const data = getBytes(_bytes, "bytes");
          if (data.length !== 32) {
            throw new Error("invalid bytes32 - not 32 bytes long");
          }
          if (data[31] !== 0) {
            throw new Error("invalid bytes32 string - no null terminator");
          }
          let length = 31;
          while (data[length - 1] === 0) {
            length--;
          }
          return toUtf8String(data.slice(0, length));
        }
        class LogDescription {
          fragment;
          name;
          signature;
          topic;
          args;
          constructor(fragment, topic, args) {
            const name = fragment.name,
              signature = fragment.format();
            defineProperties(this, {
              fragment: fragment,
              name: name,
              signature: signature,
              topic: topic,
              args: args,
            });
          }
        }
        class TransactionDescription {
          fragment;
          name;
          args;
          signature;
          selector;
          value;
          constructor(fragment, selector, args, value) {
            const name = fragment.name,
              signature = fragment.format();
            defineProperties(this, {
              fragment: fragment,
              name: name,
              args: args,
              signature: signature,
              selector: selector,
              value: value,
            });
          }
        }
        class ErrorDescription {
          fragment;
          name;
          args;
          signature;
          selector;
          constructor(fragment, selector, args) {
            const name = fragment.name,
              signature = fragment.format();
            defineProperties(this, {
              fragment: fragment,
              name: name,
              args: args,
              signature: signature,
              selector: selector,
            });
          }
        }
        class Indexed {
          hash;
          _isIndexed;
          static isIndexed(value) {
            return !!(value && value._isIndexed);
          }
          constructor(hash) {
            defineProperties(this, { hash: hash, _isIndexed: true });
          }
        }
        const PanicReasons = {
          0: "generic panic",
          1: "assert(false)",
          17: "arithmetic overflow",
          18: "division or modulo by zero",
          33: "enum overflow",
          34: "invalid encoded storage byte array accessed",
          49: "out-of-bounds array access; popping on an empty array",
          50: "out-of-bounds access of an array or bytesN",
          65: "out of memory",
          81: "uninitialized function",
        };
        const BuiltinErrors = {
          "0x08c379a0": {
            signature: "Error(string)",
            name: "Error",
            inputs: ["string"],
            reason: (message) => {
              return `reverted with reason string ${JSON.stringify(message)}`;
            },
          },
          "0x4e487b71": {
            signature: "Panic(uint256)",
            name: "Panic",
            inputs: ["uint256"],
            reason: (code) => {
              let reason = "unknown panic code";
              if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
                reason = PanicReasons[code.toString()];
              }
              return `reverted with panic code 0x${code.toString(
                16
              )} (${reason})`;
            },
          },
        };
        class Interface {
          fragments;
          deploy;
          fallback;
          receive;
          #errors;
          #events;
          #functions;
          #abiCoder;
          constructor(fragments) {
            let abi = [];
            if (typeof fragments === "string") {
              abi = JSON.parse(fragments);
            } else {
              abi = fragments;
            }
            this.#functions = new Map();
            this.#errors = new Map();
            this.#events = new Map();
            const frags = [];
            for (const a of abi) {
              try {
                frags.push(Fragment.from(a));
              } catch (error) {
                console.log("EE", error);
              }
            }
            defineProperties(this, { fragments: Object.freeze(frags) });
            let fallback = null;
            let receive = false;
            this.#abiCoder = this.getAbiCoder();
            this.fragments.forEach((fragment, index) => {
              let bucket;
              switch (fragment.type) {
                case "constructor":
                  if (this.deploy) {
                    console.log("duplicate definition - constructor");
                    return;
                  }
                  defineProperties(this, { deploy: fragment });
                  return;
                case "fallback":
                  if (fragment.inputs.length === 0) {
                    receive = true;
                  } else {
                    assertArgument(
                      !fallback || fragment.payable !== fallback.payable,
                      "conflicting fallback fragments",
                      `fragments[${index}]`,
                      fragment
                    );
                    fallback = fragment;
                    receive = fallback.payable;
                  }
                  return;
                case "function":
                  bucket = this.#functions;
                  break;
                case "event":
                  bucket = this.#events;
                  break;
                case "error":
                  bucket = this.#errors;
                  break;
                default:
                  return;
              }
              const signature = fragment.format();
              if (bucket.has(signature)) {
                return;
              }
              bucket.set(signature, fragment);
            });
            if (!this.deploy) {
              defineProperties(this, {
                deploy: ConstructorFragment.from("constructor()"),
              });
            }
            defineProperties(this, { fallback: fallback, receive: receive });
          }
          format(minimal) {
            const format = minimal ? "minimal" : "full";
            const abi = this.fragments.map((f) => f.format(format));
            return abi;
          }
          formatJson() {
            const abi = this.fragments.map((f) => f.format("json"));
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
          }
          getAbiCoder() {
            return AbiCoder.defaultAbiCoder();
          }
          #getFunction(key, values, forceUnique) {
            if (isHexString(key)) {
              const selector = key.toLowerCase();
              for (const fragment of this.#functions.values()) {
                if (selector === fragment.selector) {
                  return fragment;
                }
              }
              return null;
            }
            if (key.indexOf("(") === -1) {
              const matching = [];
              for (const [name, fragment] of this.#functions) {
                if (name.split("(")[0] === key) {
                  matching.push(fragment);
                }
              }
              if (values) {
                const lastValue =
                  values.length > 0 ? values[values.length - 1] : null;
                let valueLength = values.length;
                let allowOptions = true;
                if (
                  Typed.isTyped(lastValue) &&
                  lastValue.type === "overrides"
                ) {
                  allowOptions = false;
                  valueLength--;
                }
                for (let i = matching.length - 1; i >= 0; i--) {
                  const inputs = matching[i].inputs.length;
                  if (
                    inputs !== valueLength &&
                    (!allowOptions || inputs !== valueLength - 1)
                  ) {
                    matching.splice(i, 1);
                  }
                }
                for (let i = matching.length - 1; i >= 0; i--) {
                  const inputs = matching[i].inputs;
                  for (let j = 0; j < values.length; j++) {
                    if (!Typed.isTyped(values[j])) {
                      continue;
                    }
                    if (j >= inputs.length) {
                      if (values[j].type === "overrides") {
                        continue;
                      }
                      matching.splice(i, 1);
                      break;
                    }
                    if (values[j].type !== inputs[j].baseType) {
                      matching.splice(i, 1);
                      break;
                    }
                  }
                }
              }
              if (
                matching.length === 1 &&
                values &&
                values.length !== matching[0].inputs.length
              ) {
                const lastArg = values[values.length - 1];
                if (
                  lastArg == null ||
                  Array.isArray(lastArg) ||
                  typeof lastArg !== "object"
                ) {
                  matching.splice(0, 1);
                }
              }
              if (matching.length === 0) {
                return null;
              }
              if (matching.length > 1 && forceUnique) {
                const matchStr = matching
                  .map((m) => JSON.stringify(m.format()))
                  .join(", ");
                assertArgument(
                  false,
                  `ambiguous function description (i.e. matches ${matchStr})`,
                  "key",
                  key
                );
              }
              return matching[0];
            }
            const result = this.#functions.get(
              FunctionFragment.from(key).format()
            );
            if (result) {
              return result;
            }
            return null;
          }
          getFunctionName(key) {
            const fragment = this.#getFunction(key, null, false);
            assertArgument(fragment, "no matching function", "key", key);
            return fragment.name;
          }
          hasFunction(key) {
            return !!this.#getFunction(key, null, false);
          }
          getFunction(key, values) {
            return this.#getFunction(key, values || null, true);
          }
          forEachFunction(callback) {
            const names = Array.from(this.#functions.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              callback(this.#functions.get(name), i);
            }
          }
          #getEvent(key, values, forceUnique) {
            if (isHexString(key)) {
              const eventTopic = key.toLowerCase();
              for (const fragment of this.#events.values()) {
                if (eventTopic === fragment.topicHash) {
                  return fragment;
                }
              }
              return null;
            }
            if (key.indexOf("(") === -1) {
              const matching = [];
              for (const [name, fragment] of this.#events) {
                if (name.split("(")[0] === key) {
                  matching.push(fragment);
                }
              }
              if (values) {
                for (let i = matching.length - 1; i >= 0; i--) {
                  if (matching[i].inputs.length < values.length) {
                    matching.splice(i, 1);
                  }
                }
                for (let i = matching.length - 1; i >= 0; i--) {
                  const inputs = matching[i].inputs;
                  for (let j = 0; j < values.length; j++) {
                    if (!Typed.isTyped(values[j])) {
                      continue;
                    }
                    if (values[j].type !== inputs[j].baseType) {
                      matching.splice(i, 1);
                      break;
                    }
                  }
                }
              }
              if (matching.length === 0) {
                return null;
              }
              if (matching.length > 1 && forceUnique) {
                const matchStr = matching
                  .map((m) => JSON.stringify(m.format()))
                  .join(", ");
                assertArgument(
                  false,
                  `ambiguous event description (i.e. matches ${matchStr})`,
                  "key",
                  key
                );
              }
              return matching[0];
            }
            const result = this.#events.get(EventFragment.from(key).format());
            if (result) {
              return result;
            }
            return null;
          }
          getEventName(key) {
            const fragment = this.#getEvent(key, null, false);
            assertArgument(fragment, "no matching event", "key", key);
            return fragment.name;
          }
          hasEvent(key) {
            return !!this.#getEvent(key, null, false);
          }
          getEvent(key, values) {
            return this.#getEvent(key, values || null, true);
          }
          forEachEvent(callback) {
            const names = Array.from(this.#events.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              callback(this.#events.get(name), i);
            }
          }
          getError(key, values) {
            if (isHexString(key)) {
              const selector = key.toLowerCase();
              if (BuiltinErrors[selector]) {
                return ErrorFragment.from(BuiltinErrors[selector].signature);
              }
              for (const fragment of this.#errors.values()) {
                if (selector === fragment.selector) {
                  return fragment;
                }
              }
              return null;
            }
            if (key.indexOf("(") === -1) {
              const matching = [];
              for (const [name, fragment] of this.#errors) {
                if (name.split("(")[0] === key) {
                  matching.push(fragment);
                }
              }
              if (matching.length === 0) {
                if (key === "Error") {
                  return ErrorFragment.from("error Error(string)");
                }
                if (key === "Panic") {
                  return ErrorFragment.from("error Panic(uint256)");
                }
                return null;
              } else if (matching.length > 1) {
                const matchStr = matching
                  .map((m) => JSON.stringify(m.format()))
                  .join(", ");
                assertArgument(
                  false,
                  `ambiguous error description (i.e. ${matchStr})`,
                  "name",
                  key
                );
              }
              return matching[0];
            }
            key = ErrorFragment.from(key).format();
            if (key === "Error(string)") {
              return ErrorFragment.from("error Error(string)");
            }
            if (key === "Panic(uint256)") {
              return ErrorFragment.from("error Panic(uint256)");
            }
            const result = this.#errors.get(key);
            if (result) {
              return result;
            }
            return null;
          }
          forEachError(callback) {
            const names = Array.from(this.#errors.keys());
            names.sort((a, b) => a.localeCompare(b));
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              callback(this.#errors.get(name), i);
            }
          }
          _decodeParams(params, data) {
            return this.#abiCoder.decode(params, data);
          }
          _encodeParams(params, values) {
            return this.#abiCoder.encode(params, values);
          }
          encodeDeploy(values) {
            return this._encodeParams(this.deploy.inputs, values || []);
          }
          decodeErrorResult(fragment, data) {
            if (typeof fragment === "string") {
              const f = this.getError(fragment);
              assertArgument(f, "unknown error", "fragment", fragment);
              fragment = f;
            }
            assertArgument(
              dataSlice(data, 0, 4) === fragment.selector,
              `data signature does not match error ${fragment.name}.`,
              "data",
              data
            );
            return this._decodeParams(fragment.inputs, dataSlice(data, 4));
          }
          encodeErrorResult(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getError(fragment);
              assertArgument(f, "unknown error", "fragment", fragment);
              fragment = f;
            }
            return concat([
              fragment.selector,
              this._encodeParams(fragment.inputs, values || []),
            ]);
          }
          decodeFunctionData(fragment, data) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            assertArgument(
              dataSlice(data, 0, 4) === fragment.selector,
              `data signature does not match function ${fragment.name}.`,
              "data",
              data
            );
            return this._decodeParams(fragment.inputs, dataSlice(data, 4));
          }
          encodeFunctionData(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            return concat([
              fragment.selector,
              this._encodeParams(fragment.inputs, values || []),
            ]);
          }
          decodeFunctionResult(fragment, data) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            let message = "invalid length for result data";
            const bytes = getBytesCopy(data);
            if (bytes.length % 32 === 0) {
              try {
                return this.#abiCoder.decode(fragment.outputs, bytes);
              } catch (error) {
                message = "could not decode result data";
              }
            }
            assert$1(false, message, "BAD_DATA", {
              value: hexlify(bytes),
              info: { method: fragment.name, signature: fragment.format() },
            });
          }
          makeError(_data, tx) {
            const data = getBytes(_data, "data");
            const error = AbiCoder.getBuiltinCallException("call", tx, data);
            const customPrefix = "execution reverted (unknown custom error)";
            if (error.message.startsWith(customPrefix)) {
              const selector = hexlify(data.slice(0, 4));
              const ef = this.getError(selector);
              if (ef) {
                try {
                  const args = this.#abiCoder.decode(ef.inputs, data.slice(4));
                  error.revert = {
                    name: ef.name,
                    signature: ef.format(),
                    args: args,
                  };
                  error.reason = error.revert.signature;
                  error.message = `execution reverted: ${error.reason}`;
                } catch (e) {
                  error.message = `execution reverted (coult not decode custom error)`;
                }
              }
            }
            const parsed = this.parseTransaction(tx);
            if (parsed) {
              error.invocation = {
                method: parsed.name,
                signature: parsed.signature,
                args: parsed.args,
              };
            }
            return error;
          }
          encodeFunctionResult(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getFunction(fragment);
              assertArgument(f, "unknown function", "fragment", fragment);
              fragment = f;
            }
            return hexlify(
              this.#abiCoder.encode(fragment.outputs, values || [])
            );
          }
          encodeFilterTopics(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getEvent(fragment);
              assertArgument(f, "unknown event", "eventFragment", fragment);
              fragment = f;
            }
            assert$1(
              values.length <= fragment.inputs.length,
              `too many arguments for ${fragment.format()}`,
              "UNEXPECTED_ARGUMENT",
              { count: values.length, expectedCount: fragment.inputs.length }
            );
            const topics = [];
            if (!fragment.anonymous) {
              topics.push(fragment.topicHash);
            }
            const encodeTopic = (param, value) => {
              if (param.type === "string") {
                return id(value);
              } else if (param.type === "bytes") {
                return keccak256(hexlify(value));
              }
              if (param.type === "bool" && typeof value === "boolean") {
                value = value ? "0x01" : "0x00";
              } else if (param.type.match(/^u?int/)) {
                value = toBeHex(value);
              } else if (param.type.match(/^bytes/)) {
                value = zeroPadBytes(value, 32);
              } else if (param.type === "address") {
                this.#abiCoder.encode(["address"], [value]);
              }
              return zeroPadValue(hexlify(value), 32);
            };
            values.forEach((value, index) => {
              const param = fragment.inputs[index];
              if (!param.indexed) {
                assertArgument(
                  value == null,
                  "cannot filter non-indexed parameters; must be null",
                  "contract." + param.name,
                  value
                );
                return;
              }
              if (value == null) {
                topics.push(null);
              } else if (
                param.baseType === "array" ||
                param.baseType === "tuple"
              ) {
                assertArgument(
                  false,
                  "filtering with tuples or arrays not supported",
                  "contract." + param.name,
                  value
                );
              } else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
              } else {
                topics.push(encodeTopic(param, value));
              }
            });
            while (topics.length && topics[topics.length - 1] === null) {
              topics.pop();
            }
            return topics;
          }
          encodeEventLog(fragment, values) {
            if (typeof fragment === "string") {
              const f = this.getEvent(fragment);
              assertArgument(f, "unknown event", "eventFragment", fragment);
              fragment = f;
            }
            const topics = [];
            const dataTypes = [];
            const dataValues = [];
            if (!fragment.anonymous) {
              topics.push(fragment.topicHash);
            }
            assertArgument(
              values.length === fragment.inputs.length,
              "event arguments/values mismatch",
              "values",
              values
            );
            fragment.inputs.forEach((param, index) => {
              const value = values[index];
              if (param.indexed) {
                if (param.type === "string") {
                  topics.push(id(value));
                } else if (param.type === "bytes") {
                  topics.push(keccak256(value));
                } else if (
                  param.baseType === "tuple" ||
                  param.baseType === "array"
                ) {
                  throw new Error("not implemented");
                } else {
                  topics.push(this.#abiCoder.encode([param.type], [value]));
                }
              } else {
                dataTypes.push(param);
                dataValues.push(value);
              }
            });
            return {
              data: this.#abiCoder.encode(dataTypes, dataValues),
              topics: topics,
            };
          }
          decodeEventLog(fragment, data, topics) {
            if (typeof fragment === "string") {
              const f = this.getEvent(fragment);
              assertArgument(f, "unknown event", "eventFragment", fragment);
              fragment = f;
            }
            if (topics != null && !fragment.anonymous) {
              const eventTopic = fragment.topicHash;
              assertArgument(
                isHexString(topics[0], 32) &&
                  topics[0].toLowerCase() === eventTopic,
                "fragment/topic mismatch",
                "topics[0]",
                topics[0]
              );
              topics = topics.slice(1);
            }
            const indexed = [];
            const nonIndexed = [];
            const dynamic = [];
            fragment.inputs.forEach((param, index) => {
              if (param.indexed) {
                if (
                  param.type === "string" ||
                  param.type === "bytes" ||
                  param.baseType === "tuple" ||
                  param.baseType === "array"
                ) {
                  indexed.push(
                    ParamType.from({ type: "bytes32", name: param.name })
                  );
                  dynamic.push(true);
                } else {
                  indexed.push(param);
                  dynamic.push(false);
                }
              } else {
                nonIndexed.push(param);
                dynamic.push(false);
              }
            });
            const resultIndexed =
              topics != null
                ? this.#abiCoder.decode(indexed, concat(topics))
                : null;
            const resultNonIndexed = this.#abiCoder.decode(
              nonIndexed,
              data,
              true
            );
            const values = [];
            const keys = [];
            let nonIndexedIndex = 0,
              indexedIndex = 0;
            fragment.inputs.forEach((param, index) => {
              let value = null;
              if (param.indexed) {
                if (resultIndexed == null) {
                  value = new Indexed(null);
                } else if (dynamic[index]) {
                  value = new Indexed(resultIndexed[indexedIndex++]);
                } else {
                  try {
                    value = resultIndexed[indexedIndex++];
                  } catch (error) {
                    value = error;
                  }
                }
              } else {
                try {
                  value = resultNonIndexed[nonIndexedIndex++];
                } catch (error) {
                  value = error;
                }
              }
              values.push(value);
              keys.push(param.name || null);
            });
            return Result.fromItems(values, keys);
          }
          parseTransaction(tx) {
            const data = getBytes(tx.data, "tx.data");
            const value = getBigInt(
              tx.value != null ? tx.value : 0,
              "tx.value"
            );
            const fragment = this.getFunction(hexlify(data.slice(0, 4)));
            if (!fragment) {
              return null;
            }
            const args = this.#abiCoder.decode(fragment.inputs, data.slice(4));
            return new TransactionDescription(
              fragment,
              fragment.selector,
              args,
              value
            );
          }
          parseCallResult(data) {
            throw new Error("@TODO");
          }
          parseLog(log) {
            const fragment = this.getEvent(log.topics[0]);
            if (!fragment || fragment.anonymous) {
              return null;
            }
            return new LogDescription(
              fragment,
              fragment.topicHash,
              this.decodeEventLog(fragment, log.data, log.topics)
            );
          }
          parseError(data) {
            const hexData = hexlify(data);
            const fragment = this.getError(dataSlice(hexData, 0, 4));
            if (!fragment) {
              return null;
            }
            const args = this.#abiCoder.decode(
              fragment.inputs,
              dataSlice(hexData, 4)
            );
            return new ErrorDescription(fragment, fragment.selector, args);
          }
          static from(value) {
            if (value instanceof Interface) {
              return value;
            }
            if (typeof value === "string") {
              return new Interface(JSON.parse(value));
            }
            if (typeof value.format === "function") {
              return new Interface(value.format("json"));
            }
            return new Interface(value);
          }
        }
        const BN_0$2 = BigInt(0);
        function getValue(value) {
          if (value == null) {
            return null;
          }
          return value;
        }
        function toJson(value) {
          if (value == null) {
            return null;
          }
          return value.toString();
        }
        class FeeData {
          gasPrice;
          maxFeePerGas;
          maxPriorityFeePerGas;
          constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
            defineProperties(this, {
              gasPrice: getValue(gasPrice),
              maxFeePerGas: getValue(maxFeePerGas),
              maxPriorityFeePerGas: getValue(maxPriorityFeePerGas),
            });
          }
          toJSON() {
            const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
            return {
              _type: "FeeData",
              gasPrice: toJson(gasPrice),
              maxFeePerGas: toJson(maxFeePerGas),
              maxPriorityFeePerGas: toJson(maxPriorityFeePerGas),
            };
          }
        }
        function copyRequest(req) {
          const result = {};
          if (req.to) {
            result.to = req.to;
          }
          if (req.from) {
            result.from = req.from;
          }
          if (req.data) {
            result.data = hexlify(req.data);
          }
          const bigIntKeys =
            "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(
              /,/
            );
          for (const key of bigIntKeys) {
            if (!(key in req) || req[key] == null) {
              continue;
            }
            result[key] = getBigInt(req[key], `request.${key}`);
          }
          const numberKeys = "type,nonce".split(/,/);
          for (const key of numberKeys) {
            if (!(key in req) || req[key] == null) {
              continue;
            }
            result[key] = getNumber(req[key], `request.${key}`);
          }
          if (req.accessList) {
            result.accessList = accessListify(req.accessList);
          }
          if ("blockTag" in req) {
            result.blockTag = req.blockTag;
          }
          if ("enableCcipRead" in req) {
            result.enableCcipRead = !!req.enableCcipRead;
          }
          if ("customData" in req) {
            result.customData = req.customData;
          }
          return result;
        }
        class Block {
          provider;
          number;
          hash;
          timestamp;
          parentHash;
          nonce;
          difficulty;
          gasLimit;
          gasUsed;
          miner;
          extraData;
          baseFeePerGas;
          #transactions;
          constructor(block, provider) {
            this.#transactions = block.transactions.map((tx) => {
              if (typeof tx !== "string") {
                return new TransactionResponse(tx, provider);
              }
              return tx;
            });
            defineProperties(this, {
              provider: provider,
              hash: getValue(block.hash),
              number: block.number,
              timestamp: block.timestamp,
              parentHash: block.parentHash,
              nonce: block.nonce,
              difficulty: block.difficulty,
              gasLimit: block.gasLimit,
              gasUsed: block.gasUsed,
              miner: block.miner,
              extraData: block.extraData,
              baseFeePerGas: getValue(block.baseFeePerGas),
            });
          }
          get transactions() {
            return this.#transactions.map((tx) => {
              if (typeof tx === "string") {
                return tx;
              }
              return tx.hash;
            });
          }
          get prefetchedTransactions() {
            const txs = this.#transactions.slice();
            if (txs.length === 0) {
              return [];
            }
            assert$1(
              typeof txs[0] === "object",
              "transactions were not prefetched with block request",
              "UNSUPPORTED_OPERATION",
              { operation: "transactionResponses()" }
            );
            return txs;
          }
          toJSON() {
            const {
              baseFeePerGas,
              difficulty,
              extraData,
              gasLimit,
              gasUsed,
              hash,
              miner,
              nonce,
              number,
              parentHash,
              timestamp,
              transactions,
            } = this;
            return {
              _type: "Block",
              baseFeePerGas: toJson(baseFeePerGas),
              difficulty: toJson(difficulty),
              extraData: extraData,
              gasLimit: toJson(gasLimit),
              gasUsed: toJson(gasUsed),
              hash: hash,
              miner: miner,
              nonce: nonce,
              number: number,
              parentHash: parentHash,
              timestamp: timestamp,
              transactions: transactions,
            };
          }
          [Symbol.iterator]() {
            let index = 0;
            const txs = this.transactions;
            return {
              next: () => {
                if (index < this.length) {
                  return { value: txs[index++], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          get length() {
            return this.#transactions.length;
          }
          get date() {
            if (this.timestamp == null) {
              return null;
            }
            return new Date(this.timestamp * 1e3);
          }
          async getTransaction(indexOrHash) {
            let tx = undefined;
            if (typeof indexOrHash === "number") {
              tx = this.#transactions[indexOrHash];
            } else {
              const hash = indexOrHash.toLowerCase();
              for (const v of this.#transactions) {
                if (typeof v === "string") {
                  if (v !== hash) {
                    continue;
                  }
                  tx = v;
                  break;
                } else {
                  if (v.hash === hash) {
                    continue;
                  }
                  tx = v;
                  break;
                }
              }
            }
            if (tx == null) {
              throw new Error("no such tx");
            }
            if (typeof tx === "string") {
              return await this.provider.getTransaction(tx);
            } else {
              return tx;
            }
          }
          getPrefetchedTransaction(indexOrHash) {
            const txs = this.prefetchedTransactions;
            if (typeof indexOrHash === "number") {
              return txs[indexOrHash];
            }
            indexOrHash = indexOrHash.toLowerCase();
            for (const tx of txs) {
              if (tx.hash === indexOrHash) {
                return tx;
              }
            }
            assertArgument(
              false,
              "no matching transaction",
              "indexOrHash",
              indexOrHash
            );
          }
          isMined() {
            return !!this.hash;
          }
          isLondon() {
            return !!this.baseFeePerGas;
          }
          orphanedEvent() {
            if (!this.isMined()) {
              throw new Error("");
            }
            return createOrphanedBlockFilter(this);
          }
        }
        class Log {
          provider;
          transactionHash;
          blockHash;
          blockNumber;
          removed;
          address;
          data;
          topics;
          index;
          transactionIndex;
          constructor(log, provider) {
            this.provider = provider;
            const topics = Object.freeze(log.topics.slice());
            defineProperties(this, {
              transactionHash: log.transactionHash,
              blockHash: log.blockHash,
              blockNumber: log.blockNumber,
              removed: log.removed,
              address: log.address,
              data: log.data,
              topics: topics,
              index: log.index,
              transactionIndex: log.transactionIndex,
            });
          }
          toJSON() {
            const {
              address,
              blockHash,
              blockNumber,
              data,
              index,
              removed,
              topics,
              transactionHash,
              transactionIndex,
            } = this;
            return {
              _type: "log",
              address: address,
              blockHash: blockHash,
              blockNumber: blockNumber,
              data: data,
              index: index,
              removed: removed,
              topics: topics,
              transactionHash: transactionHash,
              transactionIndex: transactionIndex,
            };
          }
          async getBlock() {
            const block = await this.provider.getBlock(this.blockHash);
            assert$1(
              !!block,
              "failed to find transaction",
              "UNKNOWN_ERROR",
              {}
            );
            return block;
          }
          async getTransaction() {
            const tx = await this.provider.getTransaction(this.transactionHash);
            assert$1(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
            return tx;
          }
          async getTransactionReceipt() {
            const receipt = await this.provider.getTransactionReceipt(
              this.transactionHash
            );
            assert$1(
              !!receipt,
              "failed to find transaction receipt",
              "UNKNOWN_ERROR",
              {}
            );
            return receipt;
          }
          removedEvent() {
            return createRemovedLogFilter(this);
          }
        }
        class TransactionReceipt {
          provider;
          to;
          from;
          contractAddress;
          hash;
          index;
          blockHash;
          blockNumber;
          logsBloom;
          gasUsed;
          cumulativeGasUsed;
          gasPrice;
          type;
          status;
          root;
          #logs;
          constructor(tx, provider) {
            this.#logs = Object.freeze(
              tx.logs.map((log) => {
                return new Log(log, provider);
              })
            );
            let gasPrice = BN_0$2;
            if (tx.effectiveGasPrice != null) {
              gasPrice = tx.effectiveGasPrice;
            } else if (tx.gasPrice != null) {
              gasPrice = tx.gasPrice;
            }
            defineProperties(this, {
              provider: provider,
              to: tx.to,
              from: tx.from,
              contractAddress: tx.contractAddress,
              hash: tx.hash,
              index: tx.index,
              blockHash: tx.blockHash,
              blockNumber: tx.blockNumber,
              logsBloom: tx.logsBloom,
              gasUsed: tx.gasUsed,
              cumulativeGasUsed: tx.cumulativeGasUsed,
              gasPrice: gasPrice,
              type: tx.type,
              status: tx.status,
              root: tx.root,
            });
          }
          get logs() {
            return this.#logs;
          }
          toJSON() {
            const {
              to,
              from,
              contractAddress,
              hash,
              index,
              blockHash,
              blockNumber,
              logsBloom,
              logs,
              status,
              root,
            } = this;
            return {
              _type: "TransactionReceipt",
              blockHash: blockHash,
              blockNumber: blockNumber,
              contractAddress: contractAddress,
              cumulativeGasUsed: toJson(this.cumulativeGasUsed),
              from: from,
              gasPrice: toJson(this.gasPrice),
              gasUsed: toJson(this.gasUsed),
              hash: hash,
              index: index,
              logs: logs,
              logsBloom: logsBloom,
              root: root,
              status: status,
              to: to,
            };
          }
          get length() {
            return this.logs.length;
          }
          [Symbol.iterator]() {
            let index = 0;
            return {
              next: () => {
                if (index < this.length) {
                  return { value: this.logs[index++], done: false };
                }
                return { value: undefined, done: true };
              },
            };
          }
          get fee() {
            return this.gasUsed * this.gasPrice;
          }
          async getBlock() {
            const block = await this.provider.getBlock(this.blockHash);
            if (block == null) {
              throw new Error("TODO");
            }
            return block;
          }
          async getTransaction() {
            const tx = await this.provider.getTransaction(this.hash);
            if (tx == null) {
              throw new Error("TODO");
            }
            return tx;
          }
          async getResult() {
            return await this.provider.getTransactionResult(this.hash);
          }
          async confirmations() {
            return (
              (await this.provider.getBlockNumber()) - this.blockNumber + 1
            );
          }
          removedEvent() {
            return createRemovedTransactionFilter(this);
          }
          reorderedEvent(other) {
            assert$1(
              !other || other.isMined(),
              "unmined 'other' transction cannot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "reorderedEvent(other)" }
            );
            return createReorderedTransactionFilter(this, other);
          }
        }
        class TransactionResponse {
          provider;
          blockNumber;
          blockHash;
          index;
          hash;
          type;
          to;
          from;
          nonce;
          gasLimit;
          gasPrice;
          maxPriorityFeePerGas;
          maxFeePerGas;
          data;
          value;
          chainId;
          signature;
          accessList;
          #startBlock;
          constructor(tx, provider) {
            this.provider = provider;
            this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
            this.blockHash = tx.blockHash != null ? tx.blockHash : null;
            this.hash = tx.hash;
            this.index = tx.index;
            this.type = tx.type;
            this.from = tx.from;
            this.to = tx.to || null;
            this.gasLimit = tx.gasLimit;
            this.nonce = tx.nonce;
            this.data = tx.data;
            this.value = tx.value;
            this.gasPrice = tx.gasPrice;
            this.maxPriorityFeePerGas =
              tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
            this.maxFeePerGas =
              tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
            this.chainId = tx.chainId;
            this.signature = tx.signature;
            this.accessList = tx.accessList != null ? tx.accessList : null;
            this.#startBlock = -1;
          }
          toJSON() {
            const {
              blockNumber,
              blockHash,
              index,
              hash,
              type,
              to,
              from,
              nonce,
              data,
              signature,
              accessList,
            } = this;
            return {
              _type: "TransactionReceipt",
              accessList: accessList,
              blockNumber: blockNumber,
              blockHash: blockHash,
              chainId: toJson(this.chainId),
              data: data,
              from: from,
              gasLimit: toJson(this.gasLimit),
              gasPrice: toJson(this.gasPrice),
              hash: hash,
              maxFeePerGas: toJson(this.maxFeePerGas),
              maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
              nonce: nonce,
              signature: signature,
              to: to,
              index: index,
              type: type,
              value: toJson(this.value),
            };
          }
          async getBlock() {
            let blockNumber = this.blockNumber;
            if (blockNumber == null) {
              const tx = await this.getTransaction();
              if (tx) {
                blockNumber = tx.blockNumber;
              }
            }
            if (blockNumber == null) {
              return null;
            }
            const block = this.provider.getBlock(blockNumber);
            if (block == null) {
              throw new Error("TODO");
            }
            return block;
          }
          async getTransaction() {
            return this.provider.getTransaction(this.hash);
          }
          async confirmations() {
            if (this.blockNumber == null) {
              const { tx, blockNumber } = await resolveProperties({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber(),
              });
              if (tx == null || tx.blockNumber == null) {
                return 0;
              }
              return blockNumber - tx.blockNumber + 1;
            }
            const blockNumber = await this.provider.getBlockNumber();
            return blockNumber - this.blockNumber + 1;
          }
          async wait(_confirms, _timeout) {
            const confirms = _confirms == null ? 1 : _confirms;
            const timeout = _timeout == null ? 0 : _timeout;
            let startBlock = this.#startBlock;
            let nextScan = -1;
            let stopScanning = startBlock === -1 ? true : false;
            const checkReplacement = async () => {
              if (stopScanning) {
                return null;
              }
              const { blockNumber, nonce } = await resolveProperties({
                blockNumber: this.provider.getBlockNumber(),
                nonce: this.provider.getTransactionCount(this.from),
              });
              if (nonce < this.nonce) {
                startBlock = blockNumber;
                return;
              }
              if (stopScanning) {
                return null;
              }
              const mined = await this.getTransaction();
              if (mined && mined.blockNumber != null) {
                return;
              }
              if (nextScan === -1) {
                nextScan = startBlock - 3;
                if (nextScan < this.#startBlock) {
                  nextScan = this.#startBlock;
                }
              }
              while (nextScan <= blockNumber) {
                if (stopScanning) {
                  return null;
                }
                const block = await this.provider.getBlock(nextScan, true);
                if (block == null) {
                  return;
                }
                for (const hash of block) {
                  if (hash === this.hash) {
                    return;
                  }
                }
                for (let i = 0; i < block.length; i++) {
                  const tx = await block.getTransaction(i);
                  if (tx.from === this.from && tx.nonce === this.nonce) {
                    if (stopScanning) {
                      return null;
                    }
                    const receipt = await this.provider.getTransactionReceipt(
                      tx.hash
                    );
                    if (receipt == null) {
                      return;
                    }
                    if (blockNumber - receipt.blockNumber + 1 < confirms) {
                      return;
                    }
                    let reason = "replaced";
                    if (
                      tx.data === this.data &&
                      tx.to === this.to &&
                      tx.value === this.value
                    ) {
                      reason = "repriced";
                    } else if (
                      tx.data === "0x" &&
                      tx.from === tx.to &&
                      tx.value === BN_0$2
                    ) {
                      reason = "cancelled";
                    }
                    assert$1(
                      false,
                      "transaction was replaced",
                      "TRANSACTION_REPLACED",
                      {
                        cancelled:
                          reason === "replaced" || reason === "cancelled",
                        reason: reason,
                        replacement: tx.replaceableTransaction(startBlock),
                        hash: tx.hash,
                        receipt: receipt,
                      }
                    );
                  }
                }
                nextScan++;
              }
              return;
            };
            const checkReceipt = (receipt) => {
              if (receipt == null || receipt.status !== 0) {
                return receipt;
              }
              assert$1(
                false,
                "transaction execution reverted",
                "CALL_EXCEPTION",
                {
                  action: "sendTransaction",
                  data: null,
                  reason: null,
                  invocation: null,
                  revert: null,
                  transaction: { to: receipt.to, from: receipt.from, data: "" },
                  receipt: receipt,
                }
              );
            };
            const receipt = await this.provider.getTransactionReceipt(
              this.hash
            );
            if (confirms === 0) {
              return checkReceipt(receipt);
            }
            if (receipt) {
              if ((await receipt.confirmations()) >= confirms) {
                return checkReceipt(receipt);
              }
            } else {
              await checkReplacement();
              if (confirms === 0) {
                return null;
              }
            }
            const waiter = new Promise((resolve, reject) => {
              const cancellers = [];
              const cancel = () => {
                cancellers.forEach((c) => c());
              };
              cancellers.push(() => {
                stopScanning = true;
              });
              if (timeout > 0) {
                const timer = setTimeout(() => {
                  cancel();
                  reject(makeError("wait for transaction timeout", "TIMEOUT"));
                }, timeout);
                cancellers.push(() => {
                  clearTimeout(timer);
                });
              }
              const txListener = async (receipt) => {
                if ((await receipt.confirmations()) >= confirms) {
                  cancel();
                  try {
                    resolve(checkReceipt(receipt));
                  } catch (error) {
                    reject(error);
                  }
                }
              };
              cancellers.push(() => {
                this.provider.off(this.hash, txListener);
              });
              this.provider.on(this.hash, txListener);
              if (startBlock >= 0) {
                const replaceListener = async () => {
                  try {
                    await checkReplacement();
                  } catch (error) {
                    if (isError(error, "TRANSACTION_REPLACED")) {
                      cancel();
                      reject(error);
                      return;
                    }
                  }
                  if (!stopScanning) {
                    this.provider.once("block", replaceListener);
                  }
                };
                cancellers.push(() => {
                  this.provider.off("block", replaceListener);
                });
                this.provider.once("block", replaceListener);
              }
            });
            return await waiter;
          }
          isMined() {
            return this.blockHash != null;
          }
          isLegacy() {
            return this.type === 0;
          }
          isBerlin() {
            return this.type === 1;
          }
          isLondon() {
            return this.type === 2;
          }
          removedEvent() {
            assert$1(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            );
            return createRemovedTransactionFilter(this);
          }
          reorderedEvent(other) {
            assert$1(
              this.isMined(),
              "unmined transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            );
            assert$1(
              !other || other.isMined(),
              "unmined 'other' transaction canot be orphaned",
              "UNSUPPORTED_OPERATION",
              { operation: "removeEvent()" }
            );
            return createReorderedTransactionFilter(this, other);
          }
          replaceableTransaction(startBlock) {
            assertArgument(
              Number.isInteger(startBlock) && startBlock >= 0,
              "invalid startBlock",
              "startBlock",
              startBlock
            );
            const tx = new TransactionResponse(this, this.provider);
            tx.#startBlock = startBlock;
            return tx;
          }
        }
        function createOrphanedBlockFilter(block) {
          return {
            orphan: "drop-block",
            hash: block.hash,
            number: block.number,
          };
        }
        function createReorderedTransactionFilter(tx, other) {
          return { orphan: "reorder-transaction", tx: tx, other: other };
        }
        function createRemovedTransactionFilter(tx) {
          return { orphan: "drop-transaction", tx: tx };
        }
        function createRemovedLogFilter(log) {
          return {
            orphan: "drop-log",
            log: {
              transactionHash: log.transactionHash,
              blockHash: log.blockHash,
              blockNumber: log.blockNumber,
              address: log.address,
              data: log.data,
              topics: Object.freeze(log.topics.slice()),
              index: log.index,
            },
          };
        }
        class EventLog extends Log {
          interface;
          fragment;
          args;
          constructor(log, iface, fragment) {
            super(log, log.provider);
            const args = iface.decodeEventLog(fragment, log.data, log.topics);
            defineProperties(this, {
              args: args,
              fragment: fragment,
              interface: iface,
            });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        class UndecodedEventLog extends Log {
          error;
          constructor(log, error) {
            super(log, log.provider);
            defineProperties(this, { error: error });
          }
        }
        class ContractTransactionReceipt extends TransactionReceipt {
          #iface;
          constructor(iface, provider, tx) {
            super(tx, provider);
            this.#iface = iface;
          }
          get logs() {
            return super.logs.map((log) => {
              const fragment = log.topics.length
                ? this.#iface.getEvent(log.topics[0])
                : null;
              if (fragment) {
                try {
                  return new EventLog(log, this.#iface, fragment);
                } catch (error) {
                  return new UndecodedEventLog(log, error);
                }
              }
              return log;
            });
          }
        }
        class ContractTransactionResponse extends TransactionResponse {
          #iface;
          constructor(iface, provider, tx) {
            super(tx, provider);
            this.#iface = iface;
          }
          async wait(confirms) {
            const receipt = await super.wait(confirms);
            if (receipt == null) {
              return null;
            }
            return new ContractTransactionReceipt(
              this.#iface,
              this.provider,
              receipt
            );
          }
        }
        class ContractUnknownEventPayload extends EventPayload {
          log;
          constructor(contract, listener, filter, log) {
            super(contract, listener, filter);
            defineProperties(this, { log: log });
          }
          async getBlock() {
            return await this.log.getBlock();
          }
          async getTransaction() {
            return await this.log.getTransaction();
          }
          async getTransactionReceipt() {
            return await this.log.getTransactionReceipt();
          }
        }
        class ContractEventPayload extends ContractUnknownEventPayload {
          constructor(contract, listener, filter, fragment, _log) {
            super(
              contract,
              listener,
              filter,
              new EventLog(_log, contract.interface, fragment)
            );
            const args = contract.interface.decodeEventLog(
              fragment,
              this.log.data,
              this.log.topics
            );
            defineProperties(this, { args: args, fragment: fragment });
          }
          get eventName() {
            return this.fragment.name;
          }
          get eventSignature() {
            return this.fragment.format();
          }
        }
        const BN_0$1 = BigInt(0);
        function canCall(value) {
          return value && typeof value.call === "function";
        }
        function canEstimate(value) {
          return value && typeof value.estimateGas === "function";
        }
        function canResolve(value) {
          return value && typeof value.resolveName === "function";
        }
        function canSend(value) {
          return value && typeof value.sendTransaction === "function";
        }
        class PreparedTopicFilter {
          #filter;
          fragment;
          constructor(contract, fragment, args) {
            defineProperties(this, { fragment: fragment });
            if (fragment.inputs.length < args.length) {
              throw new Error("too many arguments");
            }
            const runner = getRunner(contract.runner, "resolveName");
            const resolver = canResolve(runner) ? runner : null;
            this.#filter = (async function () {
              const resolvedArgs = await Promise.all(
                fragment.inputs.map((param, index) => {
                  const arg = args[index];
                  if (arg == null) {
                    return null;
                  }
                  return param.walkAsync(args[index], (type, value) => {
                    if (type === "address") {
                      if (Array.isArray(value)) {
                        return Promise.all(
                          value.map((v) => resolveAddress(v, resolver))
                        );
                      }
                      return resolveAddress(value, resolver);
                    }
                    return value;
                  });
                })
              );
              return contract.interface.encodeFilterTopics(
                fragment,
                resolvedArgs
              );
            })();
          }
          getTopicFilter() {
            return this.#filter;
          }
        }
        function getRunner(value, feature) {
          if (value == null) {
            return null;
          }
          if (typeof value[feature] === "function") {
            return value;
          }
          if (value.provider && typeof value.provider[feature] === "function") {
            return value.provider;
          }
          return null;
        }
        function getProvider(value) {
          if (value == null) {
            return null;
          }
          return value.provider || null;
        }
        async function copyOverrides(arg, allowed) {
          const _overrides = Typed.dereference(arg, "overrides");
          assertArgument(
            typeof _overrides === "object",
            "invalid overrides parameter",
            "overrides",
            arg
          );
          const overrides = copyRequest(_overrides);
          assertArgument(
            overrides.to == null || (allowed || []).indexOf("to") >= 0,
            "cannot override to",
            "overrides.to",
            overrides.to
          );
          assertArgument(
            overrides.data == null || (allowed || []).indexOf("data") >= 0,
            "cannot override data",
            "overrides.data",
            overrides.data
          );
          if (overrides.from) {
            overrides.from = await resolveAddress(overrides.from);
          }
          return overrides;
        }
        async function resolveArgs(_runner, inputs, args) {
          const runner = getRunner(_runner, "resolveName");
          const resolver = canResolve(runner) ? runner : null;
          return await Promise.all(
            inputs.map((param, index) => {
              return param.walkAsync(args[index], (type, value) => {
                value = Typed.dereference(value, type);
                if (type === "address") {
                  return resolveAddress(value, resolver);
                }
                return value;
              });
            })
          );
        }
        function buildWrappedFallback(contract) {
          const populateTransaction = async function (overrides) {
            const tx = await copyOverrides(overrides, ["data"]);
            tx.to = await contract.getAddress();
            const iface = contract.interface;
            const noValue =
              getBigInt(tx.value || BN_0$1, "overrides.value") === BN_0$1;
            const noData = (tx.data || "0x") === "0x";
            if (
              iface.fallback &&
              !iface.fallback.payable &&
              iface.receive &&
              !noData &&
              !noValue
            ) {
              assertArgument(
                false,
                "cannot send data to receive or send value to non-payable fallback",
                "overrides",
                overrides
              );
            }
            assertArgument(
              iface.fallback || noData,
              "cannot send data to receive-only contract",
              "overrides.data",
              tx.data
            );
            const payable =
              iface.receive || (iface.fallback && iface.fallback.payable);
            assertArgument(
              payable || noValue,
              "cannot send value to non-payable fallback",
              "overrides.value",
              tx.value
            );
            assertArgument(
              iface.fallback || noData,
              "cannot send data to receive-only contract",
              "overrides.data",
              tx.data
            );
            return tx;
          };
          const staticCall = async function (overrides) {
            const runner = getRunner(contract.runner, "call");
            assert$1(
              canCall(runner),
              "contract runner does not support calling",
              "UNSUPPORTED_OPERATION",
              { operation: "call" }
            );
            const tx = await populateTransaction(overrides);
            try {
              return await runner.call(tx);
            } catch (error) {
              if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
              }
              throw error;
            }
          };
          const send = async function (overrides) {
            const runner = contract.runner;
            assert$1(
              canSend(runner),
              "contract runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            const tx = await runner.sendTransaction(
              await populateTransaction(overrides)
            );
            const provider = getProvider(contract.runner);
            return new ContractTransactionResponse(
              contract.interface,
              provider,
              tx
            );
          };
          const estimateGas = async function (overrides) {
            const runner = getRunner(contract.runner, "estimateGas");
            assert$1(
              canEstimate(runner),
              "contract runner does not support gas estimation",
              "UNSUPPORTED_OPERATION",
              { operation: "estimateGas" }
            );
            return await runner.estimateGas(
              await populateTransaction(overrides)
            );
          };
          const method = async (overrides) => {
            return await send(overrides);
          };
          defineProperties(method, {
            _contract: contract,
            estimateGas: estimateGas,
            populateTransaction: populateTransaction,
            send: send,
            staticCall: staticCall,
          });
          return method;
        }
        function buildWrappedMethod(contract, key) {
          const getFragment = function (...args) {
            const fragment = contract.interface.getFunction(key, args);
            assert$1(
              fragment,
              "no matching fragment",
              "UNSUPPORTED_OPERATION",
              { operation: "fragment", info: { key: key, args: args } }
            );
            return fragment;
          };
          const populateTransaction = async function (...args) {
            const fragment = getFragment(...args);
            let overrides = {};
            if (fragment.inputs.length + 1 === args.length) {
              overrides = await copyOverrides(args.pop());
            }
            if (fragment.inputs.length !== args.length) {
              throw new Error(
                "internal error: fragment inputs doesn't match arguments; should not happen"
              );
            }
            const resolvedArgs = await resolveArgs(
              contract.runner,
              fragment.inputs,
              args
            );
            return Object.assign(
              {},
              overrides,
              await resolveProperties({
                to: contract.getAddress(),
                data: contract.interface.encodeFunctionData(
                  fragment,
                  resolvedArgs
                ),
              })
            );
          };
          const staticCall = async function (...args) {
            const result = await staticCallResult(...args);
            if (result.length === 1) {
              return result[0];
            }
            return result;
          };
          const send = async function (...args) {
            const runner = contract.runner;
            assert$1(
              canSend(runner),
              "contract runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            const tx = await runner.sendTransaction(
              await populateTransaction(...args)
            );
            const provider = getProvider(contract.runner);
            return new ContractTransactionResponse(
              contract.interface,
              provider,
              tx
            );
          };
          const estimateGas = async function (...args) {
            const runner = getRunner(contract.runner, "estimateGas");
            assert$1(
              canEstimate(runner),
              "contract runner does not support gas estimation",
              "UNSUPPORTED_OPERATION",
              { operation: "estimateGas" }
            );
            return await runner.estimateGas(await populateTransaction(...args));
          };
          const staticCallResult = async function (...args) {
            const runner = getRunner(contract.runner, "call");
            assert$1(
              canCall(runner),
              "contract runner does not support calling",
              "UNSUPPORTED_OPERATION",
              { operation: "call" }
            );
            const tx = await populateTransaction(...args);
            let result = "0x";
            try {
              result = await runner.call(tx);
            } catch (error) {
              if (isCallException(error) && error.data) {
                throw contract.interface.makeError(error.data, tx);
              }
              throw error;
            }
            const fragment = getFragment(...args);
            return contract.interface.decodeFunctionResult(fragment, result);
          };
          const method = async (...args) => {
            const fragment = getFragment(...args);
            if (fragment.constant) {
              return await staticCall(...args);
            }
            return await send(...args);
          };
          defineProperties(method, {
            name: contract.interface.getFunctionName(key),
            _contract: contract,
            _key: key,
            getFragment: getFragment,
            estimateGas: estimateGas,
            populateTransaction: populateTransaction,
            send: send,
            staticCall: staticCall,
            staticCallResult: staticCallResult,
          });
          Object.defineProperty(method, "fragment", {
            configurable: false,
            enumerable: true,
            get: () => {
              const fragment = contract.interface.getFunction(key);
              assert$1(
                fragment,
                "no matching fragment",
                "UNSUPPORTED_OPERATION",
                { operation: "fragment", info: { key: key } }
              );
              return fragment;
            },
          });
          return method;
        }
        function buildWrappedEvent(contract, key) {
          const getFragment = function (...args) {
            const fragment = contract.interface.getEvent(key, args);
            assert$1(
              fragment,
              "no matching fragment",
              "UNSUPPORTED_OPERATION",
              { operation: "fragment", info: { key: key, args: args } }
            );
            return fragment;
          };
          const method = function (...args) {
            return new PreparedTopicFilter(
              contract,
              getFragment(...args),
              args
            );
          };
          defineProperties(method, {
            name: contract.interface.getEventName(key),
            _contract: contract,
            _key: key,
            getFragment: getFragment,
          });
          Object.defineProperty(method, "fragment", {
            configurable: false,
            enumerable: true,
            get: () => {
              const fragment = contract.interface.getEvent(key);
              assert$1(
                fragment,
                "no matching fragment",
                "UNSUPPORTED_OPERATION",
                { operation: "fragment", info: { key: key } }
              );
              return fragment;
            },
          });
          return method;
        }
        const internal = Symbol.for("_ethersInternal_contract");
        const internalValues = new WeakMap();
        function setInternal(contract, values) {
          internalValues.set(contract[internal], values);
        }
        function getInternal(contract) {
          return internalValues.get(contract[internal]);
        }
        function isDeferred(value) {
          return (
            value &&
            typeof value === "object" &&
            "getTopicFilter" in value &&
            typeof value.getTopicFilter === "function" &&
            value.fragment
          );
        }
        async function getSubInfo(contract, event) {
          let topics;
          let fragment = null;
          if (Array.isArray(event)) {
            const topicHashify = function (name) {
              if (isHexString(name, 32)) {
                return name;
              }
              const fragment = contract.interface.getEvent(name);
              assertArgument(fragment, "unknown fragment", "name", name);
              return fragment.topicHash;
            };
            topics = event.map((e) => {
              if (e == null) {
                return null;
              }
              if (Array.isArray(e)) {
                return e.map(topicHashify);
              }
              return topicHashify(e);
            });
          } else if (event === "*") {
            topics = [null];
          } else if (typeof event === "string") {
            if (isHexString(event, 32)) {
              topics = [event];
            } else {
              fragment = contract.interface.getEvent(event);
              assertArgument(fragment, "unknown fragment", "event", event);
              topics = [fragment.topicHash];
            }
          } else if (isDeferred(event)) {
            topics = await event.getTopicFilter();
          } else if ("fragment" in event) {
            fragment = event.fragment;
            topics = [fragment.topicHash];
          } else {
            assertArgument(false, "unknown event name", "event", event);
          }
          topics = topics.map((t) => {
            if (t == null) {
              return null;
            }
            if (Array.isArray(t)) {
              const items = Array.from(
                new Set(t.map((t) => t.toLowerCase())).values()
              );
              if (items.length === 1) {
                return items[0];
              }
              items.sort();
              return items;
            }
            return t.toLowerCase();
          });
          const tag = topics
            .map((t) => {
              if (t == null) {
                return "null";
              }
              if (Array.isArray(t)) {
                return t.join("|");
              }
              return t;
            })
            .join("&");
          return { fragment: fragment, tag: tag, topics: topics };
        }
        async function hasSub(contract, event) {
          const { subs } = getInternal(contract);
          return subs.get((await getSubInfo(contract, event)).tag) || null;
        }
        async function getSub(contract, operation, event) {
          const provider = getProvider(contract.runner);
          assert$1(
            provider,
            "contract runner does not support subscribing",
            "UNSUPPORTED_OPERATION",
            { operation: operation }
          );
          const { fragment, tag, topics } = await getSubInfo(contract, event);
          const { addr, subs } = getInternal(contract);
          let sub = subs.get(tag);
          if (!sub) {
            const address = addr ? addr : contract;
            const filter = { address: address, topics: topics };
            const listener = (log) => {
              let foundFragment = fragment;
              if (foundFragment == null) {
                try {
                  foundFragment = contract.interface.getEvent(log.topics[0]);
                } catch (error) {}
              }
              if (foundFragment) {
                const _foundFragment = foundFragment;
                const args = fragment
                  ? contract.interface.decodeEventLog(
                      fragment,
                      log.data,
                      log.topics
                    )
                  : [];
                emit(contract, event, args, (listener) => {
                  return new ContractEventPayload(
                    contract,
                    listener,
                    event,
                    _foundFragment,
                    log
                  );
                });
              } else {
                emit(contract, event, [], (listener) => {
                  return new ContractUnknownEventPayload(
                    contract,
                    listener,
                    event,
                    log
                  );
                });
              }
            };
            let starting = [];
            const start = () => {
              if (starting.length) {
                return;
              }
              starting.push(provider.on(filter, listener));
            };
            const stop = async () => {
              if (starting.length == 0) {
                return;
              }
              let started = starting;
              starting = [];
              await Promise.all(started);
              provider.off(filter, listener);
            };
            sub = { tag: tag, listeners: [], start: start, stop: stop };
            subs.set(tag, sub);
          }
          return sub;
        }
        let lastEmit = Promise.resolve();
        async function _emit(contract, event, args, payloadFunc) {
          await lastEmit;
          const sub = await hasSub(contract, event);
          if (!sub) {
            return false;
          }
          const count = sub.listeners.length;
          sub.listeners = sub.listeners.filter(({ listener, once }) => {
            const passArgs = Array.from(args);
            if (payloadFunc) {
              passArgs.push(payloadFunc(once ? null : listener));
            }
            try {
              listener.call(contract, ...passArgs);
            } catch (error) {}
            return !once;
          });
          if (sub.listeners.length === 0) {
            sub.stop();
            getInternal(contract).subs.delete(sub.tag);
          }
          return count > 0;
        }
        async function emit(contract, event, args, payloadFunc) {
          try {
            await lastEmit;
          } catch (error) {}
          const resultPromise = _emit(contract, event, args, payloadFunc);
          lastEmit = resultPromise;
          return await resultPromise;
        }
        const passProperties = ["then"];
        class BaseContract {
          target;
          interface;
          runner;
          filters;
          [internal];
          fallback;
          constructor(target, abi, runner, _deployTx) {
            assertArgument(
              typeof target === "string" || isAddressable(target),
              "invalid value for Contract target",
              "target",
              target
            );
            if (runner == null) {
              runner = null;
            }
            const iface = Interface.from(abi);
            defineProperties(this, {
              target: target,
              runner: runner,
              interface: iface,
            });
            Object.defineProperty(this, internal, { value: {} });
            let addrPromise;
            let addr = null;
            let deployTx = null;
            if (_deployTx) {
              const provider = getProvider(runner);
              deployTx = new ContractTransactionResponse(
                this.interface,
                provider,
                _deployTx
              );
            }
            let subs = new Map();
            if (typeof target === "string") {
              if (isHexString(target)) {
                addr = target;
                addrPromise = Promise.resolve(target);
              } else {
                const resolver = getRunner(runner, "resolveName");
                if (!canResolve(resolver)) {
                  throw makeError(
                    "contract runner does not support name resolution",
                    "UNSUPPORTED_OPERATION",
                    { operation: "resolveName" }
                  );
                }
                addrPromise = resolver.resolveName(target).then((addr) => {
                  if (addr == null) {
                    throw makeError(
                      "an ENS name used for a contract target must be correctly configured",
                      "UNCONFIGURED_NAME",
                      { value: target }
                    );
                  }
                  getInternal(this).addr = addr;
                  return addr;
                });
              }
            } else {
              addrPromise = target.getAddress().then((addr) => {
                if (addr == null) {
                  throw new Error("TODO");
                }
                getInternal(this).addr = addr;
                return addr;
              });
            }
            setInternal(this, {
              addrPromise: addrPromise,
              addr: addr,
              deployTx: deployTx,
              subs: subs,
            });
            const filters = new Proxy(
              {},
              {
                get: (target, prop, receiver) => {
                  if (
                    typeof prop === "symbol" ||
                    passProperties.indexOf(prop) >= 0
                  ) {
                    return Reflect.get(target, prop, receiver);
                  }
                  try {
                    return this.getEvent(prop);
                  } catch (error) {
                    if (
                      !isError(error, "INVALID_ARGUMENT") ||
                      error.argument !== "key"
                    ) {
                      throw error;
                    }
                  }
                  return undefined;
                },
                has: (target, prop) => {
                  if (passProperties.indexOf(prop) >= 0) {
                    return Reflect.has(target, prop);
                  }
                  return (
                    Reflect.has(target, prop) ||
                    this.interface.hasEvent(String(prop))
                  );
                },
              }
            );
            defineProperties(this, { filters: filters });
            defineProperties(this, {
              fallback:
                iface.receive || iface.fallback
                  ? buildWrappedFallback(this)
                  : null,
            });
            return new Proxy(this, {
              get: (target, prop, receiver) => {
                if (
                  typeof prop === "symbol" ||
                  prop in target ||
                  passProperties.indexOf(prop) >= 0
                ) {
                  return Reflect.get(target, prop, receiver);
                }
                try {
                  return target.getFunction(prop);
                } catch (error) {
                  if (
                    !isError(error, "INVALID_ARGUMENT") ||
                    error.argument !== "key"
                  ) {
                    throw error;
                  }
                }
                return undefined;
              },
              has: (target, prop) => {
                if (
                  typeof prop === "symbol" ||
                  prop in target ||
                  passProperties.indexOf(prop) >= 0
                ) {
                  return Reflect.has(target, prop);
                }
                return target.interface.hasFunction(prop);
              },
            });
          }
          connect(runner) {
            return new BaseContract(this.target, this.interface, runner);
          }
          attach(target) {
            return new BaseContract(target, this.interface, this.runner);
          }
          async getAddress() {
            return await getInternal(this).addrPromise;
          }
          async getDeployedCode() {
            const provider = getProvider(this.runner);
            assert$1(
              provider,
              "runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "getDeployedCode" }
            );
            const code = await provider.getCode(await this.getAddress());
            if (code === "0x") {
              return null;
            }
            return code;
          }
          async waitForDeployment() {
            const deployTx = this.deploymentTransaction();
            if (deployTx) {
              await deployTx.wait();
              return this;
            }
            const code = await this.getDeployedCode();
            if (code != null) {
              return this;
            }
            const provider = getProvider(this.runner);
            assert$1(
              provider != null,
              "contract runner does not support .provider",
              "UNSUPPORTED_OPERATION",
              { operation: "waitForDeployment" }
            );
            return new Promise((resolve, reject) => {
              const checkCode = async () => {
                try {
                  const code = await this.getDeployedCode();
                  if (code != null) {
                    return resolve(this);
                  }
                  provider.once("block", checkCode);
                } catch (error) {
                  reject(error);
                }
              };
              checkCode();
            });
          }
          deploymentTransaction() {
            return getInternal(this).deployTx;
          }
          getFunction(key) {
            if (typeof key !== "string") {
              key = key.format();
            }
            const func = buildWrappedMethod(this, key);
            return func;
          }
          getEvent(key) {
            if (typeof key !== "string") {
              key = key.format();
            }
            return buildWrappedEvent(this, key);
          }
          async queryTransaction(hash) {
            throw new Error("@TODO");
          }
          async queryFilter(event, fromBlock, toBlock) {
            if (fromBlock == null) {
              fromBlock = 0;
            }
            if (toBlock == null) {
              toBlock = "latest";
            }
            const { addr, addrPromise } = getInternal(this);
            const address = addr ? addr : await addrPromise;
            const { fragment, topics } = await getSubInfo(this, event);
            const filter = {
              address: address,
              topics: topics,
              fromBlock: fromBlock,
              toBlock: toBlock,
            };
            const provider = getProvider(this.runner);
            assert$1(
              provider,
              "contract runner does not have a provider",
              "UNSUPPORTED_OPERATION",
              { operation: "queryFilter" }
            );
            return (await provider.getLogs(filter)).map((log) => {
              let foundFragment = fragment;
              if (foundFragment == null) {
                try {
                  foundFragment = this.interface.getEvent(log.topics[0]);
                } catch (error) {}
              }
              if (foundFragment) {
                try {
                  return new EventLog(log, this.interface, foundFragment);
                } catch (error) {
                  return new UndecodedEventLog(log, error);
                }
              }
              return new Log(log, provider);
            });
          }
          async on(event, listener) {
            const sub = await getSub(this, "on", event);
            sub.listeners.push({ listener: listener, once: false });
            sub.start();
            return this;
          }
          async once(event, listener) {
            const sub = await getSub(this, "once", event);
            sub.listeners.push({ listener: listener, once: true });
            sub.start();
            return this;
          }
          async emit(event, ...args) {
            return await emit(this, event, args, null);
          }
          async listenerCount(event) {
            if (event) {
              const sub = await hasSub(this, event);
              if (!sub) {
                return 0;
              }
              return sub.listeners.length;
            }
            const { subs } = getInternal(this);
            let total = 0;
            for (const { listeners } of subs.values()) {
              total += listeners.length;
            }
            return total;
          }
          async listeners(event) {
            if (event) {
              const sub = await hasSub(this, event);
              if (!sub) {
                return [];
              }
              return sub.listeners.map(({ listener }) => listener);
            }
            const { subs } = getInternal(this);
            let result = [];
            for (const { listeners } of subs.values()) {
              result = result.concat(listeners.map(({ listener }) => listener));
            }
            return result;
          }
          async off(event, listener) {
            const sub = await hasSub(this, event);
            if (!sub) {
              return this;
            }
            if (listener) {
              const index = sub.listeners
                .map(({ listener }) => listener)
                .indexOf(listener);
              if (index >= 0) {
                sub.listeners.splice(index, 1);
              }
            }
            if (listener == null || sub.listeners.length === 0) {
              sub.stop();
              getInternal(this).subs.delete(sub.tag);
            }
            return this;
          }
          async removeAllListeners(event) {
            if (event) {
              const sub = await hasSub(this, event);
              if (!sub) {
                return this;
              }
              sub.stop();
              getInternal(this).subs.delete(sub.tag);
            } else {
              const { subs } = getInternal(this);
              for (const { tag, stop } of subs.values()) {
                stop();
                subs.delete(tag);
              }
            }
            return this;
          }
          async addListener(event, listener) {
            return await this.on(event, listener);
          }
          async removeListener(event, listener) {
            return await this.off(event, listener);
          }
          static buildClass(abi) {
            class CustomContract extends BaseContract {
              constructor(address, runner = null) {
                super(address, abi, runner);
              }
            }
            return CustomContract;
          }
          static from(target, abi, runner) {
            if (runner == null) {
              runner = null;
            }
            const contract = new this(target, abi, runner);
            return contract;
          }
        }
        function _ContractBase() {
          return BaseContract;
        }
        class Contract extends _ContractBase() {}
        class ContractFactory {
          interface;
          bytecode;
          runner;
          constructor(abi, bytecode, runner) {
            const iface = Interface.from(abi);
            if (bytecode instanceof Uint8Array) {
              bytecode = hexlify(getBytes(bytecode));
            } else {
              if (typeof bytecode === "object") {
                bytecode = bytecode.object;
              }
              if (!bytecode.startsWith("0x")) {
                bytecode = "0x" + bytecode;
              }
              bytecode = hexlify(getBytes(bytecode));
            }
            defineProperties(this, {
              bytecode: bytecode,
              interface: iface,
              runner: runner || null,
            });
          }
          attach(target) {
            return new BaseContract(target, this.interface, this.runner);
          }
          async getDeployTransaction(...args) {
            let overrides = {};
            const fragment = this.interface.deploy;
            if (fragment.inputs.length + 1 === args.length) {
              overrides = await copyOverrides(args.pop());
            }
            if (fragment.inputs.length !== args.length) {
              throw new Error("incorrect number of arguments to constructor");
            }
            const resolvedArgs = await resolveArgs(
              this.runner,
              fragment.inputs,
              args
            );
            const data = concat([
              this.bytecode,
              this.interface.encodeDeploy(resolvedArgs),
            ]);
            return Object.assign({}, overrides, { data: data });
          }
          async deploy(...args) {
            const tx = await this.getDeployTransaction(...args);
            assert$1(
              this.runner && typeof this.runner.sendTransaction === "function",
              "factory runner does not support sending transactions",
              "UNSUPPORTED_OPERATION",
              { operation: "sendTransaction" }
            );
            const sentTx = await this.runner.sendTransaction(tx);
            const address = getCreateAddress(sentTx);
            return new BaseContract(
              address,
              this.interface,
              this.runner,
              sentTx
            );
          }
          connect(runner) {
            return new ContractFactory(this.interface, this.bytecode, runner);
          }
          static fromSolidity(output, runner) {
            assertArgument(
              output != null,
              "bad compiler output",
              "output",
              output
            );
            if (typeof output === "string") {
              output = JSON.parse(output);
            }
            const abi = output.abi;
            let bytecode = "";
            if (output.bytecode) {
              bytecode = output.bytecode;
            } else if (output.evm && output.evm.bytecode) {
              bytecode = output.evm.bytecode;
            }
            return new this(abi, bytecode, runner);
          }
        }
        function getIpfsLink(link) {
          if (link.match(/^ipfs:\/\/ipfs\//i)) {
            link = link.substring(12);
          } else if (link.match(/^ipfs:\/\//i)) {
            link = link.substring(7);
          } else {
            assertArgument(false, "unsupported IPFS format", "link", link);
          }
          return `https:/\/gateway.ipfs.io/ipfs/${link}`;
        }
        class MulticoinProviderPlugin {
          name;
          constructor(name) {
            defineProperties(this, { name: name });
          }
          connect(proivder) {
            return this;
          }
          supportsCoinType(coinType) {
            return false;
          }
          async encodeAddress(coinType, address) {
            throw new Error("unsupported coin");
          }
          async decodeAddress(coinType, data) {
            throw new Error("unsupported coin");
          }
        }
        const matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
        const matchers = [
          new RegExp("^(https)://(.*)$", "i"),
          new RegExp("^(data):(.*)$", "i"),
          matcherIpfs,
          new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
        ];
        class EnsResolver {
          provider;
          address;
          name;
          #supports2544;
          #resolver;
          constructor(provider, address, name) {
            defineProperties(this, {
              provider: provider,
              address: address,
              name: name,
            });
            this.#supports2544 = null;
            this.#resolver = new Contract(
              address,
              [
                "function supportsInterface(bytes4) view returns (bool)",
                "function resolve(bytes, bytes) view returns (bytes)",
                "function addr(bytes32) view returns (address)",
                "function addr(bytes32, uint) view returns (bytes)",
                "function text(bytes32, string) view returns (string)",
                "function contenthash(bytes32) view returns (bytes)",
              ],
              provider
            );
          }
          async supportsWildcard() {
            if (this.#supports2544 == null) {
              this.#supports2544 = (async () => {
                try {
                  return await this.#resolver.supportsInterface("0x9061b923");
                } catch (error) {
                  if (isError(error, "CALL_EXCEPTION")) {
                    return false;
                  }
                  this.#supports2544 = null;
                  throw error;
                }
              })();
            }
            return await this.#supports2544;
          }
          async #fetch(funcName, params) {
            params = (params || []).slice();
            const iface = this.#resolver.interface;
            params.unshift(namehash(this.name));
            let fragment = null;
            if (await this.supportsWildcard()) {
              fragment = iface.getFunction(funcName);
              assert$1(fragment, "missing fragment", "UNKNOWN_ERROR", {
                info: { funcName: funcName },
              });
              params = [
                dnsEncode(this.name),
                iface.encodeFunctionData(fragment, params),
              ];
              funcName = "resolve(bytes,bytes)";
            }
            params.push({ enableCcipRead: true });
            try {
              const result = await this.#resolver[funcName](...params);
              if (fragment) {
                return iface.decodeFunctionResult(fragment, result)[0];
              }
              return result;
            } catch (error) {
              if (!isError(error, "CALL_EXCEPTION")) {
                throw error;
              }
            }
            return null;
          }
          async getAddress(coinType) {
            if (coinType == null) {
              coinType = 60;
            }
            if (coinType === 60) {
              try {
                const result = await this.#fetch("addr(bytes32)");
                if (result == null || result === ZeroAddress) {
                  return null;
                }
                return result;
              } catch (error) {
                if (isError(error, "CALL_EXCEPTION")) {
                  return null;
                }
                throw error;
              }
            }
            if (coinType >= 0 && coinType < 2147483648) {
              let ethCoinType = coinType + 2147483648;
              const data = await this.#fetch("addr(bytes32,uint)", [
                ethCoinType,
              ]);
              if (isHexString(data, 20)) {
                return getAddress(data);
              }
            }
            let coinPlugin = null;
            for (const plugin of this.provider.plugins) {
              if (!(plugin instanceof MulticoinProviderPlugin)) {
                continue;
              }
              if (plugin.supportsCoinType(coinType)) {
                coinPlugin = plugin;
                break;
              }
            }
            if (coinPlugin == null) {
              return null;
            }
            const data = await this.#fetch("addr(bytes32,uint)", [coinType]);
            if (data == null || data === "0x") {
              return null;
            }
            const address = await coinPlugin.decodeAddress(coinType, data);
            if (address != null) {
              return address;
            }
            assert$1(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
              operation: `getAddress(${coinType})`,
              info: { coinType: coinType, data: data },
            });
          }
          async getText(key) {
            const data = await this.#fetch("text(bytes32,string)", [key]);
            if (data == null || data === "0x") {
              return null;
            }
            return data;
          }
          async getContentHash() {
            const data = await this.#fetch("contenthash(bytes32)");
            if (data == null || data === "0x") {
              return null;
            }
            const ipfs = data.match(
              /^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/
            );
            if (ipfs) {
              const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
              const length = parseInt(ipfs[4], 16);
              if (ipfs[5].length === length * 2) {
                return `${scheme}:/\/${encodeBase58("0x" + ipfs[2])}`;
              }
            }
            const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (swarm && swarm[1].length === 64) {
              return `bzz:/\/${swarm[1]}`;
            }
            assert$1(
              false,
              `invalid or unsupported content hash data`,
              "UNSUPPORTED_OPERATION",
              { operation: "getContentHash()", info: { data: data } }
            );
          }
          async getAvatar() {
            const avatar = await this._getAvatar();
            return avatar.url;
          }
          async _getAvatar() {
            const linkage = [{ type: "name", value: this.name }];
            try {
              const avatar = await this.getText("avatar");
              if (avatar == null) {
                linkage.push({ type: "!avatar", value: "" });
                return { url: null, linkage: linkage };
              }
              linkage.push({ type: "avatar", value: avatar });
              for (let i = 0; i < matchers.length; i++) {
                const match = avatar.match(matchers[i]);
                if (match == null) {
                  continue;
                }
                const scheme = match[1].toLowerCase();
                switch (scheme) {
                  case "https":
                  case "data":
                    linkage.push({ type: "url", value: avatar });
                    return { linkage: linkage, url: avatar };
                  case "ipfs": {
                    const url = getIpfsLink(avatar);
                    linkage.push({ type: "ipfs", value: avatar });
                    linkage.push({ type: "url", value: url });
                    return { linkage: linkage, url: url };
                  }
                  case "erc721":
                  case "erc1155": {
                    const selector =
                      scheme === "erc721"
                        ? "tokenURI(uint256)"
                        : "uri(uint256)";
                    linkage.push({ type: scheme, value: avatar });
                    const owner = await this.getAddress();
                    if (owner == null) {
                      linkage.push({ type: "!owner", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    const comps = (match[2] || "").split("/");
                    if (comps.length !== 2) {
                      linkage.push({
                        type: `!${scheme}caip`,
                        value: match[2] || "",
                      });
                      return { url: null, linkage: linkage };
                    }
                    const tokenId = comps[1];
                    const contract = new Contract(
                      comps[0],
                      [
                        "function tokenURI(uint) view returns (string)",
                        "function ownerOf(uint) view returns (address)",
                        "function uri(uint) view returns (string)",
                        "function balanceOf(address, uint256) view returns (uint)",
                      ],
                      this.provider
                    );
                    if (scheme === "erc721") {
                      const tokenOwner = await contract.ownerOf(tokenId);
                      if (owner !== tokenOwner) {
                        linkage.push({ type: "!owner", value: tokenOwner });
                        return { url: null, linkage: linkage };
                      }
                      linkage.push({ type: "owner", value: tokenOwner });
                    } else if (scheme === "erc1155") {
                      const balance = await contract.balanceOf(owner, tokenId);
                      if (!balance) {
                        linkage.push({ type: "!balance", value: "0" });
                        return { url: null, linkage: linkage };
                      }
                      linkage.push({
                        type: "balance",
                        value: balance.toString(),
                      });
                    }
                    let metadataUrl = await contract[selector](tokenId);
                    if (metadataUrl == null || metadataUrl === "0x") {
                      linkage.push({ type: "!metadata-url", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    linkage.push({
                      type: "metadata-url-base",
                      value: metadataUrl,
                    });
                    if (scheme === "erc1155") {
                      metadataUrl = metadataUrl.replace(
                        "{id}",
                        toBeHex(tokenId, 32).substring(2)
                      );
                      linkage.push({
                        type: "metadata-url-expanded",
                        value: metadataUrl,
                      });
                    }
                    if (metadataUrl.match(/^ipfs:/i)) {
                      metadataUrl = getIpfsLink(metadataUrl);
                    }
                    linkage.push({ type: "metadata-url", value: metadataUrl });
                    let metadata = {};
                    const response = await new FetchRequest(metadataUrl).send();
                    response.assertOk();
                    try {
                      metadata = response.bodyJson;
                    } catch (error) {
                      try {
                        linkage.push({
                          type: "!metadata",
                          value: response.bodyText,
                        });
                      } catch (error) {
                        const bytes = response.body;
                        if (bytes) {
                          linkage.push({
                            type: "!metadata",
                            value: hexlify(bytes),
                          });
                        }
                        return { url: null, linkage: linkage };
                      }
                      return { url: null, linkage: linkage };
                    }
                    if (!metadata) {
                      linkage.push({ type: "!metadata", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    linkage.push({
                      type: "metadata",
                      value: JSON.stringify(metadata),
                    });
                    let imageUrl = metadata.image;
                    if (typeof imageUrl !== "string") {
                      linkage.push({ type: "!imageUrl", value: "" });
                      return { url: null, linkage: linkage };
                    }
                    if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                    } else {
                      const ipfs = imageUrl.match(matcherIpfs);
                      if (ipfs == null) {
                        linkage.push({
                          type: "!imageUrl-ipfs",
                          value: imageUrl,
                        });
                        return { url: null, linkage: linkage };
                      }
                      linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                      imageUrl = getIpfsLink(imageUrl);
                    }
                    linkage.push({ type: "url", value: imageUrl });
                    return { linkage: linkage, url: imageUrl };
                  }
                }
              }
            } catch (error) {}
            return { linkage: linkage, url: null };
          }
          static async getEnsAddress(provider) {
            const network = await provider.getNetwork();
            const ensPlugin = network.getPlugin(
              "org.ethers.plugins.network.Ens"
            );
            assert$1(
              ensPlugin,
              "network does not support ENS",
              "UNSUPPORTED_OPERATION",
              { operation: "getEnsAddress", info: { network: network } }
            );
            return ensPlugin.address;
          }
          static async #getResolver(provider, name) {
            const ensAddr = await EnsResolver.getEnsAddress(provider);
            try {
              const contract = new Contract(
                ensAddr,
                ["function resolver(bytes32) view returns (address)"],
                provider
              );
              const addr = await contract.resolver(namehash(name), {
                enableCcipRead: true,
              });
              if (addr === ZeroAddress) {
                return null;
              }
              return addr;
            } catch (error) {
              throw error;
            }
            return null;
          }
          static async fromName(provider, name) {
            let currentName = name;
            while (true) {
              if (currentName === "" || currentName === ".") {
                return null;
              }
              if (name !== "eth" && currentName === "eth") {
                return null;
              }
              const addr = await EnsResolver.#getResolver(
                provider,
                currentName
              );
              if (addr != null) {
                const resolver = new EnsResolver(provider, addr, name);
                if (
                  currentName !== name &&
                  !(await resolver.supportsWildcard())
                ) {
                  return null;
                }
                return resolver;
              }
              currentName = currentName.split(".").slice(1).join(".");
            }
          }
        }
        const BN_0 = BigInt(0);
        function allowNull(format, nullValue) {
          return function (value) {
            if (value == null) {
              return nullValue;
            }
            return format(value);
          };
        }
        function arrayOf(format) {
          return (array) => {
            if (!Array.isArray(array)) {
              throw new Error("not an array");
            }
            return array.map((i) => format(i));
          };
        }
        function object(format, altNames) {
          return (value) => {
            const result = {};
            for (const key in format) {
              let srcKey = key;
              if (altNames && key in altNames && !(srcKey in value)) {
                for (const altKey of altNames[key]) {
                  if (altKey in value) {
                    srcKey = altKey;
                    break;
                  }
                }
              }
              try {
                const nv = format[key](value[srcKey]);
                if (nv !== undefined) {
                  result[key] = nv;
                }
              } catch (error) {
                const message =
                  error instanceof Error ? error.message : "not-an-error";
                assert$1(
                  false,
                  `invalid value for value.${key} (${message})`,
                  "BAD_DATA",
                  { value: value }
                );
              }
            }
            return result;
          };
        }
        function formatBoolean(value) {
          switch (value) {
            case true:
            case "true":
              return true;
            case false:
            case "false":
              return false;
          }
          assertArgument(
            false,
            `invalid boolean; ${JSON.stringify(value)}`,
            "value",
            value
          );
        }
        function formatData(value) {
          assertArgument(
            isHexString(value, true),
            "invalid data",
            "value",
            value
          );
          return value;
        }
        function formatHash(value) {
          assertArgument(
            isHexString(value, 32),
            "invalid hash",
            "value",
            value
          );
          return value;
        }
        const _formatLog = object(
          {
            address: getAddress,
            blockHash: formatHash,
            blockNumber: getNumber,
            data: formatData,
            index: getNumber,
            removed: allowNull(formatBoolean, false),
            topics: arrayOf(formatHash),
            transactionHash: formatHash,
            transactionIndex: getNumber,
          },
          { index: ["logIndex"] }
        );
        function formatLog(value) {
          return _formatLog(value);
        }
        const _formatBlock = object({
          hash: allowNull(formatHash),
          parentHash: formatHash,
          number: getNumber,
          timestamp: getNumber,
          nonce: allowNull(formatData),
          difficulty: getBigInt,
          gasLimit: getBigInt,
          gasUsed: getBigInt,
          miner: allowNull(getAddress),
          extraData: formatData,
          baseFeePerGas: allowNull(getBigInt),
        });
        function formatBlock(value) {
          const result = _formatBlock(value);
          result.transactions = value.transactions.map((tx) => {
            if (typeof tx === "string") {
              return tx;
            }
            return formatTransactionResponse(tx);
          });
          return result;
        }
        const _formatReceiptLog = object(
          {
            transactionIndex: getNumber,
            blockNumber: getNumber,
            transactionHash: formatHash,
            address: getAddress,
            topics: arrayOf(formatHash),
            data: formatData,
            index: getNumber,
            blockHash: formatHash,
          },
          { index: ["logIndex"] }
        );
        function formatReceiptLog(value) {
          return _formatReceiptLog(value);
        }
        const _formatTransactionReceipt = object(
          {
            to: allowNull(getAddress, null),
            from: allowNull(getAddress, null),
            contractAddress: allowNull(getAddress, null),
            index: getNumber,
            root: allowNull(hexlify),
            gasUsed: getBigInt,
            logsBloom: allowNull(formatData),
            blockHash: formatHash,
            hash: formatHash,
            logs: arrayOf(formatReceiptLog),
            blockNumber: getNumber,
            cumulativeGasUsed: getBigInt,
            effectiveGasPrice: allowNull(getBigInt),
            status: allowNull(getNumber),
            type: allowNull(getNumber, 0),
          },
          {
            effectiveGasPrice: ["gasPrice"],
            hash: ["transactionHash"],
            index: ["transactionIndex"],
          }
        );
        function formatTransactionReceipt(value) {
          return _formatTransactionReceipt(value);
        }
        function formatTransactionResponse(value) {
          if (value.to && getBigInt(value.to) === BN_0) {
            value.to = "0x0000000000000000000000000000000000000000";
          }
          const result = object(
            {
              hash: formatHash,
              type: (value) => {
                if (value === "0x" || value == null) {
                  return 0;
                }
                return getNumber(value);
              },
              accessList: allowNull(accessListify, null),
              blockHash: allowNull(formatHash, null),
              blockNumber: allowNull(getNumber, null),
              transactionIndex: allowNull(getNumber, null),
              from: getAddress,
              gasPrice: allowNull(getBigInt),
              maxPriorityFeePerGas: allowNull(getBigInt),
              maxFeePerGas: allowNull(getBigInt),
              gasLimit: getBigInt,
              to: allowNull(getAddress, null),
              value: getBigInt,
              nonce: getNumber,
              data: formatData,
              creates: allowNull(getAddress, null),
              chainId: allowNull(getBigInt, null),
            },
            { data: ["input"], gasLimit: ["gas"] }
          )(value);
          if (result.to == null && result.creates == null) {
            result.creates = getCreateAddress(result);
          }
          if (
            (value.type === 1 || value.type === 2) &&
            value.accessList == null
          ) {
            result.accessList = [];
          }
          if (value.signature) {
            result.signature = Signature.from(value.signature);
          } else {
            result.signature = Signature.from(value);
          }
          if (result.chainId == null) {
            const chainId = result.signature.legacyChainId;
            if (chainId != null) {
              result.chainId = chainId;
            }
          }
          if (result.blockHash && getBigInt(result.blockHash) === BN_0) {
            result.blockHash = null;
          }
          return result;
        }
        const EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
        class NetworkPlugin {
          name;
          constructor(name) {
            defineProperties(this, { name: name });
          }
          clone() {
            return new NetworkPlugin(this.name);
          }
        }
        class GasCostPlugin extends NetworkPlugin {
          effectiveBlock;
          txBase;
          txCreate;
          txDataZero;
          txDataNonzero;
          txAccessListStorageKey;
          txAccessListAddress;
          constructor(effectiveBlock, costs) {
            if (effectiveBlock == null) {
              effectiveBlock = 0;
            }
            super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
            const props = { effectiveBlock: effectiveBlock };
            function set(name, nullish) {
              let value = (costs || {})[name];
              if (value == null) {
                value = nullish;
              }
              assertArgument(
                typeof value === "number",
                `invalud value for ${name}`,
                "costs",
                costs
              );
              props[name] = value;
            }
            set("txBase", 21e3);
            set("txCreate", 32e3);
            set("txDataZero", 4);
            set("txDataNonzero", 16);
            set("txAccessListStorageKey", 1900);
            set("txAccessListAddress", 2400);
            defineProperties(this, props);
          }
          clone() {
            return new GasCostPlugin(this.effectiveBlock, this);
          }
        }
        class EnsPlugin extends NetworkPlugin {
          address;
          targetNetwork;
          constructor(address, targetNetwork) {
            super("org.ethers.plugins.network.Ens");
            defineProperties(this, {
              address: address || EnsAddress,
              targetNetwork: targetNetwork == null ? 1 : targetNetwork,
            });
          }
          clone() {
            return new EnsPlugin(this.address, this.targetNetwork);
          }
        }
        class FeeDataNetworkPlugin extends NetworkPlugin {
          #feeDataFunc;
          get feeDataFunc() {
            return this.#feeDataFunc;
          }
          constructor(feeDataFunc) {
            super("org.ethers.plugins.network.FeeData");
            this.#feeDataFunc = feeDataFunc;
          }
          async getFeeData(provider) {
            return await this.#feeDataFunc(provider);
          }
          clone() {
            return new FeeDataNetworkPlugin(this.#feeDataFunc);
          }
        }
        class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
          #url;
          #processFunc;
          get url() {
            return this.#url;
          }
          get processFunc() {
            return this.#processFunc;
          }
          constructor(url, processFunc) {
            super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
            this.#url = url;
            this.#processFunc = processFunc;
          }
          clone() {
            return this;
          }
        }
        const Networks = new Map();
        class Network {
          #name;
          #chainId;
          #plugins;
          constructor(name, chainId) {
            this.#name = name;
            this.#chainId = getBigInt(chainId);
            this.#plugins = new Map();
          }
          toJSON() {
            return { name: this.name, chainId: String(this.chainId) };
          }
          get name() {
            return this.#name;
          }
          set name(value) {
            this.#name = value;
          }
          get chainId() {
            return this.#chainId;
          }
          set chainId(value) {
            this.#chainId = getBigInt(value, "chainId");
          }
          matches(other) {
            if (other == null) {
              return false;
            }
            if (typeof other === "string") {
              try {
                return this.chainId === getBigInt(other);
              } catch (error) {}
              return this.name === other;
            }
            if (typeof other === "number" || typeof other === "bigint") {
              try {
                return this.chainId === getBigInt(other);
              } catch (error) {}
              return false;
            }
            if (typeof other === "object") {
              if (other.chainId != null) {
                try {
                  return this.chainId === getBigInt(other.chainId);
                } catch (error) {}
                return false;
              }
              if (other.name != null) {
                return this.name === other.name;
              }
              return false;
            }
            return false;
          }
          get plugins() {
            return Array.from(this.#plugins.values());
          }
          attachPlugin(plugin) {
            if (this.#plugins.get(plugin.name)) {
              throw new Error(
                `cannot replace existing plugin: ${plugin.name} `
              );
            }
            this.#plugins.set(plugin.name, plugin.clone());
            return this;
          }
          getPlugin(name) {
            return this.#plugins.get(name) || null;
          }
          getPlugins(basename) {
            return this.plugins.filter(
              (p) => p.name.split("#")[0] === basename
            );
          }
          clone() {
            const clone = new Network(this.name, this.chainId);
            this.plugins.forEach((plugin) => {
              clone.attachPlugin(plugin.clone());
            });
            return clone;
          }
          computeIntrinsicGas(tx) {
            const costs =
              this.getPlugin("org.ethers.plugins.network.GasCost") ||
              new GasCostPlugin();
            let gas = costs.txBase;
            if (tx.to == null) {
              gas += costs.txCreate;
            }
            if (tx.data) {
              for (let i = 2; i < tx.data.length; i += 2) {
                if (tx.data.substring(i, i + 2) === "00") {
                  gas += costs.txDataZero;
                } else {
                  gas += costs.txDataNonzero;
                }
              }
            }
            if (tx.accessList) {
              const accessList = accessListify(tx.accessList);
              for (const addr in accessList) {
                gas +=
                  costs.txAccessListAddress +
                  costs.txAccessListStorageKey *
                    accessList[addr].storageKeys.length;
              }
            }
            return gas;
          }
          static from(network) {
            injectCommonNetworks();
            if (network == null) {
              return Network.from("mainnet");
            }
            if (typeof network === "number") {
              network = BigInt(network);
            }
            if (typeof network === "string" || typeof network === "bigint") {
              const networkFunc = Networks.get(network);
              if (networkFunc) {
                return networkFunc();
              }
              if (typeof network === "bigint") {
                return new Network("unknown", network);
              }
              assertArgument(false, "unknown network", "network", network);
            }
            if (typeof network.clone === "function") {
              const clone = network.clone();
              return clone;
            }
            if (typeof network === "object") {
              assertArgument(
                typeof network.name === "string" &&
                  typeof network.chainId === "number",
                "invalid network object name or chainId",
                "network",
                network
              );
              const custom = new Network(network.name, network.chainId);
              if (network.ensAddress || network.ensNetwork != null) {
                custom.attachPlugin(
                  new EnsPlugin(network.ensAddress, network.ensNetwork)
                );
              }
              return custom;
            }
            assertArgument(false, "invalid network", "network", network);
          }
          static register(nameOrChainId, networkFunc) {
            if (typeof nameOrChainId === "number") {
              nameOrChainId = BigInt(nameOrChainId);
            }
            const existing = Networks.get(nameOrChainId);
            if (existing) {
              assertArgument(
                false,
                `conflicting network for ${JSON.stringify(existing.name)}`,
                "nameOrChainId",
                nameOrChainId
              );
            }
            Networks.set(nameOrChainId, networkFunc);
          }
        }
        function parseUnits(_value, decimals) {
          const value = String(_value);
          if (!value.match(/^[0-9.]+$/)) {
            throw new Error(`invalid gwei value: ${_value}`);
          }
          const comps = value.split(".");
          if (comps.length === 1) {
            comps.push("");
          }
          if (comps.length !== 2) {
            throw new Error(`invalid gwei value: ${_value}`);
          }
          while (comps[1].length < decimals) {
            comps[1] += "0";
          }
          if (comps[1].length > 9) {
            let frac = BigInt(comps[1].substring(0, 9));
            if (!comps[1].substring(9).match(/^0+$/)) {
              frac++;
            }
            comps[1] = frac.toString();
          }
          return BigInt(comps[0] + comps[1]);
        }
        function getGasStationPlugin(url) {
          return new FetchUrlFeeDataNetworkPlugin(
            url,
            async (fetchFeeData, provider, request) => {
              request.setHeader("User-Agent", "ethers");
              let response;
              try {
                response = await request.send();
                const payload = response.bodyJson.standard;
                const feeData = {
                  maxFeePerGas: parseUnits(payload.maxFee, 9),
                  maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9),
                };
                return feeData;
              } catch (error) {
                assert$1(
                  false,
                  `error encountered with polygon gas station (${JSON.stringify(
                    request.url
                  )})`,
                  "SERVER_ERROR",
                  { request: request, response: response, error: error }
                );
              }
            }
          );
        }
        function getPriorityFeePlugin(maxPriorityFeePerGas) {
          return new FetchUrlFeeDataNetworkPlugin(
            "data:",
            async (fetchFeeData, provider, request) => {
              const feeData = await fetchFeeData();
              if (
                feeData.maxFeePerGas == null ||
                feeData.maxPriorityFeePerGas == null
              ) {
                return feeData;
              }
              const baseFee =
                feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
              return {
                gasPrice: feeData.gasPrice,
                maxFeePerGas: baseFee + maxPriorityFeePerGas,
                maxPriorityFeePerGas: maxPriorityFeePerGas,
              };
            }
          );
        }
        let injected = false;
        function injectCommonNetworks() {
          if (injected) {
            return;
          }
          injected = true;
          function registerEth(name, chainId, options) {
            const func = function () {
              const network = new Network(name, chainId);
              if (options.ensNetwork != null) {
                network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
              }
              network.attachPlugin(new GasCostPlugin());
              (options.plugins || []).forEach((plugin) => {
                network.attachPlugin(plugin);
              });
              return network;
            };
            Network.register(name, func);
            Network.register(chainId, func);
            if (options.altNames) {
              options.altNames.forEach((name) => {
                Network.register(name, func);
              });
            }
          }
          registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
          registerEth("ropsten", 3, { ensNetwork: 3 });
          registerEth("rinkeby", 4, { ensNetwork: 4 });
          registerEth("goerli", 5, { ensNetwork: 5 });
          registerEth("kovan", 42, { ensNetwork: 42 });
          registerEth("sepolia", 11155111, {});
          registerEth("classic", 61, {});
          registerEth("classicKotti", 6, {});
          registerEth("arbitrum", 42161, { ensNetwork: 1 });
          registerEth("arbitrum-goerli", 421613, {});
          registerEth("bnb", 56, { ensNetwork: 1 });
          registerEth("bnbt", 97, {});
          registerEth("linea", 59144, { ensNetwork: 1 });
          registerEth("linea-goerli", 59140, {});
          registerEth("matic", 137, {
            ensNetwork: 1,
            plugins: [
              getGasStationPlugin("https://gasstation.polygon.technology/v2"),
            ],
          });
          registerEth("matic-mumbai", 80001, {
            altNames: ["maticMumbai", "maticmum"],
            plugins: [
              getGasStationPlugin(
                "https://gasstation-testnet.polygon.technology/v2"
              ),
            ],
          });
          registerEth("optimism", 10, {
            ensNetwork: 1,
            plugins: [getPriorityFeePlugin(BigInt("1000000"))],
          });
          registerEth("optimism-goerli", 420, {});
          registerEth("xdai", 100, { ensNetwork: 1 });
        }
        function copy$2(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        class PollingBlockSubscriber {
          #provider;
          #poller;
          #interval;
          #blockNumber;
          constructor(provider) {
            this.#provider = provider;
            this.#poller = null;
            this.#interval = 4e3;
            this.#blockNumber = -2;
          }
          get pollingInterval() {
            return this.#interval;
          }
          set pollingInterval(value) {
            this.#interval = value;
          }
          async #poll() {
            try {
              const blockNumber = await this.#provider.getBlockNumber();
              if (this.#blockNumber === -2) {
                this.#blockNumber = blockNumber;
                return;
              }
              if (blockNumber !== this.#blockNumber) {
                for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {
                  if (this.#poller == null) {
                    return;
                  }
                  await this.#provider.emit("block", b);
                }
                this.#blockNumber = blockNumber;
              }
            } catch (error) {}
            if (this.#poller == null) {
              return;
            }
            this.#poller = this.#provider._setTimeout(
              this.#poll.bind(this),
              this.#interval
            );
          }
          start() {
            if (this.#poller) {
              return;
            }
            this.#poller = this.#provider._setTimeout(
              this.#poll.bind(this),
              this.#interval
            );
            this.#poll();
          }
          stop() {
            if (!this.#poller) {
              return;
            }
            this.#provider._clearTimeout(this.#poller);
            this.#poller = null;
          }
          pause(dropWhilePaused) {
            this.stop();
            if (dropWhilePaused) {
              this.#blockNumber = -2;
            }
          }
          resume() {
            this.start();
          }
        }
        class OnBlockSubscriber {
          #provider;
          #poll;
          #running;
          constructor(provider) {
            this.#provider = provider;
            this.#running = false;
            this.#poll = (blockNumber) => {
              this._poll(blockNumber, this.#provider);
            };
          }
          async _poll(blockNumber, provider) {
            throw new Error("sub-classes must override this");
          }
          start() {
            if (this.#running) {
              return;
            }
            this.#running = true;
            this.#poll(-2);
            this.#provider.on("block", this.#poll);
          }
          stop() {
            if (!this.#running) {
              return;
            }
            this.#running = false;
            this.#provider.off("block", this.#poll);
          }
          pause(dropWhilePaused) {
            this.stop();
          }
          resume() {
            this.start();
          }
        }
        class PollingOrphanSubscriber extends OnBlockSubscriber {
          #filter;
          constructor(provider, filter) {
            super(provider);
            this.#filter = copy$2(filter);
          }
          async _poll(blockNumber, provider) {
            throw new Error("@TODO");
          }
        }
        class PollingTransactionSubscriber extends OnBlockSubscriber {
          #hash;
          constructor(provider, hash) {
            super(provider);
            this.#hash = hash;
          }
          async _poll(blockNumber, provider) {
            const tx = await provider.getTransactionReceipt(this.#hash);
            if (tx) {
              provider.emit(this.#hash, tx);
            }
          }
        }
        class PollingEventSubscriber {
          #provider;
          #filter;
          #poller;
          #running;
          #blockNumber;
          constructor(provider, filter) {
            this.#provider = provider;
            this.#filter = copy$2(filter);
            this.#poller = this.#poll.bind(this);
            this.#running = false;
            this.#blockNumber = -2;
          }
          async #poll(blockNumber) {
            if (this.#blockNumber === -2) {
              return;
            }
            const filter = copy$2(this.#filter);
            filter.fromBlock = this.#blockNumber + 1;
            filter.toBlock = blockNumber;
            const logs = await this.#provider.getLogs(filter);
            if (logs.length === 0) {
              if (this.#blockNumber < blockNumber - 60) {
                this.#blockNumber = blockNumber - 60;
              }
              return;
            }
            for (const log of logs) {
              this.#provider.emit(this.#filter, log);
              this.#blockNumber = log.blockNumber;
            }
          }
          start() {
            if (this.#running) {
              return;
            }
            this.#running = true;
            if (this.#blockNumber === -2) {
              this.#provider.getBlockNumber().then((blockNumber) => {
                this.#blockNumber = blockNumber;
              });
            }
            this.#provider.on("block", this.#poller);
          }
          stop() {
            if (!this.#running) {
              return;
            }
            this.#running = false;
            this.#provider.off("block", this.#poller);
          }
          pause(dropWhilePaused) {
            this.stop();
            if (dropWhilePaused) {
              this.#blockNumber = -2;
            }
          }
          resume() {
            this.start();
          }
        }
        const BN_2$1 = BigInt(2);
        const MAX_CCIP_REDIRECTS = 10;
        function isPromise$1(value) {
          return value && typeof value.then === "function";
        }
        function getTag(prefix, value) {
          return (
            prefix +
            ":" +
            JSON.stringify(value, (k, v) => {
              if (v == null) {
                return "null";
              }
              if (typeof v === "bigint") {
                return `bigint:${v.toString()}`;
              }
              if (typeof v === "string") {
                return v.toLowerCase();
              }
              if (typeof v === "object" && !Array.isArray(v)) {
                const keys = Object.keys(v);
                keys.sort();
                return keys.reduce((accum, key) => {
                  accum[key] = v[key];
                  return accum;
                }, {});
              }
              return v;
            })
          );
        }
        class UnmanagedSubscriber {
          name;
          constructor(name) {
            defineProperties(this, { name: name });
          }
          start() {}
          stop() {}
          pause(dropWhilePaused) {}
          resume() {}
        }
        function copy$1(value) {
          return JSON.parse(JSON.stringify(value));
        }
        function concisify(items) {
          items = Array.from(new Set(items).values());
          items.sort();
          return items;
        }
        async function getSubscription(_event, provider) {
          if (_event == null) {
            throw new Error("invalid event");
          }
          if (Array.isArray(_event)) {
            _event = { topics: _event };
          }
          if (typeof _event === "string") {
            switch (_event) {
              case "block":
              case "pending":
              case "debug":
              case "error":
              case "network": {
                return { type: _event, tag: _event };
              }
            }
          }
          if (isHexString(_event, 32)) {
            const hash = _event.toLowerCase();
            return {
              type: "transaction",
              tag: getTag("tx", { hash: hash }),
              hash: hash,
            };
          }
          if (_event.orphan) {
            const event = _event;
            return {
              type: "orphan",
              tag: getTag("orphan", event),
              filter: copy$1(event),
            };
          }
          if (_event.address || _event.topics) {
            const event = _event;
            const filter = {
              topics: (event.topics || []).map((t) => {
                if (t == null) {
                  return null;
                }
                if (Array.isArray(t)) {
                  return concisify(t.map((t) => t.toLowerCase()));
                }
                return t.toLowerCase();
              }),
            };
            if (event.address) {
              const addresses = [];
              const promises = [];
              const addAddress = (addr) => {
                if (isHexString(addr)) {
                  addresses.push(addr);
                } else {
                  promises.push(
                    (async () => {
                      addresses.push(await resolveAddress(addr, provider));
                    })()
                  );
                }
              };
              if (Array.isArray(event.address)) {
                event.address.forEach(addAddress);
              } else {
                addAddress(event.address);
              }
              if (promises.length) {
                await Promise.all(promises);
              }
              filter.address = concisify(addresses.map((a) => a.toLowerCase()));
            }
            return {
              filter: filter,
              tag: getTag("event", filter),
              type: "event",
            };
          }
          assertArgument(false, "unknown ProviderEvent", "event", _event);
        }
        function getTime$1() {
          return new Date().getTime();
        }
        const defaultOptions$1 = { cacheTimeout: 250, pollingInterval: 4e3 };
        class AbstractProvider {
          #subs;
          #plugins;
          #pausedState;
          #destroyed;
          #networkPromise;
          #anyNetwork;
          #performCache;
          #lastBlockNumber;
          #nextTimer;
          #timers;
          #disableCcipRead;
          #options;
          constructor(_network, options) {
            this.#options = Object.assign({}, defaultOptions$1, options || {});
            if (_network === "any") {
              this.#anyNetwork = true;
              this.#networkPromise = null;
            } else if (_network) {
              const network = Network.from(_network);
              this.#anyNetwork = false;
              this.#networkPromise = Promise.resolve(network);
              setTimeout(() => {
                this.emit("network", network, null);
              }, 0);
            } else {
              this.#anyNetwork = false;
              this.#networkPromise = null;
            }
            this.#lastBlockNumber = -1;
            this.#performCache = new Map();
            this.#subs = new Map();
            this.#plugins = new Map();
            this.#pausedState = null;
            this.#destroyed = false;
            this.#nextTimer = 1;
            this.#timers = new Map();
            this.#disableCcipRead = false;
          }
          get pollingInterval() {
            return this.#options.pollingInterval;
          }
          get provider() {
            return this;
          }
          get plugins() {
            return Array.from(this.#plugins.values());
          }
          attachPlugin(plugin) {
            if (this.#plugins.get(plugin.name)) {
              throw new Error(
                `cannot replace existing plugin: ${plugin.name} `
              );
            }
            this.#plugins.set(plugin.name, plugin.connect(this));
            return this;
          }
          getPlugin(name) {
            return this.#plugins.get(name) || null;
          }
          get disableCcipRead() {
            return this.#disableCcipRead;
          }
          set disableCcipRead(value) {
            this.#disableCcipRead = !!value;
          }
          async #perform(req) {
            const timeout = this.#options.cacheTimeout;
            if (timeout < 0) {
              return await this._perform(req);
            }
            const tag = getTag(req.method, req);
            let perform = this.#performCache.get(tag);
            if (!perform) {
              perform = this._perform(req);
              this.#performCache.set(tag, perform);
              setTimeout(() => {
                if (this.#performCache.get(tag) === perform) {
                  this.#performCache.delete(tag);
                }
              }, timeout);
            }
            return await perform;
          }
          async ccipReadFetch(tx, calldata, urls) {
            if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
              return null;
            }
            const sender = tx.to.toLowerCase();
            const data = calldata.toLowerCase();
            const errorMessages = [];
            for (let i = 0; i < urls.length; i++) {
              const url = urls[i];
              const href = url
                .replace("{sender}", sender)
                .replace("{data}", data);
              const request = new FetchRequest(href);
              if (url.indexOf("{data}") === -1) {
                request.body = { data: data, sender: sender };
              }
              this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: request,
                index: i,
                urls: urls,
              });
              let errorMessage = "unknown error";
              const resp = await request.send();
              try {
                const result = resp.bodyJson;
                if (result.data) {
                  this.emit("debug", {
                    action: "receiveCcipReadFetchResult",
                    request: request,
                    result: result,
                  });
                  return result.data;
                }
                if (result.message) {
                  errorMessage = result.message;
                }
                this.emit("debug", {
                  action: "receiveCcipReadFetchError",
                  request: request,
                  result: result,
                });
              } catch (error) {}
              assert$1(
                resp.statusCode < 400 || resp.statusCode >= 500,
                `response not found during CCIP fetch: ${errorMessage}`,
                "OFFCHAIN_FAULT",
                {
                  reason: "404_MISSING_RESOURCE",
                  transaction: tx,
                  info: { url: url, errorMessage: errorMessage },
                }
              );
              errorMessages.push(errorMessage);
            }
            assert$1(
              false,
              `error encountered during CCIP fetch: ${errorMessages
                .map((m) => JSON.stringify(m))
                .join(", ")}`,
              "OFFCHAIN_FAULT",
              {
                reason: "500_SERVER_ERROR",
                transaction: tx,
                info: { urls: urls, errorMessages: errorMessages },
              }
            );
          }
          _wrapBlock(value, network) {
            return new Block(formatBlock(value), this);
          }
          _wrapLog(value, network) {
            return new Log(formatLog(value), this);
          }
          _wrapTransactionReceipt(value, network) {
            return new TransactionReceipt(
              formatTransactionReceipt(value),
              this
            );
          }
          _wrapTransactionResponse(tx, network) {
            return new TransactionResponse(formatTransactionResponse(tx), this);
          }
          _detectNetwork() {
            assert$1(
              false,
              "sub-classes must implement this",
              "UNSUPPORTED_OPERATION",
              { operation: "_detectNetwork" }
            );
          }
          async _perform(req) {
            assert$1(
              false,
              `unsupported method: ${req.method}`,
              "UNSUPPORTED_OPERATION",
              { operation: req.method, info: req }
            );
          }
          async getBlockNumber() {
            const blockNumber = getNumber(
              await this.#perform({ method: "getBlockNumber" }),
              "%response"
            );
            if (this.#lastBlockNumber >= 0) {
              this.#lastBlockNumber = blockNumber;
            }
            return blockNumber;
          }
          _getAddress(address) {
            return resolveAddress(address, this);
          }
          _getBlockTag(blockTag) {
            if (blockTag == null) {
              return "latest";
            }
            switch (blockTag) {
              case "earliest":
                return "0x0";
              case "latest":
              case "pending":
              case "safe":
              case "finalized":
                return blockTag;
            }
            if (isHexString(blockTag)) {
              if (isHexString(blockTag, 32)) {
                return blockTag;
              }
              return toQuantity(blockTag);
            }
            if (typeof blockTag === "bigint") {
              blockTag = getNumber(blockTag, "blockTag");
            }
            if (typeof blockTag === "number") {
              if (blockTag >= 0) {
                return toQuantity(blockTag);
              }
              if (this.#lastBlockNumber >= 0) {
                return toQuantity(this.#lastBlockNumber + blockTag);
              }
              return this.getBlockNumber().then((b) =>
                toQuantity(b + blockTag)
              );
            }
            assertArgument(false, "invalid blockTag", "blockTag", blockTag);
          }
          _getFilter(filter) {
            const topics = (filter.topics || []).map((t) => {
              if (t == null) {
                return null;
              }
              if (Array.isArray(t)) {
                return concisify(t.map((t) => t.toLowerCase()));
              }
              return t.toLowerCase();
            });
            const blockHash =
              "blockHash" in filter ? filter.blockHash : undefined;
            const resolve = (_address, fromBlock, toBlock) => {
              let address = undefined;
              switch (_address.length) {
                case 0:
                  break;
                case 1:
                  address = _address[0];
                  break;
                default:
                  _address.sort();
                  address = _address;
              }
              if (blockHash) {
                if (fromBlock != null || toBlock != null) {
                  throw new Error("invalid filter");
                }
              }
              const filter = {};
              if (address) {
                filter.address = address;
              }
              if (topics.length) {
                filter.topics = topics;
              }
              if (fromBlock) {
                filter.fromBlock = fromBlock;
              }
              if (toBlock) {
                filter.toBlock = toBlock;
              }
              if (blockHash) {
                filter.blockHash = blockHash;
              }
              return filter;
            };
            let address = [];
            if (filter.address) {
              if (Array.isArray(filter.address)) {
                for (const addr of filter.address) {
                  address.push(this._getAddress(addr));
                }
              } else {
                address.push(this._getAddress(filter.address));
              }
            }
            let fromBlock = undefined;
            if ("fromBlock" in filter) {
              fromBlock = this._getBlockTag(filter.fromBlock);
            }
            let toBlock = undefined;
            if ("toBlock" in filter) {
              toBlock = this._getBlockTag(filter.toBlock);
            }
            if (
              address.filter((a) => typeof a !== "string").length ||
              (fromBlock != null && typeof fromBlock !== "string") ||
              (toBlock != null && typeof toBlock !== "string")
            ) {
              return Promise.all([
                Promise.all(address),
                fromBlock,
                toBlock,
              ]).then((result) => {
                return resolve(result[0], result[1], result[2]);
              });
            }
            return resolve(address, fromBlock, toBlock);
          }
          _getTransactionRequest(_request) {
            const request = copyRequest(_request);
            const promises = [];
            ["to", "from"].forEach((key) => {
              if (request[key] == null) {
                return;
              }
              const addr = resolveAddress(request[key]);
              if (isPromise$1(addr)) {
                promises.push(
                  (async function () {
                    request[key] = await addr;
                  })()
                );
              } else {
                request[key] = addr;
              }
            });
            if (request.blockTag != null) {
              const blockTag = this._getBlockTag(request.blockTag);
              if (isPromise$1(blockTag)) {
                promises.push(
                  (async function () {
                    request.blockTag = await blockTag;
                  })()
                );
              } else {
                request.blockTag = blockTag;
              }
            }
            if (promises.length) {
              return (async function () {
                await Promise.all(promises);
                return request;
              })();
            }
            return request;
          }
          async getNetwork() {
            if (this.#networkPromise == null) {
              const detectNetwork = this._detectNetwork().then(
                (network) => {
                  this.emit("network", network, null);
                  return network;
                },
                (error) => {
                  if (this.#networkPromise === detectNetwork) {
                    this.#networkPromise = null;
                  }
                  throw error;
                }
              );
              this.#networkPromise = detectNetwork;
              return (await detectNetwork).clone();
            }
            const networkPromise = this.#networkPromise;
            const [expected, actual] = await Promise.all([
              networkPromise,
              this._detectNetwork(),
            ]);
            if (expected.chainId !== actual.chainId) {
              if (this.#anyNetwork) {
                this.emit("network", actual, expected);
                if (this.#networkPromise === networkPromise) {
                  this.#networkPromise = Promise.resolve(actual);
                }
              } else {
                assert$1(
                  false,
                  `network changed: ${expected.chainId} => ${actual.chainId} `,
                  "NETWORK_ERROR",
                  { event: "changed" }
                );
              }
            }
            return expected.clone();
          }
          async getFeeData() {
            const network = await this.getNetwork();
            const getFeeDataFunc = async () => {
              const { _block, gasPrice } = await resolveProperties({
                _block: this.#getBlock("latest", false),
                gasPrice: (async () => {
                  try {
                    const gasPrice = await this.#perform({
                      method: "getGasPrice",
                    });
                    return getBigInt(gasPrice, "%response");
                  } catch (error) {}
                  return null;
                })(),
              });
              let maxFeePerGas = null,
                maxPriorityFeePerGas = null;
              const block = this._wrapBlock(_block, network);
              if (block && block.baseFeePerGas) {
                maxPriorityFeePerGas = BigInt("1000000000");
                maxFeePerGas =
                  block.baseFeePerGas * BN_2$1 + maxPriorityFeePerGas;
              }
              return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
            };
            const plugin = network.getPlugin(
              "org.ethers.plugins.network.FetchUrlFeeDataPlugin"
            );
            if (plugin) {
              const req = new FetchRequest(plugin.url);
              const feeData = await plugin.processFunc(
                getFeeDataFunc,
                this,
                req
              );
              return new FeeData(
                feeData.gasPrice,
                feeData.maxFeePerGas,
                feeData.maxPriorityFeePerGas
              );
            }
            return await getFeeDataFunc();
          }
          async estimateGas(_tx) {
            let tx = this._getTransactionRequest(_tx);
            if (isPromise$1(tx)) {
              tx = await tx;
            }
            return getBigInt(
              await this.#perform({ method: "estimateGas", transaction: tx }),
              "%response"
            );
          }
          async #call(tx, blockTag, attempt) {
            assert$1(
              attempt < MAX_CCIP_REDIRECTS,
              "CCIP read exceeded maximum redirections",
              "OFFCHAIN_FAULT",
              {
                reason: "TOO_MANY_REDIRECTS",
                transaction: Object.assign({}, tx, {
                  blockTag: blockTag,
                  enableCcipRead: true,
                }),
              }
            );
            const transaction = copyRequest(tx);
            try {
              return hexlify(
                await this._perform({
                  method: "call",
                  transaction: transaction,
                  blockTag: blockTag,
                })
              );
            } catch (error) {
              if (
                !this.disableCcipRead &&
                isCallException(error) &&
                error.data &&
                attempt >= 0 &&
                blockTag === "latest" &&
                transaction.to != null &&
                dataSlice(error.data, 0, 4) === "0x556f1830"
              ) {
                const data = error.data;
                const txSender = await resolveAddress(transaction.to, this);
                let ccipArgs;
                try {
                  ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
                } catch (error) {
                  assert$1(false, error.message, "OFFCHAIN_FAULT", {
                    reason: "BAD_DATA",
                    transaction: transaction,
                    info: { data: data },
                  });
                }
                assert$1(
                  ccipArgs.sender.toLowerCase() === txSender.toLowerCase(),
                  "CCIP Read sender mismatch",
                  "CALL_EXCEPTION",
                  {
                    action: "call",
                    data: data,
                    reason: "OffchainLookup",
                    transaction: transaction,
                    invocation: null,
                    revert: {
                      signature:
                        "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      name: "OffchainLookup",
                      args: ccipArgs.errorArgs,
                    },
                  }
                );
                const ccipResult = await this.ccipReadFetch(
                  transaction,
                  ccipArgs.calldata,
                  ccipArgs.urls
                );
                assert$1(
                  ccipResult != null,
                  "CCIP Read failed to fetch data",
                  "OFFCHAIN_FAULT",
                  {
                    reason: "FETCH_FAILED",
                    transaction: transaction,
                    info: { data: error.data, errorArgs: ccipArgs.errorArgs },
                  }
                );
                const tx = {
                  to: txSender,
                  data: concat([
                    ccipArgs.selector,
                    encodeBytes([ccipResult, ccipArgs.extraData]),
                  ]),
                };
                this.emit("debug", {
                  action: "sendCcipReadCall",
                  transaction: tx,
                });
                try {
                  const result = await this.#call(tx, blockTag, attempt + 1);
                  this.emit("debug", {
                    action: "receiveCcipReadCallResult",
                    transaction: Object.assign({}, tx),
                    result: result,
                  });
                  return result;
                } catch (error) {
                  this.emit("debug", {
                    action: "receiveCcipReadCallError",
                    transaction: Object.assign({}, tx),
                    error: error,
                  });
                  throw error;
                }
              }
              throw error;
            }
          }
          async #checkNetwork(promise) {
            const { value } = await resolveProperties({
              network: this.getNetwork(),
              value: promise,
            });
            return value;
          }
          async call(_tx) {
            const { tx, blockTag } = await resolveProperties({
              tx: this._getTransactionRequest(_tx),
              blockTag: this._getBlockTag(_tx.blockTag),
            });
            return await this.#checkNetwork(
              this.#call(tx, blockTag, _tx.enableCcipRead ? 0 : -1)
            );
          }
          async #getAccountValue(request, _address, _blockTag) {
            let address = this._getAddress(_address);
            let blockTag = this._getBlockTag(_blockTag);
            if (typeof address !== "string" || typeof blockTag !== "string") {
              [address, blockTag] = await Promise.all([address, blockTag]);
            }
            return await this.#checkNetwork(
              this.#perform(
                Object.assign(request, { address: address, blockTag: blockTag })
              )
            );
          }
          async getBalance(address, blockTag) {
            return getBigInt(
              await this.#getAccountValue(
                { method: "getBalance" },
                address,
                blockTag
              ),
              "%response"
            );
          }
          async getTransactionCount(address, blockTag) {
            return getNumber(
              await this.#getAccountValue(
                { method: "getTransactionCount" },
                address,
                blockTag
              ),
              "%response"
            );
          }
          async getCode(address, blockTag) {
            return hexlify(
              await this.#getAccountValue(
                { method: "getCode" },
                address,
                blockTag
              )
            );
          }
          async getStorage(address, _position, blockTag) {
            const position = getBigInt(_position, "position");
            return hexlify(
              await this.#getAccountValue(
                { method: "getStorage", position: position },
                address,
                blockTag
              )
            );
          }
          async broadcastTransaction(signedTx) {
            const { blockNumber, hash, network } = await resolveProperties({
              blockNumber: this.getBlockNumber(),
              hash: this._perform({
                method: "broadcastTransaction",
                signedTransaction: signedTx,
              }),
              network: this.getNetwork(),
            });
            const tx = Transaction.from(signedTx);
            if (tx.hash !== hash) {
              throw new Error("@TODO: the returned hash did not match");
            }
            return this._wrapTransactionResponse(
              tx,
              network
            ).replaceableTransaction(blockNumber);
          }
          async #getBlock(block, includeTransactions) {
            if (isHexString(block, 32)) {
              return await this.#perform({
                method: "getBlock",
                blockHash: block,
                includeTransactions: includeTransactions,
              });
            }
            let blockTag = this._getBlockTag(block);
            if (typeof blockTag !== "string") {
              blockTag = await blockTag;
            }
            return await this.#perform({
              method: "getBlock",
              blockTag: blockTag,
              includeTransactions: includeTransactions,
            });
          }
          async getBlock(block, prefetchTxs) {
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#getBlock(block, !!prefetchTxs),
            });
            if (params == null) {
              return null;
            }
            return this._wrapBlock(params, network);
          }
          async getTransaction(hash) {
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#perform({ method: "getTransaction", hash: hash }),
            });
            if (params == null) {
              return null;
            }
            return this._wrapTransactionResponse(params, network);
          }
          async getTransactionReceipt(hash) {
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#perform({
                method: "getTransactionReceipt",
                hash: hash,
              }),
            });
            if (params == null) {
              return null;
            }
            if (params.gasPrice == null && params.effectiveGasPrice == null) {
              const tx = await this.#perform({
                method: "getTransaction",
                hash: hash,
              });
              if (tx == null) {
                throw new Error(
                  "report this; could not find tx or effectiveGasPrice"
                );
              }
              params.effectiveGasPrice = tx.gasPrice;
            }
            return this._wrapTransactionReceipt(params, network);
          }
          async getTransactionResult(hash) {
            const { result } = await resolveProperties({
              network: this.getNetwork(),
              result: this.#perform({
                method: "getTransactionResult",
                hash: hash,
              }),
            });
            if (result == null) {
              return null;
            }
            return hexlify(result);
          }
          async getLogs(_filter) {
            let filter = this._getFilter(_filter);
            if (isPromise$1(filter)) {
              filter = await filter;
            }
            const { network, params } = await resolveProperties({
              network: this.getNetwork(),
              params: this.#perform({ method: "getLogs", filter: filter }),
            });
            return params.map((p) => this._wrapLog(p, network));
          }
          _getProvider(chainId) {
            assert$1(
              false,
              "provider cannot connect to target network",
              "UNSUPPORTED_OPERATION",
              { operation: "_getProvider()" }
            );
          }
          async getResolver(name) {
            return await EnsResolver.fromName(this, name);
          }
          async getAvatar(name) {
            const resolver = await this.getResolver(name);
            if (resolver) {
              return await resolver.getAvatar();
            }
            return null;
          }
          async resolveName(name) {
            const resolver = await this.getResolver(name);
            if (resolver) {
              return await resolver.getAddress();
            }
            return null;
          }
          async lookupAddress(address) {
            address = getAddress(address);
            const node = namehash(
              address.substring(2).toLowerCase() + ".addr.reverse"
            );
            try {
              const ensAddr = await EnsResolver.getEnsAddress(this);
              const ensContract = new Contract(
                ensAddr,
                ["function resolver(bytes32) view returns (address)"],
                this
              );
              const resolver = await ensContract.resolver(node);
              if (resolver == null || resolver === ZeroAddress) {
                return null;
              }
              const resolverContract = new Contract(
                resolver,
                ["function name(bytes32) view returns (string)"],
                this
              );
              const name = await resolverContract.name(node);
              const check = await this.resolveName(name);
              if (check !== address) {
                return null;
              }
              return name;
            } catch (error) {
              if (isError(error, "BAD_DATA") && error.value === "0x") {
                return null;
              }
              if (isError(error, "CALL_EXCEPTION")) {
                return null;
              }
              throw error;
            }
            return null;
          }
          async waitForTransaction(hash, _confirms, timeout) {
            const confirms = _confirms != null ? _confirms : 1;
            if (confirms === 0) {
              return this.getTransactionReceipt(hash);
            }
            return new Promise(async (resolve, reject) => {
              let timer = null;
              const listener = async (blockNumber) => {
                try {
                  const receipt = await this.getTransactionReceipt(hash);
                  if (receipt != null) {
                    if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                      resolve(receipt);
                      if (timer) {
                        clearTimeout(timer);
                        timer = null;
                      }
                      return;
                    }
                  }
                } catch (error) {
                  console.log("EEE", error);
                }
                this.once("block", listener);
              };
              if (timeout != null) {
                timer = setTimeout(() => {
                  if (timer == null) {
                    return;
                  }
                  timer = null;
                  this.off("block", listener);
                  reject(
                    makeError("timeout", "TIMEOUT", { reason: "timeout" })
                  );
                }, timeout);
              }
              listener(await this.getBlockNumber());
            });
          }
          async waitForBlock(blockTag) {
            assert$1(false, "not implemented yet", "NOT_IMPLEMENTED", {
              operation: "waitForBlock",
            });
          }
          _clearTimeout(timerId) {
            const timer = this.#timers.get(timerId);
            if (!timer) {
              return;
            }
            if (timer.timer) {
              clearTimeout(timer.timer);
            }
            this.#timers.delete(timerId);
          }
          _setTimeout(_func, timeout) {
            if (timeout == null) {
              timeout = 0;
            }
            const timerId = this.#nextTimer++;
            const func = () => {
              this.#timers.delete(timerId);
              _func();
            };
            if (this.paused) {
              this.#timers.set(timerId, {
                timer: null,
                func: func,
                time: timeout,
              });
            } else {
              const timer = setTimeout(func, timeout);
              this.#timers.set(timerId, {
                timer: timer,
                func: func,
                time: getTime$1(),
              });
            }
            return timerId;
          }
          _forEachSubscriber(func) {
            for (const sub of this.#subs.values()) {
              func(sub.subscriber);
            }
          }
          _getSubscriber(sub) {
            switch (sub.type) {
              case "debug":
              case "error":
              case "network":
                return new UnmanagedSubscriber(sub.type);
              case "block": {
                const subscriber = new PollingBlockSubscriber(this);
                subscriber.pollingInterval = this.pollingInterval;
                return subscriber;
              }
              case "event":
                return new PollingEventSubscriber(this, sub.filter);
              case "transaction":
                return new PollingTransactionSubscriber(this, sub.hash);
              case "orphan":
                return new PollingOrphanSubscriber(this, sub.filter);
            }
            throw new Error(`unsupported event: ${sub.type}`);
          }
          _recoverSubscriber(oldSub, newSub) {
            for (const sub of this.#subs.values()) {
              if (sub.subscriber === oldSub) {
                if (sub.started) {
                  sub.subscriber.stop();
                }
                sub.subscriber = newSub;
                if (sub.started) {
                  newSub.start();
                }
                if (this.#pausedState != null) {
                  newSub.pause(this.#pausedState);
                }
                break;
              }
            }
          }
          async #hasSub(event, emitArgs) {
            let sub = await getSubscription(event, this);
            if (
              sub.type === "event" &&
              emitArgs &&
              emitArgs.length > 0 &&
              emitArgs[0].removed === true
            ) {
              sub = await getSubscription(
                { orphan: "drop-log", log: emitArgs[0] },
                this
              );
            }
            return this.#subs.get(sub.tag) || null;
          }
          async #getSub(event) {
            const subscription = await getSubscription(event, this);
            const tag = subscription.tag;
            let sub = this.#subs.get(tag);
            if (!sub) {
              const subscriber = this._getSubscriber(subscription);
              const addressableMap = new WeakMap();
              const nameMap = new Map();
              sub = {
                subscriber: subscriber,
                tag: tag,
                addressableMap: addressableMap,
                nameMap: nameMap,
                started: false,
                listeners: [],
              };
              this.#subs.set(tag, sub);
            }
            return sub;
          }
          async on(event, listener) {
            const sub = await this.#getSub(event);
            sub.listeners.push({ listener: listener, once: false });
            if (!sub.started) {
              sub.subscriber.start();
              sub.started = true;
              if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
              }
            }
            return this;
          }
          async once(event, listener) {
            const sub = await this.#getSub(event);
            sub.listeners.push({ listener: listener, once: true });
            if (!sub.started) {
              sub.subscriber.start();
              sub.started = true;
              if (this.#pausedState != null) {
                sub.subscriber.pause(this.#pausedState);
              }
            }
            return this;
          }
          async emit(event, ...args) {
            const sub = await this.#hasSub(event, args);
            if (!sub || sub.listeners.length === 0) {
              return false;
            }
            const count = sub.listeners.length;
            sub.listeners = sub.listeners.filter(({ listener, once }) => {
              const payload = new EventPayload(
                this,
                once ? null : listener,
                event
              );
              try {
                listener.call(this, ...args, payload);
              } catch (error) {}
              return !once;
            });
            if (sub.listeners.length === 0) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              this.#subs.delete(sub.tag);
            }
            return count > 0;
          }
          async listenerCount(event) {
            if (event) {
              const sub = await this.#hasSub(event);
              if (!sub) {
                return 0;
              }
              return sub.listeners.length;
            }
            let total = 0;
            for (const { listeners } of this.#subs.values()) {
              total += listeners.length;
            }
            return total;
          }
          async listeners(event) {
            if (event) {
              const sub = await this.#hasSub(event);
              if (!sub) {
                return [];
              }
              return sub.listeners.map(({ listener }) => listener);
            }
            let result = [];
            for (const { listeners } of this.#subs.values()) {
              result = result.concat(listeners.map(({ listener }) => listener));
            }
            return result;
          }
          async off(event, listener) {
            const sub = await this.#hasSub(event);
            if (!sub) {
              return this;
            }
            if (listener) {
              const index = sub.listeners
                .map(({ listener }) => listener)
                .indexOf(listener);
              if (index >= 0) {
                sub.listeners.splice(index, 1);
              }
            }
            if (!listener || sub.listeners.length === 0) {
              if (sub.started) {
                sub.subscriber.stop();
              }
              this.#subs.delete(sub.tag);
            }
            return this;
          }
          async removeAllListeners(event) {
            if (event) {
              const { tag, started, subscriber } = await this.#getSub(event);
              if (started) {
                subscriber.stop();
              }
              this.#subs.delete(tag);
            } else {
              for (const [tag, { started, subscriber }] of this.#subs) {
                if (started) {
                  subscriber.stop();
                }
                this.#subs.delete(tag);
              }
            }
            return this;
          }
          async addListener(event, listener) {
            return await this.on(event, listener);
          }
          async removeListener(event, listener) {
            return this.off(event, listener);
          }
          get destroyed() {
            return this.#destroyed;
          }
          destroy() {
            this.removeAllListeners();
            for (const timerId of this.#timers.keys()) {
              this._clearTimeout(timerId);
            }
            this.#destroyed = true;
          }
          get paused() {
            return this.#pausedState != null;
          }
          set paused(pause) {
            if (!!pause === this.paused) {
              return;
            }
            if (this.paused) {
              this.resume();
            } else {
              this.pause(false);
            }
          }
          pause(dropWhilePaused) {
            this.#lastBlockNumber = -1;
            if (this.#pausedState != null) {
              if (this.#pausedState == !!dropWhilePaused) {
                return;
              }
              assert$1(
                false,
                "cannot change pause type; resume first",
                "UNSUPPORTED_OPERATION",
                { operation: "pause" }
              );
            }
            this._forEachSubscriber((s) => s.pause(dropWhilePaused));
            this.#pausedState = !!dropWhilePaused;
            for (const timer of this.#timers.values()) {
              if (timer.timer) {
                clearTimeout(timer.timer);
              }
              timer.time = getTime$1() - timer.time;
            }
          }
          resume() {
            if (this.#pausedState == null) {
              return;
            }
            this._forEachSubscriber((s) => s.resume());
            this.#pausedState = null;
            for (const timer of this.#timers.values()) {
              let timeout = timer.time;
              if (timeout < 0) {
                timeout = 0;
              }
              timer.time = getTime$1();
              setTimeout(timer.func, timeout);
            }
          }
        }
        function _parseString(result, start) {
          try {
            const bytes = _parseBytes(result, start);
            if (bytes) {
              return toUtf8String(bytes);
            }
          } catch (error) {}
          return null;
        }
        function _parseBytes(result, start) {
          if (result === "0x") {
            return null;
          }
          try {
            const offset = getNumber(dataSlice(result, start, start + 32));
            const length = getNumber(dataSlice(result, offset, offset + 32));
            return dataSlice(result, offset + 32, offset + 32 + length);
          } catch (error) {}
          return null;
        }
        function numPad(value) {
          const result = toBeArray(value);
          if (result.length > 32) {
            throw new Error("internal; should not happen");
          }
          const padded = new Uint8Array(32);
          padded.set(result, 32 - result.length);
          return padded;
        }
        function bytesPad(value) {
          if (value.length % 32 === 0) {
            return value;
          }
          const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
          result.set(value);
          return result;
        }
        const empty = new Uint8Array([]);
        function encodeBytes(datas) {
          const result = [];
          let byteCount = 0;
          for (let i = 0; i < datas.length; i++) {
            result.push(empty);
            byteCount += 32;
          }
          for (let i = 0; i < datas.length; i++) {
            const data = getBytes(datas[i]);
            result[i] = numPad(byteCount);
            result.push(numPad(data.length));
            result.push(bytesPad(data));
            byteCount += 32 + Math.ceil(data.length / 32) * 32;
          }
          return concat(result);
        }
        const zeros =
          "0x0000000000000000000000000000000000000000000000000000000000000000";
        function parseOffchainLookup(data) {
          const result = {
            sender: "",
            urls: [],
            calldata: "",
            selector: "",
            extraData: "",
            errorArgs: [],
          };
          assert$1(
            dataLength(data) >= 5 * 32,
            "insufficient OffchainLookup data",
            "OFFCHAIN_FAULT",
            { reason: "insufficient OffchainLookup data" }
          );
          const sender = dataSlice(data, 0, 32);
          assert$1(
            dataSlice(sender, 0, 12) === dataSlice(zeros, 0, 12),
            "corrupt OffchainLookup sender",
            "OFFCHAIN_FAULT",
            { reason: "corrupt OffchainLookup sender" }
          );
          result.sender = dataSlice(sender, 12);
          try {
            const urls = [];
            const urlsOffset = getNumber(dataSlice(data, 32, 64));
            const urlsLength = getNumber(
              dataSlice(data, urlsOffset, urlsOffset + 32)
            );
            const urlsData = dataSlice(data, urlsOffset + 32);
            for (let u = 0; u < urlsLength; u++) {
              const url = _parseString(urlsData, u * 32);
              if (url == null) {
                throw new Error("abort");
              }
              urls.push(url);
            }
            result.urls = urls;
          } catch (error) {
            assert$1(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
              reason: "corrupt OffchainLookup urls",
            });
          }
          try {
            const calldata = _parseBytes(data, 64);
            if (calldata == null) {
              throw new Error("abort");
            }
            result.calldata = calldata;
          } catch (error) {
            assert$1(
              false,
              "corrupt OffchainLookup calldata",
              "OFFCHAIN_FAULT",
              { reason: "corrupt OffchainLookup calldata" }
            );
          }
          assert$1(
            dataSlice(data, 100, 128) === dataSlice(zeros, 0, 28),
            "corrupt OffchainLookup callbaackSelector",
            "OFFCHAIN_FAULT",
            { reason: "corrupt OffchainLookup callbaackSelector" }
          );
          result.selector = dataSlice(data, 96, 100);
          try {
            const extraData = _parseBytes(data, 128);
            if (extraData == null) {
              throw new Error("abort");
            }
            result.extraData = extraData;
          } catch (error) {
            assert$1(
              false,
              "corrupt OffchainLookup extraData",
              "OFFCHAIN_FAULT",
              { reason: "corrupt OffchainLookup extraData" }
            );
          }
          result.errorArgs = "sender,urls,calldata,selector,extraData"
            .split(/,/)
            .map((k) => result[k]);
          return result;
        }
        function checkProvider(signer, operation) {
          if (signer.provider) {
            return signer.provider;
          }
          assert$1(false, "missing provider", "UNSUPPORTED_OPERATION", {
            operation: operation,
          });
        }
        async function populate(signer, tx) {
          let pop = copyRequest(tx);
          if (pop.to != null) {
            pop.to = resolveAddress(pop.to, signer);
          }
          if (pop.from != null) {
            const from = pop.from;
            pop.from = Promise.all([
              signer.getAddress(),
              resolveAddress(from, signer),
            ]).then(([address, from]) => {
              assertArgument(
                address.toLowerCase() === from.toLowerCase(),
                "transaction from mismatch",
                "tx.from",
                from
              );
              return address;
            });
          } else {
            pop.from = signer.getAddress();
          }
          return await resolveProperties(pop);
        }
        class AbstractSigner {
          provider;
          constructor(provider) {
            defineProperties(this, { provider: provider || null });
          }
          async getNonce(blockTag) {
            return checkProvider(
              this,
              "getTransactionCount"
            ).getTransactionCount(await this.getAddress(), blockTag);
          }
          async populateCall(tx) {
            const pop = await populate(this, tx);
            return pop;
          }
          async populateTransaction(tx) {
            const provider = checkProvider(this, "populateTransaction");
            const pop = await populate(this, tx);
            if (pop.nonce == null) {
              pop.nonce = await this.getNonce("pending");
            }
            if (pop.gasLimit == null) {
              pop.gasLimit = await this.estimateGas(pop);
            }
            const network = await this.provider.getNetwork();
            if (pop.chainId != null) {
              const chainId = getBigInt(pop.chainId);
              assertArgument(
                chainId === network.chainId,
                "transaction chainId mismatch",
                "tx.chainId",
                tx.chainId
              );
            } else {
              pop.chainId = network.chainId;
            }
            const hasEip1559 =
              pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
            if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
              assertArgument(
                false,
                "eip-1559 transaction do not support gasPrice",
                "tx",
                tx
              );
            } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
              assertArgument(
                false,
                "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas",
                "tx",
                tx
              );
            }
            if (
              (pop.type === 2 || pop.type == null) &&
              pop.maxFeePerGas != null &&
              pop.maxPriorityFeePerGas != null
            ) {
              pop.type = 2;
            } else if (pop.type === 0 || pop.type === 1) {
              const feeData = await provider.getFeeData();
              assert$1(
                feeData.gasPrice != null,
                "network does not support gasPrice",
                "UNSUPPORTED_OPERATION",
                { operation: "getGasPrice" }
              );
              if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
              }
            } else {
              const feeData = await provider.getFeeData();
              if (pop.type == null) {
                if (
                  feeData.maxFeePerGas != null &&
                  feeData.maxPriorityFeePerGas != null
                ) {
                  pop.type = 2;
                  if (pop.gasPrice != null) {
                    const gasPrice = pop.gasPrice;
                    delete pop.gasPrice;
                    pop.maxFeePerGas = gasPrice;
                    pop.maxPriorityFeePerGas = gasPrice;
                  } else {
                    if (pop.maxFeePerGas == null) {
                      pop.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (pop.maxPriorityFeePerGas == null) {
                      pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                  }
                } else if (feeData.gasPrice != null) {
                  assert$1(
                    !hasEip1559,
                    "network does not support EIP-1559",
                    "UNSUPPORTED_OPERATION",
                    { operation: "populateTransaction" }
                  );
                  if (pop.gasPrice == null) {
                    pop.gasPrice = feeData.gasPrice;
                  }
                  pop.type = 0;
                } else {
                  assert$1(
                    false,
                    "failed to get consistent fee data",
                    "UNSUPPORTED_OPERATION",
                    { operation: "signer.getFeeData" }
                  );
                }
              } else if (pop.type === 2) {
                if (pop.maxFeePerGas == null) {
                  pop.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                  pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
            }
            return await resolveProperties(pop);
          }
          async estimateGas(tx) {
            return checkProvider(this, "estimateGas").estimateGas(
              await this.populateCall(tx)
            );
          }
          async call(tx) {
            return checkProvider(this, "call").call(
              await this.populateCall(tx)
            );
          }
          async resolveName(name) {
            const provider = checkProvider(this, "resolveName");
            return await provider.resolveName(name);
          }
          async sendTransaction(tx) {
            const provider = checkProvider(this, "sendTransaction");
            const pop = await this.populateTransaction(tx);
            delete pop.from;
            const txObj = Transaction.from(pop);
            return await provider.broadcastTransaction(
              await this.signTransaction(txObj)
            );
          }
        }
        class VoidSigner extends AbstractSigner {
          address;
          constructor(address, provider) {
            super(provider);
            defineProperties(this, { address: address });
          }
          async getAddress() {
            return this.address;
          }
          connect(provider) {
            return new VoidSigner(this.address, provider);
          }
          #throwUnsupported(suffix, operation) {
            assert$1(
              false,
              `VoidSigner cannot sign ${suffix}`,
              "UNSUPPORTED_OPERATION",
              { operation: operation }
            );
          }
          async signTransaction(tx) {
            this.#throwUnsupported("transactions", "signTransaction");
          }
          async signMessage(message) {
            this.#throwUnsupported("messages", "signMessage");
          }
          async signTypedData(domain, types, value) {
            this.#throwUnsupported("typed-data", "signTypedData");
          }
        }
        const shown = new Set();
        function showThrottleMessage(service) {
          if (shown.has(service)) {
            return;
          }
          shown.add(service);
          console.log("========= NOTICE =========");
          console.log(
            `Request-Rate Exceeded for ${service} (this message will not be repeated)`
          );
          console.log("");
          console.log(
            "The default API keys for each service are provided as a highly-throttled,"
          );
          console.log(
            "community resource for low-traffic projects and early prototyping."
          );
          console.log("");
          console.log(
            "While your application will continue to function, we highly recommended"
          );
          console.log(
            "signing up for your own API keys to improve performance, increase your"
          );
          console.log(
            "request rate/limit and enable other perks, such as metrics and advanced APIs."
          );
          console.log("");
          console.log("For more details: https://docs.ethers.org/api-keys/");
          console.log("==========================");
        }
        function copy(obj) {
          return JSON.parse(JSON.stringify(obj));
        }
        class FilterIdSubscriber {
          #provider;
          #filterIdPromise;
          #poller;
          #running;
          #network;
          #hault;
          constructor(provider) {
            this.#provider = provider;
            this.#filterIdPromise = null;
            this.#poller = this.#poll.bind(this);
            this.#running = false;
            this.#network = null;
            this.#hault = false;
          }
          _subscribe(provider) {
            throw new Error("subclasses must override this");
          }
          _emitResults(provider, result) {
            throw new Error("subclasses must override this");
          }
          _recover(provider) {
            throw new Error("subclasses must override this");
          }
          async #poll(blockNumber) {
            try {
              if (this.#filterIdPromise == null) {
                this.#filterIdPromise = this._subscribe(this.#provider);
              }
              let filterId = null;
              try {
                filterId = await this.#filterIdPromise;
              } catch (error) {
                if (
                  !isError(error, "UNSUPPORTED_OPERATION") ||
                  error.operation !== "eth_newFilter"
                ) {
                  throw error;
                }
              }
              if (filterId == null) {
                this.#filterIdPromise = null;
                this.#provider._recoverSubscriber(
                  this,
                  this._recover(this.#provider)
                );
                return;
              }
              const network = await this.#provider.getNetwork();
              if (!this.#network) {
                this.#network = network;
              }
              if (this.#network.chainId !== network.chainId) {
                throw new Error("chaid changed");
              }
              if (this.#hault) {
                return;
              }
              const result = await this.#provider.send("eth_getFilterChanges", [
                filterId,
              ]);
              await this._emitResults(this.#provider, result);
            } catch (error) {
              console.log("@TODO", error);
            }
            this.#provider.once("block", this.#poller);
          }
          #teardown() {
            const filterIdPromise = this.#filterIdPromise;
            if (filterIdPromise) {
              this.#filterIdPromise = null;
              filterIdPromise.then((filterId) => {
                this.#provider.send("eth_uninstallFilter", [filterId]);
              });
            }
          }
          start() {
            if (this.#running) {
              return;
            }
            this.#running = true;
            this.#poll(-2);
          }
          stop() {
            if (!this.#running) {
              return;
            }
            this.#running = false;
            this.#hault = true;
            this.#teardown();
            this.#provider.off("block", this.#poller);
          }
          pause(dropWhilePaused) {
            if (dropWhilePaused) {
              this.#teardown();
            }
            this.#provider.off("block", this.#poller);
          }
          resume() {
            this.start();
          }
        }
        class FilterIdEventSubscriber extends FilterIdSubscriber {
          #event;
          constructor(provider, filter) {
            super(provider);
            this.#event = copy(filter);
          }
          _recover(provider) {
            return new PollingEventSubscriber(provider, this.#event);
          }
          async _subscribe(provider) {
            const filterId = await provider.send("eth_newFilter", [
              this.#event,
            ]);
            return filterId;
          }
          async _emitResults(provider, results) {
            for (const result of results) {
              provider.emit(
                this.#event,
                provider._wrapLog(result, provider._network)
              );
            }
          }
        }
        class FilterIdPendingSubscriber extends FilterIdSubscriber {
          async _subscribe(provider) {
            return await provider.send("eth_newPendingTransactionFilter", []);
          }
          async _emitResults(provider, results) {
            for (const result of results) {
              provider.emit("pending", result);
            }
          }
        }
        const Primitive = "bigint,boolean,function,number,string,symbol".split(
          /,/g
        );
        function deepCopy(value) {
          if (value == null || Primitive.indexOf(typeof value) >= 0) {
            return value;
          }
          if (typeof value.getAddress === "function") {
            return value;
          }
          if (Array.isArray(value)) {
            return value.map(deepCopy);
          }
          if (typeof value === "object") {
            return Object.keys(value).reduce((accum, key) => {
              accum[key] = value[key];
              return accum;
            }, {});
          }
          throw new Error(`should not happen: ${value} (${typeof value})`);
        }
        function stall$3(duration) {
          return new Promise((resolve) => {
            setTimeout(resolve, duration);
          });
        }
        function getLowerCase(value) {
          if (value) {
            return value.toLowerCase();
          }
          return value;
        }
        function isPollable(value) {
          return value && typeof value.pollingInterval === "number";
        }
        const defaultOptions = {
          polling: false,
          staticNetwork: null,
          batchStallTime: 10,
          batchMaxSize: 1 << 20,
          batchMaxCount: 100,
          cacheTimeout: 250,
          pollingInterval: 4e3,
        };
        class JsonRpcSigner extends AbstractSigner {
          address;
          constructor(provider, address) {
            super(provider);
            address = getAddress(address);
            defineProperties(this, { address: address });
          }
          connect(provider) {
            assert$1(
              false,
              "cannot reconnect JsonRpcSigner",
              "UNSUPPORTED_OPERATION",
              { operation: "signer.connect" }
            );
          }
          async getAddress() {
            return this.address;
          }
          async populateTransaction(tx) {
            return await this.populateCall(tx);
          }
          async sendUncheckedTransaction(_tx) {
            const tx = deepCopy(_tx);
            const promises = [];
            if (tx.from) {
              const _from = tx.from;
              promises.push(
                (async () => {
                  const from = await resolveAddress(_from, this.provider);
                  assertArgument(
                    from != null &&
                      from.toLowerCase() === this.address.toLowerCase(),
                    "from address mismatch",
                    "transaction",
                    _tx
                  );
                  tx.from = from;
                })()
              );
            } else {
              tx.from = this.address;
            }
            if (tx.gasLimit == null) {
              promises.push(
                (async () => {
                  tx.gasLimit = await this.provider.estimateGas({
                    ...tx,
                    from: this.address,
                  });
                })()
              );
            }
            if (tx.to != null) {
              const _to = tx.to;
              promises.push(
                (async () => {
                  tx.to = await resolveAddress(_to, this.provider);
                })()
              );
            }
            if (promises.length) {
              await Promise.all(promises);
            }
            const hexTx = this.provider.getRpcTransaction(tx);
            return this.provider.send("eth_sendTransaction", [hexTx]);
          }
          async sendTransaction(tx) {
            const blockNumber = await this.provider.getBlockNumber();
            const hash = await this.sendUncheckedTransaction(tx);
            return await new Promise((resolve, reject) => {
              const timeouts = [1e3, 100];
              const checkTx = async () => {
                const tx = await this.provider.getTransaction(hash);
                if (tx != null) {
                  resolve(tx.replaceableTransaction(blockNumber));
                  return;
                }
                this.provider._setTimeout(() => {
                  checkTx();
                }, timeouts.pop() || 4e3);
              };
              checkTx();
            });
          }
          async signTransaction(_tx) {
            const tx = deepCopy(_tx);
            if (tx.from) {
              const from = await resolveAddress(tx.from, this.provider);
              assertArgument(
                from != null &&
                  from.toLowerCase() === this.address.toLowerCase(),
                "from address mismatch",
                "transaction",
                _tx
              );
              tx.from = from;
            } else {
              tx.from = this.address;
            }
            const hexTx = this.provider.getRpcTransaction(tx);
            return await this.provider.send("eth_signTransaction", [hexTx]);
          }
          async signMessage(_message) {
            const message =
              typeof _message === "string" ? toUtf8Bytes(_message) : _message;
            return await this.provider.send("personal_sign", [
              hexlify(message),
              this.address.toLowerCase(),
            ]);
          }
          async signTypedData(domain, types, _value) {
            const value = deepCopy(_value);
            const populated = await TypedDataEncoder.resolveNames(
              domain,
              types,
              value,
              async (value) => {
                const address = await resolveAddress(value);
                assertArgument(
                  address != null,
                  "TypedData does not support null address",
                  "value",
                  value
                );
                return address;
              }
            );
            return await this.provider.send("eth_signTypedData_v4", [
              this.address.toLowerCase(),
              JSON.stringify(
                TypedDataEncoder.getPayload(
                  populated.domain,
                  types,
                  populated.value
                )
              ),
            ]);
          }
          async unlock(password) {
            return this.provider.send("personal_unlockAccount", [
              this.address.toLowerCase(),
              password,
              null,
            ]);
          }
          async _legacySignMessage(_message) {
            const message =
              typeof _message === "string" ? toUtf8Bytes(_message) : _message;
            return await this.provider.send("eth_sign", [
              this.address.toLowerCase(),
              hexlify(message),
            ]);
          }
        }
        class JsonRpcApiProvider extends AbstractProvider {
          #options;
          #nextId;
          #payloads;
          #drainTimer;
          #notReady;
          #network;
          #scheduleDrain() {
            if (this.#drainTimer) {
              return;
            }
            const stallTime =
              this._getOption("batchMaxCount") === 1
                ? 0
                : this._getOption("batchStallTime");
            this.#drainTimer = setTimeout(() => {
              this.#drainTimer = null;
              const payloads = this.#payloads;
              this.#payloads = [];
              while (payloads.length) {
                const batch = [payloads.shift()];
                while (payloads.length) {
                  if (batch.length === this.#options.batchMaxCount) {
                    break;
                  }
                  batch.push(payloads.shift());
                  const bytes = JSON.stringify(batch.map((p) => p.payload));
                  if (bytes.length > this.#options.batchMaxSize) {
                    payloads.unshift(batch.pop());
                    break;
                  }
                }
                (async () => {
                  const payload =
                    batch.length === 1
                      ? batch[0].payload
                      : batch.map((p) => p.payload);
                  this.emit("debug", {
                    action: "sendRpcPayload",
                    payload: payload,
                  });
                  try {
                    const result = await this._send(payload);
                    this.emit("debug", {
                      action: "receiveRpcResult",
                      result: result,
                    });
                    for (const { resolve, reject, payload } of batch) {
                      if (this.destroyed) {
                        reject(
                          makeError(
                            "provider destroyed; cancelled request",
                            "UNSUPPORTED_OPERATION",
                            { operation: payload.method }
                          )
                        );
                        continue;
                      }
                      const resp = result.filter((r) => r.id === payload.id)[0];
                      if (resp == null) {
                        const error = makeError(
                          "missing response for request",
                          "BAD_DATA",
                          { value: result, info: { payload: payload } }
                        );
                        this.emit("error", error);
                        reject(error);
                        continue;
                      }
                      if ("error" in resp) {
                        reject(this.getRpcError(payload, resp));
                        continue;
                      }
                      resolve(resp.result);
                    }
                  } catch (error) {
                    this.emit("debug", {
                      action: "receiveRpcError",
                      error: error,
                    });
                    for (const { reject } of batch) {
                      reject(error);
                    }
                  }
                })();
              }
            }, stallTime);
          }
          constructor(network, options) {
            super(network, options);
            this.#nextId = 1;
            this.#options = Object.assign({}, defaultOptions, options || {});
            this.#payloads = [];
            this.#drainTimer = null;
            this.#network = null;
            {
              let resolve = null;
              const promise = new Promise((_resolve) => {
                resolve = _resolve;
              });
              this.#notReady = { promise: promise, resolve: resolve };
            }
            const staticNetwork = this._getOption("staticNetwork");
            if (staticNetwork) {
              assertArgument(
                network == null || staticNetwork.matches(network),
                "staticNetwork MUST match network object",
                "options",
                options
              );
              this.#network = staticNetwork;
            }
          }
          _getOption(key) {
            return this.#options[key];
          }
          get _network() {
            assert$1(
              this.#network,
              "network is not available yet",
              "NETWORK_ERROR"
            );
            return this.#network;
          }
          async _perform(req) {
            if (req.method === "call" || req.method === "estimateGas") {
              let tx = req.transaction;
              if (tx && tx.type != null && getBigInt(tx.type)) {
                if (
                  tx.maxFeePerGas == null &&
                  tx.maxPriorityFeePerGas == null
                ) {
                  const feeData = await this.getFeeData();
                  if (
                    feeData.maxFeePerGas == null &&
                    feeData.maxPriorityFeePerGas == null
                  ) {
                    req = Object.assign({}, req, {
                      transaction: Object.assign({}, tx, { type: undefined }),
                    });
                  }
                }
              }
            }
            const request = this.getRpcRequest(req);
            if (request != null) {
              return await this.send(request.method, request.args);
            }
            return super._perform(req);
          }
          async _detectNetwork() {
            const network = this._getOption("staticNetwork");
            if (network) {
              return network;
            }
            if (this.ready) {
              return Network.from(
                getBigInt(await this.send("eth_chainId", []))
              );
            }
            const payload = {
              id: this.#nextId++,
              method: "eth_chainId",
              params: [],
              jsonrpc: "2.0",
            };
            this.emit("debug", { action: "sendRpcPayload", payload: payload });
            let result;
            try {
              result = (await this._send(payload))[0];
            } catch (error) {
              this.emit("debug", { action: "receiveRpcError", error: error });
              throw error;
            }
            this.emit("debug", { action: "receiveRpcResult", result: result });
            if ("result" in result) {
              return Network.from(getBigInt(result.result));
            }
            throw this.getRpcError(payload, result);
          }
          _start() {
            if (this.#notReady == null || this.#notReady.resolve == null) {
              return;
            }
            this.#notReady.resolve();
            this.#notReady = null;
            (async () => {
              while (this.#network == null && !this.destroyed) {
                try {
                  this.#network = await this._detectNetwork();
                } catch (error) {
                  console.log(
                    "JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)"
                  );
                  this.emit(
                    "error",
                    makeError(
                      "failed to bootstrap network detection",
                      "NETWORK_ERROR",
                      {
                        event: "initial-network-discovery",
                        info: { error: error },
                      }
                    )
                  );
                  await stall$3(1e3);
                }
              }
              this.#scheduleDrain();
            })();
          }
          async _waitUntilReady() {
            if (this.#notReady == null) {
              return;
            }
            return await this.#notReady.promise;
          }
          _getSubscriber(sub) {
            if (sub.type === "pending") {
              return new FilterIdPendingSubscriber(this);
            }
            if (sub.type === "event") {
              if (this._getOption("polling")) {
                return new PollingEventSubscriber(this, sub.filter);
              }
              return new FilterIdEventSubscriber(this, sub.filter);
            }
            if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
              return new UnmanagedSubscriber("orphan");
            }
            return super._getSubscriber(sub);
          }
          get ready() {
            return this.#notReady == null;
          }
          getRpcTransaction(tx) {
            const result = {};
            [
              "chainId",
              "gasLimit",
              "gasPrice",
              "type",
              "maxFeePerGas",
              "maxPriorityFeePerGas",
              "nonce",
              "value",
            ].forEach((key) => {
              if (tx[key] == null) {
                return;
              }
              let dstKey = key;
              if (key === "gasLimit") {
                dstKey = "gas";
              }
              result[dstKey] = toQuantity(getBigInt(tx[key], `tx.${key}`));
            });
            ["from", "to", "data"].forEach((key) => {
              if (tx[key] == null) {
                return;
              }
              result[key] = hexlify(tx[key]);
            });
            if (tx.accessList) {
              result["accessList"] = accessListify(tx.accessList);
            }
            return result;
          }
          getRpcRequest(req) {
            switch (req.method) {
              case "chainId":
                return { method: "eth_chainId", args: [] };
              case "getBlockNumber":
                return { method: "eth_blockNumber", args: [] };
              case "getGasPrice":
                return { method: "eth_gasPrice", args: [] };
              case "getBalance":
                return {
                  method: "eth_getBalance",
                  args: [getLowerCase(req.address), req.blockTag],
                };
              case "getTransactionCount":
                return {
                  method: "eth_getTransactionCount",
                  args: [getLowerCase(req.address), req.blockTag],
                };
              case "getCode":
                return {
                  method: "eth_getCode",
                  args: [getLowerCase(req.address), req.blockTag],
                };
              case "getStorage":
                return {
                  method: "eth_getStorageAt",
                  args: [
                    getLowerCase(req.address),
                    "0x" + req.position.toString(16),
                    req.blockTag,
                  ],
                };
              case "broadcastTransaction":
                return {
                  method: "eth_sendRawTransaction",
                  args: [req.signedTransaction],
                };
              case "getBlock":
                if ("blockTag" in req) {
                  return {
                    method: "eth_getBlockByNumber",
                    args: [req.blockTag, !!req.includeTransactions],
                  };
                } else if ("blockHash" in req) {
                  return {
                    method: "eth_getBlockByHash",
                    args: [req.blockHash, !!req.includeTransactions],
                  };
                }
                break;
              case "getTransaction":
                return { method: "eth_getTransactionByHash", args: [req.hash] };
              case "getTransactionReceipt":
                return {
                  method: "eth_getTransactionReceipt",
                  args: [req.hash],
                };
              case "call":
                return {
                  method: "eth_call",
                  args: [this.getRpcTransaction(req.transaction), req.blockTag],
                };
              case "estimateGas": {
                return {
                  method: "eth_estimateGas",
                  args: [this.getRpcTransaction(req.transaction)],
                };
              }
              case "getLogs":
                if (req.filter && req.filter.address != null) {
                  if (Array.isArray(req.filter.address)) {
                    req.filter.address = req.filter.address.map(getLowerCase);
                  } else {
                    req.filter.address = getLowerCase(req.filter.address);
                  }
                }
                return { method: "eth_getLogs", args: [req.filter] };
            }
            return null;
          }
          getRpcError(payload, _error) {
            const { method } = payload;
            const { error } = _error;
            if (method === "eth_estimateGas" && error.message) {
              const msg = error.message;
              if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
                return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: payload.params[0],
                  info: { payload: payload, error: error },
                });
              }
            }
            if (method === "eth_call" || method === "eth_estimateGas") {
              const result = spelunkData(error);
              const e = AbiCoder.getBuiltinCallException(
                method === "eth_call" ? "call" : "estimateGas",
                payload.params[0],
                result ? result.data : null
              );
              e.info = { error: error, payload: payload };
              return e;
            }
            const message = JSON.stringify(spelunkMessage(error));
            if (
              typeof error.message === "string" &&
              error.message.match(/user denied|ethers-user-denied/i)
            ) {
              const actionMap = {
                eth_sign: "signMessage",
                personal_sign: "signMessage",
                eth_signTypedData_v4: "signTypedData",
                eth_signTransaction: "signTransaction",
                eth_sendTransaction: "sendTransaction",
                eth_requestAccounts: "requestAccess",
                wallet_requestAccounts: "requestAccess",
              };
              return makeError(`user rejected action`, "ACTION_REJECTED", {
                action: actionMap[method] || "unknown",
                reason: "rejected",
                info: { payload: payload, error: error },
              });
            }
            if (
              method === "eth_sendRawTransaction" ||
              method === "eth_sendTransaction"
            ) {
              const transaction = payload.params[0];
              if (
                message.match(/insufficient funds|base fee exceeds gas limit/i)
              ) {
                return makeError(
                  "insufficient funds for intrinsic transaction cost",
                  "INSUFFICIENT_FUNDS",
                  { transaction: transaction, info: { error: error } }
                );
              }
              if (message.match(/nonce/i) && message.match(/too low/i)) {
                return makeError(
                  "nonce has already been used",
                  "NONCE_EXPIRED",
                  { transaction: transaction, info: { error: error } }
                );
              }
              if (
                message.match(/replacement transaction/i) &&
                message.match(/underpriced/i)
              ) {
                return makeError(
                  "replacement fee too low",
                  "REPLACEMENT_UNDERPRICED",
                  { transaction: transaction, info: { error: error } }
                );
              }
              if (message.match(/only replay-protected/i)) {
                return makeError(
                  "legacy pre-eip-155 transactions not supported",
                  "UNSUPPORTED_OPERATION",
                  {
                    operation: method,
                    info: { transaction: transaction, info: { error: error } },
                  }
                );
              }
            }
            let unsupported = !!message.match(/the method .* does not exist/i);
            if (!unsupported) {
              if (
                error &&
                error.details &&
                error.details.startsWith("Unauthorized method:")
              ) {
                unsupported = true;
              }
            }
            if (unsupported) {
              return makeError(
                "unsupported operation",
                "UNSUPPORTED_OPERATION",
                {
                  operation: payload.method,
                  info: { error: error, payload: payload },
                }
              );
            }
            return makeError("could not coalesce error", "UNKNOWN_ERROR", {
              error: error,
              payload: payload,
            });
          }
          send(method, params) {
            if (this.destroyed) {
              return Promise.reject(
                makeError(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: method }
                )
              );
            }
            const id = this.#nextId++;
            const promise = new Promise((resolve, reject) => {
              this.#payloads.push({
                resolve: resolve,
                reject: reject,
                payload: {
                  method: method,
                  params: params,
                  id: id,
                  jsonrpc: "2.0",
                },
              });
            });
            this.#scheduleDrain();
            return promise;
          }
          async getSigner(address) {
            if (address == null) {
              address = 0;
            }
            const accountsPromise = this.send("eth_accounts", []);
            if (typeof address === "number") {
              const accounts = await accountsPromise;
              if (address >= accounts.length) {
                throw new Error("no such account");
              }
              return new JsonRpcSigner(this, accounts[address]);
            }
            const { accounts } = await resolveProperties({
              network: this.getNetwork(),
              accounts: accountsPromise,
            });
            address = getAddress(address);
            for (const account of accounts) {
              if (getAddress(account) === address) {
                return new JsonRpcSigner(this, address);
              }
            }
            throw new Error("invalid account");
          }
          async listAccounts() {
            const accounts = await this.send("eth_accounts", []);
            return accounts.map((a) => new JsonRpcSigner(this, a));
          }
          destroy() {
            if (this.#drainTimer) {
              clearTimeout(this.#drainTimer);
              this.#drainTimer = null;
            }
            for (const { payload, reject } of this.#payloads) {
              reject(
                makeError(
                  "provider destroyed; cancelled request",
                  "UNSUPPORTED_OPERATION",
                  { operation: payload.method }
                )
              );
            }
            this.#payloads = [];
            super.destroy();
          }
        }
        class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
          #pollingInterval;
          constructor(network, options) {
            super(network, options);
            this.#pollingInterval = 4e3;
          }
          _getSubscriber(sub) {
            const subscriber = super._getSubscriber(sub);
            if (isPollable(subscriber)) {
              subscriber.pollingInterval = this.#pollingInterval;
            }
            return subscriber;
          }
          get pollingInterval() {
            return this.#pollingInterval;
          }
          set pollingInterval(value) {
            if (!Number.isInteger(value) || value < 0) {
              throw new Error("invalid interval");
            }
            this.#pollingInterval = value;
            this._forEachSubscriber((sub) => {
              if (isPollable(sub)) {
                sub.pollingInterval = this.#pollingInterval;
              }
            });
          }
        }
        class JsonRpcProvider extends JsonRpcApiPollingProvider {
          #connect;
          constructor(url, network, options) {
            if (url == null) {
              url = "http://localhost:8545";
            }
            super(network, options);
            if (typeof url === "string") {
              this.#connect = new FetchRequest(url);
            } else {
              this.#connect = url.clone();
            }
          }
          _getConnection() {
            return this.#connect.clone();
          }
          async send(method, params) {
            await this._start();
            return await super.send(method, params);
          }
          async _send(payload) {
            const request = this._getConnection();
            request.body = JSON.stringify(payload);
            request.setHeader("content-type", "application/json");
            const response = await request.send();
            response.assertOk();
            let resp = response.bodyJson;
            if (!Array.isArray(resp)) {
              resp = [resp];
            }
            return resp;
          }
        }
        function spelunkData(value) {
          if (value == null) {
            return null;
          }
          if (
            typeof value.message === "string" &&
            value.message.match(/revert/i) &&
            isHexString(value.data)
          ) {
            return { message: value.message, data: value.data };
          }
          if (typeof value === "object") {
            for (const key in value) {
              const result = spelunkData(value[key]);
              if (result) {
                return result;
              }
            }
            return null;
          }
          if (typeof value === "string") {
            try {
              return spelunkData(JSON.parse(value));
            } catch (error) {}
          }
          return null;
        }
        function _spelunkMessage(value, result) {
          if (value == null) {
            return;
          }
          if (typeof value.message === "string") {
            result.push(value.message);
          }
          if (typeof value === "object") {
            for (const key in value) {
              _spelunkMessage(value[key], result);
            }
          }
          if (typeof value === "string") {
            try {
              return _spelunkMessage(JSON.parse(value), result);
            } catch (error) {}
          }
        }
        function spelunkMessage(value) {
          const result = [];
          _spelunkMessage(value, result);
          return result;
        }
        const defaultApiKey$1 =
          "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
        function getHost$4(name) {
          switch (name) {
            case "mainnet":
              return "rpc.ankr.com/eth";
            case "goerli":
              return "rpc.ankr.com/eth_goerli";
            case "matic":
              return "rpc.ankr.com/polygon";
            case "arbitrum":
              return "rpc.ankr.com/arbitrum";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class AnkrProvider extends JsonRpcProvider {
          apiKey;
          constructor(_network, apiKey) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (apiKey == null) {
              apiKey = defaultApiKey$1;
            }
            const options = { polling: true, staticNetwork: network };
            const request = AnkrProvider.getRequest(network, apiKey);
            super(request, network, options);
            defineProperties(this, { apiKey: apiKey });
          }
          _getProvider(chainId) {
            try {
              return new AnkrProvider(chainId, this.apiKey);
            } catch (error) {}
            return super._getProvider(chainId);
          }
          static getRequest(network, apiKey) {
            if (apiKey == null) {
              apiKey = defaultApiKey$1;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$4(network.name)}/${apiKey}`
            );
            request.allowGzip = true;
            if (apiKey === defaultApiKey$1) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("AnkrProvider");
                return true;
              };
            }
            return request;
          }
          getRpcError(payload, error) {
            if (payload.method === "eth_sendRawTransaction") {
              if (
                error &&
                error.error &&
                error.error.message ===
                  "INTERNAL_ERROR: could not replace existing tx"
              ) {
                error.error.message = "replacement transaction underpriced";
              }
            }
            return super.getRpcError(payload, error);
          }
          isCommunityResource() {
            return this.apiKey === defaultApiKey$1;
          }
        }
        const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
        function getHost$3(name) {
          switch (name) {
            case "mainnet":
              return "eth-mainnet.alchemyapi.io";
            case "goerli":
              return "eth-goerli.g.alchemy.com";
            case "sepolia":
              return "eth-sepolia.g.alchemy.com";
            case "arbitrum":
              return "arb-mainnet.g.alchemy.com";
            case "arbitrum-goerli":
              return "arb-goerli.g.alchemy.com";
            case "matic":
              return "polygon-mainnet.g.alchemy.com";
            case "matic-mumbai":
              return "polygon-mumbai.g.alchemy.com";
            case "optimism":
              return "opt-mainnet.g.alchemy.com";
            case "optimism-goerli":
              return "opt-goerli.g.alchemy.com";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class AlchemyProvider extends JsonRpcProvider {
          apiKey;
          constructor(_network, apiKey) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (apiKey == null) {
              apiKey = defaultApiKey;
            }
            const request = AlchemyProvider.getRequest(network, apiKey);
            super(request, network, { staticNetwork: network });
            defineProperties(this, { apiKey: apiKey });
          }
          _getProvider(chainId) {
            try {
              return new AlchemyProvider(chainId, this.apiKey);
            } catch (error) {}
            return super._getProvider(chainId);
          }
          async _perform(req) {
            if (req.method === "getTransactionResult") {
              const { trace, tx } = await resolveProperties({
                trace: this.send("trace_transaction", [req.hash]),
                tx: this.getTransaction(req.hash),
              });
              if (trace == null || tx == null) {
                return null;
              }
              let data;
              let error = false;
              try {
                data = trace[0].result.output;
                error = trace[0].error === "Reverted";
              } catch (error) {}
              if (data) {
                assert$1(
                  !error,
                  "an error occurred during transaction executions",
                  "CALL_EXCEPTION",
                  {
                    action: "getTransactionResult",
                    data: data,
                    reason: null,
                    transaction: tx,
                    invocation: null,
                    revert: null,
                  }
                );
                return data;
              }
              assert$1(false, "could not parse trace result", "BAD_DATA", {
                value: trace,
              });
            }
            return await super._perform(req);
          }
          isCommunityResource() {
            return this.apiKey === defaultApiKey;
          }
          static getRequest(network, apiKey) {
            if (apiKey == null) {
              apiKey = defaultApiKey;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$3(network.name)}/v2/${apiKey}`
            );
            request.allowGzip = true;
            if (apiKey === defaultApiKey) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("alchemy");
                return true;
              };
            }
            return request;
          }
        }
        class CloudflareProvider extends JsonRpcProvider {
          constructor(_network) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            assertArgument(
              network.name === "mainnet",
              "unsupported network",
              "network",
              _network
            );
            super("https://cloudflare-eth.com/", network, {
              staticNetwork: network,
            });
          }
        }
        const THROTTLE = 2e3;
        function isPromise(value) {
          return value && typeof value.then === "function";
        }
        const EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
        class EtherscanPlugin extends NetworkPlugin {
          baseUrl;
          constructor(baseUrl) {
            super(EtherscanPluginId);
            defineProperties(this, { baseUrl: baseUrl });
          }
          clone() {
            return new EtherscanPlugin(this.baseUrl);
          }
        }
        const skipKeys = ["enableCcipRead"];
        let nextId = 1;
        class EtherscanProvider extends AbstractProvider {
          network;
          apiKey;
          #plugin;
          constructor(_network, _apiKey) {
            const apiKey = _apiKey != null ? _apiKey : null;
            super();
            const network = Network.from(_network);
            this.#plugin = network.getPlugin(EtherscanPluginId);
            defineProperties(this, { apiKey: apiKey, network: network });
            this.getBaseUrl();
          }
          getBaseUrl() {
            if (this.#plugin) {
              return this.#plugin.baseUrl;
            }
            switch (this.network.name) {
              case "mainnet":
                return "https://api.etherscan.io";
              case "goerli":
                return "https://api-goerli.etherscan.io";
              case "sepolia":
                return "https://api-sepolia.etherscan.io";
              case "arbitrum":
                return "https://api.arbiscan.io";
              case "arbitrum-goerli":
                return "https://api-goerli.arbiscan.io";
              case "matic":
                return "https://api.polygonscan.com";
              case "matic-mumbai":
                return "https://api-testnet.polygonscan.com";
              case "optimism":
                return "https://api-optimistic.etherscan.io";
              case "optimism-goerli":
                return "https://api-goerli-optimistic.etherscan.io";
              case "bnb":
                return "http://api.bscscan.com";
              case "bnbt":
                return "http://api-testnet.bscscan.com";
            }
            assertArgument(
              false,
              "unsupported network",
              "network",
              this.network
            );
          }
          getUrl(module, params) {
            const query = Object.keys(params).reduce((accum, key) => {
              const value = params[key];
              if (value != null) {
                accum += `&${key}=${value}`;
              }
              return accum;
            }, "");
            const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
            return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;
          }
          getPostUrl() {
            return `${this.getBaseUrl()}/api`;
          }
          getPostData(module, params) {
            params.module = module;
            params.apikey = this.apiKey;
            return params;
          }
          async detectNetwork() {
            return this.network;
          }
          async fetch(module, params, post) {
            const id = nextId++;
            const url = post ? this.getPostUrl() : this.getUrl(module, params);
            const payload = post ? this.getPostData(module, params) : null;
            this.emit("debug", {
              action: "sendRequest",
              id: id,
              url: url,
              payload: payload,
            });
            const request = new FetchRequest(url);
            request.setThrottleParams({ slotInterval: 1e3 });
            request.retryFunc = (req, resp, attempt) => {
              if (this.isCommunityResource()) {
                showThrottleMessage("Etherscan");
              }
              return Promise.resolve(true);
            };
            request.processFunc = async (request, response) => {
              const result = response.hasBody()
                ? JSON.parse(toUtf8String(response.body))
                : {};
              const throttle =
                (typeof result.result === "string" ? result.result : "")
                  .toLowerCase()
                  .indexOf("rate limit") >= 0;
              if (module === "proxy") {
                if (
                  result &&
                  result.status == 0 &&
                  result.message == "NOTOK" &&
                  throttle
                ) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    reason: "proxy-NOTOK",
                    error: result,
                  });
                  response.throwThrottleError(result.result, THROTTLE);
                }
              } else {
                if (throttle) {
                  this.emit("debug", {
                    action: "receiveError",
                    id: id,
                    reason: "null result",
                    error: result.result,
                  });
                  response.throwThrottleError(result.result, THROTTLE);
                }
              }
              return response;
            };
            if (payload) {
              request.setHeader(
                "content-type",
                "application/x-www-form-urlencoded; charset=UTF-8"
              );
              request.body = Object.keys(payload)
                .map((k) => `${k}=${payload[k]}`)
                .join("&");
            }
            const response = await request.send();
            try {
              response.assertOk();
            } catch (error) {
              this.emit("debug", {
                action: "receiveError",
                id: id,
                error: error,
                reason: "assertOk",
              });
              assert$1(false, "response error", "SERVER_ERROR", {
                request: request,
                response: response,
              });
            }
            if (!response.hasBody()) {
              this.emit("debug", {
                action: "receiveError",
                id: id,
                error: "missing body",
                reason: "null body",
              });
              assert$1(false, "missing response", "SERVER_ERROR", {
                request: request,
                response: response,
              });
            }
            const result = JSON.parse(toUtf8String(response.body));
            if (module === "proxy") {
              if (result.jsonrpc != "2.0") {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "invalid JSON-RPC",
                });
                assert$1(
                  false,
                  "invalid JSON-RPC response (missing jsonrpc='2.0')",
                  "SERVER_ERROR",
                  {
                    request: request,
                    response: response,
                    info: { result: result },
                  }
                );
              }
              if (result.error) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "JSON-RPC error",
                });
                assert$1(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: { result: result },
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result,
              });
              return result.result;
            } else {
              if (
                result.status == 0 &&
                (result.message === "No records found" ||
                  result.message === "No transactions found")
              ) {
                this.emit("debug", {
                  action: "receiveRequest",
                  id: id,
                  result: result,
                });
                return result.result;
              }
              if (
                result.status != 1 ||
                (typeof result.message === "string" &&
                  !result.message.match(/^OK/))
              ) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                });
                assert$1(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: { result: result },
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result,
              });
              return result.result;
            }
          }
          _getTransactionPostData(transaction) {
            const result = {};
            for (let key in transaction) {
              if (skipKeys.indexOf(key) >= 0) {
                continue;
              }
              if (transaction[key] == null) {
                continue;
              }
              let value = transaction[key];
              if (key === "type" && value === 0) {
                continue;
              }
              if (
                {
                  type: true,
                  gasLimit: true,
                  gasPrice: true,
                  maxFeePerGs: true,
                  maxPriorityFeePerGas: true,
                  nonce: true,
                  value: true,
                }[key]
              ) {
                value = toQuantity(value);
              } else if (key === "accessList") {
                value =
                  "[" +
                  accessListify(value)
                    .map((set) => {
                      return `{address:"${
                        set.address
                      }",storageKeys:["${set.storageKeys.join('","')}"]}`;
                    })
                    .join(",") +
                  "]";
              } else {
                value = hexlify(value);
              }
              result[key] = value;
            }
            return result;
          }
          _checkError(req, error, transaction) {
            let message = "";
            if (isError(error, "SERVER_ERROR")) {
              try {
                message = error.info.result.error.message;
              } catch (e) {}
              if (!message) {
                try {
                  message = error.info.message;
                } catch (e) {}
              }
            }
            if (req.method === "estimateGas") {
              if (
                !message.match(/revert/i) &&
                message.match(/insufficient funds/i)
              ) {
                assert$1(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
                  transaction: req.transaction,
                });
              }
            }
            if (req.method === "call" || req.method === "estimateGas") {
              if (message.match(/execution reverted/i)) {
                let data = "";
                try {
                  data = error.info.result.error.data;
                } catch (error) {}
                const e = AbiCoder.getBuiltinCallException(
                  req.method,
                  req.transaction,
                  data
                );
                e.info = { request: req, error: error };
                throw e;
              }
            }
            if (message) {
              if (req.method === "broadcastTransaction") {
                const transaction = Transaction.from(req.signedTransaction);
                if (
                  message.match(/replacement/i) &&
                  message.match(/underpriced/i)
                ) {
                  assert$1(
                    false,
                    "replacement fee too low",
                    "REPLACEMENT_UNDERPRICED",
                    { transaction: transaction }
                  );
                }
                if (message.match(/insufficient funds/)) {
                  assert$1(
                    false,
                    "insufficient funds for intrinsic transaction cost",
                    "INSUFFICIENT_FUNDS",
                    { transaction: transaction }
                  );
                }
                if (
                  message.match(
                    /same hash was already imported|transaction nonce is too low|nonce too low/
                  )
                ) {
                  assert$1(
                    false,
                    "nonce has already been used",
                    "NONCE_EXPIRED",
                    { transaction: transaction }
                  );
                }
              }
            }
            throw error;
          }
          async _detectNetwork() {
            return this.network;
          }
          async _perform(req) {
            switch (req.method) {
              case "chainId":
                return this.network.chainId;
              case "getBlockNumber":
                return this.fetch("proxy", { action: "eth_blockNumber" });
              case "getGasPrice":
                return this.fetch("proxy", { action: "eth_gasPrice" });
              case "getBalance":
                return this.fetch("account", {
                  action: "balance",
                  address: req.address,
                  tag: req.blockTag,
                });
              case "getTransactionCount":
                return this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: req.address,
                  tag: req.blockTag,
                });
              case "getCode":
                return this.fetch("proxy", {
                  action: "eth_getCode",
                  address: req.address,
                  tag: req.blockTag,
                });
              case "getStorage":
                return this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: req.address,
                  position: req.position,
                  tag: req.blockTag,
                });
              case "broadcastTransaction":
                return this.fetch(
                  "proxy",
                  {
                    action: "eth_sendRawTransaction",
                    hex: req.signedTransaction,
                  },
                  true
                ).catch((error) => {
                  return this._checkError(req, error, req.signedTransaction);
                });
              case "getBlock":
                if ("blockTag" in req) {
                  return this.fetch("proxy", {
                    action: "eth_getBlockByNumber",
                    tag: req.blockTag,
                    boolean: req.includeTransactions ? "true" : "false",
                  });
                }
                assert$1(
                  false,
                  "getBlock by blockHash not supported by Etherscan",
                  "UNSUPPORTED_OPERATION",
                  { operation: "getBlock(blockHash)" }
                );
              case "getTransaction":
                return this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: req.hash,
                });
              case "getTransactionReceipt":
                return this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: req.hash,
                });
              case "call": {
                if (req.blockTag !== "latest") {
                  throw new Error(
                    "EtherscanProvider does not support blockTag for call"
                  );
                }
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                try {
                  return await this.fetch("proxy", postData, true);
                } catch (error) {
                  return this._checkError(req, error, req.transaction);
                }
              }
              case "estimateGas": {
                const postData = this._getTransactionPostData(req.transaction);
                postData.module = "proxy";
                postData.action = "eth_estimateGas";
                try {
                  return await this.fetch("proxy", postData, true);
                } catch (error) {
                  return this._checkError(req, error, req.transaction);
                }
              }
            }
            return super._perform(req);
          }
          async getNetwork() {
            return this.network;
          }
          async getEtherPrice() {
            if (this.network.name !== "mainnet") {
              return 0;
            }
            return parseFloat(
              (await this.fetch("stats", { action: "ethprice" })).ethusd
            );
          }
          async getContract(_address) {
            let address = this._getAddress(_address);
            if (isPromise(address)) {
              address = await address;
            }
            try {
              const resp = await this.fetch("contract", {
                action: "getabi",
                address: address,
              });
              const abi = JSON.parse(resp);
              return new Contract(address, abi, this);
            } catch (error) {
              return null;
            }
          }
          isCommunityResource() {
            return this.apiKey == null;
          }
        }
        function getGlobal() {
          if (typeof self !== "undefined") {
            return self;
          }
          if (typeof window !== "undefined") {
            return window;
          }
          if (typeof global !== "undefined") {
            return global;
          }
          throw new Error("unable to locate global object");
        }
        const _WebSocket = getGlobal().WebSocket;
        class SocketSubscriber {
          #provider;
          #filter;
          get filter() {
            return JSON.parse(this.#filter);
          }
          #filterId;
          #paused;
          #emitPromise;
          constructor(provider, filter) {
            this.#provider = provider;
            this.#filter = JSON.stringify(filter);
            this.#filterId = null;
            this.#paused = null;
            this.#emitPromise = null;
          }
          start() {
            this.#filterId = this.#provider
              .send("eth_subscribe", this.filter)
              .then((filterId) => {
                this.#provider._register(filterId, this);
                return filterId;
              });
          }
          stop() {
            this.#filterId.then((filterId) => {
              this.#provider.send("eth_unsubscribe", [filterId]);
            });
            this.#filterId = null;
          }
          pause(dropWhilePaused) {
            assert$1(
              dropWhilePaused,
              "preserve logs while paused not supported by SocketSubscriber yet",
              "UNSUPPORTED_OPERATION",
              { operation: "pause(false)" }
            );
            this.#paused = !!dropWhilePaused;
          }
          resume() {
            this.#paused = null;
          }
          _handleMessage(message) {
            if (this.#filterId == null) {
              return;
            }
            if (this.#paused === null) {
              let emitPromise = this.#emitPromise;
              if (emitPromise == null) {
                emitPromise = this._emit(this.#provider, message);
              } else {
                emitPromise = emitPromise.then(async () => {
                  await this._emit(this.#provider, message);
                });
              }
              this.#emitPromise = emitPromise.then(() => {
                if (this.#emitPromise === emitPromise) {
                  this.#emitPromise = null;
                }
              });
            }
          }
          async _emit(provider, message) {
            throw new Error("sub-classes must implemente this; _emit");
          }
        }
        class SocketBlockSubscriber extends SocketSubscriber {
          constructor(provider) {
            super(provider, ["newHeads"]);
          }
          async _emit(provider, message) {
            provider.emit("block", parseInt(message.number));
          }
        }
        class SocketPendingSubscriber extends SocketSubscriber {
          constructor(provider) {
            super(provider, ["newPendingTransactions"]);
          }
          async _emit(provider, message) {
            provider.emit("pending", message);
          }
        }
        class SocketEventSubscriber extends SocketSubscriber {
          #logFilter;
          get logFilter() {
            return JSON.parse(this.#logFilter);
          }
          constructor(provider, filter) {
            super(provider, ["logs", filter]);
            this.#logFilter = JSON.stringify(filter);
          }
          async _emit(provider, message) {
            provider.emit(
              this.logFilter,
              provider._wrapLog(message, provider._network)
            );
          }
        }
        class SocketProvider extends JsonRpcApiProvider {
          #callbacks;
          #subs;
          #pending;
          constructor(network) {
            super(network, { batchMaxCount: 1 });
            this.#callbacks = new Map();
            this.#subs = new Map();
            this.#pending = new Map();
          }
          _getSubscriber(sub) {
            switch (sub.type) {
              case "close":
                return new UnmanagedSubscriber("close");
              case "block":
                return new SocketBlockSubscriber(this);
              case "pending":
                return new SocketPendingSubscriber(this);
              case "event":
                return new SocketEventSubscriber(this, sub.filter);
              case "orphan":
                if (sub.filter.orphan === "drop-log") {
                  return new UnmanagedSubscriber("drop-log");
                }
            }
            return super._getSubscriber(sub);
          }
          _register(filterId, subscriber) {
            this.#subs.set(filterId, subscriber);
            const pending = this.#pending.get(filterId);
            if (pending) {
              for (const message of pending) {
                subscriber._handleMessage(message);
              }
              this.#pending.delete(filterId);
            }
          }
          async _send(payload) {
            assertArgument(
              !Array.isArray(payload),
              "WebSocket does not support batch send",
              "payload",
              payload
            );
            const promise = new Promise((resolve, reject) => {
              this.#callbacks.set(payload.id, {
                payload: payload,
                resolve: resolve,
                reject: reject,
              });
            });
            await this._waitUntilReady();
            await this._write(JSON.stringify(payload));
            return [await promise];
          }
          async _processMessage(message) {
            const result = JSON.parse(message);
            if (result && typeof result === "object" && "id" in result) {
              const callback = this.#callbacks.get(result.id);
              if (callback == null) {
                this.emit(
                  "error",
                  makeError("received result for unknown id", "UNKNOWN_ERROR", {
                    reasonCode: "UNKNOWN_ID",
                    result: result,
                  })
                );
                return;
              }
              this.#callbacks.delete(result.id);
              callback.resolve(result);
            } else if (result && result.method === "eth_subscription") {
              const filterId = result.params.subscription;
              const subscriber = this.#subs.get(filterId);
              if (subscriber) {
                subscriber._handleMessage(result.params.result);
              } else {
                let pending = this.#pending.get(filterId);
                if (pending == null) {
                  pending = [];
                  this.#pending.set(filterId, pending);
                }
                pending.push(result.params.result);
              }
            } else {
              this.emit(
                "error",
                makeError("received unexpected message", "UNKNOWN_ERROR", {
                  reasonCode: "UNEXPECTED_MESSAGE",
                  result: result,
                })
              );
              return;
            }
          }
          async _write(message) {
            throw new Error("sub-classes must override this");
          }
        }
        class WebSocketProvider extends SocketProvider {
          #connect;
          #websocket;
          get websocket() {
            if (this.#websocket == null) {
              throw new Error("websocket closed");
            }
            return this.#websocket;
          }
          constructor(url, network) {
            super(network);
            if (typeof url === "string") {
              this.#connect = () => {
                return new _WebSocket(url);
              };
              this.#websocket = this.#connect();
            } else if (typeof url === "function") {
              this.#connect = url;
              this.#websocket = url();
            } else {
              this.#connect = null;
              this.#websocket = url;
            }
            this.websocket.onopen = async () => {
              try {
                await this._start();
                this.resume();
              } catch (error) {
                console.log("failed to start WebsocketProvider", error);
              }
            };
            this.websocket.onmessage = (message) => {
              this._processMessage(message.data);
            };
          }
          async _write(message) {
            this.websocket.send(message);
          }
          async destroy() {
            if (this.#websocket != null) {
              this.#websocket.close();
              this.#websocket = null;
            }
            super.destroy();
          }
        }
        const defaultProjectId = "84842078b09946638c03157f83405213";
        function getHost$2(name) {
          switch (name) {
            case "mainnet":
              return "mainnet.infura.io";
            case "goerli":
              return "goerli.infura.io";
            case "sepolia":
              return "sepolia.infura.io";
            case "arbitrum":
              return "arbitrum-mainnet.infura.io";
            case "arbitrum-goerli":
              return "arbitrum-goerli.infura.io";
            case "linea":
              return "linea-mainnet.infura.io";
            case "linea-goerli":
              return "linea-goerli.infura.io";
            case "matic":
              return "polygon-mainnet.infura.io";
            case "matic-mumbai":
              return "polygon-mumbai.infura.io";
            case "optimism":
              return "optimism-mainnet.infura.io";
            case "optimism-goerli":
              return "optimism-goerli.infura.io";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class InfuraWebSocketProvider extends WebSocketProvider {
          projectId;
          projectSecret;
          constructor(network, projectId) {
            const provider = new InfuraProvider(network, projectId);
            const req = provider._getConnection();
            assert$1(
              !req.credentials,
              "INFURA WebSocket project secrets unsupported",
              "UNSUPPORTED_OPERATION",
              { operation: "InfuraProvider.getWebSocketProvider()" }
            );
            const url = req.url
              .replace(/^http/i, "ws")
              .replace("/v3/", "/ws/v3/");
            super(url, network);
            defineProperties(this, {
              projectId: provider.projectId,
              projectSecret: provider.projectSecret,
            });
          }
          isCommunityResource() {
            return this.projectId === defaultProjectId;
          }
        }
        class InfuraProvider extends JsonRpcProvider {
          projectId;
          projectSecret;
          constructor(_network, projectId, projectSecret) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (projectId == null) {
              projectId = defaultProjectId;
            }
            if (projectSecret == null) {
              projectSecret = null;
            }
            const request = InfuraProvider.getRequest(
              network,
              projectId,
              projectSecret
            );
            super(request, network, { staticNetwork: network });
            defineProperties(this, {
              projectId: projectId,
              projectSecret: projectSecret,
            });
          }
          _getProvider(chainId) {
            try {
              return new InfuraProvider(
                chainId,
                this.projectId,
                this.projectSecret
              );
            } catch (error) {}
            return super._getProvider(chainId);
          }
          isCommunityResource() {
            return this.projectId === defaultProjectId;
          }
          static getWebSocketProvider(network, projectId) {
            return new InfuraWebSocketProvider(network, projectId);
          }
          static getRequest(network, projectId, projectSecret) {
            if (projectId == null) {
              projectId = defaultProjectId;
            }
            if (projectSecret == null) {
              projectSecret = null;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$2(network.name)}/v3/${projectId}`
            );
            request.allowGzip = true;
            if (projectSecret) {
              request.setCredentials("", projectSecret);
            }
            if (projectId === defaultProjectId) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("InfuraProvider");
                return true;
              };
            }
            return request;
          }
        }
        const defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
        function getHost$1(name) {
          switch (name) {
            case "mainnet":
              return "ethers.quiknode.pro";
            case "goerli":
              return "ethers.ethereum-goerli.quiknode.pro";
            case "arbitrum":
              return "ethers.arbitrum-mainnet.quiknode.pro";
            case "arbitrum-goerli":
              return "ethers.arbitrum-goerli.quiknode.pro";
            case "matic":
              return "ethers.matic.quiknode.pro";
            case "matic-mumbai":
              return "ethers.matic-testnet.quiknode.pro";
            case "optimism":
              return "ethers.optimism.quiknode.pro";
            case "optimism-goerli":
              return "ethers.optimism-goerli.quiknode.pro";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class QuickNodeProvider extends JsonRpcProvider {
          token;
          constructor(_network, token) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (token == null) {
              token = defaultToken;
            }
            const request = QuickNodeProvider.getRequest(network, token);
            super(request, network, { staticNetwork: network });
            defineProperties(this, { token: token });
          }
          _getProvider(chainId) {
            try {
              return new QuickNodeProvider(chainId, this.token);
            } catch (error) {}
            return super._getProvider(chainId);
          }
          isCommunityResource() {
            return this.token === defaultToken;
          }
          static getRequest(network, token) {
            if (token == null) {
              token = defaultToken;
            }
            const request = new FetchRequest(
              `https:/\/${getHost$1(network.name)}/${token}`
            );
            request.allowGzip = true;
            if (token === defaultToken) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("QuickNodeProvider");
                return true;
              };
            }
            return request;
          }
        }
        const BN_1 = BigInt("1");
        const BN_2 = BigInt("2");
        function shuffle(array) {
          for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const tmp = array[i];
            array[i] = array[j];
            array[j] = tmp;
          }
        }
        function stall$2(duration) {
          return new Promise((resolve) => {
            setTimeout(resolve, duration);
          });
        }
        function getTime() {
          return new Date().getTime();
        }
        function stringify(value) {
          return JSON.stringify(value, (key, value) => {
            if (typeof value === "bigint") {
              return { type: "bigint", value: value.toString() };
            }
            return value;
          });
        }
        const defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
        const defaultState = {
          blockNumber: -2,
          requests: 0,
          lateResponses: 0,
          errorResponses: 0,
          outOfSync: -1,
          unsupportedEvents: 0,
          rollingDuration: 0,
          score: 0,
          _network: null,
          _updateNumber: null,
          _totalTime: 0,
          _lastFatalError: null,
          _lastFatalErrorTimestamp: 0,
        };
        async function waitForSync(config, blockNumber) {
          while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
            if (!config._updateNumber) {
              config._updateNumber = (async () => {
                try {
                  const blockNumber = await config.provider.getBlockNumber();
                  if (blockNumber > config.blockNumber) {
                    config.blockNumber = blockNumber;
                  }
                } catch (error) {
                  config.blockNumber = -2;
                  config._lastFatalError = error;
                  config._lastFatalErrorTimestamp = getTime();
                }
                config._updateNumber = null;
              })();
            }
            await config._updateNumber;
            config.outOfSync++;
            if (config._lastFatalError) {
              break;
            }
          }
        }
        function _normalize(value) {
          if (value == null) {
            return "null";
          }
          if (Array.isArray(value)) {
            return "[" + value.map(_normalize).join(",") + "]";
          }
          if (typeof value === "object" && typeof value.toJSON === "function") {
            return _normalize(value.toJSON());
          }
          switch (typeof value) {
            case "boolean":
            case "symbol":
              return value.toString();
            case "bigint":
            case "number":
              return BigInt(value).toString();
            case "string":
              return JSON.stringify(value);
            case "object": {
              const keys = Object.keys(value);
              keys.sort();
              return (
                "{" +
                keys
                  .map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`)
                  .join(",") +
                "}"
              );
            }
          }
          console.log("Could not serialize", value);
          throw new Error("Hmm...");
        }
        function normalizeResult(value) {
          if ("error" in value) {
            const error = value.error;
            return { tag: _normalize(error), value: error };
          }
          const result = value.result;
          return { tag: _normalize(result), value: result };
        }
        function checkQuorum(quorum, results) {
          const tally = new Map();
          for (const { value, tag, weight } of results) {
            const t = tally.get(tag) || { value: value, weight: 0 };
            t.weight += weight;
            tally.set(tag, t);
          }
          let best = null;
          for (const r of tally.values()) {
            if (r.weight >= quorum && (!best || r.weight > best.weight)) {
              best = r;
            }
          }
          if (best) {
            return best.value;
          }
          return undefined;
        }
        function getMedian(quorum, results) {
          let resultWeight = 0;
          const errorMap = new Map();
          let bestError = null;
          const values = [];
          for (const { value, tag, weight } of results) {
            if (value instanceof Error) {
              const e = errorMap.get(tag) || { value: value, weight: 0 };
              e.weight += weight;
              errorMap.set(tag, e);
              if (bestError == null || e.weight > bestError.weight) {
                bestError = e;
              }
            } else {
              values.push(BigInt(value));
              resultWeight += weight;
            }
          }
          if (resultWeight < quorum) {
            if (bestError && bestError.weight >= quorum) {
              return bestError.value;
            }
            return undefined;
          }
          values.sort((a, b) => (a < b ? -1 : b > a ? 1 : 0));
          const mid = Math.floor(values.length / 2);
          if (values.length % 2) {
            return values[mid];
          }
          return (values[mid - 1] + values[mid] + BN_1) / BN_2;
        }
        function getAnyResult(quorum, results) {
          const result = checkQuorum(quorum, results);
          if (result !== undefined) {
            return result;
          }
          for (const r of results) {
            if (r.value) {
              return r.value;
            }
          }
          return undefined;
        }
        function getFuzzyMode(quorum, results) {
          if (quorum === 1) {
            return getNumber(getMedian(quorum, results), "%internal");
          }
          const tally = new Map();
          const add = (result, weight) => {
            const t = tally.get(result) || { result: result, weight: 0 };
            t.weight += weight;
            tally.set(result, t);
          };
          for (const { weight, value } of results) {
            const r = getNumber(value);
            add(r - 1, weight);
            add(r, weight);
            add(r + 1, weight);
          }
          let bestWeight = 0;
          let bestResult = undefined;
          for (const { weight, result } of tally.values()) {
            if (
              weight >= quorum &&
              (weight > bestWeight ||
                (bestResult != null &&
                  weight === bestWeight &&
                  result > bestResult))
            ) {
              bestWeight = weight;
              bestResult = result;
            }
          }
          return bestResult;
        }
        class FallbackProvider extends AbstractProvider {
          quorum;
          eventQuorum;
          eventWorkers;
          #configs;
          #height;
          #initialSyncPromise;
          constructor(providers, network, options) {
            super(network, options);
            this.#configs = providers.map((p) => {
              if (p instanceof AbstractProvider) {
                return Object.assign(
                  { provider: p },
                  defaultConfig,
                  defaultState
                );
              } else {
                return Object.assign({}, defaultConfig, p, defaultState);
              }
            });
            this.#height = -2;
            this.#initialSyncPromise = null;
            if (options && options.quorum != null) {
              this.quorum = options.quorum;
            } else {
              this.quorum = Math.ceil(
                this.#configs.reduce((accum, config) => {
                  accum += config.weight;
                  return accum;
                }, 0) / 2
              );
            }
            this.eventQuorum = 1;
            this.eventWorkers = 1;
            assertArgument(
              this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0),
              "quorum exceed provider wieght",
              "quorum",
              this.quorum
            );
          }
          get providerConfigs() {
            return this.#configs.map((c) => {
              const result = Object.assign({}, c);
              for (const key in result) {
                if (key[0] === "_") {
                  delete result[key];
                }
              }
              return result;
            });
          }
          async _detectNetwork() {
            return Network.from(
              getBigInt(await this._perform({ method: "chainId" }))
            );
          }
          async _translatePerform(provider, req) {
            switch (req.method) {
              case "broadcastTransaction":
                return await provider.broadcastTransaction(
                  req.signedTransaction
                );
              case "call":
                return await provider.call(
                  Object.assign({}, req.transaction, { blockTag: req.blockTag })
                );
              case "chainId":
                return (await provider.getNetwork()).chainId;
              case "estimateGas":
                return await provider.estimateGas(req.transaction);
              case "getBalance":
                return await provider.getBalance(req.address, req.blockTag);
              case "getBlock": {
                const block = "blockHash" in req ? req.blockHash : req.blockTag;
                return await provider.getBlock(block, req.includeTransactions);
              }
              case "getBlockNumber":
                return await provider.getBlockNumber();
              case "getCode":
                return await provider.getCode(req.address, req.blockTag);
              case "getGasPrice":
                return (await provider.getFeeData()).gasPrice;
              case "getLogs":
                return await provider.getLogs(req.filter);
              case "getStorage":
                return await provider.getStorage(
                  req.address,
                  req.position,
                  req.blockTag
                );
              case "getTransaction":
                return await provider.getTransaction(req.hash);
              case "getTransactionCount":
                return await provider.getTransactionCount(
                  req.address,
                  req.blockTag
                );
              case "getTransactionReceipt":
                return await provider.getTransactionReceipt(req.hash);
              case "getTransactionResult":
                return await provider.getTransactionResult(req.hash);
            }
          }
          #getNextConfig(running) {
            const configs = Array.from(running).map((r) => r.config);
            const allConfigs = this.#configs.slice();
            shuffle(allConfigs);
            allConfigs.sort((a, b) => a.priority - b.priority);
            for (const config of allConfigs) {
              if (config._lastFatalError) {
                continue;
              }
              if (configs.indexOf(config) === -1) {
                return config;
              }
            }
            return null;
          }
          #addRunner(running, req) {
            const config = this.#getNextConfig(running);
            if (config == null) {
              return null;
            }
            const runner = {
              config: config,
              result: null,
              didBump: false,
              perform: null,
              staller: null,
            };
            const now = getTime();
            runner.perform = (async () => {
              try {
                config.requests++;
                const result = await this._translatePerform(
                  config.provider,
                  req
                );
                runner.result = { result: result };
              } catch (error) {
                config.errorResponses++;
                runner.result = { error: error };
              }
              const dt = getTime() - now;
              config._totalTime += dt;
              config.rollingDuration =
                0.95 * config.rollingDuration + 0.05 * dt;
              runner.perform = null;
            })();
            runner.staller = (async () => {
              await stall$2(config.stallTimeout);
              runner.staller = null;
            })();
            running.add(runner);
            return runner;
          }
          async #initialSync() {
            let initialSync = this.#initialSyncPromise;
            if (!initialSync) {
              const promises = [];
              this.#configs.forEach((config) => {
                promises.push(
                  (async () => {
                    await waitForSync(config, 0);
                    if (!config._lastFatalError) {
                      config._network = await config.provider.getNetwork();
                    }
                  })()
                );
              });
              this.#initialSyncPromise = initialSync = (async () => {
                await Promise.all(promises);
                let chainId = null;
                for (const config of this.#configs) {
                  if (config._lastFatalError) {
                    continue;
                  }
                  const network = config._network;
                  if (chainId == null) {
                    chainId = network.chainId;
                  } else if (network.chainId !== chainId) {
                    assert$1(
                      false,
                      "cannot mix providers on different networks",
                      "UNSUPPORTED_OPERATION",
                      { operation: "new FallbackProvider" }
                    );
                  }
                }
              })();
            }
            await initialSync;
          }
          async #checkQuorum(running, req) {
            const results = [];
            for (const runner of running) {
              if (runner.result != null) {
                const { tag, value } = normalizeResult(runner.result);
                results.push({
                  tag: tag,
                  value: value,
                  weight: runner.config.weight,
                });
              }
            }
            if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {
              return undefined;
            }
            switch (req.method) {
              case "getBlockNumber": {
                if (this.#height === -2) {
                  this.#height = Math.ceil(
                    getNumber(
                      getMedian(
                        this.quorum,
                        this.#configs
                          .filter((c) => !c._lastFatalError)
                          .map((c) => ({
                            value: c.blockNumber,
                            tag: getNumber(c.blockNumber).toString(),
                            weight: c.weight,
                          }))
                      )
                    )
                  );
                }
                const mode = getFuzzyMode(this.quorum, results);
                if (mode === undefined) {
                  return undefined;
                }
                if (mode > this.#height) {
                  this.#height = mode;
                }
                return this.#height;
              }
              case "getGasPrice":
              case "estimateGas":
                return getMedian(this.quorum, results);
              case "getBlock":
                if ("blockTag" in req && req.blockTag === "pending") {
                  return getAnyResult(this.quorum, results);
                }
                return checkQuorum(this.quorum, results);
              case "call":
              case "chainId":
              case "getBalance":
              case "getTransactionCount":
              case "getCode":
              case "getStorage":
              case "getTransaction":
              case "getTransactionReceipt":
              case "getLogs":
                return checkQuorum(this.quorum, results);
              case "broadcastTransaction":
                return getAnyResult(this.quorum, results);
            }
            assert$1(false, "unsupported method", "UNSUPPORTED_OPERATION", {
              operation: `_perform(${stringify(req.method)})`,
            });
          }
          async #waitForQuorum(running, req) {
            if (running.size === 0) {
              throw new Error("no runners?!");
            }
            const interesting = [];
            let newRunners = 0;
            for (const runner of running) {
              if (runner.perform) {
                interesting.push(runner.perform);
              }
              if (runner.staller) {
                interesting.push(runner.staller);
                continue;
              }
              if (runner.didBump) {
                continue;
              }
              runner.didBump = true;
              newRunners++;
            }
            const value = await this.#checkQuorum(running, req);
            if (value !== undefined) {
              if (value instanceof Error) {
                throw value;
              }
              return value;
            }
            for (let i = 0; i < newRunners; i++) {
              this.#addRunner(running, req);
            }
            assert$1(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
              request: "%sub-requests",
              info: {
                request: req,
                results: Array.from(running).map((r) => stringify(r.result)),
              },
            });
            await Promise.race(interesting);
            return await this.#waitForQuorum(running, req);
          }
          async _perform(req) {
            if (req.method === "broadcastTransaction") {
              const results = await Promise.all(
                this.#configs.map(async ({ provider, weight }) => {
                  try {
                    const result = await provider._perform(req);
                    return Object.assign(normalizeResult({ result: result }), {
                      weight: weight,
                    });
                  } catch (error) {
                    return Object.assign(normalizeResult({ error: error }), {
                      weight: weight,
                    });
                  }
                })
              );
              const result = getAnyResult(this.quorum, results);
              assert$1(
                result !== undefined,
                "problem multi-broadcasting",
                "SERVER_ERROR",
                {
                  request: "%sub-requests",
                  info: { request: req, results: results.map(stringify) },
                }
              );
              if (result instanceof Error) {
                throw result;
              }
              return result;
            }
            await this.#initialSync();
            const running = new Set();
            for (let i = 0; i < this.quorum; i++) {
              this.#addRunner(running, req);
            }
            const result = await this.#waitForQuorum(running, req);
            for (const runner of running) {
              if (runner.perform && runner.result == null) {
                runner.config.lateResponses++;
              }
            }
            return result;
          }
          async destroy() {
            for (const { provider } of this.#configs) {
              provider.destroy();
            }
            super.destroy();
          }
        }
        function isWebSocketLike(value) {
          return (
            value &&
            typeof value.send === "function" &&
            typeof value.close === "function"
          );
        }
        const Testnets =
          "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(
            " "
          );
        function getDefaultProvider(network, options) {
          if (options == null) {
            options = {};
          }
          const allowService = (name) => {
            if (options[name] === "-") {
              return false;
            }
            if (typeof options.exclusive === "string") {
              return name === options.exclusive;
            }
            if (Array.isArray(options.exclusive)) {
              return options.exclusive.indexOf(name) !== -1;
            }
            return true;
          };
          if (typeof network === "string" && network.match(/^https?:/)) {
            return new JsonRpcProvider(network);
          }
          if (
            (typeof network === "string" && network.match(/^wss?:/)) ||
            isWebSocketLike(network)
          ) {
            return new WebSocketProvider(network);
          }
          let staticNetwork = null;
          try {
            staticNetwork = Network.from(network);
          } catch (error) {}
          const providers = [];
          if (allowService("publicPolygon") && staticNetwork) {
            if (staticNetwork.name === "matic") {
              providers.push(
                new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, {
                  staticNetwork: staticNetwork,
                })
              );
            }
          }
          if (allowService("alchemy")) {
            try {
              providers.push(new AlchemyProvider(network, options.alchemy));
            } catch (error) {}
          }
          if (allowService("ankr") && options.ankr != null) {
            try {
              providers.push(new AnkrProvider(network, options.ankr));
            } catch (error) {}
          }
          if (allowService("cloudflare")) {
            try {
              providers.push(new CloudflareProvider(network));
            } catch (error) {}
          }
          if (allowService("etherscan")) {
            try {
              providers.push(new EtherscanProvider(network, options.etherscan));
            } catch (error) {}
          }
          if (allowService("infura")) {
            try {
              let projectId = options.infura;
              let projectSecret = undefined;
              if (typeof projectId === "object") {
                projectSecret = projectId.projectSecret;
                projectId = projectId.projectId;
              }
              providers.push(
                new InfuraProvider(network, projectId, projectSecret)
              );
            } catch (error) {}
          }
          if (allowService("quicknode")) {
            try {
              let token = options.quicknode;
              providers.push(new QuickNodeProvider(network, token));
            } catch (error) {}
          }
          assert$1(
            providers.length,
            "unsupported default network",
            "UNSUPPORTED_OPERATION",
            { operation: "getDefaultProvider" }
          );
          if (providers.length === 1) {
            return providers[0];
          }
          let quorum = Math.floor(providers.length / 2);
          if (quorum > 2) {
            quorum = 2;
          }
          if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
            quorum = 1;
          }
          if (options && options.quorum) {
            quorum = options.quorum;
          }
          return new FallbackProvider(providers, undefined, { quorum: quorum });
        }
        class NonceManager extends AbstractSigner {
          signer;
          #noncePromise;
          #delta;
          constructor(signer) {
            super(signer.provider);
            defineProperties(this, { signer: signer });
            this.#noncePromise = null;
            this.#delta = 0;
          }
          async getAddress() {
            return this.signer.getAddress();
          }
          connect(provider) {
            return new NonceManager(this.signer.connect(provider));
          }
          async getNonce(blockTag) {
            if (blockTag === "pending") {
              if (this.#noncePromise == null) {
                this.#noncePromise = super.getNonce("pending");
              }
              const delta = this.#delta;
              return (await this.#noncePromise) + delta;
            }
            return super.getNonce(blockTag);
          }
          increment() {
            this.#delta++;
          }
          reset() {
            this.#delta = 0;
            this.#noncePromise = null;
          }
          async sendTransaction(tx) {
            const noncePromise = this.getNonce("pending");
            this.increment();
            tx = await this.signer.populateTransaction(tx);
            tx.nonce = await noncePromise;
            return await this.signer.sendTransaction(tx);
          }
          signTransaction(tx) {
            return this.signer.signTransaction(tx);
          }
          signMessage(message) {
            return this.signer.signMessage(message);
          }
          signTypedData(domain, types, value) {
            return this.signer.signTypedData(domain, types, value);
          }
        }
        class BrowserProvider extends JsonRpcApiPollingProvider {
          #request;
          constructor(ethereum, network) {
            super(network, { batchMaxCount: 1 });
            this.#request = async (method, params) => {
              const payload = { method: method, params: params };
              this.emit("debug", {
                action: "sendEip1193Request",
                payload: payload,
              });
              try {
                const result = await ethereum.request(payload);
                this.emit("debug", {
                  action: "receiveEip1193Result",
                  result: result,
                });
                return result;
              } catch (e) {
                const error = new Error(e.message);
                error.code = e.code;
                error.data = e.data;
                error.payload = payload;
                this.emit("debug", {
                  action: "receiveEip1193Error",
                  error: error,
                });
                throw error;
              }
            };
          }
          async send(method, params) {
            await this._start();
            return await super.send(method, params);
          }
          async _send(payload) {
            assertArgument(
              !Array.isArray(payload),
              "EIP-1193 does not support batch request",
              "payload",
              payload
            );
            try {
              const result = await this.#request(
                payload.method,
                payload.params || []
              );
              return [{ id: payload.id, result: result }];
            } catch (e) {
              return [
                {
                  id: payload.id,
                  error: { code: e.code, data: e.data, message: e.message },
                },
              ];
            }
          }
          getRpcError(payload, error) {
            error = JSON.parse(JSON.stringify(error));
            switch (error.error.code || -1) {
              case 4001:
                error.error.message = `ethers-user-denied: ${error.error.message}`;
                break;
              case 4200:
                error.error.message = `ethers-unsupported: ${error.error.message}`;
                break;
            }
            return super.getRpcError(payload, error);
          }
          async hasSigner(address) {
            if (address == null) {
              address = 0;
            }
            const accounts = await this.send("eth_accounts", []);
            if (typeof address === "number") {
              return accounts.length > address;
            }
            address = address.toLowerCase();
            return (
              accounts.filter((a) => a.toLowerCase() === address).length !== 0
            );
          }
          async getSigner(address) {
            if (address == null) {
              address = 0;
            }
            if (!(await this.hasSigner(address))) {
              try {
                await this.#request("eth_requestAccounts", []);
              } catch (error) {
                const payload = error.payload;
                throw this.getRpcError(payload, {
                  id: payload.id,
                  error: error,
                });
              }
            }
            return await super.getSigner(address);
          }
        }
        const defaultApplicationId = "62e1ad51b37b8e00394bda3b";
        function getHost(name) {
          switch (name) {
            case "mainnet":
              return "eth-mainnet.gateway.pokt.network";
            case "goerli":
              return "eth-goerli.gateway.pokt.network";
            case "matic":
              return "poly-mainnet.gateway.pokt.network";
            case "matic-mumbai":
              return "polygon-mumbai-rpc.gateway.pokt.network";
          }
          assertArgument(false, "unsupported network", "network", name);
        }
        class PocketProvider extends JsonRpcProvider {
          applicationId;
          applicationSecret;
          constructor(_network, applicationId, applicationSecret) {
            if (_network == null) {
              _network = "mainnet";
            }
            const network = Network.from(_network);
            if (applicationId == null) {
              applicationId = defaultApplicationId;
            }
            if (applicationSecret == null) {
              applicationSecret = null;
            }
            const options = { staticNetwork: network };
            const request = PocketProvider.getRequest(
              network,
              applicationId,
              applicationSecret
            );
            super(request, network, options);
            defineProperties(this, {
              applicationId: applicationId,
              applicationSecret: applicationSecret,
            });
          }
          _getProvider(chainId) {
            try {
              return new PocketProvider(
                chainId,
                this.applicationId,
                this.applicationSecret
              );
            } catch (error) {}
            return super._getProvider(chainId);
          }
          static getRequest(network, applicationId, applicationSecret) {
            if (applicationId == null) {
              applicationId = defaultApplicationId;
            }
            const request = new FetchRequest(
              `https:/\/${getHost(network.name)}/v1/lb/${applicationId}`
            );
            request.allowGzip = true;
            if (applicationSecret) {
              request.setCredentials("", applicationSecret);
            }
            if (applicationId === defaultApplicationId) {
              request.retryFunc = async (request, response, attempt) => {
                showThrottleMessage("PocketProvider");
                return true;
              };
            }
            return request;
          }
          isCommunityResource() {
            return this.applicationId === defaultApplicationId;
          }
        }
        const IpcSocketProvider = undefined;
        class BaseWallet extends AbstractSigner {
          address;
          #signingKey;
          constructor(privateKey, provider) {
            super(provider);
            assertArgument(
              privateKey && typeof privateKey.sign === "function",
              "invalid private key",
              "privateKey",
              "[ REDACTED ]"
            );
            this.#signingKey = privateKey;
            const address = computeAddress(this.signingKey.publicKey);
            defineProperties(this, { address: address });
          }
          get signingKey() {
            return this.#signingKey;
          }
          get privateKey() {
            return this.signingKey.privateKey;
          }
          async getAddress() {
            return this.address;
          }
          connect(provider) {
            return new BaseWallet(this.#signingKey, provider);
          }
          async signTransaction(tx) {
            const { to, from } = await resolveProperties({
              to: tx.to ? resolveAddress(tx.to, this.provider) : undefined,
              from: tx.from
                ? resolveAddress(tx.from, this.provider)
                : undefined,
            });
            if (to != null) {
              tx.to = to;
            }
            if (from != null) {
              tx.from = from;
            }
            if (tx.from != null) {
              assertArgument(
                getAddress(tx.from) === this.address,
                "transaction from address mismatch",
                "tx.from",
                tx.from
              );
              delete tx.from;
            }
            const btx = Transaction.from(tx);
            btx.signature = this.signingKey.sign(btx.unsignedHash);
            return btx.serialized;
          }
          async signMessage(message) {
            return this.signMessageSync(message);
          }
          signMessageSync(message) {
            return this.signingKey.sign(hashMessage(message)).serialized;
          }
          async signTypedData(domain, types, value) {
            const populated = await TypedDataEncoder.resolveNames(
              domain,
              types,
              value,
              async (name) => {
                assert$1(
                  this.provider != null,
                  "cannot resolve ENS names without a provider",
                  "UNSUPPORTED_OPERATION",
                  { operation: "resolveName", info: { name: name } }
                );
                const address = await this.provider.resolveName(name);
                assert$1(
                  address != null,
                  "unconfigured ENS name",
                  "UNCONFIGURED_NAME",
                  { value: name }
                );
                return address;
              }
            );
            return this.signingKey.sign(
              TypedDataEncoder.hash(populated.domain, types, populated.value)
            ).serialized;
          }
        }
        const subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
        const Word = /^[a-z]*$/i;
        function unfold(words, sep) {
          let initial = 97;
          return words.reduce((accum, word) => {
            if (word === sep) {
              initial++;
            } else if (word.match(Word)) {
              accum.push(String.fromCharCode(initial) + word);
            } else {
              initial = 97;
              accum.push(word);
            }
            return accum;
          }, []);
        }
        function decode(data, subs) {
          for (let i = subsChrs.length - 1; i >= 0; i--) {
            data = data
              .split(subsChrs[i])
              .join(subs.substring(2 * i, 2 * i + 2));
          }
          const clumps = [];
          const leftover = data.replace(
            /(:|([0-9])|([A-Z][a-z]*))/g,
            (all, item, semi, word) => {
              if (semi) {
                for (let i = parseInt(semi); i >= 0; i--) {
                  clumps.push(";");
                }
              } else {
                clumps.push(item.toLowerCase());
              }
              return "";
            }
          );
          if (leftover) {
            throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
          }
          return unfold(unfold(clumps, ";"), ":");
        }
        function decodeOwl(data) {
          assertArgument(
            data[0] === "0",
            "unsupported auwl data",
            "data",
            data
          );
          return decode(
            data.substring(1 + 2 * subsChrs.length),
            data.substring(1, 1 + 2 * subsChrs.length)
          );
        }
        class Wordlist {
          locale;
          constructor(locale) {
            defineProperties(this, { locale: locale });
          }
          split(phrase) {
            return phrase.toLowerCase().split(/\s+/g);
          }
          join(words) {
            return words.join(" ");
          }
        }
        class WordlistOwl extends Wordlist {
          #data;
          #checksum;
          constructor(locale, data, checksum) {
            super(locale);
            this.#data = data;
            this.#checksum = checksum;
            this.#words = null;
          }
          get _data() {
            return this.#data;
          }
          _decodeWords() {
            return decodeOwl(this.#data);
          }
          #words;
          #loadWords() {
            if (this.#words == null) {
              const words = this._decodeWords();
              const checksum = id(words.join("\n") + "\n");
              if (checksum !== this.#checksum) {
                throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
              }
              this.#words = words;
            }
            return this.#words;
          }
          getWord(index) {
            const words = this.#loadWords();
            assertArgument(
              index >= 0 && index < words.length,
              `invalid word index: ${index}`,
              "index",
              index
            );
            return words[index];
          }
          getWordIndex(word) {
            return this.#loadWords().indexOf(word);
          }
        }
        const words =
          "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
        const checksum =
          "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
        let wordlist = null;
        class LangEn extends WordlistOwl {
          constructor() {
            super("en", words, checksum);
          }
          static wordlist() {
            if (wordlist == null) {
              wordlist = new LangEn();
            }
            return wordlist;
          }
        }
        function getUpperMask(bits) {
          return (((1 << bits) - 1) << (8 - bits)) & 255;
        }
        function getLowerMask(bits) {
          return ((1 << bits) - 1) & 255;
        }
        function mnemonicToEntropy(mnemonic, wordlist) {
          assertNormalize("NFKD");
          if (wordlist == null) {
            wordlist = LangEn.wordlist();
          }
          const words = wordlist.split(mnemonic);
          assertArgument(
            words.length % 3 === 0 && words.length >= 12 && words.length <= 24,
            "invalid mnemonic length",
            "mnemonic",
            "[ REDACTED ]"
          );
          const entropy = new Uint8Array(Math.ceil((11 * words.length) / 8));
          let offset = 0;
          for (let i = 0; i < words.length; i++) {
            let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
            assertArgument(
              index >= 0,
              `invalid mnemonic word at index ${i}`,
              "mnemonic",
              "[ REDACTED ]"
            );
            for (let bit = 0; bit < 11; bit++) {
              if (index & (1 << (10 - bit))) {
                entropy[offset >> 3] |= 1 << (7 - (offset % 8));
              }
              offset++;
            }
          }
          const entropyBits = (32 * words.length) / 3;
          const checksumBits = words.length / 3;
          const checksumMask = getUpperMask(checksumBits);
          const checksum =
            getBytes(sha256(entropy.slice(0, entropyBits / 8)))[0] &
            checksumMask;
          assertArgument(
            checksum === (entropy[entropy.length - 1] & checksumMask),
            "invalid mnemonic checksum",
            "mnemonic",
            "[ REDACTED ]"
          );
          return hexlify(entropy.slice(0, entropyBits / 8));
        }
        function entropyToMnemonic(entropy, wordlist) {
          assertArgument(
            entropy.length % 4 === 0 &&
              entropy.length >= 16 &&
              entropy.length <= 32,
            "invalid entropy size",
            "entropy",
            "[ REDACTED ]"
          );
          if (wordlist == null) {
            wordlist = LangEn.wordlist();
          }
          const indices = [0];
          let remainingBits = 11;
          for (let i = 0; i < entropy.length; i++) {
            if (remainingBits > 8) {
              indices[indices.length - 1] <<= 8;
              indices[indices.length - 1] |= entropy[i];
              remainingBits -= 8;
            } else {
              indices[indices.length - 1] <<= remainingBits;
              indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
              indices.push(entropy[i] & getLowerMask(8 - remainingBits));
              remainingBits += 3;
            }
          }
          const checksumBits = entropy.length / 4;
          const checksum =
            parseInt(sha256(entropy).substring(2, 4), 16) &
            getUpperMask(checksumBits);
          indices[indices.length - 1] <<= checksumBits;
          indices[indices.length - 1] |= checksum >> (8 - checksumBits);
          return wordlist.join(indices.map((index) => wordlist.getWord(index)));
        }
        const _guard$1 = {};
        class Mnemonic {
          phrase;
          password;
          wordlist;
          entropy;
          constructor(guard, entropy, phrase, password, wordlist) {
            if (password == null) {
              password = "";
            }
            if (wordlist == null) {
              wordlist = LangEn.wordlist();
            }
            assertPrivate(guard, _guard$1, "Mnemonic");
            defineProperties(this, {
              phrase: phrase,
              password: password,
              wordlist: wordlist,
              entropy: entropy,
            });
          }
          computeSeed() {
            const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
            return pbkdf2(
              toUtf8Bytes(this.phrase, "NFKD"),
              salt,
              2048,
              64,
              "sha512"
            );
          }
          static fromPhrase(phrase, password, wordlist) {
            const entropy = mnemonicToEntropy(phrase, wordlist);
            phrase = entropyToMnemonic(getBytes(entropy), wordlist);
            return new Mnemonic(_guard$1, entropy, phrase, password, wordlist);
          }
          static fromEntropy(_entropy, password, wordlist) {
            const entropy = getBytes(_entropy, "entropy");
            const phrase = entropyToMnemonic(entropy, wordlist);
            return new Mnemonic(
              _guard$1,
              hexlify(entropy),
              phrase,
              password,
              wordlist
            );
          }
          static entropyToPhrase(_entropy, wordlist) {
            const entropy = getBytes(_entropy, "entropy");
            return entropyToMnemonic(entropy, wordlist);
          }
          static phraseToEntropy(phrase, wordlist) {
            return mnemonicToEntropy(phrase, wordlist);
          }
          static isValidMnemonic(phrase, wordlist) {
            try {
              mnemonicToEntropy(phrase, wordlist);
              return true;
            } catch (error) {}
            return false;
          }
        }
        var __classPrivateFieldGet$2 =
          (__$G && __$G.__classPrivateFieldGet) ||
          function (receiver, state, kind, f) {
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a getter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return kind === "m"
              ? f
              : kind === "a"
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          };
        var __classPrivateFieldSet$2 =
          (__$G && __$G.__classPrivateFieldSet) ||
          function (receiver, state, value, kind, f) {
            if (kind === "m")
              throw new TypeError("Private method is not writable");
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a setter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              kind === "a"
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          };
        var _AES_key, _AES_Kd, _AES_Ke;
        const numberOfRounds = { 16: 10, 24: 12, 32: 14 };
        const rcon = [
          1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94,
          188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145,
        ];
        const S = [
          99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171,
          118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156,
          164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241,
          113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226,
          235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179,
          41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190,
          57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2,
          127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182,
          218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196,
          167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136,
          70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92,
          194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213,
          78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28,
          166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181,
          102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248,
          152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140,
          161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22,
        ];
        const Si = [
          82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215,
          251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222,
          233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66,
          250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73,
          109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164,
          92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94,
          21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10,
          247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2,
          193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234,
          151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173,
          53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29,
          41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75,
          198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221,
          168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81,
          127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160,
          224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97,
          23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125,
        ];
        const T1 = [
          3328402341, 4168907908, 4000806809, 4135287693, 4294111757,
          3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241,
          1445669757, 3892248089, 3050821474, 1303096294, 3967186586,
          2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171,
          2387036105, 4226871307, 1101901292, 3017069671, 1604494077,
          1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402,
          3791519004, 1033081774, 1277568618, 1815492186, 2118074177,
          4126668546, 2211236943, 1748251740, 1369810420, 3521504564,
          4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908,
          2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135,
          798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438,
          1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972,
          874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614,
          1983593293, 3084310113, 2108928974, 1378429307, 3722699582,
          1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436,
          1075847264, 3825007647, 2041688520, 3059440621, 3563743934,
          2378943302, 1740553945, 1916352843, 2487896798, 2555137236,
          2958579944, 2244988746, 3151024235, 3320835882, 1336584933,
          3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663,
          3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106,
          1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413,
          563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573,
          1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300,
          403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436,
          773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572,
          3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905,
          2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882,
          3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493,
          2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571,
          201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935,
          3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010,
          2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682,
          1235855840, 3630984372, 2891339514, 4092916743, 3488279077,
          3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016,
          1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513,
          3421038627, 2715671932, 3899946140, 1042226977, 2521517021,
          1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956,
          3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891,
          1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535,
          664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707,
          2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602,
          3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671,
          1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982,
          3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163,
          2824099068, 1841019862, 739644986,
        ];
        const T2 = [
          2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027,
          2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147,
          434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938,
          1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592,
          3963727277, 1739838676, 4250903202, 3930435503, 3206782108,
          4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059,
          1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980,
          4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049,
          1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536,
          2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848,
          1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793,
          2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018,
          4217086112, 4137964114, 1299594043, 1639438038, 3464344499,
          2068982057, 1054729187, 1901997871, 2534638724, 4121318227,
          1757008337, 0, 750906861, 1614815264, 535035132, 3363418545,
          3988151131, 3201591914, 1183697867, 3647454910, 1265776953,
          3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087,
          3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261,
          3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428,
          3123027871, 3813386408, 4087501137, 4267549603, 3229630528,
          2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548,
          3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083,
          1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855,
          2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534,
          1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,
          2551808385, 3516813135, 2141445340, 1715741218, 2119445034,
          2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540,
          2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026,
          1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516,
          1570751170, 1857934291, 4014189740, 2797888098, 2822345105,
          2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319,
          3084545389, 2348912013, 1689376213, 3533459022, 3762923945,
          3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810,
          3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758,
          607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877,
          2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234,
          2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067,
          33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753,
          2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800,
          3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444,
          3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045,
          2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245,
          3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313,
          2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766,
        ];
        const T3 = [
          1671808611, 2089089148, 2006576759, 2072901243, 4061003762,
          1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671,
          729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426,
          2191335298, 3376449993, 2106063485, 4195741690, 1508618841,
          1204391495, 4027317232, 2917941677, 3563566036, 2734514082,
          2951366063, 2629772188, 2767672228, 1922491506, 3227229120,
          3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767,
          4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329,
          1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279,
          593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466,
          118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711,
          2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610,
          455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283,
          3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444,
          1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412,
          2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753,
          1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
          4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739,
          2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960,
          1011120188, 2679776671, 2833468328, 1374921297, 2751356323,
          1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005,
          3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895,
          4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324,
          1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711,
          2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699,
          1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154,
          2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740,
          3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546,
          978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276,
          3260915650, 3547250131, 2901361580, 1655096418, 2443721105,
          2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799,
          1840765549, 2374762893, 3580146133, 1322425422, 2850048425,
          1823791212, 1459268694, 4094161908, 3928346602, 1706019429,
          2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469,
          779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072,
          3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315,
          2323976074, 1888542832, 1044544574, 3049550261, 1722469478,
          1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557,
          1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430,
          3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385,
          2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169,
          3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649,
          2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440,
          1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308,
          3151392187, 372911126,
        ];
        const T4 = [
          1667474886, 2088535288, 2004326894, 2071694838, 4075949567,
          1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926,
          724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711,
          2189597983, 3385409673, 2105378810, 4210693615, 1499065266,
          1195886990, 4042263547, 2913856577, 3570689971, 2728590687,
          2947541573, 2627518243, 2762274643, 1920112356, 3233831835,
          3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142,
          4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529,
          1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789,
          589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191,
          117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286,
          2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380,
          454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198,
          3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939,
          1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667,
          2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178,
          1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
          4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214,
          2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760,
          1010582648, 2678045221, 2829640523, 1364325282, 2745433693,
          1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505,
          3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645,
          4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699,
          1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621,
          2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854,
          1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924,
          2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440,
          3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716,
          976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736,
          3267517855, 3553849021, 2897014595, 1650632388, 2442242105,
          2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254,
          1835907034, 2374863873, 3587531953, 1313788572, 2846482505,
          1819063512, 1448540844, 4109633523, 3941213647, 1701162954,
          2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314,
          774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627,
          3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845,
          2324333839, 1886425312, 1044267644, 3048588401, 1718004428,
          1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282,
          1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215,
          3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025,
          2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609,
          3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649,
          2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520,
          1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848,
          3149649517, 370555436,
        ];
        const T5 = [
          1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753,
          2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485,
          1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703,
          1172967064, 1576976609, 3274667266, 2169303058, 2370213795,
          1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213,
          1484005843, 1239443753, 2395588676, 1975683434, 4102977912,
          2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444,
          1675577880, 3843699074, 2538681184, 1649639237, 2976151520,
          3144396420, 4269907996, 4178062228, 1883793496, 2403728665,
          2497604743, 1383856311, 2876494627, 1917518562, 3810496343,
          1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610,
          599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432,
          1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293,
          2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582,
          3178106961, 1042385657, 2531067453, 3711829422, 1306967366,
          2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327,
          2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
          2709260871, 2084704233, 4169408201, 0, 159417987, 841739592,
          504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415,
          168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535,
          3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374,
          3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893,
          766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109,
          4144047775, 1551037884, 1147550661, 1543208500, 2336434550,
          3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808,
          2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059,
          3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682,
          1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455,
          3644379585, 2362090238, 2564033334, 2801107407, 2776292904,
          3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698,
          4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924,
          1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923,
          3441850377, 1851332852, 3969562369, 2203032232, 3868552805,
          2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284,
          699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047,
          4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806,
          395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715,
          1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171,
          4211818798, 3009879386, 2463879762, 3910161971, 1842759443,
          2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029,
          3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775,
          1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
          3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627,
          4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265,
          3576870512, 1215061108, 3501741890,
        ];
        const T6 = [
          1347548327, 1400783205, 3273267108, 2520393566, 3409685355,
          4045380933, 2880240216, 2471224067, 1428173050, 4138563181,
          2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155,
          1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728,
          2743944855, 3328955385, 3875770207, 2501218972, 3955191162,
          3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409,
          2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132,
          3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975,
          2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428,
          3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120,
          53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122,
          1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468,
          3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033,
          1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602,
          1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868,
          4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618,
          2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166,
          0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663,
          1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604,
          975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021,
          2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560,
          487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081,
          1286567175, 3152976349, 4255350624, 2683765030, 3160175349,
          3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617,
          3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061,
          296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347,
          1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879,
          3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419,
          3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554,
          2607439820, 1649704518, 3270937875, 3901806776, 1580087799,
          4118987695, 3198115200, 2087309459, 2842678573, 3016697106,
          1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472,
          32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392,
          3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259,
          818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840,
          1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904,
          1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889,
          77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242,
          870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476,
          4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235,
          2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891,
          2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253,
          2334669897, 1107234197, 1899603969, 3725069491, 2631447780,
          2422494913, 1635502980, 1893020342, 1950903388, 1120974935,
        ];
        const T7 = [
          2807058932, 1699970625, 2764249623, 1586903591, 1808481195,
          1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228,
          1277555970, 3623636965, 3419915562, 1149249077, 2744104290,
          1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588,
          2544078150, 4190530515, 1608975247, 2627016082, 2062270317,
          1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554,
          2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312,
          984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180,
          2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798,
          4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195,
          3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107,
          2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658,
          3201631749, 1646252340, 4270507174, 1402811438, 1436590835,
          3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366,
          2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892,
          3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497,
          1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938,
          516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170,
          4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260,
          1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075,
          3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128,
          3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854,
          428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354,
          1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452,
          3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051,
          840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177,
          376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744,
          752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444,
          2177869557, 3727205754, 2384911031, 3215212461, 2648976442,
          2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569,
          2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044,
          2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634,
          2594734927, 1852171925, 3867060991, 3473416636, 3907448597,
          2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639,
          2486224549, 1723872674, 3157750862, 3399941250, 3501252752,
          3625268135, 2555048196, 3673637356, 1343127501, 4130281361,
          3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410,
          532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963,
          492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225,
          344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695,
          3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069,
          1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571,
          3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716,
          3835484340, 3247465558, 2220981195, 3060847922, 1551124588,
          1463996600,
        ];
        const T8 = [
          4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623,
          4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885,
          3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053,
          3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835,
          2405426947, 2459735317, 1836772287, 1381620373, 3196267988,
          1948373848, 3764988233, 3385345166, 3263785589, 2390325492,
          1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789,
          3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355,
          2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426,
          1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895,
          3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221,
          3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454,
          878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212,
          2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718,
          1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912,
          2566595609, 3186202582, 1078185097, 3651041127, 3896688048,
          2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296,
          0, 2156299017, 736970802, 292596766, 1517440620, 251657213,
          2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339,
          908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416,
          3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620,
          454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591,
          1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156,
          4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431,
          1669664834, 2535604243, 3323011204, 1243905413, 3141400786,
          4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727,
          3004591147, 1891211689, 2487810577, 3915653703, 4237083816,
          4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628,
          3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092,
          2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814,
          3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464,
          410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844,
          1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
          1865862730, 2668221674, 2960971305, 2763173681, 1059270954,
          2777952454, 2724642869, 1320957812, 2194319100, 2429595872,
          2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550,
          4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417,
          1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011,
          3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729,
          322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828,
          4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015,
          1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990,
          3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240,
          1455525988, 3414450555, 850817237, 1817998408, 3092726480,
        ];
        const U1 = [
          0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554,
          708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108,
          1181045119, 1417561698, 1517767529, 3767586992, 4003061179,
          4236429990, 4069246893, 3635733660, 3602770327, 3299278474,
          3400528769, 2430122216, 2664543715, 2362090238, 2193862645,
          2835123396, 2801107407, 3035535058, 3135740889, 3678124923,
          3576870512, 3341394285, 3374361702, 3810496343, 3977675356,
          4279080257, 4043610186, 2876494627, 2776292904, 3076639029,
          3110650942, 2472011535, 2640243204, 2403728665, 2169303058,
          1001089995, 899835584, 666464733, 699432150, 59727847, 226906860,
          530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414,
          1942435775, 2110667444, 1876241833, 1641816226, 2910219766,
          2743034109, 2976151520, 3211623147, 2505202138, 2606453969,
          2302690252, 2269728455, 3711829422, 3543599269, 3240894392,
          3475313331, 3843699074, 3943906441, 4178062228, 4144047775,
          1306967366, 1139781709, 1374988112, 1610459739, 1975683434,
          2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896,
          800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
          2017778566, 1784663195, 1683407248, 1315562145, 1080094634,
          1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864,
          1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334,
          2328828971, 2227573024, 2935566865, 2700099354, 3001755655,
          3168937228, 3868552805, 3902563182, 4203181171, 4102977912,
          3736164937, 3501741890, 3265478751, 3433712980, 1106041591,
          1340463100, 1576976609, 1408749034, 2043211483, 2009195472,
          1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354,
          159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380,
          3178106961, 3009879386, 2572697195, 2538681184, 2236228733,
          2336434550, 3509871135, 3745345300, 3441850377, 3274667266,
          3910161971, 3877198648, 4110568485, 4211818798, 2597806476,
          2497604743, 2261089178, 2295101073, 2733856160, 2902087851,
          3202437046, 2968011453, 3936291284, 3835036895, 4136440770,
          4169408201, 3535486456, 3702665459, 3467192302, 3231722213,
          2051518780, 1951317047, 1716890410, 1750902305, 1113818384,
          1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330,
          404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
          3801332234, 4035489047, 4269907996, 3569255213, 3669462566,
          3366754619, 3332740144, 2631065433, 2463879762, 2160117071,
          2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497,
          33778362, 270040487, 504459436, 875451293, 975658646, 675039627,
          641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661,
          1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972,
          632953703, 260388950, 25965917, 328671808, 496906059, 1206477858,
          1239443753, 1543208500, 1441952575, 2144161806, 1908694277,
          1675577880, 1842759443, 3610369226, 3644379585, 3408119516,
          3307916247, 4011190502, 3776767469, 4077384432, 4245618683,
          2809771154, 2842737049, 3144396420, 3043140495, 2673705150,
          2438237621, 2203032232, 2370213795,
        ];
        const U2 = [
          0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694,
          824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388,
          2135319889, 1649704518, 1767536459, 2967507152, 3152976349,
          2801566410, 2918353863, 2631447780, 2547432937, 2328143614,
          2177544179, 3901806776, 3818836405, 4270639778, 4118987695,
          3299409036, 3483825537, 3535072918, 3652904859, 2077965243,
          1893020342, 1841768865, 1724457132, 1474502543, 1559041666,
          1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372,
          261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454,
          3710368113, 3593056380, 3875770207, 3960309330, 4045380933,
          4195456072, 2471224067, 2554718734, 2237133081, 2388260884,
          3212035895, 3028143674, 2842678573, 2724322336, 4138563181,
          4255350624, 3769721975, 3955191162, 3667219033, 3516619604,
          3431546947, 3347532110, 2933734917, 2782082824, 3099667487,
          3016697106, 2196052529, 2313884476, 2499348523, 2683765030,
          1179510461, 1296297904, 1347548327, 1533017514, 1786102409,
          1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751,
          53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
          2256028891, 2607439820, 2422494913, 2706270690, 2856345839,
          3075636216, 3160175349, 3573941694, 3725069491, 3273267108,
          3356761769, 4181598602, 4063242375, 4011996048, 3828103837,
          1033297158, 915985419, 730517276, 545572369, 296679730, 446754879,
          129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177,
          1239331162, 1120974935, 1606591296, 1422699085, 4148292826,
          4233094615, 3781033664, 3931371469, 3682191598, 3497509347,
          3446004468, 3328955385, 2939266226, 2755636671, 3106780840,
          2988687269, 2198438022, 2282195339, 2501218972, 2652609425,
          1201765386, 1286567175, 1371368976, 1521706781, 1805211710,
          1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672,
          46346101, 870912086, 954669403, 636813900, 788204353, 2358957921,
          2274680428, 2592523643, 2441661558, 2695033685, 2880240216,
          3065962831, 3182487618, 3572145929, 3756299780, 3270937875,
          3388507166, 4174560061, 4091327024, 4006521127, 3854606378,
          1014646705, 930369212, 711349675, 560487590, 272786309, 457992840,
          106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326,
          1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114,
          401639597, 486441376, 768917123, 651868046, 1003007129, 818324884,
          1503449823, 1385356242, 1333838021, 1150208456, 1973745387,
          2125135846, 1673061617, 1756818940, 2970356327, 3120694122,
          2802849917, 2887651696, 2637442643, 2520393566, 2334669897,
          2149987652, 3917234703, 3799141122, 4284502037, 4100872472,
          3309594171, 3460984630, 3545789473, 3629546796, 2050466060,
          1899603969, 1814803222, 1730525723, 1443857720, 1560382517,
          1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235,
          243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545,
          3704300486, 3620022987, 3874428392, 3990953189, 4042459122,
          4227665663, 2460449204, 2578018489, 2226875310, 2411029155,
          3198115200, 3046200461, 2827177882, 2743944855,
        ];
        const U3 = [
          0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294,
          590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588,
          1367295589, 1180849278, 1265195639, 3501252752, 3720081049,
          3399941250, 3350065803, 3835484340, 3919042237, 4270507174,
          4085369519, 3102249176, 3051593425, 2734591178, 2952102595,
          2361698556, 2177869557, 2530391278, 2614737639, 3145456443,
          3060847922, 2708326185, 2892417312, 2404901663, 2187128086,
          2504130317, 2555048196, 3542330227, 3727205754, 3375740769,
          3292445032, 3876557655, 3926170974, 4246310725, 4027744588,
          1808481195, 1723872674, 1910319033, 2094410160, 1608975247,
          1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201,
          344873464, 935293895, 984907214, 766078933, 547512796, 1844882806,
          1627235199, 2011214180, 2062270317, 1507497298, 1423022939,
          1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861,
          830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679,
          2807058932, 2858115069, 2305455554, 2220981195, 2474404304,
          2658625497, 3575528878, 3625268135, 3473416636, 3254988725,
          3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
          3683022916, 3432737375, 3247465558, 3802222185, 4020912224,
          4172763771, 4122762354, 3201631749, 3017672716, 2764249623,
          2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613,
          188127444, 472615631, 287343814, 840019705, 1058709744, 671593195,
          621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577,
          1463996600, 1080017571, 1297403050, 3673637356, 3623636965,
          3235995134, 3454686199, 4007360968, 3822090177, 4107101658,
          4190530515, 2997825956, 3215212461, 2830708150, 2779915199,
          2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165,
          273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755,
          1646252340, 1863638845, 2013908262, 1963115311, 1446242576,
          1530455833, 1277555970, 1093597963, 1636604631, 1820824798,
          2073724613, 1989249228, 1436590835, 1487645946, 1337376481,
          1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051,
          821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645,
          2787207260, 2232435299, 2283490410, 2667994737, 2450346104,
          3647212047, 3564045318, 3279033885, 3464042516, 3980931627,
          3762502690, 4150144569, 4199882800, 3070356634, 3121275539,
          2904027272, 2686254721, 2200818878, 2384911031, 2570832044,
          2486224549, 3747192018, 3528626907, 3310321856, 3359936201,
          3950355702, 3867060991, 4049844452, 4234721005, 1739656202,
          1790575107, 2108100632, 1890328081, 1402811438, 1586903591,
          1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217,
          1002783846, 919489135, 567498868, 752375421, 209336225, 24197544,
          376187827, 459744698, 945164165, 895287692, 574624663, 793451934,
          1679968233, 1764313568, 2117360635, 1933530610, 1343127501,
          1560637892, 1243112415, 1192455638, 3704280881, 3519142200,
          3336358691, 3419915562, 3907448597, 3857572124, 4075877127,
          4294704398, 3029510009, 3113855344, 2927934315, 2744104290,
          2159976285, 2377486676, 2594734927, 2544078150,
        ];
        const U4 = [
          0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204,
          1059270954, 1214797936, 1097159550, 1517440620, 1400849762,
          1817998408, 1699839814, 2118541908, 2001430874, 2429595872,
          2581445614, 2194319100, 2345119218, 3034881240, 3186202582,
          2801699524, 2951971274, 3635996816, 3518358430, 3399679628,
          3283088770, 4237083816, 4118925222, 4002861748, 3885750714,
          1002142683, 850817237, 698445255, 548169417, 529487843, 377642221,
          227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577,
          1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
          2724642869, 3111247143, 2960971305, 2405426947, 2253581325,
          2638606623, 2487810577, 3808662347, 3926825029, 4044981591,
          4162096729, 3342319475, 3459953789, 3576539503, 3693126241,
          1986918061, 2137062819, 1685577905, 1836772287, 1381620373,
          1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417,
          621982671, 439452389, 322734571, 137073913, 19308535, 3871163981,
          4021308739, 4104605777, 4255800159, 3263785589, 3414450555,
          3499326569, 3651041127, 2933202493, 2815956275, 3167684641,
          3049390895, 2330014213, 2213296395, 2566595609, 2448830231,
          1305906550, 1155237496, 1607244650, 1455525988, 1776460110,
          1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818,
          514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718,
          3557504664, 3474729866, 3323011204, 4180808110, 4030667424,
          3945269170, 3794078908, 2507040230, 2623762152, 2272556026,
          2390325492, 2975484382, 3092726480, 2738905026, 2857194700,
          3973773121, 3856137295, 4274053469, 4157467219, 3371096953,
          3252932727, 3673476453, 3556361835, 2763173681, 2915017791,
          3064510765, 3215307299, 2156299017, 2307622919, 2459735317,
          2610011675, 2081048481, 1963412655, 1846563261, 1729977011,
          1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015,
          645401037, 796197571, 274084841, 425408743, 38544885, 188821243,
          3613494426, 3731654548, 3313212038, 3430322568, 4082475170,
          4200115116, 3780097726, 3896688048, 2668221674, 2516901860,
          2366882550, 2216610296, 3141400786, 2989552604, 2837966542,
          2687165888, 1202797690, 1320957812, 1437280870, 1554391400,
          1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348,
          499347990, 349075736, 736970802, 585122620, 972512814, 821712160,
          2595684844, 2478443234, 2293045232, 2174754046, 3196267988,
          3079546586, 2895723464, 2777952454, 3537852828, 3687994002,
          3234156416, 3385345166, 4142626212, 4293295786, 3841024952,
          3992742070, 174567692, 57326082, 410887952, 292596766, 777231668,
          660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912,
          1494807662, 1715193156, 1865862730, 1948373848, 2100090966,
          2701949495, 2818666809, 3004591147, 3122358053, 2235061775,
          2352307457, 2535604243, 2653899549, 3915653703, 3764988233,
          4219352155, 4067639125, 3444575871, 3294430577, 3746175075,
          3594982253, 836553431, 953270745, 600235211, 718002117, 367585007,
          484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355,
          1654886325, 1568718495, 1418573201, 1335535747, 1184342925,
        ];
        function convertToInt32(bytes) {
          const result = [];
          for (let i = 0; i < bytes.length; i += 4) {
            result.push(
              (bytes[i] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] << 8) |
                bytes[i + 3]
            );
          }
          return result;
        }
        class AES {
          get key() {
            return __classPrivateFieldGet$2(this, _AES_key, "f").slice();
          }
          constructor(key) {
            _AES_key.set(this, void 0);
            _AES_Kd.set(this, void 0);
            _AES_Ke.set(this, void 0);
            if (!(this instanceof AES)) {
              throw Error("AES must be instanitated with `new`");
            }
            __classPrivateFieldSet$2(this, _AES_key, new Uint8Array(key), "f");
            const rounds = numberOfRounds[this.key.length];
            if (rounds == null) {
              throw new TypeError(
                "invalid key size (must be 16, 24 or 32 bytes)"
              );
            }
            __classPrivateFieldSet$2(this, _AES_Ke, [], "f");
            __classPrivateFieldSet$2(this, _AES_Kd, [], "f");
            for (let i = 0; i <= rounds; i++) {
              __classPrivateFieldGet$2(this, _AES_Ke, "f").push([0, 0, 0, 0]);
              __classPrivateFieldGet$2(this, _AES_Kd, "f").push([0, 0, 0, 0]);
            }
            const roundKeyCount = (rounds + 1) * 4;
            const KC = this.key.length / 4;
            const tk = convertToInt32(this.key);
            let index;
            for (let i = 0; i < KC; i++) {
              index = i >> 2;
              __classPrivateFieldGet$2(this, _AES_Ke, "f")[index][i % 4] =
                tk[i];
              __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - index][
                i % 4
              ] = tk[i];
            }
            let rconpointer = 0;
            let t = KC,
              tt;
            while (t < roundKeyCount) {
              tt = tk[KC - 1];
              tk[0] ^=
                (S[(tt >> 16) & 255] << 24) ^
                (S[(tt >> 8) & 255] << 16) ^
                (S[tt & 255] << 8) ^
                S[(tt >> 24) & 255] ^
                (rcon[rconpointer] << 24);
              rconpointer += 1;
              if (KC != 8) {
                for (let i = 1; i < KC; i++) {
                  tk[i] ^= tk[i - 1];
                }
              } else {
                for (let i = 1; i < KC / 2; i++) {
                  tk[i] ^= tk[i - 1];
                }
                tt = tk[KC / 2 - 1];
                tk[KC / 2] ^=
                  S[tt & 255] ^
                  (S[(tt >> 8) & 255] << 8) ^
                  (S[(tt >> 16) & 255] << 16) ^
                  (S[(tt >> 24) & 255] << 24);
                for (let i = KC / 2 + 1; i < KC; i++) {
                  tk[i] ^= tk[i - 1];
                }
              }
              let i = 0,
                r,
                c;
              while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][c] = tk[i];
                __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds - r][c] =
                  tk[i++];
                t++;
              }
            }
            for (let r = 1; r < rounds; r++) {
              for (let c = 0; c < 4; c++) {
                tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c];
                __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][c] =
                  U1[(tt >> 24) & 255] ^
                  U2[(tt >> 16) & 255] ^
                  U3[(tt >> 8) & 255] ^
                  U4[tt & 255];
              }
            }
          }
          encrypt(plaintext) {
            if (plaintext.length != 16) {
              throw new TypeError("invalid plaintext size (must be 16 bytes)");
            }
            const rounds =
              __classPrivateFieldGet$2(this, _AES_Ke, "f").length - 1;
            const a = [0, 0, 0, 0];
            let t = convertToInt32(plaintext);
            for (let i = 0; i < 4; i++) {
              t[i] ^= __classPrivateFieldGet$2(this, _AES_Ke, "f")[0][i];
            }
            for (let r = 1; r < rounds; r++) {
              for (let i = 0; i < 4; i++) {
                a[i] =
                  T1[(t[i] >> 24) & 255] ^
                  T2[(t[(i + 1) % 4] >> 16) & 255] ^
                  T3[(t[(i + 2) % 4] >> 8) & 255] ^
                  T4[t[(i + 3) % 4] & 255] ^
                  __classPrivateFieldGet$2(this, _AES_Ke, "f")[r][i];
              }
              t = a.slice();
            }
            const result = new Uint8Array(16);
            let tt = 0;
            for (let i = 0; i < 4; i++) {
              tt = __classPrivateFieldGet$2(this, _AES_Ke, "f")[rounds][i];
              result[4 * i] = (S[(t[i] >> 24) & 255] ^ (tt >> 24)) & 255;
              result[4 * i + 1] =
                (S[(t[(i + 1) % 4] >> 16) & 255] ^ (tt >> 16)) & 255;
              result[4 * i + 2] =
                (S[(t[(i + 2) % 4] >> 8) & 255] ^ (tt >> 8)) & 255;
              result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
            }
            return result;
          }
          decrypt(ciphertext) {
            if (ciphertext.length != 16) {
              throw new TypeError("invalid ciphertext size (must be 16 bytes)");
            }
            const rounds =
              __classPrivateFieldGet$2(this, _AES_Kd, "f").length - 1;
            const a = [0, 0, 0, 0];
            let t = convertToInt32(ciphertext);
            for (let i = 0; i < 4; i++) {
              t[i] ^= __classPrivateFieldGet$2(this, _AES_Kd, "f")[0][i];
            }
            for (let r = 1; r < rounds; r++) {
              for (let i = 0; i < 4; i++) {
                a[i] =
                  T5[(t[i] >> 24) & 255] ^
                  T6[(t[(i + 3) % 4] >> 16) & 255] ^
                  T7[(t[(i + 2) % 4] >> 8) & 255] ^
                  T8[t[(i + 1) % 4] & 255] ^
                  __classPrivateFieldGet$2(this, _AES_Kd, "f")[r][i];
              }
              t = a.slice();
            }
            const result = new Uint8Array(16);
            let tt = 0;
            for (let i = 0; i < 4; i++) {
              tt = __classPrivateFieldGet$2(this, _AES_Kd, "f")[rounds][i];
              result[4 * i] = (Si[(t[i] >> 24) & 255] ^ (tt >> 24)) & 255;
              result[4 * i + 1] =
                (Si[(t[(i + 3) % 4] >> 16) & 255] ^ (tt >> 16)) & 255;
              result[4 * i + 2] =
                (Si[(t[(i + 2) % 4] >> 8) & 255] ^ (tt >> 8)) & 255;
              result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
            }
            return result;
          }
        }
        (_AES_key = new WeakMap()),
          (_AES_Kd = new WeakMap()),
          (_AES_Ke = new WeakMap());
        class ModeOfOperation {
          constructor(name, key, cls) {
            if (cls && !(this instanceof cls)) {
              throw new Error(`${name} must be instantiated with "new"`);
            }
            Object.defineProperties(this, {
              aes: { enumerable: true, value: new AES(key) },
              name: { enumerable: true, value: name },
            });
          }
        }
        var __classPrivateFieldSet$1 =
          (__$G && __$G.__classPrivateFieldSet) ||
          function (receiver, state, value, kind, f) {
            if (kind === "m")
              throw new TypeError("Private method is not writable");
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a setter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              kind === "a"
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          };
        var __classPrivateFieldGet$1 =
          (__$G && __$G.__classPrivateFieldGet) ||
          function (receiver, state, kind, f) {
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a getter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return kind === "m"
              ? f
              : kind === "a"
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          };
        var _CBC_iv, _CBC_lastBlock;
        class CBC extends ModeOfOperation {
          constructor(key, iv) {
            super("ECC", key, CBC);
            _CBC_iv.set(this, void 0);
            _CBC_lastBlock.set(this, void 0);
            if (iv) {
              if (iv.length % 16) {
                throw new TypeError("invalid iv size (must be 16 bytes)");
              }
              __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(iv), "f");
            } else {
              __classPrivateFieldSet$1(this, _CBC_iv, new Uint8Array(16), "f");
            }
            __classPrivateFieldSet$1(this, _CBC_lastBlock, this.iv, "f");
          }
          get iv() {
            return new Uint8Array(__classPrivateFieldGet$1(this, _CBC_iv, "f"));
          }
          encrypt(plaintext) {
            if (plaintext.length % 16) {
              throw new TypeError(
                "invalid plaintext size (must be multiple of 16 bytes)"
              );
            }
            const ciphertext = new Uint8Array(plaintext.length);
            for (let i = 0; i < plaintext.length; i += 16) {
              for (let j = 0; j < 16; j++) {
                __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] ^=
                  plaintext[i + j];
              }
              __classPrivateFieldSet$1(
                this,
                _CBC_lastBlock,
                this.aes.encrypt(
                  __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")
                ),
                "f"
              );
              ciphertext.set(
                __classPrivateFieldGet$1(this, _CBC_lastBlock, "f"),
                i
              );
            }
            return ciphertext;
          }
          decrypt(ciphertext) {
            if (ciphertext.length % 16) {
              throw new TypeError(
                "invalid ciphertext size (must be multiple of 16 bytes)"
              );
            }
            const plaintext = new Uint8Array(ciphertext.length);
            for (let i = 0; i < ciphertext.length; i += 16) {
              const block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
              for (let j = 0; j < 16; j++) {
                plaintext[i + j] =
                  block[j] ^
                  __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j];
                __classPrivateFieldGet$1(this, _CBC_lastBlock, "f")[j] =
                  ciphertext[i + j];
              }
            }
            return plaintext;
          }
        }
        (_CBC_iv = new WeakMap()), (_CBC_lastBlock = new WeakMap());
        var __classPrivateFieldSet =
          (__$G && __$G.__classPrivateFieldSet) ||
          function (receiver, state, value, kind, f) {
            if (kind === "m")
              throw new TypeError("Private method is not writable");
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a setter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot write private member to an object whose class did not declare it"
              );
            return (
              kind === "a"
                ? f.call(receiver, value)
                : f
                ? (f.value = value)
                : state.set(receiver, value),
              value
            );
          };
        var __classPrivateFieldGet =
          (__$G && __$G.__classPrivateFieldGet) ||
          function (receiver, state, kind, f) {
            if (kind === "a" && !f)
              throw new TypeError(
                "Private accessor was defined without a getter"
              );
            if (
              typeof state === "function"
                ? receiver !== state || !f
                : !state.has(receiver)
            )
              throw new TypeError(
                "Cannot read private member from an object whose class did not declare it"
              );
            return kind === "m"
              ? f
              : kind === "a"
              ? f.call(receiver)
              : f
              ? f.value
              : state.get(receiver);
          };
        var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
        class CTR extends ModeOfOperation {
          constructor(key, initialValue) {
            super("CTR", key, CTR);
            _CTR_remaining.set(this, void 0);
            _CTR_remainingIndex.set(this, void 0);
            _CTR_counter.set(this, void 0);
            __classPrivateFieldSet(this, _CTR_counter, new Uint8Array(16), "f");
            __classPrivateFieldGet(this, _CTR_counter, "f").fill(0);
            __classPrivateFieldSet(
              this,
              _CTR_remaining,
              __classPrivateFieldGet(this, _CTR_counter, "f"),
              "f"
            );
            __classPrivateFieldSet(this, _CTR_remainingIndex, 16, "f");
            if (initialValue == null) {
              initialValue = 1;
            }
            if (typeof initialValue === "number") {
              this.setCounterValue(initialValue);
            } else {
              this.setCounterBytes(initialValue);
            }
          }
          get counter() {
            return new Uint8Array(
              __classPrivateFieldGet(this, _CTR_counter, "f")
            );
          }
          setCounterValue(value) {
            if (
              !Number.isInteger(value) ||
              value < 0 ||
              value > Number.MAX_SAFE_INTEGER
            ) {
              throw new TypeError("invalid counter initial integer value");
            }
            for (let index = 15; index >= 0; --index) {
              __classPrivateFieldGet(this, _CTR_counter, "f")[index] =
                value % 256;
              value = Math.floor(value / 256);
            }
          }
          setCounterBytes(value) {
            if (value.length !== 16) {
              throw new TypeError(
                "invalid counter initial Uint8Array value length"
              );
            }
            __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
          }
          increment() {
            for (let i = 15; i >= 0; i--) {
              if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
                __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
              } else {
                __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
                break;
              }
            }
          }
          encrypt(plaintext) {
            var _a, _b;
            const crypttext = new Uint8Array(plaintext);
            for (let i = 0; i < crypttext.length; i++) {
              if (
                __classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16
              ) {
                __classPrivateFieldSet(
                  this,
                  _CTR_remaining,
                  this.aes.encrypt(
                    __classPrivateFieldGet(this, _CTR_counter, "f")
                  ),
                  "f"
                );
                __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
                this.increment();
              }
              crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[
                (__classPrivateFieldSet(
                  this,
                  _CTR_remainingIndex,
                  ((_b = __classPrivateFieldGet(
                    this,
                    _CTR_remainingIndex,
                    "f"
                  )),
                  (_a = _b++),
                  _b),
                  "f"
                ),
                _a)
              ];
            }
            return crypttext;
          }
          decrypt(ciphertext) {
            return this.encrypt(ciphertext);
          }
        }
        (_CTR_remaining = new WeakMap()),
          (_CTR_remainingIndex = new WeakMap()),
          (_CTR_counter = new WeakMap());
        function pkcs7Strip(data) {
          if (data.length < 16) {
            throw new TypeError("PKCS#7 invalid length");
          }
          const padder = data[data.length - 1];
          if (padder > 16) {
            throw new TypeError("PKCS#7 padding byte out of range");
          }
          const length = data.length - padder;
          for (let i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
              throw new TypeError("PKCS#7 invalid padding byte");
            }
          }
          return new Uint8Array(data.subarray(0, length));
        }
        function looseArrayify(hexString) {
          if (typeof hexString === "string" && !hexString.startsWith("0x")) {
            hexString = "0x" + hexString;
          }
          return getBytesCopy(hexString);
        }
        function zpad$1(value, length) {
          value = String(value);
          while (value.length < length) {
            value = "0" + value;
          }
          return value;
        }
        function getPassword(password) {
          if (typeof password === "string") {
            return toUtf8Bytes(password, "NFKC");
          }
          return getBytesCopy(password);
        }
        function spelunk(object, _path) {
          const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
          assertArgument(match != null, "invalid path", "path", _path);
          const path = match[1];
          const type = match[3];
          const reqd = match[4] === "!";
          let cur = object;
          for (const comp of path.toLowerCase().split(".")) {
            if (Array.isArray(cur)) {
              if (!comp.match(/^[0-9]+$/)) {
                break;
              }
              cur = cur[parseInt(comp)];
            } else if (typeof cur === "object") {
              let found = null;
              for (const key in cur) {
                if (key.toLowerCase() === comp) {
                  found = cur[key];
                  break;
                }
              }
              cur = found;
            } else {
              cur = null;
            }
            if (cur == null) {
              break;
            }
          }
          assertArgument(
            !reqd || cur != null,
            "missing required value",
            "path",
            path
          );
          if (type && cur != null) {
            if (type === "int") {
              if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
                return parseInt(cur);
              } else if (Number.isSafeInteger(cur)) {
                return cur;
              }
            }
            if (type === "number") {
              if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
                return parseFloat(cur);
              }
            }
            if (type === "data") {
              if (typeof cur === "string") {
                return looseArrayify(cur);
              }
            }
            if (type === "array" && Array.isArray(cur)) {
              return cur;
            }
            if (type === typeof cur) {
              return cur;
            }
            assertArgument(
              false,
              `wrong type found for ${type} `,
              "path",
              path
            );
          }
          return cur;
        }
        const defaultPath$1 = "m/44'/60'/0'/0/0";
        function isKeystoreJson(json) {
          try {
            const data = JSON.parse(json);
            const version = data.version != null ? parseInt(data.version) : 0;
            if (version === 3) {
              return true;
            }
          } catch (error) {}
          return false;
        }
        function decrypt(data, key, ciphertext) {
          const cipher = spelunk(data, "crypto.cipher:string");
          if (cipher === "aes-128-ctr") {
            const iv = spelunk(data, "crypto.cipherparams.iv:data!");
            const aesCtr = new CTR(key, iv);
            return hexlify(aesCtr.decrypt(ciphertext));
          }
          assert$1(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
            operation: "decrypt",
          });
        }
        function getAccount(data, _key) {
          const key = getBytes(_key);
          const ciphertext = spelunk(data, "crypto.ciphertext:data!");
          const computedMAC = hexlify(
            keccak256(concat([key.slice(16, 32), ciphertext]))
          ).substring(2);
          assertArgument(
            computedMAC === spelunk(data, "crypto.mac:string!").toLowerCase(),
            "incorrect password",
            "password",
            "[ REDACTED ]"
          );
          const privateKey = decrypt(data, key.slice(0, 16), ciphertext);
          const address = computeAddress(privateKey);
          if (data.address) {
            let check = data.address.toLowerCase();
            if (!check.startsWith("0x")) {
              check = "0x" + check;
            }
            assertArgument(
              getAddress(check) === address,
              "keystore address/privateKey mismatch",
              "address",
              data.address
            );
          }
          const account = { address: address, privateKey: privateKey };
          const version = spelunk(data, "x-ethers.version:string");
          if (version === "0.1") {
            const mnemonicKey = key.slice(32, 64);
            const mnemonicCiphertext = spelunk(
              data,
              "x-ethers.mnemonicCiphertext:data!"
            );
            const mnemonicIv = spelunk(data, "x-ethers.mnemonicCounter:data!");
            const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
            account.mnemonic = {
              path: spelunk(data, "x-ethers.path:string") || defaultPath$1,
              locale: spelunk(data, "x-ethers.locale:string") || "en",
              entropy: hexlify(
                getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext))
              ),
            };
          }
          return account;
        }
        function getDecryptKdfParams(data) {
          const kdf = spelunk(data, "crypto.kdf:string");
          if (kdf && typeof kdf === "string") {
            if (kdf.toLowerCase() === "scrypt") {
              const salt = spelunk(data, "crypto.kdfparams.salt:data!");
              const N = spelunk(data, "crypto.kdfparams.n:int!");
              const r = spelunk(data, "crypto.kdfparams.r:int!");
              const p = spelunk(data, "crypto.kdfparams.p:int!");
              assertArgument(
                N > 0 && (N & (N - 1)) === 0,
                "invalid kdf.N",
                "kdf.N",
                N
              );
              assertArgument(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
              const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
              assertArgument(
                dkLen === 32,
                "invalid kdf.dklen",
                "kdf.dflen",
                dkLen
              );
              return {
                name: "scrypt",
                salt: salt,
                N: N,
                r: r,
                p: p,
                dkLen: 64,
              };
            } else if (kdf.toLowerCase() === "pbkdf2") {
              const salt = spelunk(data, "crypto.kdfparams.salt:data!");
              const prf = spelunk(data, "crypto.kdfparams.prf:string!");
              const algorithm = prf.split("-").pop();
              assertArgument(
                algorithm === "sha256" || algorithm === "sha512",
                "invalid kdf.pdf",
                "kdf.pdf",
                prf
              );
              const count = spelunk(data, "crypto.kdfparams.c:int!");
              const dkLen = spelunk(data, "crypto.kdfparams.dklen:int!");
              assertArgument(
                dkLen === 32,
                "invalid kdf.dklen",
                "kdf.dklen",
                dkLen
              );
              return {
                name: "pbkdf2",
                salt: salt,
                count: count,
                dkLen: dkLen,
                algorithm: algorithm,
              };
            }
          }
          assertArgument(
            false,
            "unsupported key-derivation function",
            "kdf",
            kdf
          );
        }
        function decryptKeystoreJsonSync(json, _password) {
          const data = JSON.parse(json);
          const password = getPassword(_password);
          const params = getDecryptKdfParams(data);
          if (params.name === "pbkdf2") {
            const { salt, count, dkLen, algorithm } = params;
            const key = pbkdf2(password, salt, count, dkLen, algorithm);
            return getAccount(data, key);
          }
          assert$1(
            params.name === "scrypt",
            "cannot be reached",
            "UNKNOWN_ERROR",
            { params: params }
          );
          const { salt, N, r, p, dkLen } = params;
          const key = scryptSync(password, salt, N, r, p, dkLen);
          return getAccount(data, key);
        }
        function stall$1(duration) {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, duration);
          });
        }
        async function decryptKeystoreJson(json, _password, progress) {
          const data = JSON.parse(json);
          const password = getPassword(_password);
          const params = getDecryptKdfParams(data);
          if (params.name === "pbkdf2") {
            if (progress) {
              progress(0);
              await stall$1(0);
            }
            const { salt, count, dkLen, algorithm } = params;
            const key = pbkdf2(password, salt, count, dkLen, algorithm);
            if (progress) {
              progress(1);
              await stall$1(0);
            }
            return getAccount(data, key);
          }
          assert$1(
            params.name === "scrypt",
            "cannot be reached",
            "UNKNOWN_ERROR",
            { params: params }
          );
          const { salt, N, r, p, dkLen } = params;
          const key = await scrypt(password, salt, N, r, p, dkLen, progress);
          return getAccount(data, key);
        }
        function getEncryptKdfParams(options) {
          const salt =
            options.salt != null
              ? getBytes(options.salt, "options.salt")
              : randomBytes(32);
          let N = 1 << 17,
            r = 8,
            p = 1;
          if (options.scrypt) {
            if (options.scrypt.N) {
              N = options.scrypt.N;
            }
            if (options.scrypt.r) {
              r = options.scrypt.r;
            }
            if (options.scrypt.p) {
              p = options.scrypt.p;
            }
          }
          assertArgument(
            typeof N === "number" &&
              N > 0 &&
              Number.isSafeInteger(N) &&
              (BigInt(N) & BigInt(N - 1)) === BigInt(0),
            "invalid scrypt N parameter",
            "options.N",
            N
          );
          assertArgument(
            typeof r === "number" && r > 0 && Number.isSafeInteger(r),
            "invalid scrypt r parameter",
            "options.r",
            r
          );
          assertArgument(
            typeof p === "number" && p > 0 && Number.isSafeInteger(p),
            "invalid scrypt p parameter",
            "options.p",
            p
          );
          return { name: "scrypt", dkLen: 32, salt: salt, N: N, r: r, p: p };
        }
        function _encryptKeystore(key, kdf, account, options) {
          const privateKey = getBytes(account.privateKey, "privateKey");
          const iv =
            options.iv != null
              ? getBytes(options.iv, "options.iv")
              : randomBytes(16);
          assertArgument(
            iv.length === 16,
            "invalid options.iv length",
            "options.iv",
            options.iv
          );
          const uuidRandom =
            options.uuid != null
              ? getBytes(options.uuid, "options.uuid")
              : randomBytes(16);
          assertArgument(
            uuidRandom.length === 16,
            "invalid options.uuid length",
            "options.uuid",
            options.iv
          );
          const derivedKey = key.slice(0, 16);
          const macPrefix = key.slice(16, 32);
          const aesCtr = new CTR(derivedKey, iv);
          const ciphertext = getBytes(aesCtr.encrypt(privateKey));
          const mac = keccak256(concat([macPrefix, ciphertext]));
          const data = {
            address: account.address.substring(2).toLowerCase(),
            id: uuidV4(uuidRandom),
            version: 3,
            Crypto: {
              cipher: "aes-128-ctr",
              cipherparams: { iv: hexlify(iv).substring(2) },
              ciphertext: hexlify(ciphertext).substring(2),
              kdf: "scrypt",
              kdfparams: {
                salt: hexlify(kdf.salt).substring(2),
                n: kdf.N,
                dklen: 32,
                p: kdf.p,
                r: kdf.r,
              },
              mac: mac.substring(2),
            },
          };
          if (account.mnemonic) {
            const client =
              options.client != null ? options.client : `ethers/${version}`;
            const path = account.mnemonic.path || defaultPath$1;
            const locale = account.mnemonic.locale || "en";
            const mnemonicKey = key.slice(32, 64);
            const entropy = getBytes(
              account.mnemonic.entropy,
              "account.mnemonic.entropy"
            );
            const mnemonicIv = randomBytes(16);
            const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
            const mnemonicCiphertext = getBytes(
              mnemonicAesCtr.encrypt(entropy)
            );
            const now = new Date();
            const timestamp =
              now.getUTCFullYear() +
              "-" +
              zpad$1(now.getUTCMonth() + 1, 2) +
              "-" +
              zpad$1(now.getUTCDate(), 2) +
              "T" +
              zpad$1(now.getUTCHours(), 2) +
              "-" +
              zpad$1(now.getUTCMinutes(), 2) +
              "-" +
              zpad$1(now.getUTCSeconds(), 2) +
              ".0Z";
            const gethFilename = "UTC--" + timestamp + "--" + data.address;
            data["x-ethers"] = {
              client: client,
              gethFilename: gethFilename,
              path: path,
              locale: locale,
              mnemonicCounter: hexlify(mnemonicIv).substring(2),
              mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
              version: "0.1",
            };
          }
          return JSON.stringify(data);
        }
        function encryptKeystoreJsonSync(account, password, options) {
          if (options == null) {
            options = {};
          }
          const passwordBytes = getPassword(password);
          const kdf = getEncryptKdfParams(options);
          const key = scryptSync(
            passwordBytes,
            kdf.salt,
            kdf.N,
            kdf.r,
            kdf.p,
            64
          );
          return _encryptKeystore(getBytes(key), kdf, account, options);
        }
        async function encryptKeystoreJson(account, password, options) {
          if (options == null) {
            options = {};
          }
          const passwordBytes = getPassword(password);
          const kdf = getEncryptKdfParams(options);
          const key = await scrypt(
            passwordBytes,
            kdf.salt,
            kdf.N,
            kdf.r,
            kdf.p,
            64,
            options.progressCallback
          );
          return _encryptKeystore(getBytes(key), kdf, account, options);
        }
        const defaultPath = "m/44'/60'/0'/0/0";
        const MasterSecret = new Uint8Array([
          66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100,
        ]);
        const HardenedBit = 2147483648;
        const N = BigInt(
          "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
        );
        const Nibbles = "0123456789abcdef";
        function zpad(value, length) {
          let result = "";
          while (value) {
            result = Nibbles[value % 16] + result;
            value = Math.trunc(value / 16);
          }
          while (result.length < length * 2) {
            result = "0" + result;
          }
          return "0x" + result;
        }
        function encodeBase58Check(_value) {
          const value = getBytes(_value);
          const check = dataSlice(sha256(sha256(value)), 0, 4);
          const bytes = concat([value, check]);
          return encodeBase58(bytes);
        }
        const _guard = {};
        function ser_I(index, chainCode, publicKey, privateKey) {
          const data = new Uint8Array(37);
          if (index & HardenedBit) {
            assert$1(
              privateKey != null,
              "cannot derive child of neutered node",
              "UNSUPPORTED_OPERATION",
              { operation: "deriveChild" }
            );
            data.set(getBytes(privateKey), 1);
          } else {
            data.set(getBytes(publicKey));
          }
          for (let i = 24; i >= 0; i -= 8) {
            data[33 + (i >> 3)] = (index >> (24 - i)) & 255;
          }
          const I = getBytes(computeHmac("sha512", chainCode, data));
          return { IL: I.slice(0, 32), IR: I.slice(32) };
        }
        function derivePath(node, path) {
          const components = path.split("/");
          assertArgument(
            components.length > 0 && (components[0] === "m" || node.depth > 0),
            "invalid path",
            "path",
            path
          );
          if (components[0] === "m") {
            components.shift();
          }
          let result = node;
          for (let i = 0; i < components.length; i++) {
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
              const index = parseInt(
                component.substring(0, component.length - 1)
              );
              assertArgument(
                index < HardenedBit,
                "invalid path index",
                `path[${i}]`,
                component
              );
              result = result.deriveChild(HardenedBit + index);
            } else if (component.match(/^[0-9]+$/)) {
              const index = parseInt(component);
              assertArgument(
                index < HardenedBit,
                "invalid path index",
                `path[${i}]`,
                component
              );
              result = result.deriveChild(index);
            } else {
              assertArgument(
                false,
                "invalid path component",
                `path[${i}]`,
                component
              );
            }
          }
          return result;
        }
        class HDNodeWallet extends BaseWallet {
          publicKey;
          fingerprint;
          parentFingerprint;
          mnemonic;
          chainCode;
          path;
          index;
          depth;
          constructor(
            guard,
            signingKey,
            parentFingerprint,
            chainCode,
            path,
            index,
            depth,
            mnemonic,
            provider
          ) {
            super(signingKey, provider);
            assertPrivate(guard, _guard, "HDNodeWallet");
            defineProperties(this, {
              publicKey: signingKey.compressedPublicKey,
            });
            const fingerprint = dataSlice(
              ripemd160(sha256(this.publicKey)),
              0,
              4
            );
            defineProperties(this, {
              parentFingerprint: parentFingerprint,
              fingerprint: fingerprint,
              chainCode: chainCode,
              path: path,
              index: index,
              depth: depth,
            });
            defineProperties(this, { mnemonic: mnemonic });
          }
          connect(provider) {
            return new HDNodeWallet(
              _guard,
              this.signingKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              this.mnemonic,
              provider
            );
          }
          #account() {
            const account = {
              address: this.address,
              privateKey: this.privateKey,
            };
            const m = this.mnemonic;
            if (
              this.path &&
              m &&
              m.wordlist.locale === "en" &&
              m.password === ""
            ) {
              account.mnemonic = {
                path: this.path,
                locale: "en",
                entropy: m.entropy,
              };
            }
            return account;
          }
          async encrypt(password, progressCallback) {
            return await encryptKeystoreJson(this.#account(), password, {
              progressCallback: progressCallback,
            });
          }
          encryptSync(password) {
            return encryptKeystoreJsonSync(this.#account(), password);
          }
          get extendedKey() {
            assert$1(
              this.depth < 256,
              "Depth too deep",
              "UNSUPPORTED_OPERATION",
              { operation: "extendedKey" }
            );
            return encodeBase58Check(
              concat([
                "0x0488ADE4",
                zpad(this.depth, 1),
                this.parentFingerprint,
                zpad(this.index, 4),
                this.chainCode,
                concat(["0x00", this.privateKey]),
              ])
            );
          }
          hasPath() {
            return this.path != null;
          }
          neuter() {
            return new HDNodeVoidWallet(
              _guard,
              this.address,
              this.publicKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              this.provider
            );
          }
          deriveChild(_index) {
            const index = getNumber(_index, "index");
            assertArgument(
              index <= 4294967295,
              "invalid index",
              "index",
              index
            );
            let path = this.path;
            if (path) {
              path += "/" + (index & ~HardenedBit);
              if (index & HardenedBit) {
                path += "'";
              }
            }
            const { IR, IL } = ser_I(
              index,
              this.chainCode,
              this.publicKey,
              this.privateKey
            );
            const ki = new SigningKey(
              toBeHex((toBigInt(IL) + BigInt(this.privateKey)) % N, 32)
            );
            return new HDNodeWallet(
              _guard,
              ki,
              this.fingerprint,
              hexlify(IR),
              path,
              index,
              this.depth + 1,
              this.mnemonic,
              this.provider
            );
          }
          derivePath(path) {
            return derivePath(this, path);
          }
          static #fromSeed(_seed, mnemonic) {
            assertArgument(
              isBytesLike(_seed),
              "invalid seed",
              "seed",
              "[REDACTED]"
            );
            const seed = getBytes(_seed, "seed");
            assertArgument(
              seed.length >= 16 && seed.length <= 64,
              "invalid seed",
              "seed",
              "[REDACTED]"
            );
            const I = getBytes(computeHmac("sha512", MasterSecret, seed));
            const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
            return new HDNodeWallet(
              _guard,
              signingKey,
              "0x00000000",
              hexlify(I.slice(32)),
              "m",
              0,
              0,
              mnemonic,
              null
            );
          }
          static fromExtendedKey(extendedKey) {
            const bytes = toBeArray(decodeBase58(extendedKey));
            assertArgument(
              bytes.length === 82 ||
                encodeBase58Check(bytes.slice(0, 78)) === extendedKey,
              "invalid extended key",
              "extendedKey",
              "[ REDACTED ]"
            );
            const depth = bytes[4];
            const parentFingerprint = hexlify(bytes.slice(5, 9));
            const index = parseInt(
              hexlify(bytes.slice(9, 13)).substring(2),
              16
            );
            const chainCode = hexlify(bytes.slice(13, 45));
            const key = bytes.slice(45, 78);
            switch (hexlify(bytes.slice(0, 4))) {
              case "0x0488b21e":
              case "0x043587cf": {
                const publicKey = hexlify(key);
                return new HDNodeVoidWallet(
                  _guard,
                  computeAddress(publicKey),
                  publicKey,
                  parentFingerprint,
                  chainCode,
                  null,
                  index,
                  depth,
                  null
                );
              }
              case "0x0488ade4":
              case "0x04358394 ":
                if (key[0] !== 0) {
                  break;
                }
                return new HDNodeWallet(
                  _guard,
                  new SigningKey(key.slice(1)),
                  parentFingerprint,
                  chainCode,
                  null,
                  index,
                  depth,
                  null,
                  null
                );
            }
            assertArgument(
              false,
              "invalid extended key prefix",
              "extendedKey",
              "[ REDACTED ]"
            );
          }
          static createRandom(password, path, wordlist) {
            if (password == null) {
              password = "";
            }
            if (path == null) {
              path = defaultPath;
            }
            if (wordlist == null) {
              wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromEntropy(
              randomBytes(16),
              password,
              wordlist
            );
            return HDNodeWallet.#fromSeed(
              mnemonic.computeSeed(),
              mnemonic
            ).derivePath(path);
          }
          static fromMnemonic(mnemonic, path) {
            if (!path) {
              path = defaultPath;
            }
            return HDNodeWallet.#fromSeed(
              mnemonic.computeSeed(),
              mnemonic
            ).derivePath(path);
          }
          static fromPhrase(phrase, password, path, wordlist) {
            if (password == null) {
              password = "";
            }
            if (path == null) {
              path = defaultPath;
            }
            if (wordlist == null) {
              wordlist = LangEn.wordlist();
            }
            const mnemonic = Mnemonic.fromPhrase(phrase, password, wordlist);
            return HDNodeWallet.#fromSeed(
              mnemonic.computeSeed(),
              mnemonic
            ).derivePath(path);
          }
          static fromSeed(seed) {
            return HDNodeWallet.#fromSeed(seed, null);
          }
        }
        class HDNodeVoidWallet extends VoidSigner {
          publicKey;
          fingerprint;
          parentFingerprint;
          chainCode;
          path;
          index;
          depth;
          constructor(
            guard,
            address,
            publicKey,
            parentFingerprint,
            chainCode,
            path,
            index,
            depth,
            provider
          ) {
            super(address, provider);
            assertPrivate(guard, _guard, "HDNodeVoidWallet");
            defineProperties(this, { publicKey: publicKey });
            const fingerprint = dataSlice(ripemd160(sha256(publicKey)), 0, 4);
            defineProperties(this, {
              publicKey: publicKey,
              fingerprint: fingerprint,
              parentFingerprint: parentFingerprint,
              chainCode: chainCode,
              path: path,
              index: index,
              depth: depth,
            });
          }
          connect(provider) {
            return new HDNodeVoidWallet(
              _guard,
              this.address,
              this.publicKey,
              this.parentFingerprint,
              this.chainCode,
              this.path,
              this.index,
              this.depth,
              provider
            );
          }
          get extendedKey() {
            assert$1(
              this.depth < 256,
              "Depth too deep",
              "UNSUPPORTED_OPERATION",
              { operation: "extendedKey" }
            );
            return encodeBase58Check(
              concat([
                "0x0488B21E",
                zpad(this.depth, 1),
                this.parentFingerprint,
                zpad(this.index, 4),
                this.chainCode,
                this.publicKey,
              ])
            );
          }
          hasPath() {
            return this.path != null;
          }
          deriveChild(_index) {
            const index = getNumber(_index, "index");
            assertArgument(
              index <= 4294967295,
              "invalid index",
              "index",
              index
            );
            let path = this.path;
            if (path) {
              path += "/" + (index & ~HardenedBit);
              if (index & HardenedBit) {
                path += "'";
              }
            }
            const { IR, IL } = ser_I(
              index,
              this.chainCode,
              this.publicKey,
              null
            );
            const Ki = SigningKey.addPoints(IL, this.publicKey, true);
            const address = computeAddress(Ki);
            return new HDNodeVoidWallet(
              _guard,
              address,
              Ki,
              this.fingerprint,
              hexlify(IR),
              path,
              index,
              this.depth + 1,
              this.provider
            );
          }
          derivePath(path) {
            return derivePath(this, path);
          }
        }
        function getAccountPath(_index) {
          const index = getNumber(_index, "index");
          assertArgument(
            index >= 0 && index < HardenedBit,
            "invalid account index",
            "index",
            index
          );
          return `m/44'/60'/${index}'/0/0`;
        }
        function getIndexedAccountPath(_index) {
          const index = getNumber(_index, "index");
          assertArgument(
            index >= 0 && index < HardenedBit,
            "invalid account index",
            "index",
            index
          );
          return `m/44'/60'/0'/0/${index}`;
        }
        function isCrowdsaleJson(json) {
          try {
            const data = JSON.parse(json);
            if (data.encseed) {
              return true;
            }
          } catch (error) {}
          return false;
        }
        function decryptCrowdsaleJson(json, _password) {
          const data = JSON.parse(json);
          const password = getPassword(_password);
          const address = getAddress(spelunk(data, "ethaddr:string!"));
          const encseed = looseArrayify(spelunk(data, "encseed:string!"));
          assertArgument(
            encseed && encseed.length % 16 === 0,
            "invalid encseed",
            "json",
            json
          );
          const key = getBytes(
            pbkdf2(password, password, 2e3, 32, "sha256")
          ).slice(0, 16);
          const iv = encseed.slice(0, 16);
          const encryptedSeed = encseed.slice(16);
          const aesCbc = new CBC(key, iv);
          const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
          let seedHex = "";
          for (let i = 0; i < seed.length; i++) {
            seedHex += String.fromCharCode(seed[i]);
          }
          return { address: address, privateKey: id(seedHex) };
        }
        function stall(duration) {
          return new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, duration);
          });
        }
        class Wallet extends BaseWallet {
          constructor(key, provider) {
            if (typeof key === "string" && !key.startsWith("0x")) {
              key = "0x" + key;
            }
            let signingKey =
              typeof key === "string" ? new SigningKey(key) : key;
            super(signingKey, provider);
          }
          connect(provider) {
            return new Wallet(this.signingKey, provider);
          }
          async encrypt(password, progressCallback) {
            const account = {
              address: this.address,
              privateKey: this.privateKey,
            };
            return await encryptKeystoreJson(account, password, {
              progressCallback: progressCallback,
            });
          }
          encryptSync(password) {
            const account = {
              address: this.address,
              privateKey: this.privateKey,
            };
            return encryptKeystoreJsonSync(account, password);
          }
          static #fromAccount(account) {
            assertArgument(
              account,
              "invalid JSON wallet",
              "json",
              "[ REDACTED ]"
            );
            if (
              "mnemonic" in account &&
              account.mnemonic &&
              account.mnemonic.locale === "en"
            ) {
              const mnemonic = Mnemonic.fromEntropy(account.mnemonic.entropy);
              const wallet = HDNodeWallet.fromMnemonic(
                mnemonic,
                account.mnemonic.path
              );
              if (
                wallet.address === account.address &&
                wallet.privateKey === account.privateKey
              ) {
                return wallet;
              }
              console.log(
                "WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key"
              );
            }
            const wallet = new Wallet(account.privateKey);
            assertArgument(
              wallet.address === account.address,
              "address/privateKey mismatch",
              "json",
              "[ REDACTED ]"
            );
            return wallet;
          }
          static async fromEncryptedJson(json, password, progress) {
            let account = null;
            if (isKeystoreJson(json)) {
              account = await decryptKeystoreJson(json, password, progress);
            } else if (isCrowdsaleJson(json)) {
              if (progress) {
                progress(0);
                await stall(0);
              }
              account = decryptCrowdsaleJson(json, password);
              if (progress) {
                progress(1);
                await stall(0);
              }
            }
            return Wallet.#fromAccount(account);
          }
          static fromEncryptedJsonSync(json, password) {
            let account = null;
            if (isKeystoreJson(json)) {
              account = decryptKeystoreJsonSync(json, password);
            } else if (isCrowdsaleJson(json)) {
              account = decryptCrowdsaleJson(json, password);
            } else {
              assertArgument(
                false,
                "invalid JSON wallet",
                "json",
                "[ REDACTED ]"
              );
            }
            return Wallet.#fromAccount(account);
          }
          static createRandom(provider) {
            const wallet = HDNodeWallet.createRandom();
            if (provider) {
              return wallet.connect(provider);
            }
            return wallet;
          }
          static fromPhrase(phrase, provider) {
            const wallet = HDNodeWallet.fromPhrase(phrase);
            if (provider) {
              return wallet.connect(provider);
            }
            return wallet;
          }
        }
        const Base64 =
          ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
        function decodeBits(width, data) {
          const maxValue = (1 << width) - 1;
          const result = [];
          let accum = 0,
            bits = 0,
            flood = 0;
          for (let i = 0; i < data.length; i++) {
            accum = (accum << 6) | Base64.indexOf(data[i]);
            bits += 6;
            while (bits >= width) {
              const value = accum >> (bits - width);
              accum &= (1 << (bits - width)) - 1;
              bits -= width;
              if (value === 0) {
                flood += maxValue;
              } else {
                result.push(value + flood);
                flood = 0;
              }
            }
          }
          return result;
        }
        function decodeOwlA(data, accents) {
          let words = decodeOwl(data).join(",");
          accents.split(/,/g).forEach((accent) => {
            const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
            assertArgument(
              match !== null,
              "internal error parsing accents",
              "accents",
              accents
            );
            let posOffset = 0;
            const positions = decodeBits(parseInt(match[3]), match[4]);
            const charCode = parseInt(match[2]);
            const regex = new RegExp(`([${match[1]}])`, "g");
            words = words.replace(regex, (all, letter) => {
              const rem = --positions[posOffset];
              if (rem === 0) {
                letter = String.fromCharCode(letter.charCodeAt(0), charCode);
                posOffset++;
              }
              return letter;
            });
          });
          return words.split(",");
        }
        class WordlistOwlA extends WordlistOwl {
          #accent;
          constructor(locale, data, accent, checksum) {
            super(locale, data, checksum);
            this.#accent = accent;
          }
          get _accent() {
            return this.#accent;
          }
          _decodeWords() {
            return decodeOwlA(this._data, this._accent);
          }
        }
        const wordlists = { en: LangEn.wordlist() };
        var ethers = Object.freeze({
          __proto__: null,
          AbiCoder: AbiCoder,
          AbstractProvider: AbstractProvider,
          AbstractSigner: AbstractSigner,
          AlchemyProvider: AlchemyProvider,
          AnkrProvider: AnkrProvider,
          BaseContract: BaseContract,
          BaseWallet: BaseWallet,
          Block: Block,
          BrowserProvider: BrowserProvider,
          CloudflareProvider: CloudflareProvider,
          ConstructorFragment: ConstructorFragment,
          Contract: Contract,
          ContractEventPayload: ContractEventPayload,
          ContractFactory: ContractFactory,
          ContractTransactionReceipt: ContractTransactionReceipt,
          ContractTransactionResponse: ContractTransactionResponse,
          ContractUnknownEventPayload: ContractUnknownEventPayload,
          EnsPlugin: EnsPlugin,
          EnsResolver: EnsResolver,
          ErrorDescription: ErrorDescription,
          ErrorFragment: ErrorFragment,
          EtherSymbol: EtherSymbol,
          EtherscanPlugin: EtherscanPlugin,
          EtherscanProvider: EtherscanProvider,
          EventFragment: EventFragment,
          EventLog: EventLog,
          EventPayload: EventPayload,
          FallbackFragment: FallbackFragment,
          FallbackProvider: FallbackProvider,
          FeeData: FeeData,
          FeeDataNetworkPlugin: FeeDataNetworkPlugin,
          FetchCancelSignal: FetchCancelSignal,
          FetchRequest: FetchRequest,
          FetchResponse: FetchResponse,
          FetchUrlFeeDataNetworkPlugin: FetchUrlFeeDataNetworkPlugin,
          FixedNumber: FixedNumber,
          Fragment: Fragment,
          FunctionFragment: FunctionFragment,
          GasCostPlugin: GasCostPlugin,
          HDNodeVoidWallet: HDNodeVoidWallet,
          HDNodeWallet: HDNodeWallet,
          Indexed: Indexed,
          InfuraProvider: InfuraProvider,
          InfuraWebSocketProvider: InfuraWebSocketProvider,
          Interface: Interface,
          IpcSocketProvider: IpcSocketProvider,
          JsonRpcApiProvider: JsonRpcApiProvider,
          JsonRpcProvider: JsonRpcProvider,
          JsonRpcSigner: JsonRpcSigner,
          LangEn: LangEn,
          Log: Log,
          LogDescription: LogDescription,
          MaxInt256: MaxInt256,
          MaxUint256: MaxUint256,
          MessagePrefix: MessagePrefix,
          MinInt256: MinInt256,
          Mnemonic: Mnemonic,
          MulticoinProviderPlugin: MulticoinProviderPlugin,
          N: N$1,
          NamedFragment: NamedFragment,
          Network: Network,
          NetworkPlugin: NetworkPlugin,
          NonceManager: NonceManager,
          ParamType: ParamType,
          PocketProvider: PocketProvider,
          QuickNodeProvider: QuickNodeProvider,
          Result: Result,
          Signature: Signature,
          SigningKey: SigningKey,
          SocketBlockSubscriber: SocketBlockSubscriber,
          SocketEventSubscriber: SocketEventSubscriber,
          SocketPendingSubscriber: SocketPendingSubscriber,
          SocketProvider: SocketProvider,
          SocketSubscriber: SocketSubscriber,
          StructFragment: StructFragment,
          Transaction: Transaction,
          TransactionDescription: TransactionDescription,
          TransactionReceipt: TransactionReceipt,
          TransactionResponse: TransactionResponse,
          Typed: Typed,
          TypedDataEncoder: TypedDataEncoder,
          UndecodedEventLog: UndecodedEventLog,
          UnmanagedSubscriber: UnmanagedSubscriber,
          Utf8ErrorFuncs: Utf8ErrorFuncs,
          VoidSigner: VoidSigner,
          Wallet: Wallet,
          WebSocketProvider: WebSocketProvider,
          WeiPerEther: WeiPerEther,
          Wordlist: Wordlist,
          WordlistOwl: WordlistOwl,
          WordlistOwlA: WordlistOwlA,
          ZeroAddress: ZeroAddress,
          ZeroHash: ZeroHash,
          accessListify: accessListify,
          assert: assert$1,
          assertArgument: assertArgument,
          assertArgumentCount: assertArgumentCount,
          assertNormalize: assertNormalize,
          assertPrivate: assertPrivate,
          checkResultErrors: checkResultErrors,
          computeAddress: computeAddress,
          computeHmac: computeHmac,
          concat: concat,
          copyRequest: copyRequest,
          dataLength: dataLength,
          dataSlice: dataSlice,
          decodeBase58: decodeBase58,
          decodeBase64: decodeBase64,
          decodeBytes32String: decodeBytes32String,
          decodeRlp: decodeRlp,
          decryptCrowdsaleJson: decryptCrowdsaleJson,
          decryptKeystoreJson: decryptKeystoreJson,
          decryptKeystoreJsonSync: decryptKeystoreJsonSync,
          defaultPath: defaultPath,
          defineProperties: defineProperties,
          dnsEncode: dnsEncode,
          encodeBase58: encodeBase58,
          encodeBase64: encodeBase64,
          encodeBytes32String: encodeBytes32String,
          encodeRlp: encodeRlp,
          encryptKeystoreJson: encryptKeystoreJson,
          encryptKeystoreJsonSync: encryptKeystoreJsonSync,
          ensNormalize: ensNormalize,
          formatEther: formatEther,
          formatUnits: formatUnits,
          fromTwos: fromTwos,
          getAccountPath: getAccountPath,
          getAddress: getAddress,
          getBigInt: getBigInt,
          getBytes: getBytes,
          getBytesCopy: getBytesCopy,
          getCreate2Address: getCreate2Address,
          getCreateAddress: getCreateAddress,
          getDefaultProvider: getDefaultProvider,
          getIcapAddress: getIcapAddress,
          getIndexedAccountPath: getIndexedAccountPath,
          getNumber: getNumber,
          getUint: getUint,
          hashMessage: hashMessage,
          hexlify: hexlify,
          id: id,
          isAddress: isAddress,
          isAddressable: isAddressable,
          isBytesLike: isBytesLike,
          isCallException: isCallException,
          isCrowdsaleJson: isCrowdsaleJson,
          isError: isError,
          isHexString: isHexString,
          isKeystoreJson: isKeystoreJson,
          isValidName: isValidName,
          keccak256: keccak256,
          lock: lock,
          makeError: makeError,
          mask: mask,
          namehash: namehash,
          parseEther: parseEther,
          parseUnits: parseUnits$1,
          pbkdf2: pbkdf2,
          randomBytes: randomBytes,
          recoverAddress: recoverAddress,
          resolveAddress: resolveAddress,
          resolveProperties: resolveProperties,
          ripemd160: ripemd160,
          scrypt: scrypt,
          scryptSync: scryptSync,
          sha256: sha256,
          sha512: sha512,
          showThrottleMessage: showThrottleMessage,
          solidityPacked: solidityPacked,
          solidityPackedKeccak256: solidityPackedKeccak256,
          solidityPackedSha256: solidityPackedSha256,
          stripZerosLeft: stripZerosLeft,
          toBeArray: toBeArray,
          toBeHex: toBeHex,
          toBigInt: toBigInt,
          toNumber: toNumber,
          toQuantity: toQuantity,
          toTwos: toTwos,
          toUtf8Bytes: toUtf8Bytes,
          toUtf8CodePoints: toUtf8CodePoints,
          toUtf8String: toUtf8String,
          uuidV4: uuidV4,
          verifyMessage: verifyMessage,
          verifyTypedData: verifyTypedData,
          version: version,
          wordlists: wordlists,
          zeroPadBytes: zeroPadBytes,
          zeroPadValue: zeroPadValue,
        });
        exports.AbiCoder = AbiCoder;
        exports.AbstractProvider = AbstractProvider;
        exports.AbstractSigner = AbstractSigner;
        exports.AlchemyProvider = AlchemyProvider;
        exports.AnkrProvider = AnkrProvider;
        exports.BaseContract = BaseContract;
        exports.BaseWallet = BaseWallet;
        exports.Block = Block;
        exports.BrowserProvider = BrowserProvider;
        exports.CloudflareProvider = CloudflareProvider;
        exports.ConstructorFragment = ConstructorFragment;
        exports.Contract = Contract;
        exports.ContractEventPayload = ContractEventPayload;
        exports.ContractFactory = ContractFactory;
        exports.ContractTransactionReceipt = ContractTransactionReceipt;
        exports.ContractTransactionResponse = ContractTransactionResponse;
        exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
        exports.EnsPlugin = EnsPlugin;
        exports.EnsResolver = EnsResolver;
        exports.ErrorDescription = ErrorDescription;
        exports.ErrorFragment = ErrorFragment;
        exports.EtherSymbol = EtherSymbol;
        exports.EtherscanPlugin = EtherscanPlugin;
        exports.EtherscanProvider = EtherscanProvider;
        exports.EventFragment = EventFragment;
        exports.EventLog = EventLog;
        exports.EventPayload = EventPayload;
        exports.FallbackFragment = FallbackFragment;
        exports.FallbackProvider = FallbackProvider;
        exports.FeeData = FeeData;
        exports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
        exports.FetchCancelSignal = FetchCancelSignal;
        exports.FetchRequest = FetchRequest;
        exports.FetchResponse = FetchResponse;
        exports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
        exports.FixedNumber = FixedNumber;
        exports.Fragment = Fragment;
        exports.FunctionFragment = FunctionFragment;
        exports.GasCostPlugin = GasCostPlugin;
        exports.HDNodeVoidWallet = HDNodeVoidWallet;
        exports.HDNodeWallet = HDNodeWallet;
        exports.Indexed = Indexed;
        exports.InfuraProvider = InfuraProvider;
        exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
        exports.Interface = Interface;
        exports.IpcSocketProvider = IpcSocketProvider;
        exports.JsonRpcApiProvider = JsonRpcApiProvider;
        exports.JsonRpcProvider = JsonRpcProvider;
        exports.JsonRpcSigner = JsonRpcSigner;
        exports.LangEn = LangEn;
        exports.Log = Log;
        exports.LogDescription = LogDescription;
        exports.MaxInt256 = MaxInt256;
        exports.MaxUint256 = MaxUint256;
        exports.MessagePrefix = MessagePrefix;
        exports.MinInt256 = MinInt256;
        exports.Mnemonic = Mnemonic;
        exports.MulticoinProviderPlugin = MulticoinProviderPlugin;
        exports.N = N$1;
        exports.NamedFragment = NamedFragment;
        exports.Network = Network;
        exports.NetworkPlugin = NetworkPlugin;
        exports.NonceManager = NonceManager;
        exports.ParamType = ParamType;
        exports.PocketProvider = PocketProvider;
        exports.QuickNodeProvider = QuickNodeProvider;
        exports.Result = Result;
        exports.Signature = Signature;
        exports.SigningKey = SigningKey;
        exports.SocketBlockSubscriber = SocketBlockSubscriber;
        exports.SocketEventSubscriber = SocketEventSubscriber;
        exports.SocketPendingSubscriber = SocketPendingSubscriber;
        exports.SocketProvider = SocketProvider;
        exports.SocketSubscriber = SocketSubscriber;
        exports.StructFragment = StructFragment;
        exports.Transaction = Transaction;
        exports.TransactionDescription = TransactionDescription;
        exports.TransactionReceipt = TransactionReceipt;
        exports.TransactionResponse = TransactionResponse;
        exports.Typed = Typed;
        exports.TypedDataEncoder = TypedDataEncoder;
        exports.UndecodedEventLog = UndecodedEventLog;
        exports.UnmanagedSubscriber = UnmanagedSubscriber;
        exports.Utf8ErrorFuncs = Utf8ErrorFuncs;
        exports.VoidSigner = VoidSigner;
        exports.Wallet = Wallet;
        exports.WebSocketProvider = WebSocketProvider;
        exports.WeiPerEther = WeiPerEther;
        exports.Wordlist = Wordlist;
        exports.WordlistOwl = WordlistOwl;
        exports.WordlistOwlA = WordlistOwlA;
        exports.ZeroAddress = ZeroAddress;
        exports.ZeroHash = ZeroHash;
        exports.accessListify = accessListify;
        exports.assert = assert$1;
        exports.assertArgument = assertArgument;
        exports.assertArgumentCount = assertArgumentCount;
        exports.assertNormalize = assertNormalize;
        exports.assertPrivate = assertPrivate;
        exports.checkResultErrors = checkResultErrors;
        exports.computeAddress = computeAddress;
        exports.computeHmac = computeHmac;
        exports.concat = concat;
        exports.copyRequest = copyRequest;
        exports.dataLength = dataLength;
        exports.dataSlice = dataSlice;
        exports.decodeBase58 = decodeBase58;
        exports.decodeBase64 = decodeBase64;
        exports.decodeBytes32String = decodeBytes32String;
        exports.decodeRlp = decodeRlp;
        exports.decryptCrowdsaleJson = decryptCrowdsaleJson;
        exports.decryptKeystoreJson = decryptKeystoreJson;
        exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
        exports.defaultPath = defaultPath;
        exports.defineProperties = defineProperties;
        exports.dnsEncode = dnsEncode;
        exports.encodeBase58 = encodeBase58;
        exports.encodeBase64 = encodeBase64;
        exports.encodeBytes32String = encodeBytes32String;
        exports.encodeRlp = encodeRlp;
        exports.encryptKeystoreJson = encryptKeystoreJson;
        exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
        exports.ensNormalize = ensNormalize;
        exports.ethers = ethers;
        exports.formatEther = formatEther;
        exports.formatUnits = formatUnits;
        exports.fromTwos = fromTwos;
        exports.getAccountPath = getAccountPath;
        exports.getAddress = getAddress;
        exports.getBigInt = getBigInt;
        exports.getBytes = getBytes;
        exports.getBytesCopy = getBytesCopy;
        exports.getCreate2Address = getCreate2Address;
        exports.getCreateAddress = getCreateAddress;
        exports.getDefaultProvider = getDefaultProvider;
        exports.getIcapAddress = getIcapAddress;
        exports.getIndexedAccountPath = getIndexedAccountPath;
        exports.getNumber = getNumber;
        exports.getUint = getUint;
        exports.hashMessage = hashMessage;
        exports.hexlify = hexlify;
        exports.id = id;
        exports.isAddress = isAddress;
        exports.isAddressable = isAddressable;
        exports.isBytesLike = isBytesLike;
        exports.isCallException = isCallException;
        exports.isCrowdsaleJson = isCrowdsaleJson;
        exports.isError = isError;
        exports.isHexString = isHexString;
        exports.isKeystoreJson = isKeystoreJson;
        exports.isValidName = isValidName;
        exports.keccak256 = keccak256;
        exports.lock = lock;
        exports.makeError = makeError;
        exports.mask = mask;
        exports.namehash = namehash;
        exports.parseEther = parseEther;
        exports.parseUnits = parseUnits$1;
        exports.pbkdf2 = pbkdf2;
        exports.randomBytes = randomBytes;
        exports.recoverAddress = recoverAddress;
        exports.resolveAddress = resolveAddress;
        exports.resolveProperties = resolveProperties;
        exports.ripemd160 = ripemd160;
        exports.scrypt = scrypt;
        exports.scryptSync = scryptSync;
        exports.sha256 = sha256;
        exports.sha512 = sha512;
        exports.showThrottleMessage = showThrottleMessage;
        exports.solidityPacked = solidityPacked;
        exports.solidityPackedKeccak256 = solidityPackedKeccak256;
        exports.solidityPackedSha256 = solidityPackedSha256;
        exports.stripZerosLeft = stripZerosLeft;
        exports.toBeArray = toBeArray;
        exports.toBeHex = toBeHex;
        exports.toBigInt = toBigInt;
        exports.toNumber = toNumber;
        exports.toQuantity = toQuantity;
        exports.toTwos = toTwos;
        exports.toUtf8Bytes = toUtf8Bytes;
        exports.toUtf8CodePoints = toUtf8CodePoints;
        exports.toUtf8String = toUtf8String;
        exports.uuidV4 = uuidV4;
        exports.verifyMessage = verifyMessage;
        exports.verifyTypedData = verifyTypedData;
        exports.version = version;
        exports.wordlists = wordlists;
        exports.zeroPadBytes = zeroPadBytes;
        exports.zeroPadValue = zeroPadValue;
      });
    </script>
    <script>
      const jspdfBase64 =
        "LyoqIEBsaWNlbnNlCiAqCiAqIGpzUERGIC0gUERGIERvY3VtZW50IGNyZWF0aW9uIGZyb20gSmF2YVNjcmlwdAogKiBWZXJzaW9uIDIuNS4xIEJ1aWx0IG9uIDIwMjItMDEtMjhUMTU6Mzc6NTcuNzg5WgogKiAgICAgICAgICAgICAgICAgICAgICBDb21taXRJRCAwMDAwMDAwMAogKgogKiBDb3B5cmlnaHQgKGMpIDIwMTAtMjAyMSBKYW1lcyBIYWxsIDxqYW1lc0BwYXJhbGwuYXg+LCBodHRwczovL2dpdGh1Yi5jb20vTXJSaW8vanNQREYKICogICAgICAgICAgICAgICAyMDE1LTIwMjEgeVdvcmtzIEdtYkgsIGh0dHA6Ly93d3cueXdvcmtzLmNvbQogKiAgICAgICAgICAgICAgIDIwMTUtMjAyMSBMdWthcyBIb2xsw6RuZGVyIDxsdWthcy5ob2xsYWVuZGVyQHl3b3Jrcy5jb20+LCBodHRwczovL2dpdGh1Yi5jb20vSGFja2JyZXR0WFhYCiAqICAgICAgICAgICAgICAgMjAxNi0yMDE4IEFyYXMgQWJiYXNpIDxhcmFzLmFiYmFzaUBnbWFpbC5jb20+CiAqICAgICAgICAgICAgICAgMjAxMCBBYXJvbiBTcGlrZSwgaHR0cHM6Ly9naXRodWIuY29tL2Fjc3Bpa2UKICogICAgICAgICAgICAgICAyMDEyIFdpbGxvdyBTeXN0ZW1zIENvcnBvcmF0aW9uLCBodHRwczovL2dpdGh1Yi5jb20vd2lsbG93c3lzdGVtcwogKiAgICAgICAgICAgICAgIDIwMTIgUGFibG8gSGVzcywgaHR0cHM6Ly9naXRodWIuY29tL3BhYmxvaGVzcwogKiAgICAgICAgICAgICAgIDIwMTIgRmxvcmlhbiBKZW5ldHQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mamVuZXR0CiAqICAgICAgICAgICAgICAgMjAxMyBXYXJyZW4gV2Vja2Vzc2VyLCBodHRwczovL2dpdGh1Yi5jb20vd2FycmVud2Vja2Vzc2VyCiAqICAgICAgICAgICAgICAgMjAxMyBZb3Vzc2VmIEJlZGRhZCwgaHR0cHM6Ly9naXRodWIuY29tL2xpZm9mCiAqICAgICAgICAgICAgICAgMjAxMyBMZWUgRHJpc2NvbGwsIGh0dHBzOi8vZ2l0aHViLmNvbS9sc2RyaXNjb2xsCiAqICAgICAgICAgICAgICAgMjAxMyBTdGVmYW4gU2xvbmV2c2tpeSwgaHR0cHM6Ly9naXRodWIuY29tL3N0ZWZzbG9uCiAqICAgICAgICAgICAgICAgMjAxMyBKZXJlbXkgTW9yZWwsIGh0dHBzOi8vZ2l0aHViLmNvbS9qbW9yZWwKICogICAgICAgICAgICAgICAyMDEzIENocmlzdG9waCBIYXJ0bWFubiwgaHR0cHM6Ly9naXRodWIuY29tL2NocmlzLXJvY2sKICogICAgICAgICAgICAgICAyMDE0IEp1YW4gUGFibG8gR2F2aXJpYSwgaHR0cHM6Ly9naXRodWIuY29tL2p1YW5wZ2F2aXJpYQogKiAgICAgICAgICAgICAgIDIwMTQgSmFtZXMgTWFrZXMsIGh0dHBzOi8vZ2l0aHViLmNvbS9kb2xsYXJ1dwogKiAgICAgICAgICAgICAgIDIwMTQgRGllZ28gQ2Fzb3JyYW4sIGh0dHBzOi8vZ2l0aHViLmNvbS9kaWVnb2NyCiAqICAgICAgICAgICAgICAgMjAxNCBTdGV2ZW4gU3B1bmdpbiwgaHR0cHM6Ly9naXRodWIuY29tL0ZsYW1lbmNvCiAqICAgICAgICAgICAgICAgMjAxNCBLZW5uZXRoIEdsYXNzZXksIGh0dHBzOi8vZ2l0aHViLmNvbS9HYXZ2ZXJzCiAqCiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZwogKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKICogIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwogKiB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwogKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8KICogdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOgogKgogKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZQogKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KICoKICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsCiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgogKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORAogKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFCiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04KICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OCiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgogKgogKiBDb250cmlidXRvcihzKToKICogICAgc2llZmtlbmosIGFod29sZiwgcmlja3lndSwgTWlkbml0aCwgc2FpbnRjbGFpciwgZWFwYXJhbmdvLAogKiAgICBraW0zZXIsIG1mbywgYWxub3J0aCwgRmxhbWVuY28KICovCgohZnVuY3Rpb24odCxlKXsib2JqZWN0Ij09dHlwZW9mIGV4cG9ydHMmJiJ1bmRlZmluZWQiIT10eXBlb2YgbW9kdWxlP2UoZXhwb3J0cyk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyJleHBvcnRzIl0sZSk6ZSgodD10fHxzZWxmKS5qc3BkZj17fSl9KHRoaXMsKGZ1bmN0aW9uKHQpeyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiBlKHQpe3JldHVybihlPSJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJiJzeW1ib2wiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIHQmJiJmdW5jdGlvbiI9PXR5cGVvZiBTeW1ib2wmJnQuY29uc3RydWN0b3I9PT1TeW1ib2wmJnQhPT1TeW1ib2wucHJvdG90eXBlPyJzeW1ib2wiOnR5cGVvZiB0fSkodCl9dmFyIHI9ZnVuY3Rpb24oKXtyZXR1cm4idW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6InVuZGVmaW5lZCIhPXR5cGVvZiBnbG9iYWw/Z2xvYmFsOiJ1bmRlZmluZWQiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXN9KCk7ZnVuY3Rpb24gbigpe3IuY29uc29sZSYmImZ1bmN0aW9uIj09dHlwZW9mIHIuY29uc29sZS5sb2cmJnIuY29uc29sZS5sb2cuYXBwbHkoci5jb25zb2xlLGFyZ3VtZW50cyl9dmFyIGk9e2xvZzpuLHdhcm46ZnVuY3Rpb24odCl7ci5jb25zb2xlJiYoImZ1bmN0aW9uIj09dHlwZW9mIHIuY29uc29sZS53YXJuP3IuY29uc29sZS53YXJuLmFwcGx5KHIuY29uc29sZSxhcmd1bWVudHMpOm4uY2FsbChudWxsLGFyZ3VtZW50cykpfSxlcnJvcjpmdW5jdGlvbih0KXtyLmNvbnNvbGUmJigiZnVuY3Rpb24iPT10eXBlb2Ygci5jb25zb2xlLmVycm9yP3IuY29uc29sZS5lcnJvci5hcHBseShyLmNvbnNvbGUsYXJndW1lbnRzKTpuKHQpKX19O2Z1bmN0aW9uIGEodCxlLHIpe3ZhciBuPW5ldyBYTUxIdHRwUmVxdWVzdDtuLm9wZW4oIkdFVCIsdCksbi5yZXNwb25zZVR5cGU9ImJsb2IiLG4ub25sb2FkPWZ1bmN0aW9uKCl7bChuLnJlc3BvbnNlLGUscil9LG4ub25lcnJvcj1mdW5jdGlvbigpe2kuZXJyb3IoImNvdWxkIG5vdCBkb3dubG9hZCBmaWxlIil9LG4uc2VuZCgpfWZ1bmN0aW9uIG8odCl7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O2Uub3BlbigiSEVBRCIsdCwhMSk7dHJ5e2Uuc2VuZCgpfWNhdGNoKHQpe31yZXR1cm4gZS5zdGF0dXM+PTIwMCYmZS5zdGF0dXM8PTI5OX1mdW5jdGlvbiBzKHQpe3RyeXt0LmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoImNsaWNrIikpfWNhdGNoKHIpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUV2ZW50KCJNb3VzZUV2ZW50cyIpO2UuaW5pdE1vdXNlRXZlbnQoImNsaWNrIiwhMCwhMCx3aW5kb3csMCwwLDAsODAsMjAsITEsITEsITEsITEsMCxudWxsKSx0LmRpc3BhdGNoRXZlbnQoZSl9fXZhciBjLHUsbD1yLnNhdmVBc3x8KCJvYmplY3QiIT09KCJ1bmRlZmluZWQiPT10eXBlb2Ygd2luZG93PyJ1bmRlZmluZWQiOmUod2luZG93KSl8fHdpbmRvdyE9PXI/ZnVuY3Rpb24oKXt9OiJ1bmRlZmluZWQiIT10eXBlb2YgSFRNTEFuY2hvckVsZW1lbnQmJiJkb3dubG9hZCJpbiBIVE1MQW5jaG9yRWxlbWVudC5wcm90b3R5cGU/ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXIuVVJMfHxyLndlYmtpdFVSTCxjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImEiKTtlPWV8fHQubmFtZXx8ImRvd25sb2FkIixjLmRvd25sb2FkPWUsYy5yZWw9Im5vb3BlbmVyIiwic3RyaW5nIj09dHlwZW9mIHQ/KGMuaHJlZj10LGMub3JpZ2luIT09bG9jYXRpb24ub3JpZ2luP28oYy5ocmVmKT9hKHQsZSxuKTpzKGMsYy50YXJnZXQ9Il9ibGFuayIpOnMoYykpOihjLmhyZWY9aS5jcmVhdGVPYmplY3RVUkwodCksc2V0VGltZW91dCgoZnVuY3Rpb24oKXtpLnJldm9rZU9iamVjdFVSTChjLmhyZWYpfSksNGU0KSxzZXRUaW1lb3V0KChmdW5jdGlvbigpe3MoYyl9KSwwKSl9OiJtc1NhdmVPck9wZW5CbG9iImluIG5hdmlnYXRvcj9mdW5jdGlvbih0LHIsbil7aWYocj1yfHx0Lm5hbWV8fCJkb3dubG9hZCIsInN0cmluZyI9PXR5cGVvZiB0KWlmKG8odCkpYSh0LHIsbik7ZWxzZXt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJhIik7Yy5ocmVmPXQsYy50YXJnZXQ9Il9ibGFuayIsc2V0VGltZW91dCgoZnVuY3Rpb24oKXtzKGMpfSkpfWVsc2UgbmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoZnVuY3Rpb24odCxyKXtyZXR1cm4gdm9pZCAwPT09cj9yPXthdXRvQm9tOiExfToib2JqZWN0IiE9PWUocikmJihpLndhcm4oIkRlcHJlY2F0ZWQ6IEV4cGVjdGVkIHRoaXJkIGFyZ3VtZW50IHRvIGJlIGEgb2JqZWN0Iikscj17YXV0b0JvbTohcn0pLHIuYXV0b0JvbSYmL15ccyooPzp0ZXh0XC9cUyp8YXBwbGljYXRpb25cL3htbHxcUypcL1xTKlwreG1sKVxzKjsuKmNoYXJzZXRccyo9XHMqdXRmLTgvaS50ZXN0KHQudHlwZSk/bmV3IEJsb2IoW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUyNzkpLHRdLHt0eXBlOnQudHlwZX0pOnR9KHQsbikscil9OmZ1bmN0aW9uKHQsbixpLG8pe2lmKChvPW98fG9wZW4oIiIsIl9ibGFuayIpKSYmKG8uZG9jdW1lbnQudGl0bGU9by5kb2N1bWVudC5ib2R5LmlubmVyVGV4dD0iZG93bmxvYWRpbmcuLi4iKSwic3RyaW5nIj09dHlwZW9mIHQpcmV0dXJuIGEodCxuLGkpO3ZhciBzPSJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0iPT09dC50eXBlLGM9L2NvbnN0cnVjdG9yL2kudGVzdChyLkhUTUxFbGVtZW50KXx8ci5zYWZhcmksdT0vQ3JpT1NcL1tcZF0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2lmKCh1fHxzJiZjKSYmIm9iamVjdCI9PT0oInVuZGVmaW5lZCI9PXR5cGVvZiBGaWxlUmVhZGVyPyJ1bmRlZmluZWQiOmUoRmlsZVJlYWRlcikpKXt2YXIgbD1uZXcgRmlsZVJlYWRlcjtsLm9ubG9hZGVuZD1mdW5jdGlvbigpe3ZhciB0PWwucmVzdWx0O3Q9dT90OnQucmVwbGFjZSgvXmRhdGE6W147XSo7LywiZGF0YTphdHRhY2htZW50L2ZpbGU7Iiksbz9vLmxvY2F0aW9uLmhyZWY9dDpsb2NhdGlvbj10LG89bnVsbH0sbC5yZWFkQXNEYXRhVVJMKHQpfWVsc2V7dmFyIGg9ci5VUkx8fHIud2Via2l0VVJMLGY9aC5jcmVhdGVPYmplY3RVUkwodCk7bz9vLmxvY2F0aW9uPWY6bG9jYXRpb24uaHJlZj1mLG89bnVsbCxzZXRUaW1lb3V0KChmdW5jdGlvbigpe2gucmV2b2tlT2JqZWN0VVJMKGYpfSksNGU0KX19KTsKLyoqCiAgICogQSBjbGFzcyB0byBwYXJzZSBjb2xvciB2YWx1ZXMKICAgKiBAYXV0aG9yIFN0b3lhbiBTdGVmYW5vdiA8c3N0b29AZ21haWwuY29tPgogICAqIHtAbGluayAgIGh0dHA6Ly93d3cucGhwaWVkLmNvbS9yZ2ItY29sb3ItcGFyc2VyLWluLWphdmFzY3JpcHQvfQogICAqIEBsaWNlbnNlIFVzZSBpdCBpZiB5b3UgbGlrZSBpdAogICAqL2Z1bmN0aW9uIGgodCl7dmFyIGU7dD10fHwiIix0aGlzLm9rPSExLCIjIj09dC5jaGFyQXQoMCkmJih0PXQuc3Vic3RyKDEsNikpO3Q9e2FsaWNlYmx1ZToiZjBmOGZmIixhbnRpcXVld2hpdGU6ImZhZWJkNyIsYXF1YToiMDBmZmZmIixhcXVhbWFyaW5lOiI3ZmZmZDQiLGF6dXJlOiJmMGZmZmYiLGJlaWdlOiJmNWY1ZGMiLGJpc3F1ZToiZmZlNGM0IixibGFjazoiMDAwMDAwIixibGFuY2hlZGFsbW9uZDoiZmZlYmNkIixibHVlOiIwMDAwZmYiLGJsdWV2aW9sZXQ6IjhhMmJlMiIsYnJvd246ImE1MmEyYSIsYnVybHl3b29kOiJkZWI4ODciLGNhZGV0Ymx1ZToiNWY5ZWEwIixjaGFydHJldXNlOiI3ZmZmMDAiLGNob2NvbGF0ZToiZDI2OTFlIixjb3JhbDoiZmY3ZjUwIixjb3JuZmxvd2VyYmx1ZToiNjQ5NWVkIixjb3Juc2lsazoiZmZmOGRjIixjcmltc29uOiJkYzE0M2MiLGN5YW46IjAwZmZmZiIsZGFya2JsdWU6IjAwMDA4YiIsZGFya2N5YW46IjAwOGI4YiIsZGFya2dvbGRlbnJvZDoiYjg4NjBiIixkYXJrZ3JheToiYTlhOWE5IixkYXJrZ3JlZW46IjAwNjQwMCIsZGFya2toYWtpOiJiZGI3NmIiLGRhcmttYWdlbnRhOiI4YjAwOGIiLGRhcmtvbGl2ZWdyZWVuOiI1NTZiMmYiLGRhcmtvcmFuZ2U6ImZmOGMwMCIsZGFya29yY2hpZDoiOTkzMmNjIixkYXJrcmVkOiI4YjAwMDAiLGRhcmtzYWxtb246ImU5OTY3YSIsZGFya3NlYWdyZWVuOiI4ZmJjOGYiLGRhcmtzbGF0ZWJsdWU6IjQ4M2Q4YiIsZGFya3NsYXRlZ3JheToiMmY0ZjRmIixkYXJrdHVycXVvaXNlOiIwMGNlZDEiLGRhcmt2aW9sZXQ6Ijk0MDBkMyIsZGVlcHBpbms6ImZmMTQ5MyIsZGVlcHNreWJsdWU6IjAwYmZmZiIsZGltZ3JheToiNjk2OTY5Iixkb2RnZXJibHVlOiIxZTkwZmYiLGZlbGRzcGFyOiJkMTkyNzUiLGZpcmVicmljazoiYjIyMjIyIixmbG9yYWx3aGl0ZToiZmZmYWYwIixmb3Jlc3RncmVlbjoiMjI4YjIyIixmdWNoc2lhOiJmZjAwZmYiLGdhaW5zYm9ybzoiZGNkY2RjIixnaG9zdHdoaXRlOiJmOGY4ZmYiLGdvbGQ6ImZmZDcwMCIsZ29sZGVucm9kOiJkYWE1MjAiLGdyYXk6IjgwODA4MCIsZ3JlZW46IjAwODAwMCIsZ3JlZW55ZWxsb3c6ImFkZmYyZiIsaG9uZXlkZXc6ImYwZmZmMCIsaG90cGluazoiZmY2OWI0IixpbmRpYW5yZWQ6ImNkNWM1YyIsaW5kaWdvOiI0YjAwODIiLGl2b3J5OiJmZmZmZjAiLGtoYWtpOiJmMGU2OGMiLGxhdmVuZGVyOiJlNmU2ZmEiLGxhdmVuZGVyYmx1c2g6ImZmZjBmNSIsbGF3bmdyZWVuOiI3Y2ZjMDAiLGxlbW9uY2hpZmZvbjoiZmZmYWNkIixsaWdodGJsdWU6ImFkZDhlNiIsbGlnaHRjb3JhbDoiZjA4MDgwIixsaWdodGN5YW46ImUwZmZmZiIsbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ImZhZmFkMiIsbGlnaHRncmV5OiJkM2QzZDMiLGxpZ2h0Z3JlZW46IjkwZWU5MCIsbGlnaHRwaW5rOiJmZmI2YzEiLGxpZ2h0c2FsbW9uOiJmZmEwN2EiLGxpZ2h0c2VhZ3JlZW46IjIwYjJhYSIsbGlnaHRza3libHVlOiI4N2NlZmEiLGxpZ2h0c2xhdGVibHVlOiI4NDcwZmYiLGxpZ2h0c2xhdGVncmF5OiI3Nzg4OTkiLGxpZ2h0c3RlZWxibHVlOiJiMGM0ZGUiLGxpZ2h0eWVsbG93OiJmZmZmZTAiLGxpbWU6IjAwZmYwMCIsbGltZWdyZWVuOiIzMmNkMzIiLGxpbmVuOiJmYWYwZTYiLG1hZ2VudGE6ImZmMDBmZiIsbWFyb29uOiI4MDAwMDAiLG1lZGl1bWFxdWFtYXJpbmU6IjY2Y2RhYSIsbWVkaXVtYmx1ZToiMDAwMGNkIixtZWRpdW1vcmNoaWQ6ImJhNTVkMyIsbWVkaXVtcHVycGxlOiI5MzcwZDgiLG1lZGl1bXNlYWdyZWVuOiIzY2IzNzEiLG1lZGl1bXNsYXRlYmx1ZToiN2I2OGVlIixtZWRpdW1zcHJpbmdncmVlbjoiMDBmYTlhIixtZWRpdW10dXJxdW9pc2U6IjQ4ZDFjYyIsbWVkaXVtdmlvbGV0cmVkOiJjNzE1ODUiLG1pZG5pZ2h0Ymx1ZToiMTkxOTcwIixtaW50Y3JlYW06ImY1ZmZmYSIsbWlzdHlyb3NlOiJmZmU0ZTEiLG1vY2Nhc2luOiJmZmU0YjUiLG5hdmFqb3doaXRlOiJmZmRlYWQiLG5hdnk6IjAwMDA4MCIsb2xkbGFjZToiZmRmNWU2IixvbGl2ZToiODA4MDAwIixvbGl2ZWRyYWI6IjZiOGUyMyIsb3JhbmdlOiJmZmE1MDAiLG9yYW5nZXJlZDoiZmY0NTAwIixvcmNoaWQ6ImRhNzBkNiIscGFsZWdvbGRlbnJvZDoiZWVlOGFhIixwYWxlZ3JlZW46Ijk4ZmI5OCIscGFsZXR1cnF1b2lzZToiYWZlZWVlIixwYWxldmlvbGV0cmVkOiJkODcwOTMiLHBhcGF5YXdoaXA6ImZmZWZkNSIscGVhY2hwdWZmOiJmZmRhYjkiLHBlcnU6ImNkODUzZiIscGluazoiZmZjMGNiIixwbHVtOiJkZGEwZGQiLHBvd2RlcmJsdWU6ImIwZTBlNiIscHVycGxlOiI4MDAwODAiLHJlZDoiZmYwMDAwIixyb3N5YnJvd246ImJjOGY4ZiIscm95YWxibHVlOiI0MTY5ZTEiLHNhZGRsZWJyb3duOiI4YjQ1MTMiLHNhbG1vbjoiZmE4MDcyIixzYW5keWJyb3duOiJmNGE0NjAiLHNlYWdyZWVuOiIyZThiNTciLHNlYXNoZWxsOiJmZmY1ZWUiLHNpZW5uYToiYTA1MjJkIixzaWx2ZXI6ImMwYzBjMCIsc2t5Ymx1ZToiODdjZWViIixzbGF0ZWJsdWU6IjZhNWFjZCIsc2xhdGVncmF5OiI3MDgwOTAiLHNub3c6ImZmZmFmYSIsc3ByaW5nZ3JlZW46IjAwZmY3ZiIsc3RlZWxibHVlOiI0NjgyYjQiLHRhbjoiZDJiNDhjIix0ZWFsOiIwMDgwODAiLHRoaXN0bGU6ImQ4YmZkOCIsdG9tYXRvOiJmZjYzNDciLHR1cnF1b2lzZToiNDBlMGQwIix2aW9sZXQ6ImVlODJlZSIsdmlvbGV0cmVkOiJkMDIwOTAiLHdoZWF0OiJmNWRlYjMiLHdoaXRlOiJmZmZmZmYiLHdoaXRlc21va2U6ImY1ZjVmNSIseWVsbG93OiJmZmZmMDAiLHllbGxvd2dyZWVuOiI5YWNkMzIifVt0PSh0PXQucmVwbGFjZSgvIC9nLCIiKSkudG9Mb3dlckNhc2UoKV18fHQ7Zm9yKHZhciByPVt7cmU6L15yZ2JcKChcZHsxLDN9KSxccyooXGR7MSwzfSksXHMqKFxkezEsM30pXCkkLyxleGFtcGxlOlsicmdiKDEyMywgMjM0LCA0NSkiLCJyZ2IoMjU1LDIzNCwyNDUpIl0scHJvY2VzczpmdW5jdGlvbih0KXtyZXR1cm5bcGFyc2VJbnQodFsxXSkscGFyc2VJbnQodFsyXSkscGFyc2VJbnQodFszXSldfX0se3JlOi9eKFx3ezJ9KShcd3syfSkoXHd7Mn0pJC8sZXhhbXBsZTpbIiMwMGZmMDAiLCIzMzY2OTkiXSxwcm9jZXNzOmZ1bmN0aW9uKHQpe3JldHVybltwYXJzZUludCh0WzFdLDE2KSxwYXJzZUludCh0WzJdLDE2KSxwYXJzZUludCh0WzNdLDE2KV19fSx7cmU6L14oXHd7MX0pKFx3ezF9KShcd3sxfSkkLyxleGFtcGxlOlsiI2ZiMCIsImYwZiJdLHByb2Nlc3M6ZnVuY3Rpb24odCl7cmV0dXJuW3BhcnNlSW50KHRbMV0rdFsxXSwxNikscGFyc2VJbnQodFsyXSt0WzJdLDE2KSxwYXJzZUludCh0WzNdK3RbM10sMTYpXX19XSxuPTA7bjxyLmxlbmd0aDtuKyspe3ZhciBpPXJbbl0ucmUsYT1yW25dLnByb2Nlc3Msbz1pLmV4ZWModCk7byYmKGU9YShvKSx0aGlzLnI9ZVswXSx0aGlzLmc9ZVsxXSx0aGlzLmI9ZVsyXSx0aGlzLm9rPSEwKX10aGlzLnI9dGhpcy5yPDB8fGlzTmFOKHRoaXMucik/MDp0aGlzLnI+MjU1PzI1NTp0aGlzLnIsdGhpcy5nPXRoaXMuZzwwfHxpc05hTih0aGlzLmcpPzA6dGhpcy5nPjI1NT8yNTU6dGhpcy5nLHRoaXMuYj10aGlzLmI8MHx8aXNOYU4odGhpcy5iKT8wOnRoaXMuYj4yNTU/MjU1OnRoaXMuYix0aGlzLnRvUkdCPWZ1bmN0aW9uKCl7cmV0dXJuInJnYigiK3RoaXMucisiLCAiK3RoaXMuZysiLCAiK3RoaXMuYisiKSJ9LHRoaXMudG9IZXg9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnIudG9TdHJpbmcoMTYpLGU9dGhpcy5nLnRvU3RyaW5nKDE2KSxyPXRoaXMuYi50b1N0cmluZygxNik7cmV0dXJuIDE9PXQubGVuZ3RoJiYodD0iMCIrdCksMT09ZS5sZW5ndGgmJihlPSIwIitlKSwxPT1yLmxlbmd0aCYmKHI9IjAiK3IpLCIjIit0K2Urcn19Ci8qKgogICAqIEBsaWNlbnNlCiAgICogSm9zZXBoIE15ZXJzIGRvZXMgbm90IHNwZWNpZnkgYSBwYXJ0aWN1bGFyIGxpY2Vuc2UgZm9yIGhpcyB3b3JrLgogICAqCiAgICogQXV0aG9yOiBKb3NlcGggTXllcnMKICAgKiBBY2Nlc3NlZCBmcm9tOiBodHRwOi8vd3d3Lm15ZXJzZGFpbHkub3JnL2pvc2VwaC9qYXZhc2NyaXB0L21kNS5qcwogICAqCiAgICogTW9kaWZpZWQgYnk6IE93ZW4gTGVvbmcKICAgKi8KZnVuY3Rpb24gZih0LGUpe3ZhciByPXRbMF0sbj10WzFdLGk9dFsyXSxhPXRbM107cj1wKHIsbixpLGEsZVswXSw3LC02ODA4NzY5MzYpLGE9cChhLHIsbixpLGVbMV0sMTIsLTM4OTU2NDU4NiksaT1wKGksYSxyLG4sZVsyXSwxNyw2MDYxMDU4MTkpLG49cChuLGksYSxyLGVbM10sMjIsLTEwNDQ1MjUzMzApLHI9cChyLG4saSxhLGVbNF0sNywtMTc2NDE4ODk3KSxhPXAoYSxyLG4saSxlWzVdLDEyLDEyMDAwODA0MjYpLGk9cChpLGEscixuLGVbNl0sMTcsLTE0NzMyMzEzNDEpLG49cChuLGksYSxyLGVbN10sMjIsLTQ1NzA1OTgzKSxyPXAocixuLGksYSxlWzhdLDcsMTc3MDAzNTQxNiksYT1wKGEscixuLGksZVs5XSwxMiwtMTk1ODQxNDQxNyksaT1wKGksYSxyLG4sZVsxMF0sMTcsLTQyMDYzKSxuPXAobixpLGEscixlWzExXSwyMiwtMTk5MDQwNDE2Mikscj1wKHIsbixpLGEsZVsxMl0sNywxODA0NjAzNjgyKSxhPXAoYSxyLG4saSxlWzEzXSwxMiwtNDAzNDExMDEpLGk9cChpLGEscixuLGVbMTRdLDE3LC0xNTAyMDAyMjkwKSxyPWcocixuPXAobixpLGEscixlWzE1XSwyMiwxMjM2NTM1MzI5KSxpLGEsZVsxXSw1LC0xNjU3OTY1MTApLGE9ZyhhLHIsbixpLGVbNl0sOSwtMTA2OTUwMTYzMiksaT1nKGksYSxyLG4sZVsxMV0sMTQsNjQzNzE3NzEzKSxuPWcobixpLGEscixlWzBdLDIwLC0zNzM4OTczMDIpLHI9ZyhyLG4saSxhLGVbNV0sNSwtNzAxNTU4NjkxKSxhPWcoYSxyLG4saSxlWzEwXSw5LDM4MDE2MDgzKSxpPWcoaSxhLHIsbixlWzE1XSwxNCwtNjYwNDc4MzM1KSxuPWcobixpLGEscixlWzRdLDIwLC00MDU1Mzc4NDgpLHI9ZyhyLG4saSxhLGVbOV0sNSw1Njg0NDY0MzgpLGE9ZyhhLHIsbixpLGVbMTRdLDksLTEwMTk4MDM2OTApLGk9ZyhpLGEscixuLGVbM10sMTQsLTE4NzM2Mzk2MSksbj1nKG4saSxhLHIsZVs4XSwyMCwxMTYzNTMxNTAxKSxyPWcocixuLGksYSxlWzEzXSw1LC0xNDQ0NjgxNDY3KSxhPWcoYSxyLG4saSxlWzJdLDksLTUxNDAzNzg0KSxpPWcoaSxhLHIsbixlWzddLDE0LDE3MzUzMjg0NzMpLHI9bShyLG49ZyhuLGksYSxyLGVbMTJdLDIwLC0xOTI2NjA3NzM0KSxpLGEsZVs1XSw0LC0zNzg1NTgpLGE9bShhLHIsbixpLGVbOF0sMTEsLTIwMjI1NzQ0NjMpLGk9bShpLGEscixuLGVbMTFdLDE2LDE4MzkwMzA1NjIpLG49bShuLGksYSxyLGVbMTRdLDIzLC0zNTMwOTU1Nikscj1tKHIsbixpLGEsZVsxXSw0LC0xNTMwOTkyMDYwKSxhPW0oYSxyLG4saSxlWzRdLDExLDEyNzI4OTMzNTMpLGk9bShpLGEscixuLGVbN10sMTYsLTE1NTQ5NzYzMiksbj1tKG4saSxhLHIsZVsxMF0sMjMsLTEwOTQ3MzA2NDApLHI9bShyLG4saSxhLGVbMTNdLDQsNjgxMjc5MTc0KSxhPW0oYSxyLG4saSxlWzBdLDExLC0zNTg1MzcyMjIpLGk9bShpLGEscixuLGVbM10sMTYsLTcyMjUyMTk3OSksbj1tKG4saSxhLHIsZVs2XSwyMyw3NjAyOTE4OSkscj1tKHIsbixpLGEsZVs5XSw0LC02NDAzNjQ0ODcpLGE9bShhLHIsbixpLGVbMTJdLDExLC00MjE4MTU4MzUpLGk9bShpLGEscixuLGVbMTVdLDE2LDUzMDc0MjUyMCkscj12KHIsbj1tKG4saSxhLHIsZVsyXSwyMywtOTk1MzM4NjUxKSxpLGEsZVswXSw2LC0xOTg2MzA4NDQpLGE9dihhLHIsbixpLGVbN10sMTAsMTEyNjg5MTQxNSksaT12KGksYSxyLG4sZVsxNF0sMTUsLTE0MTYzNTQ5MDUpLG49dihuLGksYSxyLGVbNV0sMjEsLTU3NDM0MDU1KSxyPXYocixuLGksYSxlWzEyXSw2LDE3MDA0ODU1NzEpLGE9dihhLHIsbixpLGVbM10sMTAsLTE4OTQ5ODY2MDYpLGk9dihpLGEscixuLGVbMTBdLDE1LC0xMDUxNTIzKSxuPXYobixpLGEscixlWzFdLDIxLC0yMDU0OTIyNzk5KSxyPXYocixuLGksYSxlWzhdLDYsMTg3MzMxMzM1OSksYT12KGEscixuLGksZVsxNV0sMTAsLTMwNjExNzQ0KSxpPXYoaSxhLHIsbixlWzZdLDE1LC0xNTYwMTk4MzgwKSxuPXYobixpLGEscixlWzEzXSwyMSwxMzA5MTUxNjQ5KSxyPXYocixuLGksYSxlWzRdLDYsLTE0NTUyMzA3MCksYT12KGEscixuLGksZVsxMV0sMTAsLTExMjAyMTAzNzkpLGk9dihpLGEscixuLGVbMl0sMTUsNzE4Nzg3MjU5KSxuPXYobixpLGEscixlWzldLDIxLC0zNDM0ODU1NTEpLHRbMF09UyhyLHRbMF0pLHRbMV09UyhuLHRbMV0pLHRbMl09UyhpLHRbMl0pLHRbM109UyhhLHRbM10pfWZ1bmN0aW9uIGQodCxlLHIsbixpLGEpe3JldHVybiBlPVMoUyhlLHQpLFMobixhKSksUyhlPDxpfGU+Pj4zMi1pLHIpfWZ1bmN0aW9uIHAodCxlLHIsbixpLGEsbyl7cmV0dXJuIGQoZSZyfH5lJm4sdCxlLGksYSxvKX1mdW5jdGlvbiBnKHQsZSxyLG4saSxhLG8pe3JldHVybiBkKGUmbnxyJn5uLHQsZSxpLGEsbyl9ZnVuY3Rpb24gbSh0LGUscixuLGksYSxvKXtyZXR1cm4gZChlXnJebix0LGUsaSxhLG8pfWZ1bmN0aW9uIHYodCxlLHIsbixpLGEsbyl7cmV0dXJuIGQocl4oZXx+biksdCxlLGksYSxvKX1mdW5jdGlvbiBiKHQpe3ZhciBlLHI9dC5sZW5ndGgsbj1bMTczMjU4NDE5MywtMjcxNzMzODc5LC0xNzMyNTg0MTk0LDI3MTczMzg3OF07Zm9yKGU9NjQ7ZTw9dC5sZW5ndGg7ZSs9NjQpZihuLHkodC5zdWJzdHJpbmcoZS02NCxlKSkpO3Q9dC5zdWJzdHJpbmcoZS02NCk7dmFyIGk9WzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdO2ZvcihlPTA7ZTx0Lmxlbmd0aDtlKyspaVtlPj4yXXw9dC5jaGFyQ29kZUF0KGUpPDwoZSU0PDwzKTtpZihpW2U+PjJdfD0xMjg8PChlJTQ8PDMpLGU+NTUpZm9yKGYobixpKSxlPTA7ZTwxNjtlKyspaVtlXT0wO3JldHVybiBpWzE0XT04KnIsZihuLGkpLG59ZnVuY3Rpb24geSh0KXt2YXIgZSxyPVtdO2ZvcihlPTA7ZTw2NDtlKz00KXJbZT4+Ml09dC5jaGFyQ29kZUF0KGUpKyh0LmNoYXJDb2RlQXQoZSsxKTw8OCkrKHQuY2hhckNvZGVBdChlKzIpPDwxNikrKHQuY2hhckNvZGVBdChlKzMpPDwyNCk7cmV0dXJuIHJ9Yz1yLmF0b2IuYmluZChyKSx1PXIuYnRvYS5iaW5kKHIpO3ZhciB3PSIwMTIzNDU2Nzg5YWJjZGVmIi5zcGxpdCgiIik7ZnVuY3Rpb24gTih0KXtmb3IodmFyIGU9IiIscj0wO3I8NDtyKyspZSs9d1t0Pj44KnIrNCYxNV0rd1t0Pj44KnImMTVdO3JldHVybiBlfWZ1bmN0aW9uIEwodCl7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKDI1NSZ0KT4+MCwoNjUyODAmdCk+PjgsKDE2NzExNjgwJnQpPj4xNiwoNDI3ODE5MDA4MCZ0KT4+MjQpfWZ1bmN0aW9uIEEodCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hcChMKS5qb2luKCIiKX0oYih0KSl9dmFyIHg9IjVkNDE0MDJhYmM0YjJhNzZiOTcxOWQ5MTEwMTdjNTkyIiE9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT1OKHRbZV0pO3JldHVybiB0LmpvaW4oIiIpfShiKCJoZWxsbyIpKTtmdW5jdGlvbiBTKHQsZSl7aWYoeCl7dmFyIHI9KDY1NTM1JnQpKyg2NTUzNSZlKTtyZXR1cm4odD4+MTYpKyhlPj4xNikrKHI+PjE2KTw8MTZ8NjU1MzUmcn1yZXR1cm4gdCtlJjQyOTQ5NjcyOTV9Ci8qKgogICAqIEBsaWNlbnNlCiAgICogRlBERiBpcyByZWxlYXNlZCB1bmRlciBhIHBlcm1pc3NpdmUgbGljZW5zZTogdGhlcmUgaXMgbm8gdXNhZ2UgcmVzdHJpY3Rpb24uCiAgICogWW91IG1heSBlbWJlZCBpdCBmcmVlbHkgaW4geW91ciBhcHBsaWNhdGlvbiAoY29tbWVyY2lhbCBvciBub3QpLCB3aXRoIG9yCiAgICogd2l0aG91dCBtb2RpZmljYXRpb25zLgogICAqCiAgICogUmVmZXJlbmNlOiBodHRwOi8vd3d3LmZwZGYub3JnL2VuL3NjcmlwdC9zY3JpcHQzNy5waHAKICAgKi9mdW5jdGlvbiBfKHQsZSl7dmFyIHIsbixpLGE7aWYodCE9PXIpe2Zvcih2YXIgbz0oaT10LGE9MSsoMjU2L3QubGVuZ3RoPj4wKSxuZXcgQXJyYXkoYSsxKS5qb2luKGkpKSxzPVtdLGM9MDtjPDI1NjtjKyspc1tjXT1jO3ZhciB1PTA7Zm9yKGM9MDtjPDI1NjtjKyspe3ZhciBsPXNbY107dT0odStsK28uY2hhckNvZGVBdChjKSklMjU2LHNbY109c1t1XSxzW3VdPWx9cj10LG49c31lbHNlIHM9bjt2YXIgaD1lLmxlbmd0aCxmPTAsZD0wLHA9IiI7Zm9yKGM9MDtjPGg7YysrKWQ9KGQrKGw9c1tmPShmKzEpJTI1Nl0pKSUyNTYsc1tmXT1zW2RdLHNbZF09bCxvPXNbKHNbZl0rc1tkXSklMjU2XSxwKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGUuY2hhckNvZGVBdChjKV5vKTtyZXR1cm4gcH0KLyoqCiAgICogQGxpY2Vuc2UKICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAgICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAgICogQXV0aG9yOiBPd2VuIExlb25nIChAb3dlbmwxMzEpCiAgICogRGF0ZTogMTUgT2N0IDIwMjAKICAgKiBSZWZlcmVuY2VzOgogICAqIGh0dHBzOi8vd3d3LmNzLmNtdS5lZHUvfmRzdC9BZG9iZS9HYWxsZXJ5L2Fub24yMWp1bDAxLXBkZi1lbmNyeXB0aW9uLnR4dAogICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2xpb2pzL3BkZmtpdC9ibG9iL21hc3Rlci9saWIvc2VjdXJpdHkuanMKICAgKiBodHRwOi8vd3d3LmZwZGYub3JnL2VuL3NjcmlwdC9zY3JpcHQzNy5waHAKICAgKi92YXIgUD17cHJpbnQ6NCxtb2RpZnk6OCxjb3B5OjE2LCJhbm5vdC1mb3JtcyI6MzJ9O2Z1bmN0aW9uIGsodCxlLHIsbil7dGhpcy52PTEsdGhpcy5yPTI7dmFyIGk9MTkyO3QuZm9yRWFjaCgoZnVuY3Rpb24odCl7aWYodm9pZCAwIT09UC5wZXJtKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBwZXJtaXNzaW9uOiAiK3QpO2krPVBbdF19KSksdGhpcy5wYWRkaW5nPSIowr9OXk51wopBZFwwTlbDv8O6AVxiLi5cMMK2w5BoPsKAL1xmwqnDvmRTaXoiO3ZhciBhPShlK3RoaXMucGFkZGluZykuc3Vic3RyKDAsMzIpLG89KHIrdGhpcy5wYWRkaW5nKS5zdWJzdHIoMCwzMik7dGhpcy5PPXRoaXMucHJvY2Vzc093bmVyUGFzc3dvcmQoYSxvKSx0aGlzLlA9LSgxKygyNTVeaSkpLHRoaXMuZW5jcnlwdGlvbktleT1BKGErdGhpcy5PK3RoaXMubHNiRmlyc3RXb3JkKHRoaXMuUCkrdGhpcy5oZXhUb0J5dGVzKG4pKS5zdWJzdHIoMCw1KSx0aGlzLlU9Xyh0aGlzLmVuY3J5cHRpb25LZXksdGhpcy5wYWRkaW5nKX1mdW5jdGlvbiBGKHQpe2lmKC9bXlx1MDAwMC1cdTAwZmZdLy50ZXN0KHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBQREYgTmFtZSBPYmplY3Q6ICIrdCsiLCBPbmx5IGFjY2VwdCBBU0NJSSBjaGFyYWN0ZXJzLiIpO2Zvcih2YXIgZT0iIixyPXQubGVuZ3RoLG49MDtuPHI7bisrKXt2YXIgaT10LmNoYXJDb2RlQXQobik7aWYoaTwzM3x8MzU9PT1pfHwzNz09PWl8fDQwPT09aXx8NDE9PT1pfHw0Nz09PWl8fDYwPT09aXx8NjI9PT1pfHw5MT09PWl8fDkzPT09aXx8MTIzPT09aXx8MTI1PT09aXx8aT4xMjYpZSs9IiMiKygiMCIraS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtlbHNlIGUrPXRbbl19cmV0dXJuIGV9ZnVuY3Rpb24gSSh0KXtpZigib2JqZWN0IiE9PWUodCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIENvbnRleHQgcGFzc2VkIHRvIGluaXRpYWxpemUgUHViU3ViIChqc1BERi1tb2R1bGUpIik7dmFyIG49e307dGhpcy5zdWJzY3JpYmU9ZnVuY3Rpb24odCxlLHIpe2lmKHI9cnx8ITEsInN0cmluZyIhPXR5cGVvZiB0fHwiZnVuY3Rpb24iIT10eXBlb2YgZXx8ImJvb2xlYW4iIT10eXBlb2Ygcil0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBQdWJTdWIuc3Vic2NyaWJlIChqc1BERi1tb2R1bGUpIik7bi5oYXNPd25Qcm9wZXJ0eSh0KXx8KG5bdF09e30pO3ZhciBpPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzUpO3JldHVybiBuW3RdW2ldPVtlLCEhcl0saX0sdGhpcy51bnN1YnNjcmliZT1mdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gbilpZihuW2VdW3RdKXJldHVybiBkZWxldGUgbltlXVt0XSwwPT09T2JqZWN0LmtleXMobltlXSkubGVuZ3RoJiZkZWxldGUgbltlXSwhMDtyZXR1cm4hMX0sdGhpcy5wdWJsaXNoPWZ1bmN0aW9uKGUpe2lmKG4uaGFzT3duUHJvcGVydHkoZSkpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxvPVtdO2Zvcih2YXIgcyBpbiBuW2VdKXt2YXIgYz1uW2VdW3NdO3RyeXtjWzBdLmFwcGx5KHQsYSl9Y2F0Y2godCl7ci5jb25zb2xlJiZpLmVycm9yKCJqc1BERiBQdWJTdWIgRXJyb3IiLHQubWVzc2FnZSx0KX1jWzFdJiZvLnB1c2gocyl9by5sZW5ndGgmJm8uZm9yRWFjaCh0aGlzLnVuc3Vic2NyaWJlKX19LHRoaXMuZ2V0VG9waWNzPWZ1bmN0aW9uKCl7cmV0dXJuIG59fWZ1bmN0aW9uIEModCl7aWYoISh0aGlzIGluc3RhbmNlb2YgQykpcmV0dXJuIG5ldyBDKHQpO3ZhciBlPSJvcGFjaXR5LHN0cm9rZS1vcGFjaXR5Ii5zcGxpdCgiLCIpO2Zvcih2YXIgciBpbiB0KXQuaGFzT3duUHJvcGVydHkocikmJmUuaW5kZXhPZihyKT49MCYmKHRoaXNbcl09dFtyXSk7dGhpcy5pZD0iIix0aGlzLm9iamVjdE51bWJlcj0tMX1mdW5jdGlvbiBqKHQsZSl7dGhpcy5nU3RhdGU9dCx0aGlzLm1hdHJpeD1lLHRoaXMuaWQ9IiIsdGhpcy5vYmplY3ROdW1iZXI9LTF9ZnVuY3Rpb24gTyh0LGUscixuLGkpe2lmKCEodGhpcyBpbnN0YW5jZW9mIE8pKXJldHVybiBuZXcgTyh0LGUscixuLGkpO3RoaXMudHlwZT0iYXhpYWwiPT09dD8yOjMsdGhpcy5jb29yZHM9ZSx0aGlzLmNvbG9ycz1yLGouY2FsbCh0aGlzLG4saSl9ZnVuY3Rpb24gQih0LGUscixuLGkpe2lmKCEodGhpcyBpbnN0YW5jZW9mIEIpKXJldHVybiBuZXcgQih0LGUscixuLGkpO3RoaXMuYm91bmRpbmdCb3g9dCx0aGlzLnhTdGVwPWUsdGhpcy55U3RlcD1yLHRoaXMuc3RyZWFtPSIiLHRoaXMuY2xvbmVJbmRleD0wLGouY2FsbCh0aGlzLG4saSl9ZnVuY3Rpb24gTSh0KXt2YXIgbixhPSJzdHJpbmciPT10eXBlb2YgYXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXToicCIsbz1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sYz1hcmd1bWVudHNbM10sZj1bXSxkPTEscD0xNixnPSJTIixtPW51bGw7Im9iamVjdCI9PT1lKHQ9dHx8e30pJiYoYT10Lm9yaWVudGF0aW9uLG89dC51bml0fHxvLHM9dC5mb3JtYXR8fHMsYz10LmNvbXByZXNzfHx0LmNvbXByZXNzUGRmfHxjLG51bGwhPT0obT10LmVuY3J5cHRpb258fG51bGwpJiYobS51c2VyUGFzc3dvcmQ9bS51c2VyUGFzc3dvcmR8fCIiLG0ub3duZXJQYXNzd29yZD1tLm93bmVyUGFzc3dvcmR8fCIiLG0udXNlclBlcm1pc3Npb25zPW0udXNlclBlcm1pc3Npb25zfHxbXSksZD0ibnVtYmVyIj09dHlwZW9mIHQudXNlclVuaXQ/TWF0aC5hYnModC51c2VyVW5pdCk6MSx2b2lkIDAhPT10LnByZWNpc2lvbiYmKG49dC5wcmVjaXNpb24pLHZvaWQgMCE9PXQuZmxvYXRQcmVjaXNpb24mJihwPXQuZmxvYXRQcmVjaXNpb24pLGc9dC5kZWZhdWx0UGF0aE9wZXJhdGlvbnx8IlMiKSxmPXQuZmlsdGVyc3x8KCEwPT09Yz9bIkZsYXRlRW5jb2RlIl06Ziksbz1vfHwibW0iLGE9KCIiKyhhfHwiUCIpKS50b0xvd2VyQ2FzZSgpO3ZhciB2PXQucHV0T25seVVzZWRGb250c3x8ITEsYj17fSx5PXtpbnRlcm5hbDp7fSxfX3ByaXZhdGVfXzp7fX07eS5fX3ByaXZhdGVfXy5QdWJTdWI9STt2YXIgdz0iMS4zIixOPXkuX19wcml2YXRlX18uZ2V0UGRmVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB3fTt5Ll9fcHJpdmF0ZV9fLnNldFBkZlZlcnNpb249ZnVuY3Rpb24odCl7dz10fTt2YXIgTD17YTA6WzIzODMuOTQsMzM3MC4zOV0sYTE6WzE2ODMuNzgsMjM4My45NF0sYTI6WzExOTAuNTUsMTY4My43OF0sYTM6Wzg0MS44OSwxMTkwLjU1XSxhNDpbNTk1LjI4LDg0MS44OV0sYTU6WzQxOS41Myw1OTUuMjhdLGE2OlsyOTcuNjQsNDE5LjUzXSxhNzpbMjA5Ljc2LDI5Ny42NF0sYTg6WzE0Ny40LDIwOS43Nl0sYTk6WzEwNC44OCwxNDcuNF0sYTEwOls3My43LDEwNC44OF0sYjA6WzI4MzQuNjUsNDAwOC4xOV0sYjE6WzIwMDQuMDksMjgzNC42NV0sYjI6WzE0MTcuMzIsMjAwNC4wOV0sYjM6WzEwMDAuNjMsMTQxNy4zMl0sYjQ6WzcwOC42NiwxMDAwLjYzXSxiNTpbNDk4LjksNzA4LjY2XSxiNjpbMzU0LjMzLDQ5OC45XSxiNzpbMjQ5LjQ1LDM1NC4zM10sYjg6WzE3NS43NSwyNDkuNDVdLGI5OlsxMjQuNzIsMTc1Ljc1XSxiMTA6Wzg3Ljg3LDEyNC43Ml0sYzA6WzI1OTkuMzcsMzY3Ni41NF0sYzE6WzE4MzYuODUsMjU5OS4zN10sYzI6WzEyOTguMjcsMTgzNi44NV0sYzM6WzkxOC40MywxMjk4LjI3XSxjNDpbNjQ5LjEzLDkxOC40M10sYzU6WzQ1OS4yMSw2NDkuMTNdLGM2OlszMjMuMTUsNDU5LjIxXSxjNzpbMjI5LjYxLDMyMy4xNV0sYzg6WzE2MS41NywyMjkuNjFdLGM5OlsxMTMuMzksMTYxLjU3XSxjMTA6Wzc5LjM3LDExMy4zOV0sZGw6WzMxMS44MSw2MjMuNjJdLGxldHRlcjpbNjEyLDc5Ml0sImdvdmVybm1lbnQtbGV0dGVyIjpbNTc2LDc1Nl0sbGVnYWw6WzYxMiwxMDA4XSwianVuaW9yLWxlZ2FsIjpbNTc2LDM2MF0sbGVkZ2VyOlsxMjI0LDc5Ml0sdGFibG9pZDpbNzkyLDEyMjRdLCJjcmVkaXQtY2FyZCI6WzE1MywyNDNdfTt5Ll9fcHJpdmF0ZV9fLmdldFBhZ2VGb3JtYXRzPWZ1bmN0aW9uKCl7cmV0dXJuIEx9O3ZhciBBPXkuX19wcml2YXRlX18uZ2V0UGFnZUZvcm1hdD1mdW5jdGlvbih0KXtyZXR1cm4gTFt0XX07cz1zfHwiYTQiO3ZhciB4PXtDT01QQVQ6ImNvbXBhdCIsQURWQU5DRUQ6ImFkdmFuY2VkIn0sUz14LkNPTVBBVDtmdW5jdGlvbiBfKCl7dGhpcy5zYXZlR3JhcGhpY3NTdGF0ZSgpLGh0KG5ldyBWdChfdCwwLDAsLV90LDAsUnIoKSpfdCkudG9TdHJpbmcoKSsiIGNtIiksdGhpcy5zZXRGb250U2l6ZSh0aGlzLmdldEZvbnRTaXplKCkvX3QpLGc9Im4iLFM9eC5BRFZBTkNFRH1mdW5jdGlvbiBQKCl7dGhpcy5yZXN0b3JlR3JhcGhpY3NTdGF0ZSgpLGc9IlMiLFM9eC5DT01QQVR9dmFyIGo9eS5fX3ByaXZhdGVfXy5jb21iaW5lRm9udFN0eWxlQW5kRm9udFdlaWdodD1mdW5jdGlvbih0LGUpe2lmKCJib2xkIj09dCYmIm5vcm1hbCI9PWV8fCJib2xkIj09dCYmNDAwPT1lfHwibm9ybWFsIj09dCYmIml0YWxpYyI9PWV8fCJib2xkIj09dCYmIml0YWxpYyI9PWUpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIENvbWJpbmF0aW9uIG9mIGZvbnR3ZWlnaHQgYW5kIGZvbnRzdHlsZSIpO3JldHVybiBlJiYodD00MDA9PWV8fCJub3JtYWwiPT09ZT8iaXRhbGljIj09PXQ/Iml0YWxpYyI6Im5vcm1hbCI6NzAwIT1lJiYiYm9sZCIhPT1lfHwibm9ybWFsIiE9PXQ/KDcwMD09ZT8iYm9sZCI6ZSkrIiIrdDoiYm9sZCIpLHR9O3kuYWR2YW5jZWRBUEk9ZnVuY3Rpb24odCl7dmFyIGU9Uz09PXguQ09NUEFUO3JldHVybiBlJiZfLmNhbGwodGhpcyksImZ1bmN0aW9uIiE9dHlwZW9mIHR8fCh0KHRoaXMpLGUmJlAuY2FsbCh0aGlzKSksdGhpc30seS5jb21wYXRBUEk9ZnVuY3Rpb24odCl7dmFyIGU9Uz09PXguQURWQU5DRUQ7cmV0dXJuIGUmJlAuY2FsbCh0aGlzKSwiZnVuY3Rpb24iIT10eXBlb2YgdHx8KHQodGhpcyksZSYmXy5jYWxsKHRoaXMpKSx0aGlzfSx5LmlzQWR2YW5jZWRBUEk9ZnVuY3Rpb24oKXtyZXR1cm4gUz09PXguQURWQU5DRUR9O3ZhciBFLHE9ZnVuY3Rpb24odCl7aWYoUyE9PXguQURWQU5DRUQpdGhyb3cgbmV3IEVycm9yKHQrIiBpcyBvbmx5IGF2YWlsYWJsZSBpbiAnYWR2YW5jZWQnIEFQSSBtb2RlLiBZb3UgbmVlZCB0byBjYWxsIGFkdmFuY2VkQVBJKCkgZmlyc3QuIil9LEQ9eS5yb3VuZFRvUHJlY2lzaW9uPXkuX19wcml2YXRlX18ucm91bmRUb1ByZWNpc2lvbj1mdW5jdGlvbih0LGUpe3ZhciByPW58fGU7aWYoaXNOYU4odCl8fGlzTmFOKHIpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYucm91bmRUb1ByZWNpc2lvbiIpO3JldHVybiB0LnRvRml4ZWQocikucmVwbGFjZSgvMCskLywiIil9O0U9eS5ocGY9eS5fX3ByaXZhdGVfXy5ocGY9Im51bWJlciI9PXR5cGVvZiBwP2Z1bmN0aW9uKHQpe2lmKGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuaHBmIik7cmV0dXJuIEQodCxwKX06InNtYXJ0Ij09PXA/ZnVuY3Rpb24odCl7aWYoaXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5ocGYiKTtyZXR1cm4gRCh0LHQ+LTEmJnQ8MT8xNjo1KX06ZnVuY3Rpb24odCl7aWYoaXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5ocGYiKTtyZXR1cm4gRCh0LDE2KX07dmFyIFI9eS5mMj15Ll9fcHJpdmF0ZV9fLmYyPWZ1bmN0aW9uKHQpe2lmKGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuZjIiKTtyZXR1cm4gRCh0LDIpfSxUPXkuX19wcml2YXRlX18uZjM9ZnVuY3Rpb24odCl7aWYoaXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5mMyIpO3JldHVybiBEKHQsMyl9LFU9eS5zY2FsZT15Ll9fcHJpdmF0ZV9fLnNjYWxlPWZ1bmN0aW9uKHQpe2lmKGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuc2NhbGUiKTtyZXR1cm4gUz09PXguQ09NUEFUP3QqX3Q6Uz09PXguQURWQU5DRUQ/dDp2b2lkIDB9LHo9ZnVuY3Rpb24odCl7cmV0dXJuIFM9PT14LkNPTVBBVD9ScigpLXQ6Uz09PXguQURWQU5DRUQ/dDp2b2lkIDB9LEg9ZnVuY3Rpb24odCl7cmV0dXJuIFUoeih0KSl9O3kuX19wcml2YXRlX18uc2V0UHJlY2lzaW9uPXkuc2V0UHJlY2lzaW9uPWZ1bmN0aW9uKHQpeyJudW1iZXIiPT10eXBlb2YgcGFyc2VJbnQodCwxMCkmJihuPXBhcnNlSW50KHQsMTApKX07dmFyIFcsVj0iMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLEc9eS5fX3ByaXZhdGVfXy5nZXRGaWxlSWQ9ZnVuY3Rpb24oKXtyZXR1cm4gVn0sWT15Ll9fcHJpdmF0ZV9fLnNldEZpbGVJZD1mdW5jdGlvbih0KXtyZXR1cm4gVj12b2lkIDAhPT10JiYvXlthLWZBLUYwLTldezMyfSQvLnRlc3QodCk/dC50b1VwcGVyQ2FzZSgpOlYuc3BsaXQoIiIpLm1hcCgoZnVuY3Rpb24oKXtyZXR1cm4iQUJDREVGMDEyMzQ1Njc4OSIuY2hhckF0KE1hdGguZmxvb3IoMTYqTWF0aC5yYW5kb20oKSkpfSkpLmpvaW4oIiIpLG51bGwhPT1tJiYoWWU9bmV3IGsobS51c2VyUGVybWlzc2lvbnMsbS51c2VyUGFzc3dvcmQsbS5vd25lclBhc3N3b3JkLFYpKSxWfTt5LnNldEZpbGVJZD1mdW5jdGlvbih0KXtyZXR1cm4gWSh0KSx0aGlzfSx5LmdldEZpbGVJZD1mdW5jdGlvbigpe3JldHVybiBHKCl9O3ZhciBKPXkuX19wcml2YXRlX18uY29udmVydERhdGVUb1BERkRhdGU9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRUaW1lem9uZU9mZnNldCgpLHI9ZTwwPyIrIjoiLSIsbj1NYXRoLmZsb29yKE1hdGguYWJzKGUvNjApKSxpPU1hdGguYWJzKGUlNjApLGE9W3IsUShuKSwiJyIsUShpKSwiJyJdLmpvaW4oIiIpO3JldHVyblsiRDoiLHQuZ2V0RnVsbFllYXIoKSxRKHQuZ2V0TW9udGgoKSsxKSxRKHQuZ2V0RGF0ZSgpKSxRKHQuZ2V0SG91cnMoKSksUSh0LmdldE1pbnV0ZXMoKSksUSh0LmdldFNlY29uZHMoKSksYV0uam9pbigiIil9LFg9eS5fX3ByaXZhdGVfXy5jb252ZXJ0UERGRGF0ZVRvRGF0ZT1mdW5jdGlvbih0KXt2YXIgZT1wYXJzZUludCh0LnN1YnN0cigyLDQpLDEwKSxyPXBhcnNlSW50KHQuc3Vic3RyKDYsMiksMTApLTEsbj1wYXJzZUludCh0LnN1YnN0cig4LDIpLDEwKSxpPXBhcnNlSW50KHQuc3Vic3RyKDEwLDIpLDEwKSxhPXBhcnNlSW50KHQuc3Vic3RyKDEyLDIpLDEwKSxvPXBhcnNlSW50KHQuc3Vic3RyKDE0LDIpLDEwKTtyZXR1cm4gbmV3IERhdGUoZSxyLG4saSxhLG8sMCl9LEs9eS5fX3ByaXZhdGVfXy5zZXRDcmVhdGlvbkRhdGU9ZnVuY3Rpb24odCl7dmFyIGU7aWYodm9pZCAwPT09dCYmKHQ9bmV3IERhdGUpLHQgaW5zdGFuY2VvZiBEYXRlKWU9Sih0KTtlbHNle2lmKCEvXkQ6KDIwWzAtMl1bMC05XXwyMDNbMC03XXwxOVs3LTldWzAtOV0pKDBbMC05XXwxWzAtMl0pKFswLTJdWzAtOV18M1swLTFdKSgwWzAtOV18MVswLTldfDJbMC0zXSkoMFswLTldfFsxLTVdWzAtOV0pKDBbMC05XXxbMS01XVswLTldKShcKzBbMC05XXxcKzFbMC00XXwtMFswLTldfC0xWzAtMV0pJygwWzAtOV18WzEtNV1bMC05XSknPyQvLnRlc3QodCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5zZXRDcmVhdGlvbkRhdGUiKTtlPXR9cmV0dXJuIFc9ZX0sWj15Ll9fcHJpdmF0ZV9fLmdldENyZWF0aW9uRGF0ZT1mdW5jdGlvbih0KXt2YXIgZT1XO3JldHVybiJqc0RhdGUiPT09dCYmKGU9WChXKSksZX07eS5zZXRDcmVhdGlvbkRhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIEsodCksdGhpc30seS5nZXRDcmVhdGlvbkRhdGU9ZnVuY3Rpb24odCl7cmV0dXJuIFoodCl9O3ZhciAkLFE9eS5fX3ByaXZhdGVfXy5wYWRkMj1mdW5jdGlvbih0KXtyZXR1cm4oIjAiK3BhcnNlSW50KHQpKS5zbGljZSgtMil9LHR0PXkuX19wcml2YXRlX18ucGFkZDJIZXg9ZnVuY3Rpb24odCl7cmV0dXJuKCIwMCIrKHQ9dC50b1N0cmluZygpKSkuc3Vic3RyKHQubGVuZ3RoKX0sZXQ9MCxydD1bXSxudD1bXSxpdD0wLGF0PVtdLG90PVtdLHN0PSExLGN0PW50LHV0PWZ1bmN0aW9uKCl7ZXQ9MCxpdD0wLG50PVtdLHJ0PVtdLGF0PVtdLFF0PUt0KCksdGU9S3QoKX07eS5fX3ByaXZhdGVfXy5zZXRDdXN0b21PdXRwdXREZXN0aW5hdGlvbj1mdW5jdGlvbih0KXtzdD0hMCxjdD10fTt2YXIgbHQ9ZnVuY3Rpb24odCl7c3R8fChjdD10KX07eS5fX3ByaXZhdGVfXy5yZXNldEN1c3RvbU91dHB1dERlc3RpbmF0aW9uPWZ1bmN0aW9uKCl7c3Q9ITEsY3Q9bnR9O3ZhciBodD15Ll9fcHJpdmF0ZV9fLm91dD1mdW5jdGlvbih0KXtyZXR1cm4gdD10LnRvU3RyaW5nKCksaXQrPXQubGVuZ3RoKzEsY3QucHVzaCh0KSxjdH0sZnQ9eS5fX3ByaXZhdGVfXy53cml0ZT1mdW5jdGlvbih0KXtyZXR1cm4gaHQoMT09PWFyZ3VtZW50cy5sZW5ndGg/dC50b1N0cmluZygpOkFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoYXJndW1lbnRzLCIgIikpfSxkdD15Ll9fcHJpdmF0ZV9fLmdldEFycmF5QnVmZmVyPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxyPW5ldyBBcnJheUJ1ZmZlcihlKSxuPW5ldyBVaW50OEFycmF5KHIpO2UtLTspbltlXT10LmNoYXJDb2RlQXQoZSk7cmV0dXJuIHJ9LHB0PVtbIkhlbHZldGljYSIsImhlbHZldGljYSIsIm5vcm1hbCIsIldpbkFuc2lFbmNvZGluZyJdLFsiSGVsdmV0aWNhLUJvbGQiLCJoZWx2ZXRpY2EiLCJib2xkIiwiV2luQW5zaUVuY29kaW5nIl0sWyJIZWx2ZXRpY2EtT2JsaXF1ZSIsImhlbHZldGljYSIsIml0YWxpYyIsIldpbkFuc2lFbmNvZGluZyJdLFsiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIiwiaGVsdmV0aWNhIiwiYm9sZGl0YWxpYyIsIldpbkFuc2lFbmNvZGluZyJdLFsiQ291cmllciIsImNvdXJpZXIiLCJub3JtYWwiLCJXaW5BbnNpRW5jb2RpbmciXSxbIkNvdXJpZXItQm9sZCIsImNvdXJpZXIiLCJib2xkIiwiV2luQW5zaUVuY29kaW5nIl0sWyJDb3VyaWVyLU9ibGlxdWUiLCJjb3VyaWVyIiwiaXRhbGljIiwiV2luQW5zaUVuY29kaW5nIl0sWyJDb3VyaWVyLUJvbGRPYmxpcXVlIiwiY291cmllciIsImJvbGRpdGFsaWMiLCJXaW5BbnNpRW5jb2RpbmciXSxbIlRpbWVzLVJvbWFuIiwidGltZXMiLCJub3JtYWwiLCJXaW5BbnNpRW5jb2RpbmciXSxbIlRpbWVzLUJvbGQiLCJ0aW1lcyIsImJvbGQiLCJXaW5BbnNpRW5jb2RpbmciXSxbIlRpbWVzLUl0YWxpYyIsInRpbWVzIiwiaXRhbGljIiwiV2luQW5zaUVuY29kaW5nIl0sWyJUaW1lcy1Cb2xkSXRhbGljIiwidGltZXMiLCJib2xkaXRhbGljIiwiV2luQW5zaUVuY29kaW5nIl0sWyJaYXBmRGluZ2JhdHMiLCJ6YXBmZGluZ2JhdHMiLCJub3JtYWwiLG51bGxdLFsiU3ltYm9sIiwic3ltYm9sIiwibm9ybWFsIixudWxsXV07eS5fX3ByaXZhdGVfXy5nZXRTdGFuZGFyZEZvbnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHB0fTt2YXIgZ3Q9dC5mb250U2l6ZXx8MTY7eS5fX3ByaXZhdGVfXy5zZXRGb250U2l6ZT15LnNldEZvbnRTaXplPWZ1bmN0aW9uKHQpe3JldHVybiBndD1TPT09eC5BRFZBTkNFRD90L190OnQsdGhpc307dmFyIG10LHZ0PXkuX19wcml2YXRlX18uZ2V0Rm9udFNpemU9eS5nZXRGb250U2l6ZT1mdW5jdGlvbigpe3JldHVybiBTPT09eC5DT01QQVQ/Z3Q6Z3QqX3R9LGJ0PXQuUjJMfHwhMTt5Ll9fcHJpdmF0ZV9fLnNldFIyTD15LnNldFIyTD1mdW5jdGlvbih0KXtyZXR1cm4gYnQ9dCx0aGlzfSx5Ll9fcHJpdmF0ZV9fLmdldFIyTD15LmdldFIyTD1mdW5jdGlvbigpe3JldHVybiBidH07dmFyIHl0LHd0PXkuX19wcml2YXRlX18uc2V0Wm9vbU1vZGU9ZnVuY3Rpb24odCl7dmFyIGU9W3ZvaWQgMCxudWxsLCJmdWxsd2lkdGgiLCJmdWxsaGVpZ2h0IiwiZnVsbHBhZ2UiLCJvcmlnaW5hbCJdO2lmKC9eKD86XGQrXC5cZCp8XGQqXC5cZCt8XGQrKSUkLy50ZXN0KHQpKW10PXQ7ZWxzZSBpZihpc05hTih0KSl7aWYoLTE9PT1lLmluZGV4T2YodCkpdGhyb3cgbmV3IEVycm9yKCd6b29tIG11c3QgYmUgSW50ZWdlciAoZS5nLiAyKSwgYSBwZXJjZW50YWdlIFZhbHVlIChlLmcuIDMwMCUpIG9yIGZ1bGx3aWR0aCwgZnVsbGhlaWdodCwgZnVsbHBhZ2UsIG9yaWdpbmFsLiAiJyt0KyciIGlzIG5vdCByZWNvZ25pemVkLicpO210PXR9ZWxzZSBtdD1wYXJzZUludCh0LDEwKX07eS5fX3ByaXZhdGVfXy5nZXRab29tTW9kZT1mdW5jdGlvbigpe3JldHVybiBtdH07dmFyIE50LEx0PXkuX19wcml2YXRlX18uc2V0UGFnZU1vZGU9ZnVuY3Rpb24odCl7aWYoLTE9PVt2b2lkIDAsbnVsbCwiVXNlTm9uZSIsIlVzZU91dGxpbmVzIiwiVXNlVGh1bWJzIiwiRnVsbFNjcmVlbiJdLmluZGV4T2YodCkpdGhyb3cgbmV3IEVycm9yKCdQYWdlIG1vZGUgbXVzdCBiZSBvbmUgb2YgVXNlTm9uZSwgVXNlT3V0bGluZXMsIFVzZVRodW1icywgb3IgRnVsbFNjcmVlbi4gIicrdCsnIiBpcyBub3QgcmVjb2duaXplZC4nKTt5dD10fTt5Ll9fcHJpdmF0ZV9fLmdldFBhZ2VNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHl0fTt2YXIgQXQ9eS5fX3ByaXZhdGVfXy5zZXRMYXlvdXRNb2RlPWZ1bmN0aW9uKHQpe2lmKC0xPT1bdm9pZCAwLG51bGwsImNvbnRpbnVvdXMiLCJzaW5nbGUiLCJ0d29sZWZ0IiwidHdvcmlnaHQiLCJ0d28iXS5pbmRleE9mKHQpKXRocm93IG5ldyBFcnJvcignTGF5b3V0IG1vZGUgbXVzdCBiZSBvbmUgb2YgY29udGludW91cywgc2luZ2xlLCB0d29sZWZ0LCB0d29yaWdodC4gIicrdCsnIiBpcyBub3QgcmVjb2duaXplZC4nKTtOdD10fTt5Ll9fcHJpdmF0ZV9fLmdldExheW91dE1vZGU9ZnVuY3Rpb24oKXtyZXR1cm4gTnR9LHkuX19wcml2YXRlX18uc2V0RGlzcGxheU1vZGU9eS5zZXREaXNwbGF5TW9kZT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHd0KHQpLEF0KGUpLEx0KHIpLHRoaXN9O3ZhciB4dD17dGl0bGU6IiIsc3ViamVjdDoiIixhdXRob3I6IiIsa2V5d29yZHM6IiIsY3JlYXRvcjoiIn07eS5fX3ByaXZhdGVfXy5nZXREb2N1bWVudFByb3BlcnR5PWZ1bmN0aW9uKHQpe2lmKC0xPT09T2JqZWN0LmtleXMoeHQpLmluZGV4T2YodCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5nZXREb2N1bWVudFByb3BlcnR5Iik7cmV0dXJuIHh0W3RdfSx5Ll9fcHJpdmF0ZV9fLmdldERvY3VtZW50UHJvcGVydGllcz1mdW5jdGlvbigpe3JldHVybiB4dH0seS5fX3ByaXZhdGVfXy5zZXREb2N1bWVudFByb3BlcnRpZXM9eS5zZXRQcm9wZXJ0aWVzPXkuc2V0RG9jdW1lbnRQcm9wZXJ0aWVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB4dCl4dC5oYXNPd25Qcm9wZXJ0eShlKSYmdFtlXSYmKHh0W2VdPXRbZV0pO3JldHVybiB0aGlzfSx5Ll9fcHJpdmF0ZV9fLnNldERvY3VtZW50UHJvcGVydHk9ZnVuY3Rpb24odCxlKXtpZigtMT09PU9iamVjdC5rZXlzKHh0KS5pbmRleE9mKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnNldERvY3VtZW50UHJvcGVydHkiKTtyZXR1cm4geHRbdF09ZX07dmFyIFN0LF90LFB0LGt0LEZ0LEl0PXt9LEN0PXt9LGp0PVtdLE90PXt9LEJ0PXt9LE10PXt9LEV0PXt9LHF0PW51bGwsRHQ9MCxSdD1bXSxUdD1uZXcgSSh5KSxVdD10LmhvdGZpeGVzfHxbXSx6dD17fSxIdD17fSxXdD1bXSxWdD1mdW5jdGlvbiB0KGUscixuLGksYSxvKXtpZighKHRoaXMgaW5zdGFuY2VvZiB0KSlyZXR1cm4gbmV3IHQoZSxyLG4saSxhLG8pO2lzTmFOKGUpJiYoZT0xKSxpc05hTihyKSYmKHI9MCksaXNOYU4obikmJihuPTApLGlzTmFOKGkpJiYoaT0xKSxpc05hTihhKSYmKGE9MCksaXNOYU4obykmJihvPTApLHRoaXMuX21hdHJpeD1bZSxyLG4saSxhLG9dfTtPYmplY3QuZGVmaW5lUHJvcGVydHkoVnQucHJvdG90eXBlLCJzeCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXhbMF19LHNldDpmdW5jdGlvbih0KXt0aGlzLl9tYXRyaXhbMF09dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVnQucHJvdG90eXBlLCJzaHkiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzFdfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fbWF0cml4WzFdPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LnByb3RvdHlwZSwic2h4Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFsyXX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21hdHJpeFsyXT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdC5wcm90b3R5cGUsInN5Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFszXX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21hdHJpeFszXT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdC5wcm90b3R5cGUsInR4Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFs0XX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21hdHJpeFs0XT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdC5wcm90b3R5cGUsInR5Iix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFs1XX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21hdHJpeFs1XT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdC5wcm90b3R5cGUsImEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzBdfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fbWF0cml4WzBdPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LnByb3RvdHlwZSwiYiIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXhbMV19LHNldDpmdW5jdGlvbih0KXt0aGlzLl9tYXRyaXhbMV09dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVnQucHJvdG90eXBlLCJjIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFsyXX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21hdHJpeFsyXT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdC5wcm90b3R5cGUsImQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbWF0cml4WzNdfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fbWF0cml4WzNdPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LnByb3RvdHlwZSwiZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9tYXRyaXhbNF19LHNldDpmdW5jdGlvbih0KXt0aGlzLl9tYXRyaXhbNF09dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoVnQucHJvdG90eXBlLCJmIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX21hdHJpeFs1XX0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuX21hdHJpeFs1XT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdC5wcm90b3R5cGUsInJvdGF0aW9uIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5zaHgsdGhpcy5zeCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LnByb3RvdHlwZSwic2NhbGVYIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVjb21wb3NlKCkuc2NhbGUuc3h9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LnByb3RvdHlwZSwic2NhbGVZIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVjb21wb3NlKCkuc2NhbGUuc3l9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ0LnByb3RvdHlwZSwiaXNJZGVudGl0eSIse2dldDpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5zeCYmKDA9PT10aGlzLnNoeSYmKDA9PT10aGlzLnNoeCYmKDE9PT10aGlzLnN5JiYoMD09PXRoaXMudHgmJjA9PT10aGlzLnR5KSkpKX19KSxWdC5wcm90b3R5cGUuam9pbj1mdW5jdGlvbih0KXtyZXR1cm5bdGhpcy5zeCx0aGlzLnNoeSx0aGlzLnNoeCx0aGlzLnN5LHRoaXMudHgsdGhpcy50eV0ubWFwKEUpLmpvaW4odCl9LFZ0LnByb3RvdHlwZS5tdWx0aXBseT1mdW5jdGlvbih0KXt2YXIgZT10LnN4KnRoaXMuc3grdC5zaHkqdGhpcy5zaHgscj10LnN4KnRoaXMuc2h5K3Quc2h5KnRoaXMuc3ksbj10LnNoeCp0aGlzLnN4K3Quc3kqdGhpcy5zaHgsaT10LnNoeCp0aGlzLnNoeSt0LnN5KnRoaXMuc3ksYT10LnR4KnRoaXMuc3grdC50eSp0aGlzLnNoeCt0aGlzLnR4LG89dC50eCp0aGlzLnNoeSt0LnR5KnRoaXMuc3krdGhpcy50eTtyZXR1cm4gbmV3IFZ0KGUscixuLGksYSxvKX0sVnQucHJvdG90eXBlLmRlY29tcG9zZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuc3gsZT10aGlzLnNoeSxyPXRoaXMuc2h4LG49dGhpcy5zeSxpPXRoaXMudHgsYT10aGlzLnR5LG89TWF0aC5zcXJ0KHQqdCtlKmUpLHM9KHQvPW8pKnIrKGUvPW8pKm47ci09dCpzLG4tPWUqczt2YXIgYz1NYXRoLnNxcnQocipyK24qbik7cmV0dXJuIHMvPWMsdCoobi89Yyk8ZSooci89YykmJih0PS10LGU9LWUscz0tcyxvPS1vKSx7c2NhbGU6bmV3IFZ0KG8sMCwwLGMsMCwwKSx0cmFuc2xhdGU6bmV3IFZ0KDEsMCwwLDEsaSxhKSxyb3RhdGU6bmV3IFZ0KHQsZSwtZSx0LDAsMCksc2tldzpuZXcgVnQoMSwwLHMsMSwwLDApfX0sVnQucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmpvaW4oIiAiKX0sVnQucHJvdG90eXBlLmludmVyc2VkPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zeCxlPXRoaXMuc2h5LHI9dGhpcy5zaHgsbj10aGlzLnN5LGk9dGhpcy50eCxhPXRoaXMudHksbz0xLyh0Km4tZSpyKSxzPW4qbyxjPS1lKm8sdT0tcipvLGw9dCpvO3JldHVybiBuZXcgVnQocyxjLHUsbCwtcyppLXUqYSwtYyppLWwqYSl9LFZ0LnByb3RvdHlwZS5hcHBseVRvUG9pbnQ9ZnVuY3Rpb24odCl7dmFyIGU9dC54KnRoaXMuc3grdC55KnRoaXMuc2h4K3RoaXMudHgscj10LngqdGhpcy5zaHkrdC55KnRoaXMuc3krdGhpcy50eTtyZXR1cm4gbmV3IENyKGUscil9LFZ0LnByb3RvdHlwZS5hcHBseVRvUmVjdGFuZ2xlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYXBwbHlUb1BvaW50KHQpLHI9dGhpcy5hcHBseVRvUG9pbnQobmV3IENyKHQueCt0LncsdC55K3QuaCkpO3JldHVybiBuZXcganIoZS54LGUueSxyLngtZS54LHIueS1lLnkpfSxWdC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN4LGU9dGhpcy5zaHkscj10aGlzLnNoeCxuPXRoaXMuc3ksaT10aGlzLnR4LGE9dGhpcy50eTtyZXR1cm4gbmV3IFZ0KHQsZSxyLG4saSxhKX0seS5NYXRyaXg9VnQ7dmFyIEd0PXkubWF0cml4TXVsdD1mdW5jdGlvbih0LGUpe3JldHVybiBlLm11bHRpcGx5KHQpfSxZdD1uZXcgVnQoMSwwLDAsMSwwLDApO3kudW5pdE1hdHJpeD15LmlkZW50aXR5TWF0cml4PVl0O3ZhciBKdD1mdW5jdGlvbih0LGUpe2lmKCFCdFt0XSl7dmFyIHI9KGUgaW5zdGFuY2VvZiBPPyJTaCI6IlAiKSsoT2JqZWN0LmtleXMoT3QpLmxlbmd0aCsxKS50b1N0cmluZygxMCk7ZS5pZD1yLEJ0W3RdPXIsT3Rbcl09ZSxUdC5wdWJsaXNoKCJhZGRQYXR0ZXJuIixlKX19O3kuU2hhZGluZ1BhdHRlcm49Tyx5LlRpbGluZ1BhdHRlcm49Qix5LmFkZFNoYWRpbmdQYXR0ZXJuPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHEoImFkZFNoYWRpbmdQYXR0ZXJuKCkiKSxKdCh0LGUpLHRoaXN9LHkuYmVnaW5UaWxpbmdQYXR0ZXJuPWZ1bmN0aW9uKHQpe3EoImJlZ2luVGlsaW5nUGF0dGVybigpIiksQnIodC5ib3VuZGluZ0JveFswXSx0LmJvdW5kaW5nQm94WzFdLHQuYm91bmRpbmdCb3hbMl0tdC5ib3VuZGluZ0JveFswXSx0LmJvdW5kaW5nQm94WzNdLXQuYm91bmRpbmdCb3hbMV0sdC5tYXRyaXgpfSx5LmVuZFRpbGluZ1BhdHRlcm49ZnVuY3Rpb24odCxlKXtxKCJlbmRUaWxpbmdQYXR0ZXJuKCkiKSxlLnN0cmVhbT1vdFskXS5qb2luKCJcbiIpLEp0KHQsZSksVHQucHVibGlzaCgiZW5kVGlsaW5nUGF0dGVybiIsZSksV3QucG9wKCkucmVzdG9yZSgpfTt2YXIgWHQ9eS5fX3ByaXZhdGVfXy5uZXdPYmplY3Q9ZnVuY3Rpb24oKXt2YXIgdD1LdCgpO3JldHVybiBadCh0LCEwKSx0fSxLdD15Ll9fcHJpdmF0ZV9fLm5ld09iamVjdERlZmVycmVkPWZ1bmN0aW9uKCl7cmV0dXJuIGV0KysscnRbZXRdPWZ1bmN0aW9uKCl7cmV0dXJuIGl0fSxldH0sWnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT0iYm9vbGVhbiI9PXR5cGVvZiBlJiZlLHJ0W3RdPWl0LGUmJmh0KHQrIiAwIG9iaiIpLHR9LCR0PXkuX19wcml2YXRlX18ubmV3QWRkaXRpb25hbE9iamVjdD1mdW5jdGlvbigpe3ZhciB0PXtvYmpJZDpLdCgpLGNvbnRlbnQ6IiJ9O3JldHVybiBhdC5wdXNoKHQpLHR9LFF0PUt0KCksdGU9S3QoKSxlZT15Ll9fcHJpdmF0ZV9fLmRlY29kZUNvbG9yU3RyaW5nPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3BsaXQoIiAiKTtpZigyIT09ZS5sZW5ndGh8fCJnIiE9PWVbMV0mJiJHIiE9PWVbMV0pe2lmKDU9PT1lLmxlbmd0aCYmKCJrIj09PWVbNF18fCJLIj09PWVbNF0pKXtlPVsoMS1lWzBdKSooMS1lWzNdKSwoMS1lWzFdKSooMS1lWzNdKSwoMS1lWzJdKSooMS1lWzNdKSwiciJdfX1lbHNle3ZhciByPXBhcnNlRmxvYXQoZVswXSk7ZT1bcixyLHIsInIiXX1mb3IodmFyIG49IiMiLGk9MDtpPDM7aSsrKW4rPSgiMCIrTWF0aC5mbG9vcigyNTUqcGFyc2VGbG9hdChlW2ldKSkudG9TdHJpbmcoMTYpKS5zbGljZSgtMik7cmV0dXJuIG59LHJlPXkuX19wcml2YXRlX18uZW5jb2RlQ29sb3JTdHJpbmc9ZnVuY3Rpb24odCl7dmFyIHI7InN0cmluZyI9PXR5cGVvZiB0JiYodD17Y2gxOnR9KTt2YXIgbj10LmNoMSxpPXQuY2gyLGE9dC5jaDMsbz10LmNoNCxzPSJkcmF3Ij09PXQucGRmQ29sb3JUeXBlP1siRyIsIlJHIiwiSyJdOlsiZyIsInJnIiwiayJdO2lmKCJzdHJpbmciPT10eXBlb2YgbiYmIiMiIT09bi5jaGFyQXQoMCkpe3ZhciBjPW5ldyBoKG4pO2lmKGMub2spbj1jLnRvSGV4KCk7ZWxzZSBpZighL15cZCpcLj9cZCokLy50ZXN0KG4pKXRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvciAiJytuKyciIHBhc3NlZCB0byBqc1BERi5lbmNvZGVDb2xvclN0cmluZy4nKX1pZigic3RyaW5nIj09dHlwZW9mIG4mJi9eI1swLTlBLUZhLWZdezN9JC8udGVzdChuKSYmKG49IiMiK25bMV0rblsxXStuWzJdK25bMl0rblszXStuWzNdKSwic3RyaW5nIj09dHlwZW9mIG4mJi9eI1swLTlBLUZhLWZdezZ9JC8udGVzdChuKSl7dmFyIHU9cGFyc2VJbnQobi5zdWJzdHIoMSksMTYpO249dT4+MTYmMjU1LGk9dT4+OCYyNTUsYT0yNTUmdX1pZih2b2lkIDA9PT1pfHx2b2lkIDA9PT1vJiZuPT09aSYmaT09PWEpaWYoInN0cmluZyI9PXR5cGVvZiBuKXI9bisiICIrc1swXTtlbHNlIHN3aXRjaCh0LnByZWNpc2lvbil7Y2FzZSAyOnI9UihuLzI1NSkrIiAiK3NbMF07YnJlYWs7Y2FzZSAzOmRlZmF1bHQ6cj1UKG4vMjU1KSsiICIrc1swXX1lbHNlIGlmKHZvaWQgMD09PW98fCJvYmplY3QiPT09ZShvKSl7aWYobyYmIWlzTmFOKG8uYSkmJjA9PT1vLmEpcmV0dXJuIHI9WyIxLiIsIjEuIiwiMS4iLHNbMV1dLmpvaW4oIiAiKTtpZigic3RyaW5nIj09dHlwZW9mIG4pcj1bbixpLGEsc1sxXV0uam9pbigiICIpO2Vsc2Ugc3dpdGNoKHQucHJlY2lzaW9uKXtjYXNlIDI6cj1bUihuLzI1NSksUihpLzI1NSksUihhLzI1NSksc1sxXV0uam9pbigiICIpO2JyZWFrO2RlZmF1bHQ6Y2FzZSAzOnI9W1Qobi8yNTUpLFQoaS8yNTUpLFQoYS8yNTUpLHNbMV1dLmpvaW4oIiAiKX19ZWxzZSBpZigic3RyaW5nIj09dHlwZW9mIG4pcj1bbixpLGEsbyxzWzJdXS5qb2luKCIgIik7ZWxzZSBzd2l0Y2godC5wcmVjaXNpb24pe2Nhc2UgMjpyPVtSKG4pLFIoaSksUihhKSxSKG8pLHNbMl1dLmpvaW4oIiAiKTticmVhaztjYXNlIDM6ZGVmYXVsdDpyPVtUKG4pLFQoaSksVChhKSxUKG8pLHNbMl1dLmpvaW4oIiAiKX1yZXR1cm4gcn0sbmU9eS5fX3ByaXZhdGVfXy5nZXRGaWx0ZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGZ9LGllPXkuX19wcml2YXRlX18ucHV0U3RyZWFtPWZ1bmN0aW9uKHQpe3ZhciBlPSh0PXR8fHt9KS5kYXRhfHwiIixyPXQuZmlsdGVyc3x8bmUoKSxuPXQuYWxyZWFkeUFwcGxpZWRGaWx0ZXJzfHxbXSxpPXQuYWRkTGVuZ3RoMXx8ITEsYT1lLmxlbmd0aCxvPXQub2JqZWN0SWQscz1mdW5jdGlvbih0KXtyZXR1cm4gdH07aWYobnVsbCE9PW0mJnZvaWQgMD09PW8pdGhyb3cgbmV3IEVycm9yKCJPYmplY3RJZCBtdXN0IGJlIHBhc3NlZCB0byBwdXRTdHJlYW0gZm9yIGZpbGUgZW5jcnlwdGlvbiIpO251bGwhPT1tJiYocz1ZZS5lbmNyeXB0b3IobywwKSk7dmFyIGM9e307ITA9PT1yJiYocj1bIkZsYXRlRW5jb2RlIl0pO3ZhciB1PXQuYWRkaXRpb25hbEtleVZhbHVlc3x8W10sbD0oYz12b2lkIDAhPT1NLkFQSS5wcm9jZXNzRGF0YUJ5RmlsdGVycz9NLkFQSS5wcm9jZXNzRGF0YUJ5RmlsdGVycyhlLHIpOntkYXRhOmUscmV2ZXJzZUNoYWluOltdfSkucmV2ZXJzZUNoYWluKyhBcnJheS5pc0FycmF5KG4pP24uam9pbigiICIpOm4udG9TdHJpbmcoKSk7aWYoMCE9PWMuZGF0YS5sZW5ndGgmJih1LnB1c2goe2tleToiTGVuZ3RoIix2YWx1ZTpjLmRhdGEubGVuZ3RofSksITA9PT1pJiZ1LnB1c2goe2tleToiTGVuZ3RoMSIsdmFsdWU6YX0pKSwwIT1sLmxlbmd0aClpZihsLnNwbGl0KCIvIikubGVuZ3RoLTE9PTEpdS5wdXNoKHtrZXk6IkZpbHRlciIsdmFsdWU6bH0pO2Vsc2V7dS5wdXNoKHtrZXk6IkZpbHRlciIsdmFsdWU6IlsiK2wrIl0ifSk7Zm9yKHZhciBoPTA7aDx1Lmxlbmd0aDtoKz0xKWlmKCJEZWNvZGVQYXJtcyI9PT11W2hdLmtleSl7Zm9yKHZhciBmPVtdLGQ9MDtkPGMucmV2ZXJzZUNoYWluLnNwbGl0KCIvIikubGVuZ3RoLTE7ZCs9MSlmLnB1c2goIm51bGwiKTtmLnB1c2godVtoXS52YWx1ZSksdVtoXS52YWx1ZT0iWyIrZi5qb2luKCIgIikrIl0ifX1odCgiPDwiKTtmb3IodmFyIHA9MDtwPHUubGVuZ3RoO3ArKylodCgiLyIrdVtwXS5rZXkrIiAiK3VbcF0udmFsdWUpO2h0KCI+PiIpLDAhPT1jLmRhdGEubGVuZ3RoJiYoaHQoInN0cmVhbSIpLGh0KHMoYy5kYXRhKSksaHQoImVuZHN0cmVhbSIpKX0sYWU9eS5fX3ByaXZhdGVfXy5wdXRQYWdlPWZ1bmN0aW9uKHQpe3ZhciBlPXQubnVtYmVyLHI9dC5kYXRhLG49dC5vYmpJZCxpPXQuY29udGVudHNPYmpJZDtadChuLCEwKSxodCgiPDwvVHlwZSAvUGFnZSIpLGh0KCIvUGFyZW50ICIrdC5yb290RGljdGlvbmFyeU9iaklkKyIgMCBSIiksaHQoIi9SZXNvdXJjZXMgIit0LnJlc291cmNlRGljdGlvbmFyeU9iaklkKyIgMCBSIiksaHQoIi9NZWRpYUJveCBbIitwYXJzZUZsb2F0KEUodC5tZWRpYUJveC5ib3R0b21MZWZ0WCkpKyIgIitwYXJzZUZsb2F0KEUodC5tZWRpYUJveC5ib3R0b21MZWZ0WSkpKyIgIitFKHQubWVkaWFCb3gudG9wUmlnaHRYKSsiICIrRSh0Lm1lZGlhQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09dC5jcm9wQm94JiZodCgiL0Nyb3BCb3ggWyIrRSh0LmNyb3BCb3guYm90dG9tTGVmdFgpKyIgIitFKHQuY3JvcEJveC5ib3R0b21MZWZ0WSkrIiAiK0UodC5jcm9wQm94LnRvcFJpZ2h0WCkrIiAiK0UodC5jcm9wQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09dC5ibGVlZEJveCYmaHQoIi9CbGVlZEJveCBbIitFKHQuYmxlZWRCb3guYm90dG9tTGVmdFgpKyIgIitFKHQuYmxlZWRCb3guYm90dG9tTGVmdFkpKyIgIitFKHQuYmxlZWRCb3gudG9wUmlnaHRYKSsiICIrRSh0LmJsZWVkQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09dC50cmltQm94JiZodCgiL1RyaW1Cb3ggWyIrRSh0LnRyaW1Cb3guYm90dG9tTGVmdFgpKyIgIitFKHQudHJpbUJveC5ib3R0b21MZWZ0WSkrIiAiK0UodC50cmltQm94LnRvcFJpZ2h0WCkrIiAiK0UodC50cmltQm94LnRvcFJpZ2h0WSkrIl0iKSxudWxsIT09dC5hcnRCb3gmJmh0KCIvQXJ0Qm94IFsiK0UodC5hcnRCb3guYm90dG9tTGVmdFgpKyIgIitFKHQuYXJ0Qm94LmJvdHRvbUxlZnRZKSsiICIrRSh0LmFydEJveC50b3BSaWdodFgpKyIgIitFKHQuYXJ0Qm94LnRvcFJpZ2h0WSkrIl0iKSwibnVtYmVyIj09dHlwZW9mIHQudXNlclVuaXQmJjEhPT10LnVzZXJVbml0JiZodCgiL1VzZXJVbml0ICIrdC51c2VyVW5pdCksVHQucHVibGlzaCgicHV0UGFnZSIse29iaklkOm4scGFnZUNvbnRleHQ6UnRbZV0scGFnZU51bWJlcjplLHBhZ2U6cn0pLGh0KCIvQ29udGVudHMgIitpKyIgMCBSIiksaHQoIj4+IiksaHQoImVuZG9iaiIpO3ZhciBhPXIuam9pbigiXG4iKTtyZXR1cm4gUz09PXguQURWQU5DRUQmJihhKz0iXG5RIiksWnQoaSwhMCksaWUoe2RhdGE6YSxmaWx0ZXJzOm5lKCksb2JqZWN0SWQ6aX0pLGh0KCJlbmRvYmoiKSxufSxvZT15Ll9fcHJpdmF0ZV9fLnB1dFBhZ2VzPWZ1bmN0aW9uKCl7dmFyIHQsZSxyPVtdO2Zvcih0PTE7dDw9RHQ7dCsrKVJ0W3RdLm9iaklkPUt0KCksUnRbdF0uY29udGVudHNPYmpJZD1LdCgpO2Zvcih0PTE7dDw9RHQ7dCsrKXIucHVzaChhZSh7bnVtYmVyOnQsZGF0YTpvdFt0XSxvYmpJZDpSdFt0XS5vYmpJZCxjb250ZW50c09iaklkOlJ0W3RdLmNvbnRlbnRzT2JqSWQsbWVkaWFCb3g6UnRbdF0ubWVkaWFCb3gsY3JvcEJveDpSdFt0XS5jcm9wQm94LGJsZWVkQm94OlJ0W3RdLmJsZWVkQm94LHRyaW1Cb3g6UnRbdF0udHJpbUJveCxhcnRCb3g6UnRbdF0uYXJ0Qm94LHVzZXJVbml0OlJ0W3RdLnVzZXJVbml0LHJvb3REaWN0aW9uYXJ5T2JqSWQ6UXQscmVzb3VyY2VEaWN0aW9uYXJ5T2JqSWQ6dGV9KSk7WnQoUXQsITApLGh0KCI8PC9UeXBlIC9QYWdlcyIpO3ZhciBuPSIvS2lkcyBbIjtmb3IoZT0wO2U8RHQ7ZSsrKW4rPXJbZV0rIiAwIFIgIjtodChuKyJdIiksaHQoIi9Db3VudCAiK0R0KSxodCgiPj4iKSxodCgiZW5kb2JqIiksVHQucHVibGlzaCgicG9zdFB1dFBhZ2VzIil9LHNlPWZ1bmN0aW9uKHQpe1R0LnB1Ymxpc2goInB1dEZvbnQiLHtmb250OnQsb3V0Omh0LG5ld09iamVjdDpYdCxwdXRTdHJlYW06aWV9KSwhMCE9PXQuaXNBbHJlYWR5UHV0dGVkJiYodC5vYmplY3ROdW1iZXI9WHQoKSxodCgiPDwiKSxodCgiL1R5cGUgL0ZvbnQiKSxodCgiL0Jhc2VGb250IC8iK0YodC5wb3N0U2NyaXB0TmFtZSkpLGh0KCIvU3VidHlwZSAvVHlwZTEiKSwic3RyaW5nIj09dHlwZW9mIHQuZW5jb2RpbmcmJmh0KCIvRW5jb2RpbmcgLyIrdC5lbmNvZGluZyksaHQoIi9GaXJzdENoYXIgMzIiKSxodCgiL0xhc3RDaGFyIDI1NSIpLGh0KCI+PiIpLGh0KCJlbmRvYmoiKSl9LGNlPWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIEl0KUl0Lmhhc093blByb3BlcnR5KHQpJiYoITE9PT12fHwhMD09PXYmJmIuaGFzT3duUHJvcGVydHkodCkpJiZzZShJdFt0XSl9LHVlPWZ1bmN0aW9uKHQpe3Qub2JqZWN0TnVtYmVyPVh0KCk7dmFyIGU9W107ZS5wdXNoKHtrZXk6IlR5cGUiLHZhbHVlOiIvWE9iamVjdCJ9KSxlLnB1c2goe2tleToiU3VidHlwZSIsdmFsdWU6Ii9Gb3JtIn0pLGUucHVzaCh7a2V5OiJCQm94Iix2YWx1ZToiWyIrW0UodC54KSxFKHQueSksRSh0LngrdC53aWR0aCksRSh0LnkrdC5oZWlnaHQpXS5qb2luKCIgIikrIl0ifSksZS5wdXNoKHtrZXk6Ik1hdHJpeCIsdmFsdWU6IlsiK3QubWF0cml4LnRvU3RyaW5nKCkrIl0ifSk7dmFyIHI9dC5wYWdlc1sxXS5qb2luKCJcbiIpO2llKHtkYXRhOnIsYWRkaXRpb25hbEtleVZhbHVlczplLG9iamVjdElkOnQub2JqZWN0TnVtYmVyfSksaHQoImVuZG9iaiIpfSxsZT1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiB6dCl6dC5oYXNPd25Qcm9wZXJ0eSh0KSYmdWUoenRbdF0pfSxoZT1mdW5jdGlvbih0LGUpe3ZhciByLG49W10saT0xLyhlLTEpO2ZvcihyPTA7cjwxO3IrPWkpbi5wdXNoKHIpO2lmKG4ucHVzaCgxKSwwIT10WzBdLm9mZnNldCl7dmFyIGE9e29mZnNldDowLGNvbG9yOnRbMF0uY29sb3J9O3QudW5zaGlmdChhKX1pZigxIT10W3QubGVuZ3RoLTFdLm9mZnNldCl7dmFyIG89e29mZnNldDoxLGNvbG9yOnRbdC5sZW5ndGgtMV0uY29sb3J9O3QucHVzaChvKX1mb3IodmFyIHM9IiIsYz0wLHU9MDt1PG4ubGVuZ3RoO3UrKyl7Zm9yKHI9blt1XTtyPnRbYysxXS5vZmZzZXQ7KWMrKzt2YXIgbD10W2NdLm9mZnNldCxoPShyLWwpLyh0W2MrMV0ub2Zmc2V0LWwpLGY9dFtjXS5jb2xvcixkPXRbYysxXS5jb2xvcjtzKz10dChNYXRoLnJvdW5kKCgxLWgpKmZbMF0raCpkWzBdKS50b1N0cmluZygxNikpK3R0KE1hdGgucm91bmQoKDEtaCkqZlsxXStoKmRbMV0pLnRvU3RyaW5nKDE2KSkrdHQoTWF0aC5yb3VuZCgoMS1oKSpmWzJdK2gqZFsyXSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gcy50cmltKCl9LGZlPWZ1bmN0aW9uKHQsZSl7ZXx8KGU9MjEpO3ZhciByPVh0KCksbj1oZSh0LmNvbG9ycyxlKSxpPVtdO2kucHVzaCh7a2V5OiJGdW5jdGlvblR5cGUiLHZhbHVlOiIwIn0pLGkucHVzaCh7a2V5OiJEb21haW4iLHZhbHVlOiJbMC4wIDEuMF0ifSksaS5wdXNoKHtrZXk6IlNpemUiLHZhbHVlOiJbIitlKyJdIn0pLGkucHVzaCh7a2V5OiJCaXRzUGVyU2FtcGxlIix2YWx1ZToiOCJ9KSxpLnB1c2goe2tleToiUmFuZ2UiLHZhbHVlOiJbMC4wIDEuMCAwLjAgMS4wIDAuMCAxLjBdIn0pLGkucHVzaCh7a2V5OiJEZWNvZGUiLHZhbHVlOiJbMC4wIDEuMCAwLjAgMS4wIDAuMCAxLjBdIn0pLGllKHtkYXRhOm4sYWRkaXRpb25hbEtleVZhbHVlczppLGFscmVhZHlBcHBsaWVkRmlsdGVyczpbIi9BU0NJSUhleERlY29kZSJdLG9iamVjdElkOnJ9KSxodCgiZW5kb2JqIiksdC5vYmplY3ROdW1iZXI9WHQoKSxodCgiPDwgL1NoYWRpbmdUeXBlICIrdC50eXBlKSxodCgiL0NvbG9yU3BhY2UgL0RldmljZVJHQiIpO3ZhciBhPSIvQ29vcmRzIFsiK0UocGFyc2VGbG9hdCh0LmNvb3Jkc1swXSkpKyIgIitFKHBhcnNlRmxvYXQodC5jb29yZHNbMV0pKSsiICI7Mj09PXQudHlwZT9hKz1FKHBhcnNlRmxvYXQodC5jb29yZHNbMl0pKSsiICIrRShwYXJzZUZsb2F0KHQuY29vcmRzWzNdKSk6YSs9RShwYXJzZUZsb2F0KHQuY29vcmRzWzJdKSkrIiAiK0UocGFyc2VGbG9hdCh0LmNvb3Jkc1szXSkpKyIgIitFKHBhcnNlRmxvYXQodC5jb29yZHNbNF0pKSsiICIrRShwYXJzZUZsb2F0KHQuY29vcmRzWzVdKSksaHQoYSs9Il0iKSx0Lm1hdHJpeCYmaHQoIi9NYXRyaXggWyIrdC5tYXRyaXgudG9TdHJpbmcoKSsiXSIpLGh0KCIvRnVuY3Rpb24gIityKyIgMCBSIiksaHQoIi9FeHRlbmQgW3RydWUgdHJ1ZV0iKSxodCgiPj4iKSxodCgiZW5kb2JqIil9LGRlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9S3QoKSxuPVh0KCk7ZS5wdXNoKHtyZXNvdXJjZXNPaWQ6cixvYmplY3RPaWQ6bn0pLHQub2JqZWN0TnVtYmVyPW47dmFyIGk9W107aS5wdXNoKHtrZXk6IlR5cGUiLHZhbHVlOiIvUGF0dGVybiJ9KSxpLnB1c2goe2tleToiUGF0dGVyblR5cGUiLHZhbHVlOiIxIn0pLGkucHVzaCh7a2V5OiJQYWludFR5cGUiLHZhbHVlOiIxIn0pLGkucHVzaCh7a2V5OiJUaWxpbmdUeXBlIix2YWx1ZToiMSJ9KSxpLnB1c2goe2tleToiQkJveCIsdmFsdWU6IlsiK3QuYm91bmRpbmdCb3gubWFwKEUpLmpvaW4oIiAiKSsiXSJ9KSxpLnB1c2goe2tleToiWFN0ZXAiLHZhbHVlOkUodC54U3RlcCl9KSxpLnB1c2goe2tleToiWVN0ZXAiLHZhbHVlOkUodC55U3RlcCl9KSxpLnB1c2goe2tleToiUmVzb3VyY2VzIix2YWx1ZTpyKyIgMCBSIn0pLHQubWF0cml4JiZpLnB1c2goe2tleToiTWF0cml4Iix2YWx1ZToiWyIrdC5tYXRyaXgudG9TdHJpbmcoKSsiXSJ9KSxpZSh7ZGF0YTp0LnN0cmVhbSxhZGRpdGlvbmFsS2V5VmFsdWVzOmksb2JqZWN0SWQ6dC5vYmplY3ROdW1iZXJ9KSxodCgiZW5kb2JqIil9LHBlPWZ1bmN0aW9uKHQpe3ZhciBlO2ZvcihlIGluIE90KU90Lmhhc093blByb3BlcnR5KGUpJiYoT3RbZV1pbnN0YW5jZW9mIE8/ZmUoT3RbZV0pOk90W2VdaW5zdGFuY2VvZiBCJiZkZShPdFtlXSx0KSl9LGdlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0Lm9iamVjdE51bWJlcj1YdCgpLGh0KCI8PCIpLHQpc3dpdGNoKGUpe2Nhc2Uib3BhY2l0eSI6aHQoIi9jYSAiK1IodFtlXSkpO2JyZWFrO2Nhc2Uic3Ryb2tlLW9wYWNpdHkiOmh0KCIvQ0EgIitSKHRbZV0pKX1odCgiPj4iKSxodCgiZW5kb2JqIil9LG1lPWZ1bmN0aW9uKCl7dmFyIHQ7Zm9yKHQgaW4gTXQpTXQuaGFzT3duUHJvcGVydHkodCkmJmdlKE10W3RdKX0sdmU9ZnVuY3Rpb24oKXtmb3IodmFyIHQgaW4gaHQoIi9YT2JqZWN0IDw8IiksenQpenQuaGFzT3duUHJvcGVydHkodCkmJnp0W3RdLm9iamVjdE51bWJlcj49MCYmaHQoIi8iK3QrIiAiK3p0W3RdLm9iamVjdE51bWJlcisiIDAgUiIpO1R0LnB1Ymxpc2goInB1dFhvYmplY3REaWN0IiksaHQoIj4+Iil9LGJlPWZ1bmN0aW9uKCl7WWUub2lkPVh0KCksaHQoIjw8IiksaHQoIi9GaWx0ZXIgL1N0YW5kYXJkIiksaHQoIi9WICIrWWUudiksaHQoIi9SICIrWWUuciksaHQoIi9VIDwiK1llLnRvSGV4U3RyaW5nKFllLlUpKyI+IiksaHQoIi9PIDwiK1llLnRvSGV4U3RyaW5nKFllLk8pKyI+IiksaHQoIi9QICIrWWUuUCksaHQoIj4+IiksaHQoImVuZG9iaiIpfSx5ZT1mdW5jdGlvbigpe2Zvcih2YXIgdCBpbiBodCgiL0ZvbnQgPDwiKSxJdClJdC5oYXNPd25Qcm9wZXJ0eSh0KSYmKCExPT09dnx8ITA9PT12JiZiLmhhc093blByb3BlcnR5KHQpKSYmaHQoIi8iK3QrIiAiK0l0W3RdLm9iamVjdE51bWJlcisiIDAgUiIpO2h0KCI+PiIpfSx3ZT1mdW5jdGlvbigpe2lmKE9iamVjdC5rZXlzKE90KS5sZW5ndGg+MCl7Zm9yKHZhciB0IGluIGh0KCIvU2hhZGluZyA8PCIpLE90KU90Lmhhc093blByb3BlcnR5KHQpJiZPdFt0XWluc3RhbmNlb2YgTyYmT3RbdF0ub2JqZWN0TnVtYmVyPj0wJiZodCgiLyIrdCsiICIrT3RbdF0ub2JqZWN0TnVtYmVyKyIgMCBSIik7VHQucHVibGlzaCgicHV0U2hhZGluZ1BhdHRlcm5EaWN0IiksaHQoIj4+Iil9fSxOZT1mdW5jdGlvbih0KXtpZihPYmplY3Qua2V5cyhPdCkubGVuZ3RoPjApe2Zvcih2YXIgZSBpbiBodCgiL1BhdHRlcm4gPDwiKSxPdClPdC5oYXNPd25Qcm9wZXJ0eShlKSYmT3RbZV1pbnN0YW5jZW9mIHkuVGlsaW5nUGF0dGVybiYmT3RbZV0ub2JqZWN0TnVtYmVyPj0wJiZPdFtlXS5vYmplY3ROdW1iZXI8dCYmaHQoIi8iK2UrIiAiK090W2VdLm9iamVjdE51bWJlcisiIDAgUiIpO1R0LnB1Ymxpc2goInB1dFRpbGluZ1BhdHRlcm5EaWN0IiksaHQoIj4+Iil9fSxMZT1mdW5jdGlvbigpe2lmKE9iamVjdC5rZXlzKE10KS5sZW5ndGg+MCl7dmFyIHQ7Zm9yKHQgaW4gaHQoIi9FeHRHU3RhdGUgPDwiKSxNdClNdC5oYXNPd25Qcm9wZXJ0eSh0KSYmTXRbdF0ub2JqZWN0TnVtYmVyPj0wJiZodCgiLyIrdCsiICIrTXRbdF0ub2JqZWN0TnVtYmVyKyIgMCBSIik7VHQucHVibGlzaCgicHV0R1N0YXRlRGljdCIpLGh0KCI+PiIpfX0sQWU9ZnVuY3Rpb24odCl7WnQodC5yZXNvdXJjZXNPaWQsITApLGh0KCI8PCIpLGh0KCIvUHJvY1NldCBbL1BERiAvVGV4dCAvSW1hZ2VCIC9JbWFnZUMgL0ltYWdlSV0iKSx5ZSgpLHdlKCksTmUodC5vYmplY3RPaWQpLExlKCksdmUoKSxodCgiPj4iKSxodCgiZW5kb2JqIil9LHhlPWZ1bmN0aW9uKCl7dmFyIHQ9W107Y2UoKSxtZSgpLGxlKCkscGUodCksVHQucHVibGlzaCgicHV0UmVzb3VyY2VzIiksdC5mb3JFYWNoKEFlKSxBZSh7cmVzb3VyY2VzT2lkOnRlLG9iamVjdE9pZDpOdW1iZXIuTUFYX1NBRkVfSU5URUdFUn0pLFR0LnB1Ymxpc2goInBvc3RQdXRSZXNvdXJjZXMiKX0sU2U9ZnVuY3Rpb24oKXtUdC5wdWJsaXNoKCJwdXRBZGRpdGlvbmFsT2JqZWN0cyIpO2Zvcih2YXIgdD0wO3Q8YXQubGVuZ3RoO3QrKyl7dmFyIGU9YXRbdF07WnQoZS5vYmpJZCwhMCksaHQoZS5jb250ZW50KSxodCgiZW5kb2JqIil9VHQucHVibGlzaCgicG9zdFB1dEFkZGl0aW9uYWxPYmplY3RzIil9LF9lPWZ1bmN0aW9uKHQpe0N0W3QuZm9udE5hbWVdPUN0W3QuZm9udE5hbWVdfHx7fSxDdFt0LmZvbnROYW1lXVt0LmZvbnRTdHlsZV09dC5pZH0sUGU9ZnVuY3Rpb24odCxlLHIsbixpKXt2YXIgYT17aWQ6IkYiKyhPYmplY3Qua2V5cyhJdCkubGVuZ3RoKzEpLnRvU3RyaW5nKDEwKSxwb3N0U2NyaXB0TmFtZTp0LGZvbnROYW1lOmUsZm9udFN0eWxlOnIsZW5jb2Rpbmc6bixpc1N0YW5kYXJkRm9udDppfHwhMSxtZXRhZGF0YTp7fX07cmV0dXJuIFR0LnB1Ymxpc2goImFkZEZvbnQiLHtmb250OmEsaW5zdGFuY2U6dGhpc30pLEl0W2EuaWRdPWEsX2UoYSksYS5pZH0sa2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAscj1wdC5sZW5ndGg7ZTxyO2UrKyl7dmFyIG49UGUuY2FsbCh0aGlzLHRbZV1bMF0sdFtlXVsxXSx0W2VdWzJdLHB0W2VdWzNdLCEwKTshMT09PXYmJihiW25dPSEwKTt2YXIgaT10W2VdWzBdLnNwbGl0KCItIik7X2Uoe2lkOm4sZm9udE5hbWU6aVswXSxmb250U3R5bGU6aVsxXXx8IiJ9KX1UdC5wdWJsaXNoKCJhZGRGb250cyIse2ZvbnRzOkl0LGRpY3Rpb25hcnk6Q3R9KX0sRmU9ZnVuY3Rpb24odCl7cmV0dXJuIHQuZm9vPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiB0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jYXRjaCh0KXt2YXIgZT10LnN0YWNrfHwiIjt+ZS5pbmRleE9mKCIgYXQgIikmJihlPWUuc3BsaXQoIiBhdCAiKVsxXSk7dmFyIG49IkVycm9yIGluIGZ1bmN0aW9uICIrZS5zcGxpdCgiXG4iKVswXS5zcGxpdCgiPCIpWzBdKyI6ICIrdC5tZXNzYWdlO2lmKCFyLmNvbnNvbGUpdGhyb3cgbmV3IEVycm9yKG4pO3IuY29uc29sZS5lcnJvcihuLHQpLHIuYWxlcnQmJmFsZXJ0KG4pfX0sdC5mb28uYmFyPXQsdC5mb299LEllPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLGEsbyxzLGMsdSxsO2lmKGk9KGU9ZXx8e30pLnNvdXJjZUVuY29kaW5nfHwiVW5pY29kZSIsbz1lLm91dHB1dEVuY29kaW5nLChlLmF1dG9lbmNvZGV8fG8pJiZJdFtTdF0ubWV0YWRhdGEmJkl0W1N0XS5tZXRhZGF0YVtpXSYmSXRbU3RdLm1ldGFkYXRhW2ldLmVuY29kaW5nJiYoYT1JdFtTdF0ubWV0YWRhdGFbaV0uZW5jb2RpbmcsIW8mJkl0W1N0XS5lbmNvZGluZyYmKG89SXRbU3RdLmVuY29kaW5nKSwhbyYmYS5jb2RlUGFnZXMmJihvPWEuY29kZVBhZ2VzWzBdKSwic3RyaW5nIj09dHlwZW9mIG8mJihvPWFbb10pLG8pKXtmb3IoYz0hMSxzPVtdLHI9MCxuPXQubGVuZ3RoO3I8bjtyKyspKHU9b1t0LmNoYXJDb2RlQXQocildKT9zLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh1KSk6cy5wdXNoKHRbcl0pLHNbcl0uY2hhckNvZGVBdCgwKT4+OCYmKGM9ITApO3Q9cy5qb2luKCIiKX1mb3Iocj10Lmxlbmd0aDt2b2lkIDA9PT1jJiYwIT09cjspdC5jaGFyQ29kZUF0KHItMSk+PjgmJihjPSEwKSxyLS07aWYoIWMpcmV0dXJuIHQ7Zm9yKHM9ZS5ub0JPTT9bXTpbMjU0LDI1NV0scj0wLG49dC5sZW5ndGg7cjxuO3IrKyl7aWYoKGw9KHU9dC5jaGFyQ29kZUF0KHIpKT4+OCk+PjgpdGhyb3cgbmV3IEVycm9yKCJDaGFyYWN0ZXIgYXQgcG9zaXRpb24gIityKyIgb2Ygc3RyaW5nICciK3QrIicgZXhjZWVkcyAxNmJpdHMuIENhbm5vdCBiZSBlbmNvZGVkIGludG8gVUNTLTIgQkUiKTtzLnB1c2gobCkscy5wdXNoKHUtKGw8PDgpKX1yZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSh2b2lkIDAscyl9LENlPXkuX19wcml2YXRlX18ucGRmRXNjYXBlPXkucGRmRXNjYXBlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIEllKHQsZSkucmVwbGFjZSgvXFwvZywiXFxcXCIpLnJlcGxhY2UoL1woL2csIlxcKCIpLnJlcGxhY2UoL1wpL2csIlxcKSIpfSxqZT15Ll9fcHJpdmF0ZV9fLmJlZ2luUGFnZT1mdW5jdGlvbih0KXtvdFsrK0R0XT1bXSxSdFtEdF09e29iaklkOjAsY29udGVudHNPYmpJZDowLHVzZXJVbml0Ok51bWJlcihkKSxhcnRCb3g6bnVsbCxibGVlZEJveDpudWxsLGNyb3BCb3g6bnVsbCx0cmltQm94Om51bGwsbWVkaWFCb3g6e2JvdHRvbUxlZnRYOjAsYm90dG9tTGVmdFk6MCx0b3BSaWdodFg6TnVtYmVyKHRbMF0pLHRvcFJpZ2h0WTpOdW1iZXIodFsxXSl9fSxNZShEdCksbHQob3RbJF0pfSxPZT1mdW5jdGlvbih0LGUpe3ZhciByLG4sbztzd2l0Y2goYT1lfHxhLCJzdHJpbmciPT10eXBlb2YgdCYmKHI9QSh0LnRvTG93ZXJDYXNlKCkpLEFycmF5LmlzQXJyYXkocikmJihuPXJbMF0sbz1yWzFdKSksQXJyYXkuaXNBcnJheSh0KSYmKG49dFswXSpfdCxvPXRbMV0qX3QpLGlzTmFOKG4pJiYobj1zWzBdLG89c1sxXSksKG4+MTQ0MDB8fG8+MTQ0MDApJiYoaS53YXJuKCJBIHBhZ2UgaW4gYSBQREYgY2FuIG5vdCBiZSB3aWRlciBvciB0YWxsZXIgdGhhbiAxNDQwMCB1c2VyVW5pdC4ganNQREYgbGltaXRzIHRoZSB3aWR0aC9oZWlnaHQgdG8gMTQ0MDAiKSxuPU1hdGgubWluKDE0NDAwLG4pLG89TWF0aC5taW4oMTQ0MDAsbykpLHM9W24sb10sYS5zdWJzdHIoMCwxKSl7Y2FzZSJsIjpvPm4mJihzPVtvLG5dKTticmVhaztjYXNlInAiOm4+byYmKHM9W28sbl0pfWplKHMpLHByKGZyKSxodChMciksMCE9PWtyJiZodChrcisiIEoiKSwwIT09RnImJmh0KEZyKyIgaiIpLFR0LnB1Ymxpc2goImFkZFBhZ2UiLHtwYWdlTnVtYmVyOkR0fSl9LEJlPWZ1bmN0aW9uKHQpe3Q+MCYmdDw9RHQmJihvdC5zcGxpY2UodCwxKSxSdC5zcGxpY2UodCwxKSxEdC0tLCQ+RHQmJigkPUR0KSx0aGlzLnNldFBhZ2UoJCkpfSxNZT1mdW5jdGlvbih0KXt0PjAmJnQ8PUR0JiYoJD10KX0sRWU9eS5fX3ByaXZhdGVfXy5nZXROdW1iZXJPZlBhZ2VzPXkuZ2V0TnVtYmVyT2ZQYWdlcz1mdW5jdGlvbigpe3JldHVybiBvdC5sZW5ndGgtMX0scWU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGE9dm9pZCAwO3JldHVybiByPXJ8fHt9LHQ9dm9pZCAwIT09dD90Okl0W1N0XS5mb250TmFtZSxlPXZvaWQgMCE9PWU/ZTpJdFtTdF0uZm9udFN0eWxlLG49dC50b0xvd2VyQ2FzZSgpLHZvaWQgMCE9PUN0W25dJiZ2b2lkIDAhPT1DdFtuXVtlXT9hPUN0W25dW2VdOnZvaWQgMCE9PUN0W3RdJiZ2b2lkIDAhPT1DdFt0XVtlXT9hPUN0W3RdW2VdOiExPT09ci5kaXNhYmxlV2FybmluZyYmaS53YXJuKCJVbmFibGUgdG8gbG9vayB1cCBmb250IGxhYmVsIGZvciBmb250ICciK3QrIicsICciK2UrIicuIFJlZmVyIHRvIGdldEZvbnRMaXN0KCkgZm9yIGF2YWlsYWJsZSBmb250cy4iKSxhfHxyLm5vRmFsbGJhY2t8fG51bGw9PShhPUN0LnRpbWVzW2VdKSYmKGE9Q3QudGltZXMubm9ybWFsKSxhfSxEZT15Ll9fcHJpdmF0ZV9fLnB1dEluZm89ZnVuY3Rpb24oKXt2YXIgdD1YdCgpLGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9O2Zvcih2YXIgciBpbiBudWxsIT09bSYmKGU9WWUuZW5jcnlwdG9yKHQsMCkpLGh0KCI8PCIpLGh0KCIvUHJvZHVjZXIgKCIrQ2UoZSgianNQREYgIitNLnZlcnNpb24pKSsiKSIpLHh0KXh0Lmhhc093blByb3BlcnR5KHIpJiZ4dFtyXSYmaHQoIi8iK3Iuc3Vic3RyKDAsMSkudG9VcHBlckNhc2UoKStyLnN1YnN0cigxKSsiICgiK0NlKGUoeHRbcl0pKSsiKSIpO2h0KCIvQ3JlYXRpb25EYXRlICgiK0NlKGUoVykpKyIpIiksaHQoIj4+IiksaHQoImVuZG9iaiIpfSxSZT15Ll9fcHJpdmF0ZV9fLnB1dENhdGFsb2c9ZnVuY3Rpb24odCl7dmFyIGU9KHQ9dHx8e30pLnJvb3REaWN0aW9uYXJ5T2JqSWR8fFF0O3N3aXRjaChYdCgpLGh0KCI8PCIpLGh0KCIvVHlwZSAvQ2F0YWxvZyIpLGh0KCIvUGFnZXMgIitlKyIgMCBSIiksbXR8fChtdD0iZnVsbHdpZHRoIiksbXQpe2Nhc2UiZnVsbHdpZHRoIjpodCgiL09wZW5BY3Rpb24gWzMgMCBSIC9GaXRIIG51bGxdIik7YnJlYWs7Y2FzZSJmdWxsaGVpZ2h0IjpodCgiL09wZW5BY3Rpb24gWzMgMCBSIC9GaXRWIG51bGxdIik7YnJlYWs7Y2FzZSJmdWxscGFnZSI6aHQoIi9PcGVuQWN0aW9uIFszIDAgUiAvRml0XSIpO2JyZWFrO2Nhc2Uib3JpZ2luYWwiOmh0KCIvT3BlbkFjdGlvbiBbMyAwIFIgL1hZWiBudWxsIG51bGwgMV0iKTticmVhaztkZWZhdWx0OnZhciByPSIiK210OyIlIj09PXIuc3Vic3RyKHIubGVuZ3RoLTEpJiYobXQ9cGFyc2VJbnQobXQpLzEwMCksIm51bWJlciI9PXR5cGVvZiBtdCYmaHQoIi9PcGVuQWN0aW9uIFszIDAgUiAvWFlaIG51bGwgbnVsbCAiK1IobXQpKyJdIil9c3dpdGNoKE50fHwoTnQ9ImNvbnRpbnVvdXMiKSxOdCl7Y2FzZSJjb250aW51b3VzIjpodCgiL1BhZ2VMYXlvdXQgL09uZUNvbHVtbiIpO2JyZWFrO2Nhc2Uic2luZ2xlIjpodCgiL1BhZ2VMYXlvdXQgL1NpbmdsZVBhZ2UiKTticmVhaztjYXNlInR3byI6Y2FzZSJ0d29sZWZ0IjpodCgiL1BhZ2VMYXlvdXQgL1R3b0NvbHVtbkxlZnQiKTticmVhaztjYXNlInR3b3JpZ2h0IjpodCgiL1BhZ2VMYXlvdXQgL1R3b0NvbHVtblJpZ2h0Iil9eXQmJmh0KCIvUGFnZU1vZGUgLyIreXQpLFR0LnB1Ymxpc2goInB1dENhdGFsb2ciKSxodCgiPj4iKSxodCgiZW5kb2JqIil9LFRlPXkuX19wcml2YXRlX18ucHV0VHJhaWxlcj1mdW5jdGlvbigpe2h0KCJ0cmFpbGVyIiksaHQoIjw8IiksaHQoIi9TaXplICIrKGV0KzEpKSxodCgiL1Jvb3QgIitldCsiIDAgUiIpLGh0KCIvSW5mbyAiKyhldC0xKSsiIDAgUiIpLG51bGwhPT1tJiZodCgiL0VuY3J5cHQgIitZZS5vaWQrIiAwIFIiKSxodCgiL0lEIFsgPCIrVisiPiA8IitWKyI+IF0iKSxodCgiPj4iKX0sVWU9eS5fX3ByaXZhdGVfXy5wdXRIZWFkZXI9ZnVuY3Rpb24oKXtodCgiJVBERi0iK3cpLGh0KCIlwrrDn8Ksw6AiKX0semU9eS5fX3ByaXZhdGVfXy5wdXRYUmVmPWZ1bmN0aW9uKCl7dmFyIHQ9IjAwMDAwMDAwMDAiO2h0KCJ4cmVmIiksaHQoIjAgIisoZXQrMSkpLGh0KCIwMDAwMDAwMDAwIDY1NTM1IGYgIik7Zm9yKHZhciBlPTE7ZTw9ZXQ7ZSsrKXsiZnVuY3Rpb24iPT10eXBlb2YgcnRbZV0/aHQoKHQrcnRbZV0oKSkuc2xpY2UoLTEwKSsiIDAwMDAwIG4gIik6dm9pZCAwIT09cnRbZV0/aHQoKHQrcnRbZV0pLnNsaWNlKC0xMCkrIiAwMDAwMCBuICIpOmh0KCIwMDAwMDAwMDAwIDAwMDAwIG4gIil9fSxIZT15Ll9fcHJpdmF0ZV9fLmJ1aWxkRG9jdW1lbnQ9ZnVuY3Rpb24oKXt1dCgpLGx0KG50KSxUdC5wdWJsaXNoKCJidWlsZERvY3VtZW50IiksVWUoKSxvZSgpLFNlKCkseGUoKSxudWxsIT09bSYmYmUoKSxEZSgpLFJlKCk7dmFyIHQ9aXQ7cmV0dXJuIHplKCksVGUoKSxodCgic3RhcnR4cmVmIiksaHQoIiIrdCksaHQoIiUlRU9GIiksbHQob3RbJF0pLG50LmpvaW4oIlxuIil9LFdlPXkuX19wcml2YXRlX18uZ2V0QmxvYj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IEJsb2IoW2R0KHQpXSx7dHlwZToiYXBwbGljYXRpb24vcGRmIn0pfSxWZT15Lm91dHB1dD15Ll9fcHJpdmF0ZV9fLm91dHB1dD1GZSgoZnVuY3Rpb24odCxlKXtzd2l0Y2goInN0cmluZyI9PXR5cGVvZihlPWV8fHt9KT9lPXtmaWxlbmFtZTplfTplLmZpbGVuYW1lPWUuZmlsZW5hbWV8fCJnZW5lcmF0ZWQucGRmIix0KXtjYXNlIHZvaWQgMDpyZXR1cm4gSGUoKTtjYXNlInNhdmUiOnkuc2F2ZShlLmZpbGVuYW1lKTticmVhaztjYXNlImFycmF5YnVmZmVyIjpyZXR1cm4gZHQoSGUoKSk7Y2FzZSJibG9iIjpyZXR1cm4gV2UoSGUoKSk7Y2FzZSJibG9idXJpIjpjYXNlImJsb2J1cmwiOmlmKHZvaWQgMCE9PXIuVVJMJiYiZnVuY3Rpb24iPT10eXBlb2Ygci5VUkwuY3JlYXRlT2JqZWN0VVJMKXJldHVybiByLlVSTCYmci5VUkwuY3JlYXRlT2JqZWN0VVJMKFdlKEhlKCkpKXx8dm9pZCAwO2kud2FybigiYmxvYnVybCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgc3lzdGVtLCBiZWNhdXNlIFVSTC5jcmVhdGVPYmplY3RVUkwgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXIuIik7YnJlYWs7Y2FzZSJkYXRhdXJpc3RyaW5nIjpjYXNlImRhdGF1cmxzdHJpbmciOnZhciBuPSIiLGE9SGUoKTt0cnl7bj11KGEpfWNhdGNoKHQpe249dSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYSkpKX1yZXR1cm4iZGF0YTphcHBsaWNhdGlvbi9wZGY7ZmlsZW5hbWU9IitlLmZpbGVuYW1lKyI7YmFzZTY0LCIrbjtjYXNlInBkZm9iamVjdG5ld3dpbmRvdyI6aWYoIltvYmplY3QgV2luZG93XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikpe3ZhciBvPSJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9wZGZvYmplY3QvMi4xLjEvcGRmb2JqZWN0Lm1pbi5qcyIscz0nIGludGVncml0eT0ic2hhNTEyLTR6ZS9hOS80anF1K3RYOWRmT3FKWVN2eVlkNU02cXVtLzNIcENMcisvSnFmMHdoYzM3VlVia3BOR0hSNy84cFNuQ0Z3NDdUMWZtSXB3QlY3VXlTaDNnPT0iIGNyb3Nzb3JpZ2luPSJhbm9ueW1vdXMiJztlLnBkZk9iamVjdFVybCYmKG89ZS5wZGZPYmplY3RVcmwscz0iIik7dmFyIGM9JzxodG1sPjxzdHlsZT5odG1sLCBib2R5IHsgcGFkZGluZzogMDsgbWFyZ2luOiAwOyB9IGlmcmFtZSB7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IGJvcmRlcjogMDt9ICA8L3N0eWxlPjxib2R5PjxzY3JpcHQgc3JjPSInK28rJyInK3MrJz48XC9zY3JpcHQ+PHNjcmlwdCA+UERGT2JqZWN0LmVtYmVkKCInK3RoaXMub3V0cHV0KCJkYXRhdXJsc3RyaW5nIikrJyIsICcrSlNPTi5zdHJpbmdpZnkoZSkrIik7PFwvc2NyaXB0PjwvYm9keT48L2h0bWw+IixsPXIub3BlbigpO3JldHVybiBudWxsIT09bCYmbC5kb2N1bWVudC53cml0ZShjKSxsfXRocm93IG5ldyBFcnJvcigiVGhlIG9wdGlvbiBwZGZvYmplY3RuZXd3aW5kb3cganVzdCB3b3JrcyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnQuIik7Y2FzZSJwZGZqc25ld3dpbmRvdyI6aWYoIltvYmplY3QgV2luZG93XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocikpe3ZhciBoPSc8aHRtbD48c3R5bGU+aHRtbCwgYm9keSB7IHBhZGRpbmc6IDA7IG1hcmdpbjogMDsgfSBpZnJhbWUgeyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlOyBib3JkZXI6IDA7fSAgPC9zdHlsZT48Ym9keT48aWZyYW1lIGlkPSJwZGZWaWV3ZXIiIHNyYz0iJysoZS5wZGZKc1VybHx8ImV4YW1wbGVzL1BERi5qcy93ZWIvdmlld2VyLmh0bWwiKSsiP2ZpbGU9JmRvd25sb2FkTmFtZT0iK2UuZmlsZW5hbWUrJyIgd2lkdGg9IjUwMHB4IiBoZWlnaHQ9IjQwMHB4IiAvPjwvYm9keT48L2h0bWw+JyxmPXIub3BlbigpO2lmKG51bGwhPT1mKXtmLmRvY3VtZW50LndyaXRlKGgpO3ZhciBkPXRoaXM7Zi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucXVlcnlTZWxlY3RvcigiI3BkZlZpZXdlciIpLm9ubG9hZD1mdW5jdGlvbigpe2YuZG9jdW1lbnQudGl0bGU9ZS5maWxlbmFtZSxmLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCIjcGRmVmlld2VyIikuY29udGVudFdpbmRvdy5QREZWaWV3ZXJBcHBsaWNhdGlvbi5vcGVuKGQub3V0cHV0KCJibG9idXJsIikpfX1yZXR1cm4gZn10aHJvdyBuZXcgRXJyb3IoIlRoZSBvcHRpb24gcGRmanNuZXd3aW5kb3cganVzdCB3b3JrcyBpbiBhIGJyb3dzZXItZW52aXJvbm1lbnQuIik7Y2FzZSJkYXRhdXJsbmV3d2luZG93IjppZigiW29iamVjdCBXaW5kb3ddIiE9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKSl0aHJvdyBuZXcgRXJyb3IoIlRoZSBvcHRpb24gZGF0YXVybG5ld3dpbmRvdyBqdXN0IHdvcmtzIGluIGEgYnJvd3Nlci1lbnZpcm9ubWVudC4iKTt2YXIgcD0nPGh0bWw+PHN0eWxlPmh0bWwsIGJvZHkgeyBwYWRkaW5nOiAwOyBtYXJnaW46IDA7IH0gaWZyYW1lIHsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgYm9yZGVyOiAwO30gIDwvc3R5bGU+PGJvZHk+PGlmcmFtZSBzcmM9IicrdGhpcy5vdXRwdXQoImRhdGF1cmlzdHJpbmciLGUpKyciPjwvaWZyYW1lPjwvYm9keT48L2h0bWw+JyxnPXIub3BlbigpO2lmKG51bGwhPT1nJiYoZy5kb2N1bWVudC53cml0ZShwKSxnLmRvY3VtZW50LnRpdGxlPWUuZmlsZW5hbWUpLGd8fCJ1bmRlZmluZWQiPT10eXBlb2Ygc2FmYXJpKXJldHVybiBnO2JyZWFrO2Nhc2UiZGF0YXVyaSI6Y2FzZSJkYXRhdXJsIjpyZXR1cm4gci5kb2N1bWVudC5sb2NhdGlvbi5ocmVmPXRoaXMub3V0cHV0KCJkYXRhdXJpc3RyaW5nIixlKTtkZWZhdWx0OnJldHVybiBudWxsfX0pKSxHZT1mdW5jdGlvbih0KXtyZXR1cm4hMD09PUFycmF5LmlzQXJyYXkoVXQpJiZVdC5pbmRleE9mKHQpPi0xfTtzd2l0Y2gobyl7Y2FzZSJwdCI6X3Q9MTticmVhaztjYXNlIm1tIjpfdD03Mi8yNS40O2JyZWFrO2Nhc2UiY20iOl90PTcyLzIuNTQ7YnJlYWs7Y2FzZSJpbiI6X3Q9NzI7YnJlYWs7Y2FzZSJweCI6X3Q9MT09R2UoInB4X3NjYWxpbmciKT8uNzU6OTYvNzI7YnJlYWs7Y2FzZSJwYyI6Y2FzZSJlbSI6X3Q9MTI7YnJlYWs7Y2FzZSJleCI6X3Q9NjticmVhaztkZWZhdWx0OmlmKCJudW1iZXIiIT10eXBlb2Ygbyl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgdW5pdDogIitvKTtfdD1vfXZhciBZZT1udWxsO0soKSxZKCk7dmFyIEplPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09bT9ZZS5lbmNyeXB0b3IodCwwKTpmdW5jdGlvbih0KXtyZXR1cm4gdH19LFhlPXkuX19wcml2YXRlX18uZ2V0UGFnZUluZm89eS5nZXRQYWdlSW5mbz1mdW5jdGlvbih0KXtpZihpc05hTih0KXx8dCUxIT0wKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuZ2V0UGFnZUluZm8iKTtyZXR1cm57b2JqSWQ6UnRbdF0ub2JqSWQscGFnZU51bWJlcjp0LHBhZ2VDb250ZXh0OlJ0W3RdfX0sS2U9eS5fX3ByaXZhdGVfXy5nZXRQYWdlSW5mb0J5T2JqSWQ9ZnVuY3Rpb24odCl7aWYoaXNOYU4odCl8fHQlMSE9MCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIGpzUERGLmdldFBhZ2VJbmZvQnlPYmpJZCIpO2Zvcih2YXIgZSBpbiBSdClpZihSdFtlXS5vYmpJZD09PXQpYnJlYWs7cmV0dXJuIFhlKGUpfSxaZT15Ll9fcHJpdmF0ZV9fLmdldEN1cnJlbnRQYWdlSW5mbz15LmdldEN1cnJlbnRQYWdlSW5mbz1mdW5jdGlvbigpe3JldHVybntvYmpJZDpSdFskXS5vYmpJZCxwYWdlTnVtYmVyOiQscGFnZUNvbnRleHQ6UnRbJF19fTt5LmFkZFBhZ2U9ZnVuY3Rpb24oKXtyZXR1cm4gT2UuYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXN9LHkuc2V0UGFnZT1mdW5jdGlvbigpe3JldHVybiBNZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksbHQuY2FsbCh0aGlzLG90WyRdKSx0aGlzfSx5Lmluc2VydFBhZ2U9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYWRkUGFnZSgpLHRoaXMubW92ZVBhZ2UoJCx0KSx0aGlzfSx5Lm1vdmVQYWdlPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbjtpZih0PmUpe3I9b3RbdF0sbj1SdFt0XTtmb3IodmFyIGk9dDtpPmU7aS0tKW90W2ldPW90W2ktMV0sUnRbaV09UnRbaS0xXTtvdFtlXT1yLFJ0W2VdPW4sdGhpcy5zZXRQYWdlKGUpfWVsc2UgaWYodDxlKXtyPW90W3RdLG49UnRbdF07Zm9yKHZhciBhPXQ7YTxlO2ErKylvdFthXT1vdFthKzFdLFJ0W2FdPVJ0W2ErMV07b3RbZV09cixSdFtlXT1uLHRoaXMuc2V0UGFnZShlKX1yZXR1cm4gdGhpc30seS5kZWxldGVQYWdlPWZ1bmN0aW9uKCl7cmV0dXJuIEJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzfSx5Ll9fcHJpdmF0ZV9fLnRleHQ9eS50ZXh0PWZ1bmN0aW9uKHQscixuLGksYSl7dmFyIG8scyxjLHUsbCxoLGYsZCxwLGc9KGk9aXx8e30pLnNjb3BlfHx0aGlzO2lmKCJudW1iZXIiPT10eXBlb2YgdCYmIm51bWJlciI9PXR5cGVvZiByJiYoInN0cmluZyI9PXR5cGVvZiBufHxBcnJheS5pc0FycmF5KG4pKSl7dmFyIG09bjtuPXIscj10LHQ9bX1pZihhcmd1bWVudHNbM11pbnN0YW5jZW9mIFZ0PT0hMT8oYz1hcmd1bWVudHNbNF0sdT1hcmd1bWVudHNbNV0sIm9iamVjdCI9PT1lKGY9YXJndW1lbnRzWzNdKSYmbnVsbCE9PWZ8fCgic3RyaW5nIj09dHlwZW9mIGMmJih1PWMsYz1udWxsKSwic3RyaW5nIj09dHlwZW9mIGYmJih1PWYsZj1udWxsKSwibnVtYmVyIj09dHlwZW9mIGYmJihjPWYsZj1udWxsKSxpPXtmbGFnczpmLGFuZ2xlOmMsYWxpZ246dX0pKToocSgiVGhlIHRyYW5zZm9ybSBwYXJhbWV0ZXIgb2YgdGV4dCgpIHdpdGggYSBNYXRyaXggdmFsdWUiKSxwPWEpLGlzTmFOKHIpfHxpc05hTihuKXx8bnVsbD09dCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi50ZXh0Iik7aWYoMD09PXQubGVuZ3RoKXJldHVybiBnO3ZhciB2PSIiLHk9ITEsdz0ibnVtYmVyIj09dHlwZW9mIGkubGluZUhlaWdodEZhY3Rvcj9pLmxpbmVIZWlnaHRGYWN0b3I6aHIsTj1nLmludGVybmFsLnNjYWxlRmFjdG9yO2Z1bmN0aW9uIEwodCl7cmV0dXJuIHQ9dC5zcGxpdCgiXHQiKS5qb2luKEFycmF5KGkuVGFiTGVufHw5KS5qb2luKCIgIikpLENlKHQsZil9ZnVuY3Rpb24gQSh0KXtmb3IodmFyIGUscj10LmNvbmNhdCgpLG49W10saT1yLmxlbmd0aDtpLS07KSJzdHJpbmciPT10eXBlb2YoZT1yLnNoaWZ0KCkpP24ucHVzaChlKTpBcnJheS5pc0FycmF5KHQpJiYoMT09PWUubGVuZ3RofHx2b2lkIDA9PT1lWzFdJiZ2b2lkIDA9PT1lWzJdKT9uLnB1c2goZVswXSk6bi5wdXNoKFtlWzBdLGVbMV0sZVsyXV0pO3JldHVybiBufWZ1bmN0aW9uIF8odCxlKXt2YXIgcjtpZigic3RyaW5nIj09dHlwZW9mIHQpcj1lKHQpWzBdO2Vsc2UgaWYoQXJyYXkuaXNBcnJheSh0KSl7Zm9yKHZhciBuLGksYT10LmNvbmNhdCgpLG89W10scz1hLmxlbmd0aDtzLS07KSJzdHJpbmciPT10eXBlb2Yobj1hLnNoaWZ0KCkpP28ucHVzaChlKG4pWzBdKTpBcnJheS5pc0FycmF5KG4pJiYic3RyaW5nIj09dHlwZW9mIG5bMF0mJihpPWUoblswXSxuWzFdLG5bMl0pLG8ucHVzaChbaVswXSxpWzFdLGlbMl1dKSk7cj1vfXJldHVybiByfXZhciBQPSExLGs9ITA7aWYoInN0cmluZyI9PXR5cGVvZiB0KVA9ITA7ZWxzZSBpZihBcnJheS5pc0FycmF5KHQpKXt2YXIgRj10LmNvbmNhdCgpO3M9W107Zm9yKHZhciBJLEM9Ri5sZW5ndGg7Qy0tOykoInN0cmluZyIhPXR5cGVvZihJPUYuc2hpZnQoKSl8fEFycmF5LmlzQXJyYXkoSSkmJiJzdHJpbmciIT10eXBlb2YgSVswXSkmJihrPSExKTtQPWt9aWYoITE9PT1QKXRocm93IG5ldyBFcnJvcignVHlwZSBvZiB0ZXh0IG11c3QgYmUgc3RyaW5nIG9yIEFycmF5LiAiJyt0KyciIGlzIG5vdCByZWNvZ25pemVkLicpOyJzdHJpbmciPT10eXBlb2YgdCYmKHQ9dC5tYXRjaCgvW1xyP1xuXS8pP3Quc3BsaXQoL1xyXG58XHJ8XG4vZyk6W3RdKTt2YXIgaj1ndC9nLmludGVybmFsLnNjYWxlRmFjdG9yLE89aioody0xKTtzd2l0Y2goaS5iYXNlbGluZSl7Y2FzZSJib3R0b20iOm4tPU87YnJlYWs7Y2FzZSJ0b3AiOm4rPWotTzticmVhaztjYXNlImhhbmdpbmciOm4rPWotMipPO2JyZWFrO2Nhc2UibWlkZGxlIjpuKz1qLzItT31pZigoaD1pLm1heFdpZHRofHwwKT4wJiYoInN0cmluZyI9PXR5cGVvZiB0P3Q9Zy5zcGxpdFRleHRUb1NpemUodCxoKToiW29iamVjdCBBcnJheV0iPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpJiYodD10LnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb25jYXQoZy5zcGxpdFRleHRUb1NpemUoZSxoKSl9KSxbXSkpKSxvPXt0ZXh0OnQseDpyLHk6bixvcHRpb25zOmksbXV0ZXg6e3BkZkVzY2FwZTpDZSxhY3RpdmVGb250S2V5OlN0LGZvbnRzOkl0LGFjdGl2ZUZvbnRTaXplOmd0fX0sVHQucHVibGlzaCgicHJlUHJvY2Vzc1RleHQiLG8pLHQ9by50ZXh0LGM9KGk9by5vcHRpb25zKS5hbmdsZSxwIGluc3RhbmNlb2YgVnQ9PSExJiZjJiYibnVtYmVyIj09dHlwZW9mIGMpe2MqPU1hdGguUEkvMTgwLDA9PT1pLnJvdGF0aW9uRGlyZWN0aW9uJiYoYz0tYyksUz09PXguQURWQU5DRUQmJihjPS1jKTt2YXIgQj1NYXRoLmNvcyhjKSxNPU1hdGguc2luKGMpO3A9bmV3IFZ0KEIsTSwtTSxCLDAsMCl9ZWxzZSBjJiZjIGluc3RhbmNlb2YgVnQmJihwPWMpO1MhPT14LkFEVkFOQ0VEfHxwfHwocD1ZdCksdm9pZCAwIT09KGw9aS5jaGFyU3BhY2V8fF9yKSYmKHYrPUUoVShsKSkrIiBUY1xuIix0aGlzLnNldENoYXJTcGFjZSh0aGlzLmdldENoYXJTcGFjZSgpfHwwKSksdm9pZCAwIT09KGQ9aS5ob3Jpem9udGFsU2NhbGUpJiYodis9RSgxMDAqZCkrIiBUelxuIik7aS5sYW5nO3ZhciBEPS0xLFI9dm9pZCAwIT09aS5yZW5kZXJpbmdNb2RlP2kucmVuZGVyaW5nTW9kZTppLnN0cm9rZSxUPWcuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZUNvbnRleHQ7c3dpdGNoKFIpe2Nhc2UgMDpjYXNlITE6Y2FzZSJmaWxsIjpEPTA7YnJlYWs7Y2FzZSAxOmNhc2UhMDpjYXNlInN0cm9rZSI6RD0xO2JyZWFrO2Nhc2UgMjpjYXNlImZpbGxUaGVuU3Ryb2tlIjpEPTI7YnJlYWs7Y2FzZSAzOmNhc2UiaW52aXNpYmxlIjpEPTM7YnJlYWs7Y2FzZSA0OmNhc2UiZmlsbEFuZEFkZEZvckNsaXBwaW5nIjpEPTQ7YnJlYWs7Y2FzZSA1OmNhc2Uic3Ryb2tlQW5kQWRkUGF0aEZvckNsaXBwaW5nIjpEPTU7YnJlYWs7Y2FzZSA2OmNhc2UiZmlsbFRoZW5TdHJva2VBbmRBZGRUb1BhdGhGb3JDbGlwcGluZyI6RD02O2JyZWFrO2Nhc2UgNzpjYXNlImFkZFRvUGF0aEZvckNsaXBwaW5nIjpEPTd9dmFyIHo9dm9pZCAwIT09VC51c2VkUmVuZGVyaW5nTW9kZT9ULnVzZWRSZW5kZXJpbmdNb2RlOi0xOy0xIT09RD92Kz1EKyIgVHJcbiI6LTEhPT16JiYodis9IjAgVHJcbiIpLC0xIT09RCYmKFQudXNlZFJlbmRlcmluZ01vZGU9RCksdT1pLmFsaWdufHwibGVmdCI7dmFyIEgsVz1ndCp3LFY9Zy5pbnRlcm5hbC5wYWdlU2l6ZS5nZXRXaWR0aCgpLEc9SXRbU3RdO2w9aS5jaGFyU3BhY2V8fF9yLGg9aS5tYXhXaWR0aHx8MCxmPU9iamVjdC5hc3NpZ24oe2F1dG9lbmNvZGU6ITAsbm9CT006ITB9LGkuZmxhZ3MpO3ZhciBZPVtdO2lmKCJbb2JqZWN0IEFycmF5XSI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpe3ZhciBKO3M9QSh0KSwibGVmdCIhPT11JiYoSD1zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIGcuZ2V0U3RyaW5nVW5pdFdpZHRoKHQse2ZvbnQ6RyxjaGFyU3BhY2U6bCxmb250U2l6ZTpndCxkb0tlcm5pbmc6ITF9KSpndC9OfSkpKTt2YXIgWCxLPTA7aWYoInJpZ2h0Ij09PXUpe3ItPUhbMF0sdD1bXSxDPXMubGVuZ3RoO2Zvcih2YXIgWj0wO1o8QztaKyspMD09PVo/KFg9YnIociksSj15cihuKSk6KFg9VShLLUhbWl0pLEo9LVcpLHQucHVzaChbc1taXSxYLEpdKSxLPUhbWl19ZWxzZSBpZigiY2VudGVyIj09PXUpe3ItPUhbMF0vMix0PVtdLEM9cy5sZW5ndGg7Zm9yKHZhciAkPTA7JDxDOyQrKykwPT09JD8oWD1icihyKSxKPXlyKG4pKTooWD1VKChLLUhbJF0pLzIpLEo9LVcpLHQucHVzaChbc1skXSxYLEpdKSxLPUhbJF19ZWxzZSBpZigibGVmdCI9PT11KXt0PVtdLEM9cy5sZW5ndGg7Zm9yKHZhciBRPTA7UTxDO1ErKyl0LnB1c2goc1tRXSl9ZWxzZXtpZigianVzdGlmeSIhPT11KXRocm93IG5ldyBFcnJvcignVW5yZWNvZ25pemVkIGFsaWdubWVudCBvcHRpb24sIHVzZSAibGVmdCIsICJjZW50ZXIiLCAicmlnaHQiIG9yICJqdXN0aWZ5Ii4nKTt0PVtdLEM9cy5sZW5ndGgsaD0wIT09aD9oOlY7Zm9yKHZhciB0dD0wO3R0PEM7dHQrKylKPTA9PT10dD95cihuKTotVyxYPTA9PT10dD9icihyKTowLHR0PEMtMT9ZLnB1c2goRShVKChoLUhbdHRdKS8oc1t0dF0uc3BsaXQoIiAiKS5sZW5ndGgtMSkpKSk6WS5wdXNoKDApLHQucHVzaChbc1t0dF0sWCxKXSl9fXZhciBldD0iYm9vbGVhbiI9PXR5cGVvZiBpLlIyTD9pLlIyTDpidDshMD09PWV0JiYodD1fKHQsKGZ1bmN0aW9uKHQsZSxyKXtyZXR1cm5bdC5zcGxpdCgiIikucmV2ZXJzZSgpLmpvaW4oIiIpLGUscl19KSkpLG89e3RleHQ6dCx4OnIseTpuLG9wdGlvbnM6aSxtdXRleDp7cGRmRXNjYXBlOkNlLGFjdGl2ZUZvbnRLZXk6U3QsZm9udHM6SXQsYWN0aXZlRm9udFNpemU6Z3R9fSxUdC5wdWJsaXNoKCJwb3N0UHJvY2Vzc1RleHQiLG8pLHQ9by50ZXh0LHk9by5tdXRleC5pc0hleHx8ITE7dmFyIHJ0PUl0W1N0XS5lbmNvZGluZzsiV2luQW5zaUVuY29kaW5nIiE9PXJ0JiYiU3RhbmRhcmRFbmNvZGluZyIhPT1ydHx8KHQ9Xyh0LChmdW5jdGlvbih0LGUscil7cmV0dXJuW0wodCksZSxyXX0pKSkscz1BKHQpLHQ9W107Zm9yKHZhciBudCxpdCxhdCxvdD0wLHN0PTEsY3Q9QXJyYXkuaXNBcnJheShzWzBdKT9zdDpvdCx1dD0iIixsdD1mdW5jdGlvbih0LGUscil7dmFyIG49IiI7cmV0dXJuIHIgaW5zdGFuY2VvZiBWdD8ocj0ibnVtYmVyIj09dHlwZW9mIGkuYW5nbGU/R3QocixuZXcgVnQoMSwwLDAsMSx0LGUpKTpHdChuZXcgVnQoMSwwLDAsMSx0LGUpLHIpLFM9PT14LkFEVkFOQ0VEJiYocj1HdChuZXcgVnQoMSwwLDAsLTEsMCwwKSxyKSksbj1yLmpvaW4oIiAiKSsiIFRtXG4iKTpuPUUodCkrIiAiK0UoZSkrIiBUZFxuIixufSxmdD0wO2Z0PHMubGVuZ3RoO2Z0Kyspe3N3aXRjaCh1dD0iIixjdCl7Y2FzZSBzdDphdD0oeT8iPCI6IigiKStzW2Z0XVswXSsoeT8iPiI6IikiKSxudD1wYXJzZUZsb2F0KHNbZnRdWzFdKSxpdD1wYXJzZUZsb2F0KHNbZnRdWzJdKTticmVhaztjYXNlIG90OmF0PSh5PyI8IjoiKCIpK3NbZnRdKyh5PyI+IjoiKSIpLG50PWJyKHIpLGl0PXlyKG4pfXZvaWQgMCE9PVkmJnZvaWQgMCE9PVlbZnRdJiYodXQ9WVtmdF0rIiBUd1xuIiksMD09PWZ0P3QucHVzaCh1dCtsdChudCxpdCxwKSthdCk6Y3Q9PT1vdD90LnB1c2godXQrYXQpOmN0PT09c3QmJnQucHVzaCh1dCtsdChudCxpdCxwKSthdCl9dD1jdD09PW90P3Quam9pbigiIFRqXG5UKiAiKTp0LmpvaW4oIiBUalxuIiksdCs9IiBUalxuIjt2YXIgZHQ9IkJUXG4vIjtyZXR1cm4gZHQrPVN0KyIgIitndCsiIFRmXG4iLGR0Kz1FKGd0KncpKyIgVExcbiIsZHQrPXhyKyJcbiIsZHQrPXYsZHQrPXQsaHQoZHQrPSJFVCIpLGJbU3RdPSEwLGd9O3ZhciAkZT15Ll9fcHJpdmF0ZV9fLmNsaXA9eS5jbGlwPWZ1bmN0aW9uKHQpe3JldHVybiBodCgiZXZlbm9kZCI9PT10PyJXKiI6IlciKSx0aGlzfTt5LmNsaXBFdmVuT2RkPWZ1bmN0aW9uKCl7cmV0dXJuICRlKCJldmVub2RkIil9LHkuX19wcml2YXRlX18uZGlzY2FyZFBhdGg9eS5kaXNjYXJkUGF0aD1mdW5jdGlvbigpe3JldHVybiBodCgibiIpLHRoaXN9O3ZhciBRZT15Ll9fcHJpdmF0ZV9fLmlzVmFsaWRTdHlsZT1mdW5jdGlvbih0KXt2YXIgZT0hMTtyZXR1cm4tMSE9PVt2b2lkIDAsbnVsbCwiUyIsIkQiLCJGIiwiREYiLCJGRCIsImYiLCJmKiIsIkIiLCJCKiIsIm4iXS5pbmRleE9mKHQpJiYoZT0hMCksZX07eS5fX3ByaXZhdGVfXy5zZXREZWZhdWx0UGF0aE9wZXJhdGlvbj15LnNldERlZmF1bHRQYXRoT3BlcmF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiBRZSh0KSYmKGc9dCksdGhpc307dmFyIHRyPXkuX19wcml2YXRlX18uZ2V0U3R5bGU9eS5nZXRTdHlsZT1mdW5jdGlvbih0KXt2YXIgZT1nO3N3aXRjaCh0KXtjYXNlIkQiOmNhc2UiUyI6ZT0iUyI7YnJlYWs7Y2FzZSJGIjplPSJmIjticmVhaztjYXNlIkZEIjpjYXNlIkRGIjplPSJCIjticmVhaztjYXNlImYiOmNhc2UiZioiOmNhc2UiQiI6Y2FzZSJCKiI6ZT10fXJldHVybiBlfSxlcj15LmNsb3NlPWZ1bmN0aW9uKCl7cmV0dXJuIGh0KCJoIiksdGhpc307eS5zdHJva2U9ZnVuY3Rpb24oKXtyZXR1cm4gaHQoIlMiKSx0aGlzfSx5LmZpbGw9ZnVuY3Rpb24odCl7cmV0dXJuIHJyKCJmIix0KSx0aGlzfSx5LmZpbGxFdmVuT2RkPWZ1bmN0aW9uKHQpe3JldHVybiBycigiZioiLHQpLHRoaXN9LHkuZmlsbFN0cm9rZT1mdW5jdGlvbih0KXtyZXR1cm4gcnIoIkIiLHQpLHRoaXN9LHkuZmlsbFN0cm9rZUV2ZW5PZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHJyKCJCKiIsdCksdGhpc307dmFyIHJyPWZ1bmN0aW9uKHQscil7Im9iamVjdCI9PT1lKHIpP2FyKHIsdCk6aHQodCl9LG5yPWZ1bmN0aW9uKHQpe251bGw9PT10fHxTPT09eC5BRFZBTkNFRCYmdm9pZCAwPT09dHx8KHQ9dHIodCksaHQodCkpfTtmdW5jdGlvbiBpcih0LGUscixuLGkpe3ZhciBhPW5ldyBCKGV8fHRoaXMuYm91bmRpbmdCb3gscnx8dGhpcy54U3RlcCxufHx0aGlzLnlTdGVwLHRoaXMuZ1N0YXRlLGl8fHRoaXMubWF0cml4KTthLnN0cmVhbT10aGlzLnN0cmVhbTt2YXIgbz10KyIkJCIrdGhpcy5jbG9uZUluZGV4KysrIiQkIjtyZXR1cm4gSnQobyxhKSxhfXZhciBhcj1mdW5jdGlvbih0LGUpe3ZhciByPUJ0W3Qua2V5XSxuPU90W3JdO2lmKG4gaW5zdGFuY2VvZiBPKWh0KCJxIiksaHQob3IoZSkpLG4uZ1N0YXRlJiZ5LnNldEdTdGF0ZShuLmdTdGF0ZSksaHQodC5tYXRyaXgudG9TdHJpbmcoKSsiIGNtIiksaHQoIi8iK3IrIiBzaCIpLGh0KCJRIik7ZWxzZSBpZihuIGluc3RhbmNlb2YgQil7dmFyIGk9bmV3IFZ0KDEsMCwwLC0xLDAsUnIoKSk7dC5tYXRyaXgmJihpPWkubXVsdGlwbHkodC5tYXRyaXh8fFl0KSxyPWlyLmNhbGwobix0LmtleSx0LmJvdW5kaW5nQm94LHQueFN0ZXAsdC55U3RlcCxpKS5pZCksaHQoInEiKSxodCgiL1BhdHRlcm4gY3MiKSxodCgiLyIrcisiIHNjbiIpLG4uZ1N0YXRlJiZ5LnNldEdTdGF0ZShuLmdTdGF0ZSksaHQoZSksaHQoIlEiKX19LG9yPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlImYiOmNhc2UiRiI6cmV0dXJuIlcgbiI7Y2FzZSJmKiI6cmV0dXJuIlcqIG4iO2Nhc2UiQiI6cmV0dXJuIlcgUyI7Y2FzZSJCKiI6cmV0dXJuIlcqIFMiO2Nhc2UiUyI6cmV0dXJuIlcgUyI7Y2FzZSJuIjpyZXR1cm4iVyBuIn19LHNyPXkubW92ZVRvPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGh0KEUoVSh0KSkrIiAiK0UoSChlKSkrIiBtIiksdGhpc30sY3I9eS5saW5lVG89ZnVuY3Rpb24odCxlKXtyZXR1cm4gaHQoRShVKHQpKSsiICIrRShIKGUpKSsiIGwiKSx0aGlzfSx1cj15LmN1cnZlVG89ZnVuY3Rpb24odCxlLHIsbixpLGEpe3JldHVybiBodChbRShVKHQpKSxFKEgoZSkpLEUoVShyKSksRShIKG4pKSxFKFUoaSkpLEUoSChhKSksImMiXS5qb2luKCIgIikpLHRoaXN9O3kuX19wcml2YXRlX18ubGluZT15LmxpbmU9ZnVuY3Rpb24odCxlLHIsbixpKXtpZihpc05hTih0KXx8aXNOYU4oZSl8fGlzTmFOKHIpfHxpc05hTihuKXx8IVFlKGkpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmxpbmUiKTtyZXR1cm4gUz09PXguQ09NUEFUP3RoaXMubGluZXMoW1tyLXQsbi1lXV0sdCxlLFsxLDFdLGl8fCJTIik6dGhpcy5saW5lcyhbW3ItdCxuLWVdXSx0LGUsWzEsMV0pLnN0cm9rZSgpfSx5Ll9fcHJpdmF0ZV9fLmxpbmVzPXkubGluZXM9ZnVuY3Rpb24odCxlLHIsbixpLGEpe3ZhciBvLHMsYyx1LGwsaCxmLGQscCxnLG0sdjtpZigibnVtYmVyIj09dHlwZW9mIHQmJih2PXIscj1lLGU9dCx0PXYpLG49bnx8WzEsMV0sYT1hfHwhMSxpc05hTihlKXx8aXNOYU4ocil8fCFBcnJheS5pc0FycmF5KHQpfHwhQXJyYXkuaXNBcnJheShuKXx8IVFlKGkpfHwiYm9vbGVhbiIhPXR5cGVvZiBhKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmxpbmVzIik7Zm9yKHNyKGUsciksbz1uWzBdLHM9blsxXSx1PXQubGVuZ3RoLGc9ZSxtPXIsYz0wO2M8dTtjKyspMj09PShsPXRbY10pLmxlbmd0aD8oZz1sWzBdKm8rZyxtPWxbMV0qcyttLGNyKGcsbSkpOihoPWxbMF0qbytnLGY9bFsxXSpzK20sZD1sWzJdKm8rZyxwPWxbM10qcyttLGc9bFs0XSpvK2csbT1sWzVdKnMrbSx1cihoLGYsZCxwLGcsbSkpO3JldHVybiBhJiZlcigpLG5yKGkpLHRoaXN9LHkucGF0aD1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIHI9dFtlXSxuPXIuYztzd2l0Y2goci5vcCl7Y2FzZSJtIjpzcihuWzBdLG5bMV0pO2JyZWFrO2Nhc2UibCI6Y3IoblswXSxuWzFdKTticmVhaztjYXNlImMiOnVyLmFwcGx5KHRoaXMsbik7YnJlYWs7Y2FzZSJoIjplcigpfX1yZXR1cm4gdGhpc30seS5fX3ByaXZhdGVfXy5yZWN0PXkucmVjdD1mdW5jdGlvbih0LGUscixuLGkpe2lmKGlzTmFOKHQpfHxpc05hTihlKXx8aXNOYU4ocil8fGlzTmFOKG4pfHwhUWUoaSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYucmVjdCIpO3JldHVybiBTPT09eC5DT01QQVQmJihuPS1uKSxodChbRShVKHQpKSxFKEgoZSkpLEUoVShyKSksRShVKG4pKSwicmUiXS5qb2luKCIgIikpLG5yKGkpLHRoaXN9LHkuX19wcml2YXRlX18udHJpYW5nbGU9eS50cmlhbmdsZT1mdW5jdGlvbih0LGUscixuLGksYSxvKXtpZihpc05hTih0KXx8aXNOYU4oZSl8fGlzTmFOKHIpfHxpc05hTihuKXx8aXNOYU4oaSl8fGlzTmFOKGEpfHwhUWUobykpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYudHJpYW5nbGUiKTtyZXR1cm4gdGhpcy5saW5lcyhbW3ItdCxuLWVdLFtpLXIsYS1uXSxbdC1pLGUtYV1dLHQsZSxbMSwxXSxvLCEwKSx0aGlzfSx5Ll9fcHJpdmF0ZV9fLnJvdW5kZWRSZWN0PXkucm91bmRlZFJlY3Q9ZnVuY3Rpb24odCxlLHIsbixpLGEsbyl7aWYoaXNOYU4odCl8fGlzTmFOKGUpfHxpc05hTihyKXx8aXNOYU4obil8fGlzTmFOKGkpfHxpc05hTihhKXx8IVFlKG8pKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLnJvdW5kZWRSZWN0Iik7dmFyIHM9NC8zKihNYXRoLlNRUlQyLTEpO3JldHVybiBpPU1hdGgubWluKGksLjUqciksYT1NYXRoLm1pbihhLC41Km4pLHRoaXMubGluZXMoW1tyLTIqaSwwXSxbaSpzLDAsaSxhLWEqcyxpLGFdLFswLG4tMiphXSxbMCxhKnMsLWkqcyxhLC1pLGFdLFsyKmktciwwXSxbLWkqcywwLC1pLC1hKnMsLWksLWFdLFswLDIqYS1uXSxbMCwtYSpzLGkqcywtYSxpLC1hXV0sdCtpLGUsWzEsMV0sbywhMCksdGhpc30seS5fX3ByaXZhdGVfXy5lbGxpcHNlPXkuZWxsaXBzZT1mdW5jdGlvbih0LGUscixuLGkpe2lmKGlzTmFOKHQpfHxpc05hTihlKXx8aXNOYU4ocil8fGlzTmFOKG4pfHwhUWUoaSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuZWxsaXBzZSIpO3ZhciBhPTQvMyooTWF0aC5TUVJUMi0xKSpyLG89NC8zKihNYXRoLlNRUlQyLTEpKm47cmV0dXJuIHNyKHQrcixlKSx1cih0K3IsZS1vLHQrYSxlLW4sdCxlLW4pLHVyKHQtYSxlLW4sdC1yLGUtbyx0LXIsZSksdXIodC1yLGUrbyx0LWEsZStuLHQsZStuKSx1cih0K2EsZStuLHQrcixlK28sdCtyLGUpLG5yKGkpLHRoaXN9LHkuX19wcml2YXRlX18uY2lyY2xlPXkuY2lyY2xlPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKGlzTmFOKHQpfHxpc05hTihlKXx8aXNOYU4ocil8fCFRZShuKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jaXJjbGUiKTtyZXR1cm4gdGhpcy5lbGxpcHNlKHQsZSxyLHIsbil9LHkuc2V0Rm9udD1mdW5jdGlvbih0LGUscil7cmV0dXJuIHImJihlPWooZSxyKSksU3Q9cWUodCxlLHtkaXNhYmxlV2FybmluZzohMX0pLHRoaXN9O3ZhciBscj15Ll9fcHJpdmF0ZV9fLmdldEZvbnQ9eS5nZXRGb250PWZ1bmN0aW9uKCl7cmV0dXJuIEl0W3FlLmFwcGx5KHksYXJndW1lbnRzKV19O3kuX19wcml2YXRlX18uZ2V0Rm9udExpc3Q9eS5nZXRGb250TGlzdD1mdW5jdGlvbigpe3ZhciB0LGUscj17fTtmb3IodCBpbiBDdClpZihDdC5oYXNPd25Qcm9wZXJ0eSh0KSlmb3IoZSBpbiByW3RdPVtdLEN0W3RdKUN0W3RdLmhhc093blByb3BlcnR5KGUpJiZyW3RdLnB1c2goZSk7cmV0dXJuIHJ9LHkuYWRkRm9udD1mdW5jdGlvbih0LGUscixuLGkpe3ZhciBhPVsiU3RhbmRhcmRFbmNvZGluZyIsIk1hY1JvbWFuRW5jb2RpbmciLCJJZGVudGl0eS1IIiwiV2luQW5zaUVuY29kaW5nIl07cmV0dXJuIGFyZ3VtZW50c1szXSYmLTEhPT1hLmluZGV4T2YoYXJndW1lbnRzWzNdKT9pPWFyZ3VtZW50c1szXTphcmd1bWVudHNbM10mJi0xPT1hLmluZGV4T2YoYXJndW1lbnRzWzNdKSYmKHI9aihyLG4pKSxpPWl8fCJJZGVudGl0eS1IIixQZS5jYWxsKHRoaXMsdCxlLHIsaSl9O3ZhciBocixmcj10LmxpbmVXaWR0aHx8LjIwMDAyNSxkcj15Ll9fcHJpdmF0ZV9fLmdldExpbmVXaWR0aD15LmdldExpbmVXaWR0aD1mdW5jdGlvbigpe3JldHVybiBmcn0scHI9eS5fX3ByaXZhdGVfXy5zZXRMaW5lV2lkdGg9eS5zZXRMaW5lV2lkdGg9ZnVuY3Rpb24odCl7cmV0dXJuIGZyPXQsaHQoRShVKHQpKSsiIHciKSx0aGlzfTt5Ll9fcHJpdmF0ZV9fLnNldExpbmVEYXNoPU0uQVBJLnNldExpbmVEYXNoPU0uQVBJLnNldExpbmVEYXNoUGF0dGVybj1mdW5jdGlvbih0LGUpe2lmKHQ9dHx8W10sZT1lfHwwLGlzTmFOKGUpfHwhQXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5zZXRMaW5lRGFzaCIpO3JldHVybiB0PXQubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gRShVKHQpKX0pKS5qb2luKCIgIiksZT1FKFUoZSkpLGh0KCJbIit0KyJdICIrZSsiIGQiKSx0aGlzfTt2YXIgZ3I9eS5fX3ByaXZhdGVfXy5nZXRMaW5lSGVpZ2h0PXkuZ2V0TGluZUhlaWdodD1mdW5jdGlvbigpe3JldHVybiBndCpocn07eS5fX3ByaXZhdGVfXy5nZXRMaW5lSGVpZ2h0PXkuZ2V0TGluZUhlaWdodD1mdW5jdGlvbigpe3JldHVybiBndCpocn07dmFyIG1yPXkuX19wcml2YXRlX18uc2V0TGluZUhlaWdodEZhY3Rvcj15LnNldExpbmVIZWlnaHRGYWN0b3I9ZnVuY3Rpb24odCl7cmV0dXJuIm51bWJlciI9PXR5cGVvZih0PXR8fDEuMTUpJiYoaHI9dCksdGhpc30sdnI9eS5fX3ByaXZhdGVfXy5nZXRMaW5lSGVpZ2h0RmFjdG9yPXkuZ2V0TGluZUhlaWdodEZhY3Rvcj1mdW5jdGlvbigpe3JldHVybiBocn07bXIodC5saW5lSGVpZ2h0KTt2YXIgYnI9eS5fX3ByaXZhdGVfXy5nZXRIb3Jpem9udGFsQ29vcmRpbmF0ZT1mdW5jdGlvbih0KXtyZXR1cm4gVSh0KX0seXI9eS5fX3ByaXZhdGVfXy5nZXRWZXJ0aWNhbENvb3JkaW5hdGU9ZnVuY3Rpb24odCl7cmV0dXJuIFM9PT14LkFEVkFOQ0VEP3Q6UnRbJF0ubWVkaWFCb3gudG9wUmlnaHRZLVJ0WyRdLm1lZGlhQm94LmJvdHRvbUxlZnRZLVUodCl9LHdyPXkuX19wcml2YXRlX18uZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGVTdHJpbmc9eS5nZXRIb3Jpem9udGFsQ29vcmRpbmF0ZVN0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gRShicih0KSl9LE5yPXkuX19wcml2YXRlX18uZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nPXkuZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nPWZ1bmN0aW9uKHQpe3JldHVybiBFKHlyKHQpKX0sTHI9dC5zdHJva2VDb2xvcnx8IjAgRyI7eS5fX3ByaXZhdGVfXy5nZXRTdHJva2VDb2xvcj15LmdldERyYXdDb2xvcj1mdW5jdGlvbigpe3JldHVybiBlZShMcil9LHkuX19wcml2YXRlX18uc2V0U3Ryb2tlQ29sb3I9eS5zZXREcmF3Q29sb3I9ZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuIExyPXJlKHtjaDE6dCxjaDI6ZSxjaDM6cixjaDQ6bixwZGZDb2xvclR5cGU6ImRyYXciLHByZWNpc2lvbjoyfSksaHQoTHIpLHRoaXN9O3ZhciBBcj10LmZpbGxDb2xvcnx8IjAgZyI7eS5fX3ByaXZhdGVfXy5nZXRGaWxsQ29sb3I9eS5nZXRGaWxsQ29sb3I9ZnVuY3Rpb24oKXtyZXR1cm4gZWUoQXIpfSx5Ll9fcHJpdmF0ZV9fLnNldEZpbGxDb2xvcj15LnNldEZpbGxDb2xvcj1mdW5jdGlvbih0LGUscixuKXtyZXR1cm4gQXI9cmUoe2NoMTp0LGNoMjplLGNoMzpyLGNoNDpuLHBkZkNvbG9yVHlwZToiZmlsbCIscHJlY2lzaW9uOjJ9KSxodChBciksdGhpc307dmFyIHhyPXQudGV4dENvbG9yfHwiMCBnIixTcj15Ll9fcHJpdmF0ZV9fLmdldFRleHRDb2xvcj15LmdldFRleHRDb2xvcj1mdW5jdGlvbigpe3JldHVybiBlZSh4cil9O3kuX19wcml2YXRlX18uc2V0VGV4dENvbG9yPXkuc2V0VGV4dENvbG9yPWZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiB4cj1yZSh7Y2gxOnQsY2gyOmUsY2gzOnIsY2g0Om4scGRmQ29sb3JUeXBlOiJ0ZXh0IixwcmVjaXNpb246M30pLHRoaXN9O3ZhciBfcj10LmNoYXJTcGFjZSxQcj15Ll9fcHJpdmF0ZV9fLmdldENoYXJTcGFjZT15LmdldENoYXJTcGFjZT1mdW5jdGlvbigpe3JldHVybiBwYXJzZUZsb2F0KF9yfHwwKX07eS5fX3ByaXZhdGVfXy5zZXRDaGFyU3BhY2U9eS5zZXRDaGFyU3BhY2U9ZnVuY3Rpb24odCl7aWYoaXNOYU4odCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5zZXRDaGFyU3BhY2UiKTtyZXR1cm4gX3I9dCx0aGlzfTt2YXIga3I9MDt5LkNhcEpvaW5TdHlsZXM9ezA6MCxidXR0OjAsYnV0OjAsbWl0ZXI6MCwxOjEscm91bmQ6MSxyb3VuZGVkOjEsY2lyY2xlOjEsMjoyLHByb2plY3Rpbmc6Mixwcm9qZWN0OjIsc3F1YXJlOjIsYmV2ZWw6Mn0seS5fX3ByaXZhdGVfXy5zZXRMaW5lQ2FwPXkuc2V0TGluZUNhcD1mdW5jdGlvbih0KXt2YXIgZT15LkNhcEpvaW5TdHlsZXNbdF07aWYodm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoIkxpbmUgY2FwIHN0eWxlIG9mICciK3QrIicgaXMgbm90IHJlY29nbml6ZWQuIFNlZSBvciBleHRlbmQgLkNhcEpvaW5TdHlsZXMgcHJvcGVydHkgZm9yIHZhbGlkIHN0eWxlcyIpO3JldHVybiBrcj1lLGh0KGUrIiBKIiksdGhpc307dmFyIEZyPTA7eS5fX3ByaXZhdGVfXy5zZXRMaW5lSm9pbj15LnNldExpbmVKb2luPWZ1bmN0aW9uKHQpe3ZhciBlPXkuQ2FwSm9pblN0eWxlc1t0XTtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcigiTGluZSBqb2luIHN0eWxlIG9mICciK3QrIicgaXMgbm90IHJlY29nbml6ZWQuIFNlZSBvciBleHRlbmQgLkNhcEpvaW5TdHlsZXMgcHJvcGVydHkgZm9yIHZhbGlkIHN0eWxlcyIpO3JldHVybiBGcj1lLGh0KGUrIiBqIiksdGhpc30seS5fX3ByaXZhdGVfXy5zZXRMaW5lTWl0ZXJMaW1pdD15Ll9fcHJpdmF0ZV9fLnNldE1pdGVyTGltaXQ9eS5zZXRMaW5lTWl0ZXJMaW1pdD15LnNldE1pdGVyTGltaXQ9ZnVuY3Rpb24odCl7aWYodD10fHwwLGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuc2V0TGluZU1pdGVyTGltaXQiKTtyZXR1cm4gaHQoRShVKHQpKSsiIE0iKSx0aGlzfSx5LkdTdGF0ZT1DLHkuc2V0R1N0YXRlPWZ1bmN0aW9uKHQpeyh0PSJzdHJpbmciPT10eXBlb2YgdD9NdFtFdFt0XV06SXIobnVsbCx0KSkuZXF1YWxzKHF0KXx8KGh0KCIvIit0LmlkKyIgZ3MiKSxxdD10KX07dmFyIElyPWZ1bmN0aW9uKHQsZSl7aWYoIXR8fCFFdFt0XSl7dmFyIHI9ITE7Zm9yKHZhciBuIGluIE10KWlmKE10Lmhhc093blByb3BlcnR5KG4pJiZNdFtuXS5lcXVhbHMoZSkpe3I9ITA7YnJlYWt9aWYocillPU10W25dO2Vsc2V7dmFyIGk9IkdTIisoT2JqZWN0LmtleXMoTXQpLmxlbmd0aCsxKS50b1N0cmluZygxMCk7TXRbaV09ZSxlLmlkPWl9cmV0dXJuIHQmJihFdFt0XT1lLmlkKSxUdC5wdWJsaXNoKCJhZGRHU3RhdGUiLGUpLGV9fTt5LmFkZEdTdGF0ZT1mdW5jdGlvbih0LGUpe3JldHVybiBJcih0LGUpLHRoaXN9LHkuc2F2ZUdyYXBoaWNzU3RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gaHQoInEiKSxqdC5wdXNoKHtrZXk6U3Qsc2l6ZTpndCxjb2xvcjp4cn0pLHRoaXN9LHkucmVzdG9yZUdyYXBoaWNzU3RhdGU9ZnVuY3Rpb24oKXtodCgiUSIpO3ZhciB0PWp0LnBvcCgpO3JldHVybiBTdD10LmtleSxndD10LnNpemUseHI9dC5jb2xvcixxdD1udWxsLHRoaXN9LHkuc2V0Q3VycmVudFRyYW5zZm9ybWF0aW9uTWF0cml4PWZ1bmN0aW9uKHQpe3JldHVybiBodCh0LnRvU3RyaW5nKCkrIiBjbSIpLHRoaXN9LHkuY29tbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gaHQoIiMiK3QpLHRoaXN9O3ZhciBDcj1mdW5jdGlvbih0LGUpe3ZhciByPXR8fDA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByfSxzZXQ6ZnVuY3Rpb24odCl7aXNOYU4odCl8fChyPXBhcnNlRmxvYXQodCkpfX0pO3ZhciBuPWV8fDA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInkiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufSxzZXQ6ZnVuY3Rpb24odCl7aXNOYU4odCl8fChuPXBhcnNlRmxvYXQodCkpfX0pO3ZhciBpPSJwdCI7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0eXBlIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKHQpe2k9dC50b1N0cmluZygpfX0pLHRoaXN9LGpyPWZ1bmN0aW9uKHQsZSxyLG4pe0NyLmNhbGwodGhpcyx0LGUpLHRoaXMudHlwZT0icmVjdCI7dmFyIGk9cnx8MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidyIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGl9LHNldDpmdW5jdGlvbih0KXtpc05hTih0KXx8KGk9cGFyc2VGbG9hdCh0KSl9fSk7dmFyIGE9bnx8MDtyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImgiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBhfSxzZXQ6ZnVuY3Rpb24odCl7aXNOYU4odCl8fChhPXBhcnNlRmxvYXQodCkpfX0pLHRoaXN9LE9yPWZ1bmN0aW9uKCl7dGhpcy5wYWdlPUR0LHRoaXMuY3VycmVudFBhZ2U9JCx0aGlzLnBhZ2VzPW90LnNsaWNlKDApLHRoaXMucGFnZXNDb250ZXh0PVJ0LnNsaWNlKDApLHRoaXMueD1QdCx0aGlzLnk9a3QsdGhpcy5tYXRyaXg9RnQsdGhpcy53aWR0aD1xcigkKSx0aGlzLmhlaWdodD1ScigkKSx0aGlzLm91dHB1dERlc3RpbmF0aW9uPWN0LHRoaXMuaWQ9IiIsdGhpcy5vYmplY3ROdW1iZXI9LTF9O09yLnByb3RvdHlwZS5yZXN0b3JlPWZ1bmN0aW9uKCl7RHQ9dGhpcy5wYWdlLCQ9dGhpcy5jdXJyZW50UGFnZSxSdD10aGlzLnBhZ2VzQ29udGV4dCxvdD10aGlzLnBhZ2VzLFB0PXRoaXMueCxrdD10aGlzLnksRnQ9dGhpcy5tYXRyaXgsRHIoJCx0aGlzLndpZHRoKSxUcigkLHRoaXMuaGVpZ2h0KSxjdD10aGlzLm91dHB1dERlc3RpbmF0aW9ufTt2YXIgQnI9ZnVuY3Rpb24odCxlLHIsbixpKXtXdC5wdXNoKG5ldyBPciksRHQ9JD0wLG90PVtdLFB0PXQsa3Q9ZSxGdD1pLGplKFtyLG5dKX0sTXI9ZnVuY3Rpb24odCl7aWYoSHRbdF0pV3QucG9wKCkucmVzdG9yZSgpO2Vsc2V7dmFyIGU9bmV3IE9yLHI9IlhvIisoT2JqZWN0LmtleXMoenQpLmxlbmd0aCsxKS50b1N0cmluZygxMCk7ZS5pZD1yLEh0W3RdPXIsenRbcl09ZSxUdC5wdWJsaXNoKCJhZGRGb3JtT2JqZWN0IixlKSxXdC5wb3AoKS5yZXN0b3JlKCl9fTtmb3IodmFyIEVyIGluIHkuYmVnaW5Gb3JtT2JqZWN0PWZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIEJyKHQsZSxyLG4saSksdGhpc30seS5lbmRGb3JtT2JqZWN0PWZ1bmN0aW9uKHQpe3JldHVybiBNcih0KSx0aGlzfSx5LmRvRm9ybU9iamVjdD1mdW5jdGlvbih0LGUpe3ZhciByPXp0W0h0W3RdXTtyZXR1cm4gaHQoInEiKSxodChlLnRvU3RyaW5nKCkrIiBjbSIpLGh0KCIvIityLmlkKyIgRG8iKSxodCgiUSIpLHRoaXN9LHkuZ2V0Rm9ybU9iamVjdD1mdW5jdGlvbih0KXt2YXIgZT16dFtIdFt0XV07cmV0dXJue3g6ZS54LHk6ZS55LHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0LG1hdHJpeDplLm1hdHJpeH19LHkuc2F2ZT1mdW5jdGlvbih0LGUpe3JldHVybiB0PXR8fCJnZW5lcmF0ZWQucGRmIiwoZT1lfHx7fSkucmV0dXJuUHJvbWlzZT1lLnJldHVyblByb21pc2V8fCExLCExPT09ZS5yZXR1cm5Qcm9taXNlPyhsKFdlKEhlKCkpLHQpLCJmdW5jdGlvbiI9PXR5cGVvZiBsLnVubG9hZCYmci5zZXRUaW1lb3V0JiZzZXRUaW1lb3V0KGwudW5sb2FkLDkxMSksdGhpcyk6bmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsbil7dHJ5e3ZhciBpPWwoV2UoSGUoKSksdCk7ImZ1bmN0aW9uIj09dHlwZW9mIGwudW5sb2FkJiZyLnNldFRpbWVvdXQmJnNldFRpbWVvdXQobC51bmxvYWQsOTExKSxlKGkpfWNhdGNoKHQpe24odC5tZXNzYWdlKX19KSl9LE0uQVBJKU0uQVBJLmhhc093blByb3BlcnR5KEVyKSYmKCJldmVudHMiPT09RXImJk0uQVBJLmV2ZW50cy5sZW5ndGg/ZnVuY3Rpb24odCxlKXt2YXIgcixuLGk7Zm9yKGk9ZS5sZW5ndGgtMTstMSE9PWk7aS0tKXI9ZVtpXVswXSxuPWVbaV1bMV0sdC5zdWJzY3JpYmUuYXBwbHkodCxbcl0uY29uY2F0KCJmdW5jdGlvbiI9PXR5cGVvZiBuP1tuXTpuKSl9KFR0LE0uQVBJLmV2ZW50cyk6eVtFcl09TS5BUElbRXJdKTt2YXIgcXI9eS5nZXRQYWdlV2lkdGg9ZnVuY3Rpb24odCl7cmV0dXJuKFJ0W3Q9dHx8JF0ubWVkaWFCb3gudG9wUmlnaHRYLVJ0W3RdLm1lZGlhQm94LmJvdHRvbUxlZnRYKS9fdH0sRHI9eS5zZXRQYWdlV2lkdGg9ZnVuY3Rpb24odCxlKXtSdFt0XS5tZWRpYUJveC50b3BSaWdodFg9ZSpfdCtSdFt0XS5tZWRpYUJveC5ib3R0b21MZWZ0WH0sUnI9eS5nZXRQYWdlSGVpZ2h0PWZ1bmN0aW9uKHQpe3JldHVybihSdFt0PXR8fCRdLm1lZGlhQm94LnRvcFJpZ2h0WS1SdFt0XS5tZWRpYUJveC5ib3R0b21MZWZ0WSkvX3R9LFRyPXkuc2V0UGFnZUhlaWdodD1mdW5jdGlvbih0LGUpe1J0W3RdLm1lZGlhQm94LnRvcFJpZ2h0WT1lKl90K1J0W3RdLm1lZGlhQm94LmJvdHRvbUxlZnRZfTtyZXR1cm4geS5pbnRlcm5hbD17cGRmRXNjYXBlOkNlLGdldFN0eWxlOnRyLGdldEZvbnQ6bHIsZ2V0Rm9udFNpemU6dnQsZ2V0Q2hhclNwYWNlOlByLGdldFRleHRDb2xvcjpTcixnZXRMaW5lSGVpZ2h0OmdyLGdldExpbmVIZWlnaHRGYWN0b3I6dnIsZ2V0TGluZVdpZHRoOmRyLHdyaXRlOmZ0LGdldEhvcml6b250YWxDb29yZGluYXRlOmJyLGdldFZlcnRpY2FsQ29vcmRpbmF0ZTp5cixnZXRDb29yZGluYXRlU3RyaW5nOndyLGdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZzpOcixjb2xsZWN0aW9uczp7fSxuZXdPYmplY3Q6WHQsbmV3QWRkaXRpb25hbE9iamVjdDokdCxuZXdPYmplY3REZWZlcnJlZDpLdCxuZXdPYmplY3REZWZlcnJlZEJlZ2luOlp0LGdldEZpbHRlcnM6bmUscHV0U3RyZWFtOmllLGV2ZW50czpUdCxzY2FsZUZhY3RvcjpfdCxwYWdlU2l6ZTp7Z2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gcXIoJCl9LHNldFdpZHRoOmZ1bmN0aW9uKHQpe0RyKCQsdCl9LGdldEhlaWdodDpmdW5jdGlvbigpe3JldHVybiBScigkKX0sc2V0SGVpZ2h0OmZ1bmN0aW9uKHQpe1RyKCQsdCl9fSxlbmNyeXB0aW9uT3B0aW9uczptLGVuY3J5cHRpb246WWUsZ2V0RW5jcnlwdG9yOkplLG91dHB1dDpWZSxnZXROdW1iZXJPZlBhZ2VzOkVlLHBhZ2VzOm90LG91dDpodCxmMjpSLGYzOlQsZ2V0UGFnZUluZm86WGUsZ2V0UGFnZUluZm9CeU9iaklkOktlLGdldEN1cnJlbnRQYWdlSW5mbzpaZSxnZXRQREZWZXJzaW9uOk4sUG9pbnQ6Q3IsUmVjdGFuZ2xlOmpyLE1hdHJpeDpWdCxoYXNIb3RmaXg6R2V9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh5LmludGVybmFsLnBhZ2VTaXplLCJ3aWR0aCIse2dldDpmdW5jdGlvbigpe3JldHVybiBxcigkKX0sc2V0OmZ1bmN0aW9uKHQpe0RyKCQsdCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHkuaW50ZXJuYWwucGFnZVNpemUsImhlaWdodCIse2dldDpmdW5jdGlvbigpe3JldHVybiBScigkKX0sc2V0OmZ1bmN0aW9uKHQpe1RyKCQsdCl9LGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwfSksa2UuY2FsbCh5LHB0KSxTdD0iRjEiLE9lKHMsYSksVHQucHVibGlzaCgiaW5pdGlhbGl6ZWQiKSx5fWsucHJvdG90eXBlLmxzYkZpcnN0V29yZD1mdW5jdGlvbih0KXtyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0Pj4wJjI1NSx0Pj44JjI1NSx0Pj4xNiYyNTUsdD4+MjQmMjU1KX0say5wcm90b3R5cGUudG9IZXhTdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQoIiIpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuKCIwIisoMjU1JnQuY2hhckNvZGVBdCgwKSkudG9TdHJpbmcoMTYpKS5zbGljZSgtMil9KSkuam9pbigiIil9LGsucHJvdG90eXBlLmhleFRvQnl0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MDtyPHQubGVuZ3RoO3IrPTIpZS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQodC5zdWJzdHIociwyKSwxNikpKTtyZXR1cm4gZS5qb2luKCIiKX0say5wcm90b3R5cGUucHJvY2Vzc093bmVyUGFzc3dvcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gXyhBKGUpLnN1YnN0cigwLDUpLHQpfSxrLnByb3RvdHlwZS5lbmNyeXB0b3I9ZnVuY3Rpb24odCxlKXt2YXIgcj1BKHRoaXMuZW5jcnlwdGlvbktleStTdHJpbmcuZnJvbUNoYXJDb2RlKDI1NSZ0LHQ+PjgmMjU1LHQ+PjE2JjI1NSwyNTUmZSxlPj44JjI1NSkpLnN1YnN0cigwLDEwKTtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIF8ocix0KX19LEMucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih0KXt2YXIgcixuPSJpZCxvYmplY3ROdW1iZXIsZXF1YWxzIjtpZighdHx8ZSh0KSE9PWUodGhpcykpcmV0dXJuITE7dmFyIGk9MDtmb3IociBpbiB0aGlzKWlmKCEobi5pbmRleE9mKHIpPj0wKSl7aWYodGhpcy5oYXNPd25Qcm9wZXJ0eShyKSYmIXQuaGFzT3duUHJvcGVydHkocikpcmV0dXJuITE7aWYodGhpc1tyXSE9PXRbcl0pcmV0dXJuITE7aSsrfWZvcihyIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmbi5pbmRleE9mKHIpPDAmJmktLTtyZXR1cm4gMD09PWl9LE0uQVBJPXtldmVudHM6W119LE0udmVyc2lvbj0iMi41LjEiO3ZhciBFPU0uQVBJLHE9MSxEPWZ1bmN0aW9uKHQpe3JldHVybiB0LnJlcGxhY2UoL1xcL2csIlxcXFwiKS5yZXBsYWNlKC9cKC9nLCJcXCgiKS5yZXBsYWNlKC9cKS9nLCJcXCkiKX0sUj1mdW5jdGlvbih0KXtyZXR1cm4gdC5yZXBsYWNlKC9cXFxcL2csIlxcIikucmVwbGFjZSgvXFxcKC9nLCIoIikucmVwbGFjZSgvXFxcKS9nLCIpIil9LFQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQudG9GaXhlZCgyKX0sVT1mdW5jdGlvbih0KXtyZXR1cm4gdC50b0ZpeGVkKDUpfTtFLl9fYWNyb2Zvcm1fXz17fTt2YXIgej1mdW5jdGlvbih0LGUpe3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLHQucHJvdG90eXBlLmNvbnN0cnVjdG9yPXR9LEg9ZnVuY3Rpb24odCl7cmV0dXJuIHQqcX0sVz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgY3Qscj1MdC5pbnRlcm5hbC5nZXRIZWlnaHQodCl8fDAsbj1MdC5pbnRlcm5hbC5nZXRXaWR0aCh0KXx8MDtyZXR1cm4gZS5CQm94PVswLDAsTnVtYmVyKFQobikpLE51bWJlcihUKHIpKV0sZX0sVj1FLl9fYWNyb2Zvcm1fXy5zZXRCaXQ9ZnVuY3Rpb24odCxlKXtpZih0PXR8fDAsZT1lfHwwLGlzTmFOKHQpfHxpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5BUEkuX19hY3JvZm9ybV9fLnNldEJpdCIpO3JldHVybiB0fD0xPDxlfSxHPUUuX19hY3JvZm9ybV9fLmNsZWFyQml0PWZ1bmN0aW9uKHQsZSl7aWYodD10fHwwLGU9ZXx8MCxpc05hTih0KXx8aXNOYU4oZSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuQVBJLl9fYWNyb2Zvcm1fXy5jbGVhckJpdCIpO3JldHVybiB0Jj1+KDE8PGUpfSxZPUUuX19hY3JvZm9ybV9fLmdldEJpdD1mdW5jdGlvbih0LGUpe2lmKGlzTmFOKHQpfHxpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5BUEkuX19hY3JvZm9ybV9fLmdldEJpdCIpO3JldHVybiAwPT0odCYxPDxlKT8wOjF9LEo9RS5fX2Fjcm9mb3JtX18uZ2V0Qml0Rm9yUGRmPWZ1bmN0aW9uKHQsZSl7aWYoaXNOYU4odCl8fGlzTmFOKGUpKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLkFQSS5fX2Fjcm9mb3JtX18uZ2V0Qml0Rm9yUGRmIik7cmV0dXJuIFkodCxlLTEpfSxYPUUuX19hY3JvZm9ybV9fLnNldEJpdEZvclBkZj1mdW5jdGlvbih0LGUpe2lmKGlzTmFOKHQpfHxpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5BUEkuX19hY3JvZm9ybV9fLnNldEJpdEZvclBkZiIpO3JldHVybiBWKHQsZS0xKX0sSz1FLl9fYWNyb2Zvcm1fXy5jbGVhckJpdEZvclBkZj1mdW5jdGlvbih0LGUpe2lmKGlzTmFOKHQpfHxpc05hTihlKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5BUEkuX19hY3JvZm9ybV9fLmNsZWFyQml0Rm9yUGRmIik7cmV0dXJuIEcodCxlLTEpfSxaPUUuX19hY3JvZm9ybV9fLmNhbGN1bGF0ZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS5pbnRlcm5hbC5nZXRIb3Jpem9udGFsQ29vcmRpbmF0ZSxuPWUuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlLGk9dFswXSxhPXRbMV0sbz10WzJdLHM9dFszXSxjPXt9O3JldHVybiBjLmxvd2VyTGVmdF9YPXIoaSl8fDAsYy5sb3dlckxlZnRfWT1uKGErcyl8fDAsYy51cHBlclJpZ2h0X1g9cihpK28pfHwwLGMudXBwZXJSaWdodF9ZPW4oYSl8fDAsW051bWJlcihUKGMubG93ZXJMZWZ0X1gpKSxOdW1iZXIoVChjLmxvd2VyTGVmdF9ZKSksTnVtYmVyKFQoYy51cHBlclJpZ2h0X1gpKSxOdW1iZXIoVChjLnVwcGVyUmlnaHRfWSkpXX0sJD1mdW5jdGlvbih0KXtpZih0LmFwcGVhcmFuY2VTdHJlYW1Db250ZW50KXJldHVybiB0LmFwcGVhcmFuY2VTdHJlYW1Db250ZW50O2lmKHQuVnx8dC5EVil7dmFyIGU9W10scj10Ll9WfHx0LkRWLG49USh0LHIpLGk9dC5zY29wZS5pbnRlcm5hbC5nZXRGb250KHQuZm9udE5hbWUsdC5mb250U3R5bGUpLmlkO2UucHVzaCgiL1R4IEJNQyIpLGUucHVzaCgicSIpLGUucHVzaCgiQlQiKSxlLnB1c2godC5zY29wZS5fX3ByaXZhdGVfXy5lbmNvZGVDb2xvclN0cmluZyh0LmNvbG9yKSksZS5wdXNoKCIvIitpKyIgIitUKG4uZm9udFNpemUpKyIgVGYiKSxlLnB1c2goIjEgMCAwIDEgMCAwIFRtIiksZS5wdXNoKG4udGV4dCksZS5wdXNoKCJFVCIpLGUucHVzaCgiUSIpLGUucHVzaCgiRU1DIik7dmFyIGE9Vyh0KTtyZXR1cm4gYS5zY29wZT10LnNjb3BlLGEuc3RyZWFtPWUuam9pbigiXG4iKSxhfX0sUT1mdW5jdGlvbih0LGUpe3ZhciByPTA9PT10LmZvbnRTaXplP3QubWF4Rm9udFNpemU6dC5mb250U2l6ZSxuPXt0ZXh0OiIiLGZvbnRTaXplOiIifSxpPShlPSIpIj09KGU9IigiPT1lLnN1YnN0cigwLDEpP2Uuc3Vic3RyKDEpOmUpLnN1YnN0cihlLmxlbmd0aC0xKT9lLnN1YnN0cigwLGUubGVuZ3RoLTEpOmUpLnNwbGl0KCIgIik7aT10Lm11bHRpbGluZT9pLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuc3BsaXQoIlxuIil9KSk6aS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVyblt0XX0pKTt2YXIgYT1yLG89THQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpfHwwO289bzwwPy1vOm87dmFyIHM9THQuaW50ZXJuYWwuZ2V0V2lkdGgodCl8fDA7cz1zPDA/LXM6czt2YXIgYz1mdW5jdGlvbihlLHIsbil7aWYoZSsxPGkubGVuZ3RoKXt2YXIgYT1yKyIgIitpW2UrMV1bMF07cmV0dXJuIHR0KGEsdCxuKS53aWR0aDw9cy00fXJldHVybiExfTthKys7dDpmb3IoO2E+MDspe2U9IiIsYS0tO3ZhciB1LGwsaD10dCgiMyIsdCxhKS5oZWlnaHQsZj10Lm11bHRpbGluZT9vLWE6KG8taCkvMixkPWYrPTIscD0wLGc9MCxtPTA7aWYoYTw9MCl7ZT0iKC4uLikgVGpcbiIsZSs9IiUgV2lkdGggb2YgVGV4dDogIit0dChlLHQsYT0xMikud2lkdGgrIiwgRmllbGRXaWR0aDoiK3MrIlxuIjticmVha31mb3IodmFyIHY9IiIsYj0wLHk9MDt5PGkubGVuZ3RoO3krKylpZihpLmhhc093blByb3BlcnR5KHkpKXt2YXIgdz0hMTtpZigxIT09aVt5XS5sZW5ndGgmJm0hPT1pW3ldLmxlbmd0aC0xKXtpZigoaCsyKSooYisyKSsyPm8pY29udGludWUgdDt2Kz1pW3ldW21dLHc9ITAsZz15LHktLX1lbHNle3Y9IiAiPT0odis9aVt5XVttXSsiICIpLnN1YnN0cih2Lmxlbmd0aC0xKT92LnN1YnN0cigwLHYubGVuZ3RoLTEpOnY7dmFyIE49cGFyc2VJbnQoeSksTD1jKE4sdixhKSxBPXk+PWkubGVuZ3RoLTE7aWYoTCYmIUEpe3YrPSIgIixtPTA7Y29udGludWV9aWYoTHx8QSl7aWYoQSlnPU47ZWxzZSBpZih0Lm11bHRpbGluZSYmKGgrMikqKGIrMikrMj5vKWNvbnRpbnVlIHR9ZWxzZXtpZighdC5tdWx0aWxpbmUpY29udGludWUgdDtpZigoaCsyKSooYisyKSsyPm8pY29udGludWUgdDtnPU59fWZvcih2YXIgeD0iIixTPXA7Uzw9ZztTKyspe3ZhciBfPWlbU107aWYodC5tdWx0aWxpbmUpe2lmKFM9PT1nKXt4Kz1fW21dKyIgIixtPShtKzEpJV8ubGVuZ3RoO2NvbnRpbnVlfWlmKFM9PT1wKXt4Kz1fW18ubGVuZ3RoLTFdKyIgIjtjb250aW51ZX19eCs9X1swXSsiICJ9c3dpdGNoKHg9IiAiPT14LnN1YnN0cih4Lmxlbmd0aC0xKT94LnN1YnN0cigwLHgubGVuZ3RoLTEpOngsbD10dCh4LHQsYSkud2lkdGgsdC50ZXh0QWxpZ24pe2Nhc2UicmlnaHQiOnU9cy1sLTI7YnJlYWs7Y2FzZSJjZW50ZXIiOnU9KHMtbCkvMjticmVhaztjYXNlImxlZnQiOmRlZmF1bHQ6dT0yfWUrPVQodSkrIiAiK1QoZCkrIiBUZFxuIixlKz0iKCIrRCh4KSsiKSBUalxuIixlKz0tVCh1KSsiIDAgVGRcbiIsZD0tKGErMiksbD0wLHA9dz9nOmcrMSxiKyssdj0iIn1lbHNlO2JyZWFrfXJldHVybiBuLnRleHQ9ZSxuLmZvbnRTaXplPWEsbn0sdHQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWUuc2NvcGUuaW50ZXJuYWwuZ2V0Rm9udChlLmZvbnROYW1lLGUuZm9udFN0eWxlKSxpPWUuc2NvcGUuZ2V0U3RyaW5nVW5pdFdpZHRoKHQse2ZvbnQ6bixmb250U2l6ZTpwYXJzZUZsb2F0KHIpLGNoYXJTcGFjZTowfSkqcGFyc2VGbG9hdChyKTtyZXR1cm57aGVpZ2h0OmUuc2NvcGUuZ2V0U3RyaW5nVW5pdFdpZHRoKCIzIix7Zm9udDpuLGZvbnRTaXplOnBhcnNlRmxvYXQociksY2hhclNwYWNlOjB9KSpwYXJzZUZsb2F0KHIpKjEuNSx3aWR0aDppfX0sZXQ9e2ZpZWxkczpbXSx4Rm9ybXM6W10sYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdDpudWxsLHByaW50ZWRPdXQ6ITEsaW50ZXJuYWw6bnVsbCxpc0luaXRpYWxpemVkOiExfSxydD1mdW5jdGlvbih0LGUpe3ZhciByPXt0eXBlOiJyZWZlcmVuY2UiLG9iamVjdDp0fTt2b2lkIDA9PT1lLmludGVybmFsLmdldFBhZ2VJbmZvKHQucGFnZSkucGFnZUNvbnRleHQuYW5ub3RhdGlvbnMuZmluZCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZT09PXIudHlwZSYmdC5vYmplY3Q9PT1yLm9iamVjdH0pKSYmZS5pbnRlcm5hbC5nZXRQYWdlSW5mbyh0LnBhZ2UpLnBhZ2VDb250ZXh0LmFubm90YXRpb25zLnB1c2gocil9LG50PWZ1bmN0aW9uKHQscil7Zm9yKHZhciBuIGluIHQpaWYodC5oYXNPd25Qcm9wZXJ0eShuKSl7dmFyIGk9bixhPXRbbl07ci5pbnRlcm5hbC5uZXdPYmplY3REZWZlcnJlZEJlZ2luKGEub2JqSWQsITApLCJvYmplY3QiPT09ZShhKSYmImZ1bmN0aW9uIj09dHlwZW9mIGEucHV0U3RyZWFtJiZhLnB1dFN0cmVhbSgpLGRlbGV0ZSB0W2ldfX0saXQ9ZnVuY3Rpb24odCxyKXtpZihyLnNjb3BlPXQsdm9pZCAwIT09dC5pbnRlcm5hbCYmKHZvaWQgMD09PXQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW58fCExPT09dC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5pc0luaXRpYWxpemVkKSl7aWYobHQuRmllbGROdW09MCx0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZXQpKSx0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QpdGhyb3cgbmV3IEVycm9yKCJFeGNlcHRpb24gd2hpbGUgY3JlYXRpbmcgQWNyb2Zvcm1EaWN0aW9uYXJ5Iik7cT10LmludGVybmFsLnNjYWxlRmFjdG9yLHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdD1uZXcgdXQsdC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290LnNjb3BlPXQsdC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290Ll9ldmVudElEPXQuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicG9zdFB1dFJlc291cmNlcyIsKGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKHQpe3QuaW50ZXJuYWwuZXZlbnRzLnVuc3Vic2NyaWJlKHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5fZXZlbnRJRCksZGVsZXRlIHQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5fZXZlbnRJRCx0LmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnByaW50ZWRPdXQ9ITB9KHQpfSkpLHQuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgiYnVpbGREb2N1bWVudCIsKGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKHQpe3QuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5vYmpJZD12b2lkIDA7dmFyIGU9dC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290LkZpZWxkcztmb3IodmFyIHIgaW4gZSlpZihlLmhhc093blByb3BlcnR5KHIpKXt2YXIgbj1lW3JdO24ub2JqSWQ9dm9pZCAwLG4uaGFzQW5ub3RhdGlvbiYmcnQobix0KX19KHQpfSkpLHQuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicHV0Q2F0YWxvZyIsKGZ1bmN0aW9uKCl7IWZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdCl0aHJvdyBuZXcgRXJyb3IoInB1dENhdGFsb2dDYWxsYmFjazogUm9vdCBtaXNzaW5nLiIpO3QuaW50ZXJuYWwud3JpdGUoIi9BY3JvRm9ybSAiK3QuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5vYmpJZCsiIDAgUiIpfSh0KX0pKSx0LmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInBvc3RQdXRQYWdlcyIsKGZ1bmN0aW9uKHIpeyFmdW5jdGlvbih0LHIpe3ZhciBuPSF0O2Zvcih2YXIgaSBpbiB0fHwoci5pbnRlcm5hbC5uZXdPYmplY3REZWZlcnJlZEJlZ2luKHIuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5vYmpJZCwhMCksci5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5hY3JvRm9ybURpY3Rpb25hcnlSb290LnB1dFN0cmVhbSgpKSx0PXR8fHIuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdC5LaWRzKWlmKHQuaGFzT3duUHJvcGVydHkoaSkpe3ZhciBhPXRbaV0sbz1bXSxzPWEuUmVjdDtpZihhLlJlY3QmJihhLlJlY3Q9WihhLlJlY3QscikpLHIuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWRCZWdpbihhLm9iaklkLCEwKSxhLkRBPUx0LmNyZWF0ZURlZmF1bHRBcHBlYXJhbmNlU3RyZWFtKGEpLCJvYmplY3QiPT09ZShhKSYmImZ1bmN0aW9uIj09dHlwZW9mIGEuZ2V0S2V5VmFsdWVMaXN0Rm9yU3RyZWFtJiYobz1hLmdldEtleVZhbHVlTGlzdEZvclN0cmVhbSgpKSxhLlJlY3Q9cyxhLmhhc0FwcGVhcmFuY2VTdHJlYW0mJiFhLmFwcGVhcmFuY2VTdHJlYW1Db250ZW50KXt2YXIgYz0kKGEpO28ucHVzaCh7a2V5OiJBUCIsdmFsdWU6Ijw8L04gIitjKyI+PiJ9KSxyLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLnhGb3Jtcy5wdXNoKGMpfWlmKGEuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQpe3ZhciB1PSIiO2Zvcih2YXIgbCBpbiBhLmFwcGVhcmFuY2VTdHJlYW1Db250ZW50KWlmKGEuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQuaGFzT3duUHJvcGVydHkobCkpe3ZhciBoPWEuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnRbbF07aWYodSs9Ii8iK2wrIiAiLHUrPSI8PCIsT2JqZWN0LmtleXMoaCkubGVuZ3RoPj0xfHxBcnJheS5pc0FycmF5KGgpKXtmb3IodmFyIGkgaW4gaClpZihoLmhhc093blByb3BlcnR5KGkpKXt2YXIgZj1oW2ldOyJmdW5jdGlvbiI9PXR5cGVvZiBmJiYoZj1mLmNhbGwocixhKSksdSs9Ii8iK2krIiAiK2YrIiAiLHIuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLmluZGV4T2YoZik+PTB8fHIuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLnB1c2goZil9fWVsc2UiZnVuY3Rpb24iPT10eXBlb2YoZj1oKSYmKGY9Zi5jYWxsKHIsYSkpLHUrPSIvIitpKyIgIitmLHIuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLmluZGV4T2YoZik+PTB8fHIuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4ueEZvcm1zLnB1c2goZik7dSs9Ij4+In1vLnB1c2goe2tleToiQVAiLHZhbHVlOiI8PFxuIit1KyI+PiJ9KX1yLmludGVybmFsLnB1dFN0cmVhbSh7YWRkaXRpb25hbEtleVZhbHVlczpvLG9iamVjdElkOmEub2JqSWR9KSxyLmludGVybmFsLm91dCgiZW5kb2JqIil9biYmbnQoci5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi54Rm9ybXMscil9KHIsdCl9KSksdC5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5pc0luaXRpYWxpemVkPSEwfX0sYXQ9RS5fX2Fjcm9mb3JtX18uYXJyYXlUb1BkZkFycmF5PWZ1bmN0aW9uKHQscixuKXt2YXIgaT1mdW5jdGlvbih0KXtyZXR1cm4gdH07aWYoQXJyYXkuaXNBcnJheSh0KSl7Zm9yKHZhciBhPSJbIixvPTA7bzx0Lmxlbmd0aDtvKyspc3dpdGNoKDAhPT1vJiYoYSs9IiAiKSxlKHRbb10pKXtjYXNlImJvb2xlYW4iOmNhc2UibnVtYmVyIjpjYXNlIm9iamVjdCI6YSs9dFtvXS50b1N0cmluZygpO2JyZWFrO2Nhc2Uic3RyaW5nIjoiLyIhPT10W29dLnN1YnN0cigwLDEpPyh2b2lkIDAhPT1yJiZuJiYoaT1uLmludGVybmFsLmdldEVuY3J5cHRvcihyKSksYSs9IigiK0QoaSh0W29dLnRvU3RyaW5nKCkpKSsiKSIpOmErPXRbb10udG9TdHJpbmcoKX1yZXR1cm4gYSs9Il0ifXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgdG8ganNQREYuX19hY3JvZm9ybV9fLmFycmF5VG9QZGZBcnJheSIpfTt2YXIgb3Q9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWZ1bmN0aW9uKHQpe3JldHVybiB0fTtyZXR1cm4gdm9pZCAwIT09ZSYmciYmKG49ci5pbnRlcm5hbC5nZXRFbmNyeXB0b3IoZSkpLCh0PXR8fCIiKS50b1N0cmluZygpLHQ9IigiK0Qobih0KSkrIikifSxzdD1mdW5jdGlvbigpe3RoaXMuX29iaklkPXZvaWQgMCx0aGlzLl9zY29wZT12b2lkIDAsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm9iaklkIix7Z2V0OmZ1bmN0aW9uKCl7aWYodm9pZCAwPT09dGhpcy5fb2JqSWQpe2lmKHZvaWQgMD09PXRoaXMuc2NvcGUpcmV0dXJuO3RoaXMuX29iaklkPXRoaXMuc2NvcGUuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWQoKX1yZXR1cm4gdGhpcy5fb2JqSWR9LHNldDpmdW5jdGlvbih0KXt0aGlzLl9vYmpJZD10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzY29wZSIse3ZhbHVlOnRoaXMuX3Njb3BlLHdyaXRhYmxlOiEwfSl9O3N0LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9iaklkKyIgMCBSIn0sc3QucHJvdG90eXBlLnB1dFN0cmVhbT1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0S2V5VmFsdWVMaXN0Rm9yU3RyZWFtKCk7dGhpcy5zY29wZS5pbnRlcm5hbC5wdXRTdHJlYW0oe2RhdGE6dGhpcy5zdHJlYW0sYWRkaXRpb25hbEtleVZhbHVlczp0LG9iamVjdElkOnRoaXMub2JqSWR9KSx0aGlzLnNjb3BlLmludGVybmFsLm91dCgiZW5kb2JqIil9LHN0LnByb3RvdHlwZS5nZXRLZXlWYWx1ZUxpc3RGb3JTdHJlYW09ZnVuY3Rpb24oKXt2YXIgdD1bXSxlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuImNvbnRlbnQiIT10JiYiYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQiIT10JiYic2NvcGUiIT10JiYib2JqSWQiIT10JiYiXyIhPXQuc3Vic3RyaW5nKDAsMSl9KSk7Zm9yKHZhciByIGluIGUpaWYoITE9PT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsZVtyXSkuY29uZmlndXJhYmxlKXt2YXIgbj1lW3JdLGk9dGhpc1tuXTtpJiYoQXJyYXkuaXNBcnJheShpKT90LnB1c2goe2tleTpuLHZhbHVlOmF0KGksdGhpcy5vYmpJZCx0aGlzLnNjb3BlKX0pOmkgaW5zdGFuY2VvZiBzdD8oaS5zY29wZT10aGlzLnNjb3BlLHQucHVzaCh7a2V5Om4sdmFsdWU6aS5vYmpJZCsiIDAgUiJ9KSk6ImZ1bmN0aW9uIiE9dHlwZW9mIGkmJnQucHVzaCh7a2V5Om4sdmFsdWU6aX0pKX1yZXR1cm4gdH07dmFyIGN0PWZ1bmN0aW9uKCl7c3QuY2FsbCh0aGlzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiVHlwZSIse3ZhbHVlOiIvWE9iamVjdCIsY29uZmlndXJhYmxlOiExLHdyaXRhYmxlOiEwfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlN1YnR5cGUiLHt2YWx1ZToiL0Zvcm0iLGNvbmZpZ3VyYWJsZTohMSx3cml0YWJsZTohMH0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJGb3JtVHlwZSIse3ZhbHVlOjEsY29uZmlndXJhYmxlOiExLHdyaXRhYmxlOiEwfSk7dmFyIHQsZT1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiQkJveCIse2NvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX0sc2V0OmZ1bmN0aW9uKHQpe2U9dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiUmVzb3VyY2VzIix7dmFsdWU6IjIgMCBSIixjb25maWd1cmFibGU6ITEsd3JpdGFibGU6ITB9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywic3RyZWFtIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsc2V0OmZ1bmN0aW9uKGUpe3Q9ZS50cmltKCl9LGdldDpmdW5jdGlvbigpe3JldHVybiB0fHxudWxsfX0pfTt6KGN0LHN0KTt2YXIgdXQ9ZnVuY3Rpb24oKXtzdC5jYWxsKHRoaXMpO3ZhciB0LGU9W107T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIktpZHMiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZS5sZW5ndGg+MD9lOnZvaWQgMH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiRmllbGRzIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkRBIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7aWYodCl7dmFyIGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9O3JldHVybiB0aGlzLnNjb3BlJiYoZT10aGlzLnNjb3BlLmludGVybmFsLmdldEVuY3J5cHRvcih0aGlzLm9iaklkKSksIigiK0QoZSh0KSkrIikifX0sc2V0OmZ1bmN0aW9uKGUpe3Q9ZX19KX07eih1dCxzdCk7dmFyIGx0PWZ1bmN0aW9uIHQoKXtzdC5jYWxsKHRoaXMpO3ZhciBlPTQ7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkYiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX0sc2V0OmZ1bmN0aW9uKHQpe2lmKGlzTmFOKHQpKXRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAiJyt0KyciIGZvciBhdHRyaWJ1dGUgRiBzdXBwbGllZC4nKTtlPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNob3dXaGVuUHJpbnRlZCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKEooZSwzKSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GPVgoZSwzKTp0aGlzLkY9SyhlLDMpfX0pO3ZhciByPTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkZmIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbih0KXtpZihpc05hTih0KSl0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgIicrdCsnIiBmb3IgYXR0cmlidXRlIEZmIHN1cHBsaWVkLicpO3I9dH19KTt2YXIgbj1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiUmVjdCIse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe2lmKDAhPT1uLmxlbmd0aClyZXR1cm4gbn0sc2V0OmZ1bmN0aW9uKHQpe249dm9pZCAwIT09dD90OltdfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ4Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIW58fGlzTmFOKG5bMF0pPzA6blswXX0sc2V0OmZ1bmN0aW9uKHQpe25bMF09dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiFufHxpc05hTihuWzFdKT8wOm5bMV19LHNldDpmdW5jdGlvbih0KXtuWzFdPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIndpZHRoIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIW58fGlzTmFOKG5bMl0pPzA6blsyXX0sc2V0OmZ1bmN0aW9uKHQpe25bMl09dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaGVpZ2h0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIW58fGlzTmFOKG5bM10pPzA6blszXX0sc2V0OmZ1bmN0aW9uKHQpe25bM109dH19KTt2YXIgaT0iIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiRlQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaX0sc2V0OmZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIi9CdG4iOmNhc2UiL1R4IjpjYXNlIi9DaCI6Y2FzZSIvU2lnIjppPXQ7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgIicrdCsnIiBmb3IgYXR0cmlidXRlIEZUIHN1cHBsaWVkLicpfX19KTt2YXIgYT1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJUIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7aWYoIWF8fGEubGVuZ3RoPDEpe2lmKHRoaXMgaW5zdGFuY2VvZiBidClyZXR1cm47YT0iRmllbGRPYmplY3QiK3QuRmllbGROdW0rK312YXIgZT1mdW5jdGlvbih0KXtyZXR1cm4gdH07cmV0dXJuIHRoaXMuc2NvcGUmJihlPXRoaXMuc2NvcGUuaW50ZXJuYWwuZ2V0RW5jcnlwdG9yKHRoaXMub2JqSWQpKSwiKCIrRChlKGEpKSsiKSJ9LHNldDpmdW5jdGlvbih0KXthPXQudG9TdHJpbmcoKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZmllbGROYW1lIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGF9LHNldDpmdW5jdGlvbih0KXthPXR9fSk7dmFyIG89ImhlbHZldGljYSI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZvbnROYW1lIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99LHNldDpmdW5jdGlvbih0KXtvPXR9fSk7dmFyIHM9Im5vcm1hbCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZvbnRTdHlsZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBzfSxzZXQ6ZnVuY3Rpb24odCl7cz10fX0pO3ZhciBjPTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZvbnRTaXplIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGN9LHNldDpmdW5jdGlvbih0KXtjPXR9fSk7dmFyIHU9dm9pZCAwO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtYXhGb250U2l6ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB2b2lkIDA9PT11PzUwL3E6dX0sc2V0OmZ1bmN0aW9uKHQpe3U9dH19KTt2YXIgbD0iYmxhY2siO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb2xvciIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBsfSxzZXQ6ZnVuY3Rpb24odCl7bD10fX0pO3ZhciBoPSIvRjEgMCBUZiAwIGciO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJEQSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe2lmKCEoIWh8fHRoaXMgaW5zdGFuY2VvZiBidHx8dGhpcyBpbnN0YW5jZW9mIHd0KSlyZXR1cm4gb3QoaCx0aGlzLm9iaklkLHRoaXMuc2NvcGUpfSxzZXQ6ZnVuY3Rpb24odCl7dD10LnRvU3RyaW5nKCksaD10fX0pO3ZhciBmPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkRWIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7aWYoZilyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGd0PT0hMT9vdChmLHRoaXMub2JqSWQsdGhpcy5zY29wZSk6Zn0sc2V0OmZ1bmN0aW9uKHQpe3Q9dC50b1N0cmluZygpLGY9dGhpcyBpbnN0YW5jZW9mIGd0PT0hMT8iKCI9PT10LnN1YnN0cigwLDEpP1IodC5zdWJzdHIoMSx0Lmxlbmd0aC0yKSk6Uih0KTp0fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJkZWZhdWx0VmFsdWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGd0PT0hMD9SKGYuc3Vic3RyKDEsZi5sZW5ndGgtMSkpOmZ9LHNldDpmdW5jdGlvbih0KXt0PXQudG9TdHJpbmcoKSxmPXRoaXMgaW5zdGFuY2VvZiBndD09ITA/Ii8iK3Q6dH19KTt2YXIgZD1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJfViIse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe2lmKGQpcmV0dXJuIGR9LHNldDpmdW5jdGlvbih0KXt0aGlzLlY9dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiViIse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe2lmKGQpcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBndD09ITE/b3QoZCx0aGlzLm9iaklkLHRoaXMuc2NvcGUpOmR9LHNldDpmdW5jdGlvbih0KXt0PXQudG9TdHJpbmcoKSxkPXRoaXMgaW5zdGFuY2VvZiBndD09ITE/IigiPT09dC5zdWJzdHIoMCwxKT9SKHQuc3Vic3RyKDEsdC5sZW5ndGgtMikpOlIodCk6dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidmFsdWUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGd0PT0hMD9SKGQuc3Vic3RyKDEsZC5sZW5ndGgtMSkpOmR9LHNldDpmdW5jdGlvbih0KXt0PXQudG9TdHJpbmcoKSxkPXRoaXMgaW5zdGFuY2VvZiBndD09ITA/Ii8iK3Q6dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiaGFzQW5ub3RhdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLlJlY3R9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNBbm5vdGF0aW9uPyIvQW5ub3QiOm51bGx9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlN1YnR5cGUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNBbm5vdGF0aW9uPyIvV2lkZ2V0IjpudWxsfX0pO3ZhciBwLGc9ITE7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImhhc0FwcGVhcmFuY2VTdHJlYW0iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZ30sc2V0OmZ1bmN0aW9uKHQpe3Q9Qm9vbGVhbih0KSxnPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhZ2UiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtpZihwKXJldHVybiBwfSxzZXQ6ZnVuY3Rpb24odCl7cD10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyZWFkT25seSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKEoodGhpcy5GZiwxKSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMSk6dGhpcy5GZj1LKHRoaXMuRmYsMSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInJlcXVpcmVkIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDIpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwyKTp0aGlzLkZmPUsodGhpcy5GZiwyKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibm9FeHBvcnQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMykpfSxzZXQ6ZnVuY3Rpb24odCl7ITA9PT1Cb29sZWFuKHQpP3RoaXMuRmY9WCh0aGlzLkZmLDMpOnRoaXMuRmY9Syh0aGlzLkZmLDMpfX0pO3ZhciBtPW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlEiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtpZihudWxsIT09bSlyZXR1cm4gbX0sc2V0OmZ1bmN0aW9uKHQpe2lmKC0xPT09WzAsMSwyXS5pbmRleE9mKHQpKXRocm93IG5ldyBFcnJvcignSW52YWxpZCB2YWx1ZSAiJyt0KyciIGZvciBhdHRyaWJ1dGUgUSBzdXBwbGllZC4nKTttPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRleHRBbGlnbiIse2dldDpmdW5jdGlvbigpe3ZhciB0O3N3aXRjaChtKXtjYXNlIDA6ZGVmYXVsdDp0PSJsZWZ0IjticmVhaztjYXNlIDE6dD0iY2VudGVyIjticmVhaztjYXNlIDI6dD0icmlnaHQifXJldHVybiB0fSxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxzZXQ6ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UicmlnaHQiOmNhc2UgMjptPTI7YnJlYWs7Y2FzZSJjZW50ZXIiOmNhc2UgMTptPTE7YnJlYWs7Y2FzZSJsZWZ0IjpjYXNlIDA6ZGVmYXVsdDptPTB9fX0pfTt6KGx0LHN0KTt2YXIgaHQ9ZnVuY3Rpb24oKXtsdC5jYWxsKHRoaXMpLHRoaXMuRlQ9Ii9DaCIsdGhpcy5WPSIoKSIsdGhpcy5mb250TmFtZT0iemFwZmRpbmdiYXRzIjt2YXIgdD0wO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJUSSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0fSxzZXQ6ZnVuY3Rpb24oZSl7dD1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0b3BJbmRleCIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0fSxzZXQ6ZnVuY3Rpb24oZSl7dD1lfX0pO3ZhciBlPVtdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJPcHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYXQoZSx0aGlzLm9iaklkLHRoaXMuc2NvcGUpfSxzZXQ6ZnVuY3Rpb24odCl7dmFyIHIsbjtuPVtdLCJzdHJpbmciPT10eXBlb2Yocj10KSYmKG49ZnVuY3Rpb24odCxlLHIpe3J8fChyPTEpO2Zvcih2YXIgbixpPVtdO249ZS5leGVjKHQpOylpLnB1c2gobltyXSk7cmV0dXJuIGl9KHIsL1woKC4qPylcKS9nKSksZT1ufX0pLHRoaXMuZ2V0T3B0aW9ucz1mdW5jdGlvbigpe3JldHVybiBlfSx0aGlzLnNldE9wdGlvbnM9ZnVuY3Rpb24odCl7ZT10LHRoaXMuc29ydCYmZS5zb3J0KCl9LHRoaXMuYWRkT3B0aW9uPWZ1bmN0aW9uKHQpe3Q9KHQ9dHx8IiIpLnRvU3RyaW5nKCksZS5wdXNoKHQpLHRoaXMuc29ydCYmZS5zb3J0KCl9LHRoaXMucmVtb3ZlT3B0aW9uPWZ1bmN0aW9uKHQscil7Zm9yKHI9cnx8ITEsdD0odD10fHwiIikudG9TdHJpbmcoKTstMSE9PWUuaW5kZXhPZih0KSYmKGUuc3BsaWNlKGUuaW5kZXhPZih0KSwxKSwhMSE9PXIpOyk7fSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tYm8iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMTgpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwxOCk6dGhpcy5GZj1LKHRoaXMuRmYsMTgpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJlZGl0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDE5KSl9LHNldDpmdW5jdGlvbih0KXshMD09PXRoaXMuY29tYm8mJighMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMTkpOnRoaXMuRmY9Syh0aGlzLkZmLDE5KSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInNvcnQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMjApKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT8odGhpcy5GZj1YKHRoaXMuRmYsMjApLGUuc29ydCgpKTp0aGlzLkZmPUsodGhpcy5GZiwyMCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm11bHRpU2VsZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDIyKSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMjIpOnRoaXMuRmY9Syh0aGlzLkZmLDIyKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZG9Ob3RTcGVsbENoZWNrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDIzKSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMjMpOnRoaXMuRmY9Syh0aGlzLkZmLDIzKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY29tbWl0T25TZWxDaGFuZ2UiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMjcpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwyNyk6dGhpcy5GZj1LKHRoaXMuRmYsMjcpfX0pLHRoaXMuaGFzQXBwZWFyYW5jZVN0cmVhbT0hMX07eihodCxsdCk7dmFyIGZ0PWZ1bmN0aW9uKCl7aHQuY2FsbCh0aGlzKSx0aGlzLmZvbnROYW1lPSJoZWx2ZXRpY2EiLHRoaXMuY29tYm89ITF9O3ooZnQsaHQpO3ZhciBkdD1mdW5jdGlvbigpe2Z0LmNhbGwodGhpcyksdGhpcy5jb21ibz0hMH07eihkdCxmdCk7dmFyIHB0PWZ1bmN0aW9uKCl7ZHQuY2FsbCh0aGlzKSx0aGlzLmVkaXQ9ITB9O3oocHQsZHQpO3ZhciBndD1mdW5jdGlvbigpe2x0LmNhbGwodGhpcyksdGhpcy5GVD0iL0J0biIsT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm5vVG9nZ2xlVG9PZmYiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMTUpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwxNSk6dGhpcy5GZj1LKHRoaXMuRmYsMTUpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYWRpbyIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBCb29sZWFuKEoodGhpcy5GZiwxNikpfSxzZXQ6ZnVuY3Rpb24odCl7ITA9PT1Cb29sZWFuKHQpP3RoaXMuRmY9WCh0aGlzLkZmLDE2KTp0aGlzLkZmPUsodGhpcy5GZiwxNil9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInB1c2hCdXR0b24iLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMTcpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwxNyk6dGhpcy5GZj1LKHRoaXMuRmYsMTcpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJyYWRpb0lzVW5pc29uIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDI2KSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMjYpOnRoaXMuRmY9Syh0aGlzLkZmLDI2KX19KTt2YXIgdCxyPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJNSyIse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3ZhciB0PWZ1bmN0aW9uKHQpe3JldHVybiB0fTtpZih0aGlzLnNjb3BlJiYodD10aGlzLnNjb3BlLmludGVybmFsLmdldEVuY3J5cHRvcih0aGlzLm9iaklkKSksMCE9PU9iamVjdC5rZXlzKHIpLmxlbmd0aCl7dmFyIGUsbj1bXTtmb3IoZSBpbiBuLnB1c2goIjw8IiksciluLnB1c2goIi8iK2UrIiAoIitEKHQocltlXSkpKyIpIik7cmV0dXJuIG4ucHVzaCgiPj4iKSxuLmpvaW4oIlxuIil9fSxzZXQ6ZnVuY3Rpb24odCl7Im9iamVjdCI9PT1lKHQpJiYocj10KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FwdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiByLkNBfHwiIn0sc2V0OmZ1bmN0aW9uKHQpeyJzdHJpbmciPT10eXBlb2YgdCYmKHIuQ0E9dCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkFTIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9LHNldDpmdW5jdGlvbihlKXt0PWV9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFwcGVhcmFuY2VTdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0LnN1YnN0cigxLHQubGVuZ3RoLTEpfSxzZXQ6ZnVuY3Rpb24oZSl7dD0iLyIrZX19KX07eihndCxsdCk7dmFyIG10PWZ1bmN0aW9uKCl7Z3QuY2FsbCh0aGlzKSx0aGlzLnB1c2hCdXR0b249ITB9O3oobXQsZ3QpO3ZhciB2dD1mdW5jdGlvbigpe2d0LmNhbGwodGhpcyksdGhpcy5yYWRpbz0hMCx0aGlzLnB1c2hCdXR0b249ITE7dmFyIHQ9W107T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIktpZHMiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sc2V0OmZ1bmN0aW9uKGUpe3Q9dm9pZCAwIT09ZT9lOltdfX0pfTt6KHZ0LGd0KTt2YXIgYnQ9ZnVuY3Rpb24oKXt2YXIgdCxyO2x0LmNhbGwodGhpcyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIlBhcmVudCIse2VudW1lcmFibGU6ITEsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0fSxzZXQ6ZnVuY3Rpb24oZSl7dD1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJvcHRpb25OYW1lIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbih0KXtyPXR9fSk7dmFyIG4saT17fTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiTUsiLHtlbnVtZXJhYmxlOiExLGNvbmZpZ3VyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXt2YXIgdD1mdW5jdGlvbih0KXtyZXR1cm4gdH07dGhpcy5zY29wZSYmKHQ9dGhpcy5zY29wZS5pbnRlcm5hbC5nZXRFbmNyeXB0b3IodGhpcy5vYmpJZCkpO3ZhciBlLHI9W107Zm9yKGUgaW4gci5wdXNoKCI8PCIpLGkpci5wdXNoKCIvIitlKyIgKCIrRCh0KGlbZV0pKSsiKSIpO3JldHVybiByLnB1c2goIj4+Iiksci5qb2luKCJcbiIpfSxzZXQ6ZnVuY3Rpb24odCl7Im9iamVjdCI9PT1lKHQpJiYoaT10KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY2FwdGlvbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBpLkNBfHwiIn0sc2V0OmZ1bmN0aW9uKHQpeyJzdHJpbmciPT10eXBlb2YgdCYmKGkuQ0E9dCl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIkFTIix7ZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59LHNldDpmdW5jdGlvbih0KXtuPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImFwcGVhcmFuY2VTdGF0ZSIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBuLnN1YnN0cigxLG4ubGVuZ3RoLTEpfSxzZXQ6ZnVuY3Rpb24odCl7bj0iLyIrdH19KSx0aGlzLmNhcHRpb249ImwiLHRoaXMuYXBwZWFyYW5jZVN0YXRlPSJPZmYiLHRoaXMuX0FwcGVhcmFuY2VUeXBlPUx0LlJhZGlvQnV0dG9uLkNpcmNsZSx0aGlzLmFwcGVhcmFuY2VTdHJlYW1Db250ZW50PXRoaXMuX0FwcGVhcmFuY2VUeXBlLmNyZWF0ZUFwcGVhcmFuY2VTdHJlYW0odGhpcy5vcHRpb25OYW1lKX07eihidCxsdCksdnQucHJvdG90eXBlLnNldEFwcGVhcmFuY2U9ZnVuY3Rpb24odCl7aWYoISgiY3JlYXRlQXBwZWFyYW5jZVN0cmVhbSJpbiB0KXx8ISgiZ2V0Q0EiaW4gdCkpdGhyb3cgbmV3IEVycm9yKCJDb3VsZG4ndCBhc3NpZ24gQXBwZWFyYW5jZSB0byBSYWRpb0J1dHRvbi4gQXBwZWFyYW5jZSB3YXMgSW52YWxpZCEiKTtmb3IodmFyIGUgaW4gdGhpcy5LaWRzKWlmKHRoaXMuS2lkcy5oYXNPd25Qcm9wZXJ0eShlKSl7dmFyIHI9dGhpcy5LaWRzW2VdO3IuYXBwZWFyYW5jZVN0cmVhbUNvbnRlbnQ9dC5jcmVhdGVBcHBlYXJhbmNlU3RyZWFtKHIub3B0aW9uTmFtZSksci5jYXB0aW9uPXQuZ2V0Q0EoKX19LHZ0LnByb3RvdHlwZS5jcmVhdGVPcHRpb249ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGJ0O3JldHVybiBlLlBhcmVudD10aGlzLGUub3B0aW9uTmFtZT10LHRoaXMuS2lkcy5wdXNoKGUpLEF0LmNhbGwodGhpcy5zY29wZSxlKSxlfTt2YXIgeXQ9ZnVuY3Rpb24oKXtndC5jYWxsKHRoaXMpLHRoaXMuZm9udE5hbWU9InphcGZkaW5nYmF0cyIsdGhpcy5jYXB0aW9uPSIzIix0aGlzLmFwcGVhcmFuY2VTdGF0ZT0iT24iLHRoaXMudmFsdWU9Ik9uIix0aGlzLnRleHRBbGlnbj0iY2VudGVyIix0aGlzLmFwcGVhcmFuY2VTdHJlYW1Db250ZW50PUx0LkNoZWNrQm94LmNyZWF0ZUFwcGVhcmFuY2VTdHJlYW0oKX07eih5dCxndCk7dmFyIHd0PWZ1bmN0aW9uKCl7bHQuY2FsbCh0aGlzKSx0aGlzLkZUPSIvVHgiLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtdWx0aWxpbmUiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMTMpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwxMyk6dGhpcy5GZj1LKHRoaXMuRmYsMTMpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmaWxlU2VsZWN0Iix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDIxKSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMjEpOnRoaXMuRmY9Syh0aGlzLkZmLDIxKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZG9Ob3RTcGVsbENoZWNrIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDIzKSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMjMpOnRoaXMuRmY9Syh0aGlzLkZmLDIzKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZG9Ob3RTY3JvbGwiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMjQpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwyNCk6dGhpcy5GZj1LKHRoaXMuRmYsMjQpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjb21iIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4oSih0aGlzLkZmLDI1KSl9LHNldDpmdW5jdGlvbih0KXshMD09PUJvb2xlYW4odCk/dGhpcy5GZj1YKHRoaXMuRmYsMjUpOnRoaXMuRmY9Syh0aGlzLkZmLDI1KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicmljaFRleHQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMjYpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwyNik6dGhpcy5GZj1LKHRoaXMuRmYsMjYpfX0pO3ZhciB0PW51bGw7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIk1heExlbiIse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0fSxzZXQ6ZnVuY3Rpb24oZSl7dD1lfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJtYXhMZW5ndGgiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sc2V0OmZ1bmN0aW9uKGUpe051bWJlci5pc0ludGVnZXIoZSkmJih0PWUpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJoYXNBcHBlYXJhbmNlU3RyZWFtIix7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuVnx8dGhpcy5EVn19KX07eih3dCxsdCk7dmFyIE50PWZ1bmN0aW9uKCl7d3QuY2FsbCh0aGlzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFzc3dvcmQiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQm9vbGVhbihKKHRoaXMuRmYsMTQpKX0sc2V0OmZ1bmN0aW9uKHQpeyEwPT09Qm9vbGVhbih0KT90aGlzLkZmPVgodGhpcy5GZiwxNCk6dGhpcy5GZj1LKHRoaXMuRmYsMTQpfX0pLHRoaXMucGFzc3dvcmQ9ITB9O3ooTnQsd3QpO3ZhciBMdD17Q2hlY2tCb3g6e2NyZWF0ZUFwcGVhcmFuY2VTdHJlYW06ZnVuY3Rpb24oKXtyZXR1cm57Tjp7T246THQuQ2hlY2tCb3guWWVzTm9ybWFsfSxEOntPbjpMdC5DaGVja0JveC5ZZXNQdXNoRG93bixPZmY6THQuQ2hlY2tCb3guT2ZmUHVzaERvd259fX0sWWVzUHVzaERvd246ZnVuY3Rpb24odCl7dmFyIGU9Vyh0KTtlLnNjb3BlPXQuc2NvcGU7dmFyIHI9W10sbj10LnNjb3BlLmludGVybmFsLmdldEZvbnQodC5mb250TmFtZSx0LmZvbnRTdHlsZSkuaWQsaT10LnNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKHQuY29sb3IpLGE9USh0LHQuY2FwdGlvbik7cmV0dXJuIHIucHVzaCgiMC43NDkwMjMgZyIpLHIucHVzaCgiMCAwICIrVChMdC5pbnRlcm5hbC5nZXRXaWR0aCh0KSkrIiAiK1QoTHQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpKSsiIHJlIiksci5wdXNoKCJmIiksci5wdXNoKCJCTUMiKSxyLnB1c2goInEiKSxyLnB1c2goIjAgMCAxIHJnIiksci5wdXNoKCIvIituKyIgIitUKGEuZm9udFNpemUpKyIgVGYgIitpKSxyLnB1c2goIkJUIiksci5wdXNoKGEudGV4dCksci5wdXNoKCJFVCIpLHIucHVzaCgiUSIpLHIucHVzaCgiRU1DIiksZS5zdHJlYW09ci5qb2luKCJcbiIpLGV9LFllc05vcm1hbDpmdW5jdGlvbih0KXt2YXIgZT1XKHQpO2Uuc2NvcGU9dC5zY29wZTt2YXIgcj10LnNjb3BlLmludGVybmFsLmdldEZvbnQodC5mb250TmFtZSx0LmZvbnRTdHlsZSkuaWQsbj10LnNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKHQuY29sb3IpLGk9W10sYT1MdC5pbnRlcm5hbC5nZXRIZWlnaHQodCksbz1MdC5pbnRlcm5hbC5nZXRXaWR0aCh0KSxzPVEodCx0LmNhcHRpb24pO3JldHVybiBpLnB1c2goIjEgZyIpLGkucHVzaCgiMCAwICIrVChvKSsiICIrVChhKSsiIHJlIiksaS5wdXNoKCJmIiksaS5wdXNoKCJxIiksaS5wdXNoKCIwIDAgMSByZyIpLGkucHVzaCgiMCAwICIrVChvLTEpKyIgIitUKGEtMSkrIiByZSIpLGkucHVzaCgiVyIpLGkucHVzaCgibiIpLGkucHVzaCgiMCBnIiksaS5wdXNoKCJCVCIpLGkucHVzaCgiLyIrcisiICIrVChzLmZvbnRTaXplKSsiIFRmICIrbiksaS5wdXNoKHMudGV4dCksaS5wdXNoKCJFVCIpLGkucHVzaCgiUSIpLGUuc3RyZWFtPWkuam9pbigiXG4iKSxlfSxPZmZQdXNoRG93bjpmdW5jdGlvbih0KXt2YXIgZT1XKHQpO2Uuc2NvcGU9dC5zY29wZTt2YXIgcj1bXTtyZXR1cm4gci5wdXNoKCIwLjc0OTAyMyBnIiksci5wdXNoKCIwIDAgIitUKEx0LmludGVybmFsLmdldFdpZHRoKHQpKSsiICIrVChMdC5pbnRlcm5hbC5nZXRIZWlnaHQodCkpKyIgcmUiKSxyLnB1c2goImYiKSxlLnN0cmVhbT1yLmpvaW4oIlxuIiksZX19LFJhZGlvQnV0dG9uOntDaXJjbGU6e2NyZWF0ZUFwcGVhcmFuY2VTdHJlYW06ZnVuY3Rpb24odCl7dmFyIGU9e0Q6e09mZjpMdC5SYWRpb0J1dHRvbi5DaXJjbGUuT2ZmUHVzaERvd259LE46e319O3JldHVybiBlLk5bdF09THQuUmFkaW9CdXR0b24uQ2lyY2xlLlllc05vcm1hbCxlLkRbdF09THQuUmFkaW9CdXR0b24uQ2lyY2xlLlllc1B1c2hEb3duLGV9LGdldENBOmZ1bmN0aW9uKCl7cmV0dXJuImwifSxZZXNOb3JtYWw6ZnVuY3Rpb24odCl7dmFyIGU9Vyh0KTtlLnNjb3BlPXQuc2NvcGU7dmFyIHI9W10sbj1MdC5pbnRlcm5hbC5nZXRXaWR0aCh0KTw9THQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpP0x0LmludGVybmFsLmdldFdpZHRoKHQpLzQ6THQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpLzQ7bj1OdW1iZXIoKC45Km4pLnRvRml4ZWQoNSkpO3ZhciBpPUx0LmludGVybmFsLkJlemllcl9DLGE9TnVtYmVyKChuKmkpLnRvRml4ZWQoNSkpO3JldHVybiByLnB1c2goInEiKSxyLnB1c2goIjEgMCAwIDEgIitVKEx0LmludGVybmFsLmdldFdpZHRoKHQpLzIpKyIgIitVKEx0LmludGVybmFsLmdldEhlaWdodCh0KS8yKSsiIGNtIiksci5wdXNoKG4rIiAwIG0iKSxyLnB1c2gobisiICIrYSsiICIrYSsiICIrbisiIDAgIituKyIgYyIpLHIucHVzaCgiLSIrYSsiICIrbisiIC0iK24rIiAiK2ErIiAtIituKyIgMCBjIiksci5wdXNoKCItIituKyIgLSIrYSsiIC0iK2ErIiAtIituKyIgMCAtIituKyIgYyIpLHIucHVzaChhKyIgLSIrbisiICIrbisiIC0iK2ErIiAiK24rIiAwIGMiKSxyLnB1c2goImYiKSxyLnB1c2goIlEiKSxlLnN0cmVhbT1yLmpvaW4oIlxuIiksZX0sWWVzUHVzaERvd246ZnVuY3Rpb24odCl7dmFyIGU9Vyh0KTtlLnNjb3BlPXQuc2NvcGU7dmFyIHI9W10sbj1MdC5pbnRlcm5hbC5nZXRXaWR0aCh0KTw9THQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpP0x0LmludGVybmFsLmdldFdpZHRoKHQpLzQ6THQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpLzQ7bj1OdW1iZXIoKC45Km4pLnRvRml4ZWQoNSkpO3ZhciBpPU51bWJlcigoMipuKS50b0ZpeGVkKDUpKSxhPU51bWJlcigoaSpMdC5pbnRlcm5hbC5CZXppZXJfQykudG9GaXhlZCg1KSksbz1OdW1iZXIoKG4qTHQuaW50ZXJuYWwuQmV6aWVyX0MpLnRvRml4ZWQoNSkpO3JldHVybiByLnB1c2goIjAuNzQ5MDIzIGciKSxyLnB1c2goInEiKSxyLnB1c2goIjEgMCAwIDEgIitVKEx0LmludGVybmFsLmdldFdpZHRoKHQpLzIpKyIgIitVKEx0LmludGVybmFsLmdldEhlaWdodCh0KS8yKSsiIGNtIiksci5wdXNoKGkrIiAwIG0iKSxyLnB1c2goaSsiICIrYSsiICIrYSsiICIraSsiIDAgIitpKyIgYyIpLHIucHVzaCgiLSIrYSsiICIraSsiIC0iK2krIiAiK2ErIiAtIitpKyIgMCBjIiksci5wdXNoKCItIitpKyIgLSIrYSsiIC0iK2ErIiAtIitpKyIgMCAtIitpKyIgYyIpLHIucHVzaChhKyIgLSIraSsiICIraSsiIC0iK2ErIiAiK2krIiAwIGMiKSxyLnB1c2goImYiKSxyLnB1c2goIlEiKSxyLnB1c2goIjAgZyIpLHIucHVzaCgicSIpLHIucHVzaCgiMSAwIDAgMSAiK1UoTHQuaW50ZXJuYWwuZ2V0V2lkdGgodCkvMikrIiAiK1UoTHQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpLzIpKyIgY20iKSxyLnB1c2gobisiIDAgbSIpLHIucHVzaChuKyIgIitvKyIgIitvKyIgIituKyIgMCAiK24rIiBjIiksci5wdXNoKCItIitvKyIgIituKyIgLSIrbisiICIrbysiIC0iK24rIiAwIGMiKSxyLnB1c2goIi0iK24rIiAtIitvKyIgLSIrbysiIC0iK24rIiAwIC0iK24rIiBjIiksci5wdXNoKG8rIiAtIituKyIgIituKyIgLSIrbysiICIrbisiIDAgYyIpLHIucHVzaCgiZiIpLHIucHVzaCgiUSIpLGUuc3RyZWFtPXIuam9pbigiXG4iKSxlfSxPZmZQdXNoRG93bjpmdW5jdGlvbih0KXt2YXIgZT1XKHQpO2Uuc2NvcGU9dC5zY29wZTt2YXIgcj1bXSxuPUx0LmludGVybmFsLmdldFdpZHRoKHQpPD1MdC5pbnRlcm5hbC5nZXRIZWlnaHQodCk/THQuaW50ZXJuYWwuZ2V0V2lkdGgodCkvNDpMdC5pbnRlcm5hbC5nZXRIZWlnaHQodCkvNDtuPU51bWJlcigoLjkqbikudG9GaXhlZCg1KSk7dmFyIGk9TnVtYmVyKCgyKm4pLnRvRml4ZWQoNSkpLGE9TnVtYmVyKChpKkx0LmludGVybmFsLkJlemllcl9DKS50b0ZpeGVkKDUpKTtyZXR1cm4gci5wdXNoKCIwLjc0OTAyMyBnIiksci5wdXNoKCJxIiksci5wdXNoKCIxIDAgMCAxICIrVShMdC5pbnRlcm5hbC5nZXRXaWR0aCh0KS8yKSsiICIrVShMdC5pbnRlcm5hbC5nZXRIZWlnaHQodCkvMikrIiBjbSIpLHIucHVzaChpKyIgMCBtIiksci5wdXNoKGkrIiAiK2ErIiAiK2ErIiAiK2krIiAwICIraSsiIGMiKSxyLnB1c2goIi0iK2ErIiAiK2krIiAtIitpKyIgIithKyIgLSIraSsiIDAgYyIpLHIucHVzaCgiLSIraSsiIC0iK2ErIiAtIithKyIgLSIraSsiIDAgLSIraSsiIGMiKSxyLnB1c2goYSsiIC0iK2krIiAiK2krIiAtIithKyIgIitpKyIgMCBjIiksci5wdXNoKCJmIiksci5wdXNoKCJRIiksZS5zdHJlYW09ci5qb2luKCJcbiIpLGV9fSxDcm9zczp7Y3JlYXRlQXBwZWFyYW5jZVN0cmVhbTpmdW5jdGlvbih0KXt2YXIgZT17RDp7T2ZmOkx0LlJhZGlvQnV0dG9uLkNyb3NzLk9mZlB1c2hEb3dufSxOOnt9fTtyZXR1cm4gZS5OW3RdPUx0LlJhZGlvQnV0dG9uLkNyb3NzLlllc05vcm1hbCxlLkRbdF09THQuUmFkaW9CdXR0b24uQ3Jvc3MuWWVzUHVzaERvd24sZX0sZ2V0Q0E6ZnVuY3Rpb24oKXtyZXR1cm4iOCJ9LFllc05vcm1hbDpmdW5jdGlvbih0KXt2YXIgZT1XKHQpO2Uuc2NvcGU9dC5zY29wZTt2YXIgcj1bXSxuPUx0LmludGVybmFsLmNhbGN1bGF0ZUNyb3NzKHQpO3JldHVybiByLnB1c2goInEiKSxyLnB1c2goIjEgMSAiK1QoTHQuaW50ZXJuYWwuZ2V0V2lkdGgodCktMikrIiAiK1QoTHQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpLTIpKyIgcmUiKSxyLnB1c2goIlciKSxyLnB1c2goIm4iKSxyLnB1c2goVChuLngxLngpKyIgIitUKG4ueDEueSkrIiBtIiksci5wdXNoKFQobi54Mi54KSsiICIrVChuLngyLnkpKyIgbCIpLHIucHVzaChUKG4ueDQueCkrIiAiK1Qobi54NC55KSsiIG0iKSxyLnB1c2goVChuLngzLngpKyIgIitUKG4ueDMueSkrIiBsIiksci5wdXNoKCJzIiksci5wdXNoKCJRIiksZS5zdHJlYW09ci5qb2luKCJcbiIpLGV9LFllc1B1c2hEb3duOmZ1bmN0aW9uKHQpe3ZhciBlPVcodCk7ZS5zY29wZT10LnNjb3BlO3ZhciByPUx0LmludGVybmFsLmNhbGN1bGF0ZUNyb3NzKHQpLG49W107cmV0dXJuIG4ucHVzaCgiMC43NDkwMjMgZyIpLG4ucHVzaCgiMCAwICIrVChMdC5pbnRlcm5hbC5nZXRXaWR0aCh0KSkrIiAiK1QoTHQuaW50ZXJuYWwuZ2V0SGVpZ2h0KHQpKSsiIHJlIiksbi5wdXNoKCJmIiksbi5wdXNoKCJxIiksbi5wdXNoKCIxIDEgIitUKEx0LmludGVybmFsLmdldFdpZHRoKHQpLTIpKyIgIitUKEx0LmludGVybmFsLmdldEhlaWdodCh0KS0yKSsiIHJlIiksbi5wdXNoKCJXIiksbi5wdXNoKCJuIiksbi5wdXNoKFQoci54MS54KSsiICIrVChyLngxLnkpKyIgbSIpLG4ucHVzaChUKHIueDIueCkrIiAiK1Qoci54Mi55KSsiIGwiKSxuLnB1c2goVChyLng0LngpKyIgIitUKHIueDQueSkrIiBtIiksbi5wdXNoKFQoci54My54KSsiICIrVChyLngzLnkpKyIgbCIpLG4ucHVzaCgicyIpLG4ucHVzaCgiUSIpLGUuc3RyZWFtPW4uam9pbigiXG4iKSxlfSxPZmZQdXNoRG93bjpmdW5jdGlvbih0KXt2YXIgZT1XKHQpO2Uuc2NvcGU9dC5zY29wZTt2YXIgcj1bXTtyZXR1cm4gci5wdXNoKCIwLjc0OTAyMyBnIiksci5wdXNoKCIwIDAgIitUKEx0LmludGVybmFsLmdldFdpZHRoKHQpKSsiICIrVChMdC5pbnRlcm5hbC5nZXRIZWlnaHQodCkpKyIgcmUiKSxyLnB1c2goImYiKSxlLnN0cmVhbT1yLmpvaW4oIlxuIiksZX19fSxjcmVhdGVEZWZhdWx0QXBwZWFyYW5jZVN0cmVhbTpmdW5jdGlvbih0KXt2YXIgZT10LnNjb3BlLmludGVybmFsLmdldEZvbnQodC5mb250TmFtZSx0LmZvbnRTdHlsZSkuaWQscj10LnNjb3BlLl9fcHJpdmF0ZV9fLmVuY29kZUNvbG9yU3RyaW5nKHQuY29sb3IpO3JldHVybiIvIitlKyIgIit0LmZvbnRTaXplKyIgVGYgIityfX07THQuaW50ZXJuYWw9e0Jlemllcl9DOi41NTE5MTUwMjQ0OTQsY2FsY3VsYXRlQ3Jvc3M6ZnVuY3Rpb24odCl7dmFyIGU9THQuaW50ZXJuYWwuZ2V0V2lkdGgodCkscj1MdC5pbnRlcm5hbC5nZXRIZWlnaHQodCksbj1NYXRoLm1pbihlLHIpO3JldHVybnt4MTp7eDooZS1uKS8yLHk6KHItbikvMitufSx4Mjp7eDooZS1uKS8yK24seTooci1uKS8yfSx4Mzp7eDooZS1uKS8yLHk6KHItbikvMn0seDQ6e3g6KGUtbikvMituLHk6KHItbikvMitufX19fSxMdC5pbnRlcm5hbC5nZXRXaWR0aD1mdW5jdGlvbih0KXt2YXIgcj0wO3JldHVybiJvYmplY3QiPT09ZSh0KSYmKHI9SCh0LlJlY3RbMl0pKSxyfSxMdC5pbnRlcm5hbC5nZXRIZWlnaHQ9ZnVuY3Rpb24odCl7dmFyIHI9MDtyZXR1cm4ib2JqZWN0Ij09PWUodCkmJihyPUgodC5SZWN0WzNdKSkscn07dmFyIEF0PUUuYWRkRmllbGQ9ZnVuY3Rpb24odCl7aWYoaXQodGhpcyx0KSwhKHQgaW5zdGFuY2VvZiBsdCkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCB0byBqc1BERi5hZGRGaWVsZC4iKTt2YXIgZTtyZXR1cm4oZT10KS5zY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5wcmludGVkT3V0JiYoZS5zY29wZS5pbnRlcm5hbC5hY3JvZm9ybVBsdWdpbi5wcmludGVkT3V0PSExLGUuc2NvcGUuaW50ZXJuYWwuYWNyb2Zvcm1QbHVnaW4uYWNyb0Zvcm1EaWN0aW9uYXJ5Um9vdD1udWxsKSxlLnNjb3BlLmludGVybmFsLmFjcm9mb3JtUGx1Z2luLmFjcm9Gb3JtRGljdGlvbmFyeVJvb3QuRmllbGRzLnB1c2goZSksdC5wYWdlPXQuc2NvcGUuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZU51bWJlcix0aGlzfTtFLkFjcm9Gb3JtQ2hvaWNlRmllbGQ9aHQsRS5BY3JvRm9ybUxpc3RCb3g9ZnQsRS5BY3JvRm9ybUNvbWJvQm94PWR0LEUuQWNyb0Zvcm1FZGl0Qm94PXB0LEUuQWNyb0Zvcm1CdXR0b249Z3QsRS5BY3JvRm9ybVB1c2hCdXR0b249bXQsRS5BY3JvRm9ybVJhZGlvQnV0dG9uPXZ0LEUuQWNyb0Zvcm1DaGVja0JveD15dCxFLkFjcm9Gb3JtVGV4dEZpZWxkPXd0LEUuQWNyb0Zvcm1QYXNzd29yZEZpZWxkPU50LEUuQWNyb0Zvcm1BcHBlYXJhbmNlPUx0LEUuQWNyb0Zvcm09e0Nob2ljZUZpZWxkOmh0LExpc3RCb3g6ZnQsQ29tYm9Cb3g6ZHQsRWRpdEJveDpwdCxCdXR0b246Z3QsUHVzaEJ1dHRvbjptdCxSYWRpb0J1dHRvbjp2dCxDaGVja0JveDp5dCxUZXh0RmllbGQ6d3QsUGFzc3dvcmRGaWVsZDpOdCxBcHBlYXJhbmNlOkx0fSxNLkFjcm9Gb3JtPXtDaG9pY2VGaWVsZDpodCxMaXN0Qm94OmZ0LENvbWJvQm94OmR0LEVkaXRCb3g6cHQsQnV0dG9uOmd0LFB1c2hCdXR0b246bXQsUmFkaW9CdXR0b246dnQsQ2hlY2tCb3g6eXQsVGV4dEZpZWxkOnd0LFBhc3N3b3JkRmllbGQ6TnQsQXBwZWFyYW5jZTpMdH07dmFyIHh0PU0uQWNyb0Zvcm07ZnVuY3Rpb24gU3QodCl7cmV0dXJuIHQucmVkdWNlKChmdW5jdGlvbih0LGUscil7cmV0dXJuIHRbZV09cix0fSkse30pfSFmdW5jdGlvbih0KXt0Ll9fYWRkaW1hZ2VfXz17fTt2YXIgcj0iVU5LTk9XTiIsbj17UE5HOltbMTM3LDgwLDc4LDcxXV0sVElGRjpbWzc3LDc3LDAsNDJdLFs3Myw3Myw0MiwwXV0sSlBFRzpbWzI1NSwyMTYsMjU1LDIyNCx2b2lkIDAsdm9pZCAwLDc0LDcwLDczLDcwLDBdLFsyNTUsMjE2LDI1NSwyMjUsdm9pZCAwLHZvaWQgMCw2OSwxMjAsMTA1LDEwMiwwLDBdLFsyNTUsMjE2LDI1NSwyMTldLFsyNTUsMjE2LDI1NSwyMzhdXSxKUEVHMjAwMDpbWzAsMCwwLDEyLDEwNiw4MCwzMiwzMl1dLEdJRjg3YTpbWzcxLDczLDcwLDU2LDU1LDk3XV0sR0lGODlhOltbNzEsNzMsNzAsNTYsNTcsOTddXSxXRUJQOltbODIsNzMsNzAsNzAsdm9pZCAwLHZvaWQgMCx2b2lkIDAsdm9pZCAwLDg3LDY5LDY2LDgwXV0sQk1QOltbNjYsNzddLFs2Niw2NV0sWzY3LDczXSxbNjcsODBdLFs3Myw2N10sWzgwLDg0XV19LGk9dC5fX2FkZGltYWdlX18uZ2V0SW1hZ2VGaWxlVHlwZUJ5SW1hZ2VEYXRhPWZ1bmN0aW9uKHQsZSl7dmFyIGksYSxvLHMsYyx1PXI7aWYoIlJHQkEiPT09KGU9ZXx8cil8fHZvaWQgMCE9PXQuZGF0YSYmdC5kYXRhIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkmJiJoZWlnaHQiaW4gdCYmIndpZHRoImluIHQpcmV0dXJuIlJHQkEiO2lmKHgodCkpZm9yKGMgaW4gbilmb3Iobz1uW2NdLGk9MDtpPG8ubGVuZ3RoO2krPTEpe2ZvcihzPSEwLGE9MDthPG9baV0ubGVuZ3RoO2ErPTEpaWYodm9pZCAwIT09b1tpXVthXSYmb1tpXVthXSE9PXRbYV0pe3M9ITE7YnJlYWt9aWYoITA9PT1zKXt1PWM7YnJlYWt9fWVsc2UgZm9yKGMgaW4gbilmb3Iobz1uW2NdLGk9MDtpPG8ubGVuZ3RoO2krPTEpe2ZvcihzPSEwLGE9MDthPG9baV0ubGVuZ3RoO2ErPTEpaWYodm9pZCAwIT09b1tpXVthXSYmb1tpXVthXSE9PXQuY2hhckNvZGVBdChhKSl7cz0hMTticmVha31pZighMD09PXMpe3U9YzticmVha319cmV0dXJuIHU9PT1yJiZlIT09ciYmKHU9ZSksdX0sYT1mdW5jdGlvbiB0KGUpe2Zvcih2YXIgcj10aGlzLmludGVybmFsLndyaXRlLG49dGhpcy5pbnRlcm5hbC5wdXRTdHJlYW0saT0oMCx0aGlzLmludGVybmFsLmdldEZpbHRlcnMpKCk7LTEhPT1pLmluZGV4T2YoIkZsYXRlRW5jb2RlIik7KWkuc3BsaWNlKGkuaW5kZXhPZigiRmxhdGVFbmNvZGUiKSwxKTtlLm9iamVjdElkPXRoaXMuaW50ZXJuYWwubmV3T2JqZWN0KCk7dmFyIGE9W107aWYoYS5wdXNoKHtrZXk6IlR5cGUiLHZhbHVlOiIvWE9iamVjdCJ9KSxhLnB1c2goe2tleToiU3VidHlwZSIsdmFsdWU6Ii9JbWFnZSJ9KSxhLnB1c2goe2tleToiV2lkdGgiLHZhbHVlOmUud2lkdGh9KSxhLnB1c2goe2tleToiSGVpZ2h0Iix2YWx1ZTplLmhlaWdodH0pLGUuY29sb3JTcGFjZT09PWIuSU5ERVhFRD9hLnB1c2goe2tleToiQ29sb3JTcGFjZSIsdmFsdWU6IlsvSW5kZXhlZCAvRGV2aWNlUkdCICIrKGUucGFsZXR0ZS5sZW5ndGgvMy0xKSsiICIrKCJzTWFzayJpbiBlJiZ2b2lkIDAhPT1lLnNNYXNrP2Uub2JqZWN0SWQrMjplLm9iamVjdElkKzEpKyIgMCBSXSJ9KTooYS5wdXNoKHtrZXk6IkNvbG9yU3BhY2UiLHZhbHVlOiIvIitlLmNvbG9yU3BhY2V9KSxlLmNvbG9yU3BhY2U9PT1iLkRFVklDRV9DTVlLJiZhLnB1c2goe2tleToiRGVjb2RlIix2YWx1ZToiWzEgMCAxIDAgMSAwIDEgMF0ifSkpLGEucHVzaCh7a2V5OiJCaXRzUGVyQ29tcG9uZW50Iix2YWx1ZTplLmJpdHNQZXJDb21wb25lbnR9KSwiZGVjb2RlUGFyYW1ldGVycyJpbiBlJiZ2b2lkIDAhPT1lLmRlY29kZVBhcmFtZXRlcnMmJmEucHVzaCh7a2V5OiJEZWNvZGVQYXJtcyIsdmFsdWU6Ijw8IitlLmRlY29kZVBhcmFtZXRlcnMrIj4+In0pLCJ0cmFuc3BhcmVuY3kiaW4gZSYmQXJyYXkuaXNBcnJheShlLnRyYW5zcGFyZW5jeSkpe2Zvcih2YXIgbz0iIixzPTAsYz1lLnRyYW5zcGFyZW5jeS5sZW5ndGg7czxjO3MrKylvKz1lLnRyYW5zcGFyZW5jeVtzXSsiICIrZS50cmFuc3BhcmVuY3lbc10rIiAiO2EucHVzaCh7a2V5OiJNYXNrIix2YWx1ZToiWyIrbysiXSJ9KX12b2lkIDAhPT1lLnNNYXNrJiZhLnB1c2goe2tleToiU01hc2siLHZhbHVlOmUub2JqZWN0SWQrMSsiIDAgUiJ9KTt2YXIgdT12b2lkIDAhPT1lLmZpbHRlcj9bIi8iK2UuZmlsdGVyXTp2b2lkIDA7aWYobih7ZGF0YTplLmRhdGEsYWRkaXRpb25hbEtleVZhbHVlczphLGFscmVhZHlBcHBsaWVkRmlsdGVyczp1LG9iamVjdElkOmUub2JqZWN0SWR9KSxyKCJlbmRvYmoiKSwic01hc2siaW4gZSYmdm9pZCAwIT09ZS5zTWFzayl7dmFyIGw9Ii9QcmVkaWN0b3IgIitlLnByZWRpY3RvcisiIC9Db2xvcnMgMSAvQml0c1BlckNvbXBvbmVudCAiK2UuYml0c1BlckNvbXBvbmVudCsiIC9Db2x1bW5zICIrZS53aWR0aCxoPXt3aWR0aDplLndpZHRoLGhlaWdodDplLmhlaWdodCxjb2xvclNwYWNlOiJEZXZpY2VHcmF5IixiaXRzUGVyQ29tcG9uZW50OmUuYml0c1BlckNvbXBvbmVudCxkZWNvZGVQYXJhbWV0ZXJzOmwsZGF0YTplLnNNYXNrfTsiZmlsdGVyImluIGUmJihoLmZpbHRlcj1lLmZpbHRlciksdC5jYWxsKHRoaXMsaCl9aWYoZS5jb2xvclNwYWNlPT09Yi5JTkRFWEVEKXt2YXIgZj10aGlzLmludGVybmFsLm5ld09iamVjdCgpO24oe2RhdGE6XyhuZXcgVWludDhBcnJheShlLnBhbGV0dGUpKSxvYmplY3RJZDpmfSkscigiZW5kb2JqIil9fSxvPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5pbnRlcm5hbC5jb2xsZWN0aW9ucy5hZGRJbWFnZV9pbWFnZXM7Zm9yKHZhciBlIGluIHQpYS5jYWxsKHRoaXMsdFtlXSl9LHM9ZnVuY3Rpb24oKXt2YXIgdCxlPXRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnMuYWRkSW1hZ2VfaW1hZ2VzLHI9dGhpcy5pbnRlcm5hbC53cml0ZTtmb3IodmFyIG4gaW4gZSlyKCIvSSIrKHQ9ZVtuXSkuaW5kZXgsdC5vYmplY3RJZCwiMCIsIlIiKX0sdT1mdW5jdGlvbigpe3RoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnMuYWRkSW1hZ2VfaW1hZ2VzfHwodGhpcy5pbnRlcm5hbC5jb2xsZWN0aW9ucy5hZGRJbWFnZV9pbWFnZXM9e30sdGhpcy5pbnRlcm5hbC5ldmVudHMuc3Vic2NyaWJlKCJwdXRSZXNvdXJjZXMiLG8pLHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicHV0WG9iamVjdERpY3QiLHMpKX0sbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnMuYWRkSW1hZ2VfaW1hZ2VzO3JldHVybiB1LmNhbGwodGhpcyksdH0saD1mdW5jdGlvbigpe3JldHVybiBPYmplY3Qua2V5cyh0aGlzLmludGVybmFsLmNvbGxlY3Rpb25zLmFkZEltYWdlX2ltYWdlcykubGVuZ3RofSxmPWZ1bmN0aW9uKGUpe3JldHVybiJmdW5jdGlvbiI9PXR5cGVvZiB0WyJwcm9jZXNzIitlLnRvVXBwZXJDYXNlKCldfSxkPWZ1bmN0aW9uKHQpe3JldHVybiJvYmplY3QiPT09ZSh0KSYmMT09PXQubm9kZVR5cGV9LHA9ZnVuY3Rpb24oZSxyKXtpZigiSU1HIj09PWUubm9kZU5hbWUmJmUuaGFzQXR0cmlidXRlKCJzcmMiKSl7dmFyIG49IiIrZS5nZXRBdHRyaWJ1dGUoInNyYyIpO2lmKDA9PT1uLmluZGV4T2YoImRhdGE6aW1hZ2UvIikpcmV0dXJuIGModW5lc2NhcGUobikuc3BsaXQoImJhc2U2NCwiKS5wb3AoKSk7dmFyIGk9dC5sb2FkRmlsZShuLCEwKTtpZih2b2lkIDAhPT1pKXJldHVybiBpfWlmKCJDQU5WQVMiPT09ZS5ub2RlTmFtZSl7aWYoMD09PWUud2lkdGh8fDA9PT1lLmhlaWdodCl0aHJvdyBuZXcgRXJyb3IoIkdpdmVuIGNhbnZhcyBtdXN0IGhhdmUgZGF0YS4gQ2FudmFzIHdpZHRoOiAiK2Uud2lkdGgrIiwgaGVpZ2h0OiAiK2UuaGVpZ2h0KTt2YXIgYTtzd2l0Y2gocil7Y2FzZSJQTkciOmE9ImltYWdlL3BuZyI7YnJlYWs7Y2FzZSJXRUJQIjphPSJpbWFnZS93ZWJwIjticmVhaztjYXNlIkpQRUciOmNhc2UiSlBHIjpkZWZhdWx0OmE9ImltYWdlL2pwZWcifXJldHVybiBjKGUudG9EYXRhVVJMKGEsMSkuc3BsaXQoImJhc2U2NCwiKS5wb3AoKSl9fSxnPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJuYWwuY29sbGVjdGlvbnMuYWRkSW1hZ2VfaW1hZ2VzO2lmKGUpZm9yKHZhciByIGluIGUpaWYodD09PWVbcl0uYWxpYXMpcmV0dXJuIGVbcl19LG09ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0fHxlfHwodD0tOTYsZT0tOTYpLHQ8MCYmKHQ9LTEqci53aWR0aCo3Mi90L3RoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3IpLGU8MCYmKGU9LTEqci5oZWlnaHQqNzIvZS90aGlzLmludGVybmFsLnNjYWxlRmFjdG9yKSwwPT09dCYmKHQ9ZSpyLndpZHRoL3IuaGVpZ2h0KSwwPT09ZSYmKGU9dCpyLmhlaWdodC9yLndpZHRoKSxbdCxlXX0sdj1mdW5jdGlvbih0LGUscixuLGksYSl7dmFyIG89bS5jYWxsKHRoaXMscixuLGkpLHM9dGhpcy5pbnRlcm5hbC5nZXRDb29yZGluYXRlU3RyaW5nLGM9dGhpcy5pbnRlcm5hbC5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmcsdT1sLmNhbGwodGhpcyk7aWYocj1vWzBdLG49b1sxXSx1W2kuaW5kZXhdPWksYSl7YSo9TWF0aC5QSS8xODA7dmFyIGg9TWF0aC5jb3MoYSksZj1NYXRoLnNpbihhKSxkPWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvRml4ZWQoNCl9LHA9W2QoaCksZChmKSxkKC0xKmYpLGQoaCksMCwwLCJjbSJdfXRoaXMuaW50ZXJuYWwud3JpdGUoInEiKSxhPyh0aGlzLmludGVybmFsLndyaXRlKFsxLCIwIiwiMCIsMSxzKHQpLGMoZStuKSwiY20iXS5qb2luKCIgIikpLHRoaXMuaW50ZXJuYWwud3JpdGUocC5qb2luKCIgIikpLHRoaXMuaW50ZXJuYWwud3JpdGUoW3MociksIjAiLCIwIixzKG4pLCIwIiwiMCIsImNtIl0uam9pbigiICIpKSk6dGhpcy5pbnRlcm5hbC53cml0ZShbcyhyKSwiMCIsIjAiLHMobikscyh0KSxjKGUrbiksImNtIl0uam9pbigiICIpKSx0aGlzLmlzQWR2YW5jZWRBUEkoKSYmdGhpcy5pbnRlcm5hbC53cml0ZShbMSwwLDAsLTEsMCwwLCJjbSJdLmpvaW4oIiAiKSksdGhpcy5pbnRlcm5hbC53cml0ZSgiL0kiK2kuaW5kZXgrIiBEbyIpLHRoaXMuaW50ZXJuYWwud3JpdGUoIlEiKX0sYj10LmNvbG9yX3NwYWNlcz17REVWSUNFX1JHQjoiRGV2aWNlUkdCIixERVZJQ0VfR1JBWToiRGV2aWNlR3JheSIsREVWSUNFX0NNWUs6IkRldmljZUNNWUsiLENBTF9HUkVZOiJDYWxHcmF5IixDQUxfUkdCOiJDYWxSR0IiLExBQjoiTGFiIixJQ0NfQkFTRUQ6IklDQ0Jhc2VkIixJTkRFWEVEOiJJbmRleGVkIixQQVRURVJOOiJQYXR0ZXJuIixTRVBBUkFUSU9OOiJTZXBhcmF0aW9uIixERVZJQ0VfTjoiRGV2aWNlTiJ9O3QuZGVjb2RlPXtEQ1RfREVDT0RFOiJEQ1REZWNvZGUiLEZMQVRFX0RFQ09ERToiRmxhdGVEZWNvZGUiLExaV19ERUNPREU6IkxaV0RlY29kZSIsSlBYX0RFQ09ERToiSlBYRGVjb2RlIixKQklHMl9ERUNPREU6IkpCSUcyRGVjb2RlIixBU0NJSTg1X0RFQ09ERToiQVNDSUk4NURlY29kZSIsQVNDSUlfSEVYX0RFQ09ERToiQVNDSUlIZXhEZWNvZGUiLFJVTl9MRU5HVEhfREVDT0RFOiJSdW5MZW5ndGhEZWNvZGUiLENDSVRUX0ZBWF9ERUNPREU6IkNDSVRURmF4RGVjb2RlIn07dmFyIHk9dC5pbWFnZV9jb21wcmVzc2lvbj17Tk9ORToiTk9ORSIsRkFTVDoiRkFTVCIsTUVESVVNOiJNRURJVU0iLFNMT1c6IlNMT1cifSx3PXQuX19hZGRpbWFnZV9fLnNIYXNoQ29kZT1mdW5jdGlvbih0KXt2YXIgZSxyLG49MDtpZigic3RyaW5nIj09dHlwZW9mIHQpZm9yKHI9dC5sZW5ndGgsZT0wO2U8cjtlKyspbj0objw8NSktbit0LmNoYXJDb2RlQXQoZSksbnw9MDtlbHNlIGlmKHgodCkpZm9yKHI9dC5ieXRlTGVuZ3RoLzIsZT0wO2U8cjtlKyspbj0objw8NSktbit0W2VdLG58PTA7cmV0dXJuIG59LE49dC5fX2FkZGltYWdlX18udmFsaWRhdGVTdHJpbmdBc0Jhc2U2ND1mdW5jdGlvbih0KXsodD10fHwiIikudG9TdHJpbmcoKS50cmltKCk7dmFyIGU9ITA7cmV0dXJuIDA9PT10Lmxlbmd0aCYmKGU9ITEpLHQubGVuZ3RoJTQhPTAmJihlPSExKSwhMT09PS9eW0EtWmEtejAtOSsvXSskLy50ZXN0KHQuc3Vic3RyKDAsdC5sZW5ndGgtMikpJiYoZT0hMSksITE9PT0vXltBLVphLXowLTkvXVtBLVphLXowLTkrL118W0EtWmEtejAtOSsvXT18PT0kLy50ZXN0KHQuc3Vic3RyKC0yKSkmJihlPSExKSxlfSxMPXQuX19hZGRpbWFnZV9fLmV4dHJhY3RJbWFnZUZyb21EYXRhVXJsPWZ1bmN0aW9uKHQpe3ZhciBlPSh0PXR8fCIiKS5zcGxpdCgiYmFzZTY0LCIpLHI9bnVsbDtpZigyPT09ZS5sZW5ndGgpe3ZhciBuPS9eZGF0YTooXHcqXC9cdyopOyooY2hhcnNldD0oPyFjaGFyc2V0PSlbXHc9LV0qKSo7KiQvLmV4ZWMoZVswXSk7QXJyYXkuaXNBcnJheShuKSYmKHI9e21pbWVUeXBlOm5bMV0sY2hhcnNldDpuWzJdLGRhdGE6ZVsxXX0pfXJldHVybiByfSxBPXQuX19hZGRpbWFnZV9fLnN1cHBvcnRzQXJyYXlCdWZmZXI9ZnVuY3Rpb24oKXtyZXR1cm4idW5kZWZpbmVkIiE9dHlwZW9mIEFycmF5QnVmZmVyJiYidW5kZWZpbmVkIiE9dHlwZW9mIFVpbnQ4QXJyYXl9O3QuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXI9ZnVuY3Rpb24odCl7cmV0dXJuIEEoKSYmdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfTt2YXIgeD10Ll9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyVmlldz1mdW5jdGlvbih0KXtyZXR1cm4gQSgpJiYidW5kZWZpbmVkIiE9dHlwZW9mIFVpbnQzMkFycmF5JiYodCBpbnN0YW5jZW9mIEludDhBcnJheXx8dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fCJ1bmRlZmluZWQiIT10eXBlb2YgVWludDhDbGFtcGVkQXJyYXkmJnQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dCBpbnN0YW5jZW9mIEludDE2QXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50MTZBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSl9LFM9dC5fX2FkZGltYWdlX18uYmluYXJ5U3RyaW5nVG9VaW50OEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxyPW5ldyBVaW50OEFycmF5KGUpLG49MDtuPGU7bisrKXJbbl09dC5jaGFyQ29kZUF0KG4pO3JldHVybiByfSxfPXQuX19hZGRpbWFnZV9fLmFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmc9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSIiLHI9eCh0KT90Om5ldyBVaW50OEFycmF5KHQpLG49MDtuPHIubGVuZ3RoO24rPTgxOTIpZSs9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLHIuc3ViYXJyYXkobixuKzgxOTIpKTtyZXR1cm4gZX07dC5hZGRJbWFnZT1mdW5jdGlvbigpe3ZhciB0LG4saSxhLG8scyxjLGwsaDtpZigibnVtYmVyIj09dHlwZW9mIGFyZ3VtZW50c1sxXT8obj1yLGk9YXJndW1lbnRzWzFdLGE9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdLHM9YXJndW1lbnRzWzRdLGM9YXJndW1lbnRzWzVdLGw9YXJndW1lbnRzWzZdLGg9YXJndW1lbnRzWzddKToobj1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10sbz1hcmd1bWVudHNbNF0scz1hcmd1bWVudHNbNV0sYz1hcmd1bWVudHNbNl0sbD1hcmd1bWVudHNbN10saD1hcmd1bWVudHNbOF0pLCJvYmplY3QiPT09ZSh0PWFyZ3VtZW50c1swXSkmJiFkKHQpJiYiaW1hZ2VEYXRhImluIHQpe3ZhciBmPXQ7dD1mLmltYWdlRGF0YSxuPWYuZm9ybWF0fHxufHxyLGk9Zi54fHxpfHwwLGE9Zi55fHxhfHwwLG89Zi53fHxmLndpZHRofHxvLHM9Zi5ofHxmLmhlaWdodHx8cyxjPWYuYWxpYXN8fGMsbD1mLmNvbXByZXNzaW9ufHxsLGg9Zi5yb3RhdGlvbnx8Zi5hbmdsZXx8aH12YXIgcD10aGlzLmludGVybmFsLmdldEZpbHRlcnMoKTtpZih2b2lkIDA9PT1sJiYtMSE9PXAuaW5kZXhPZigiRmxhdGVFbmNvZGUiKSYmKGw9IlNMT1ciKSxpc05hTihpKXx8aXNOYU4oYSkpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGNvb3JkaW5hdGVzIHBhc3NlZCB0byBqc1BERi5hZGRJbWFnZSIpO3UuY2FsbCh0aGlzKTt2YXIgZz1QLmNhbGwodGhpcyx0LG4sYyxsKTtyZXR1cm4gdi5jYWxsKHRoaXMsaSxhLG8scyxnLGgpLHRoaXN9O3ZhciBQPWZ1bmN0aW9uKGUsbixhLG8pe3ZhciBzLGMsdTtpZigic3RyaW5nIj09dHlwZW9mIGUmJmkoZSk9PT1yKXtlPXVuZXNjYXBlKGUpO3ZhciBsPWsoZSwhMSk7KCIiIT09bHx8dm9pZCAwIT09KGw9dC5sb2FkRmlsZShlLCEwKSkpJiYoZT1sKX1pZihkKGUpJiYoZT1wKGUsbikpLG49aShlLG4pLCFmKG4pKXRocm93IG5ldyBFcnJvcigiYWRkSW1hZ2UgZG9lcyBub3Qgc3VwcG9ydCBmaWxlcyBvZiB0eXBlICciK24rIicsIHBsZWFzZSBlbnN1cmUgdGhhdCBhIHBsdWdpbiBmb3IgJyIrbisiJyBzdXBwb3J0IGlzIGFkZGVkLiIpO2lmKChudWxsPT0odT1hKXx8MD09PXUubGVuZ3RoKSYmKGE9ZnVuY3Rpb24odCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0fHx4KHQpP3codCk6eCh0LmRhdGEpP3codC5kYXRhKTpudWxsfShlKSksKHM9Zy5jYWxsKHRoaXMsYSkpfHwoQSgpJiYoZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fCJSR0JBIj09PW58fChjPWUsZT1TKGUpKSkscz10aGlzWyJwcm9jZXNzIituLnRvVXBwZXJDYXNlKCldKGUsaC5jYWxsKHRoaXMpLGEsZnVuY3Rpb24oZSl7cmV0dXJuIGUmJiJzdHJpbmciPT10eXBlb2YgZSYmKGU9ZS50b1VwcGVyQ2FzZSgpKSxlIGluIHQuaW1hZ2VfY29tcHJlc3Npb24/ZTp5Lk5PTkV9KG8pLGMpKSwhcyl0aHJvdyBuZXcgRXJyb3IoIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbHN0IHByb2Nlc3NpbmcgdGhlIGltYWdlLiIpO3JldHVybiBzfSxrPXQuX19hZGRpbWFnZV9fLmNvbnZlcnRCYXNlNjRUb0JpbmFyeVN0cmluZz1mdW5jdGlvbih0LGUpe3ZhciByO2U9ImJvb2xlYW4iIT10eXBlb2YgZXx8ZTt2YXIgbixpPSIiO2lmKCJzdHJpbmciPT10eXBlb2YgdCl7bj1udWxsIT09KHI9TCh0KSk/ci5kYXRhOnQ7dHJ5e2k9YyhuKX1jYXRjaCh0KXtpZihlKXRocm93IE4obik/bmV3IEVycm9yKCJhdG9iLUVycm9yIGluIGpzUERGLmNvbnZlcnRCYXNlNjRUb0JpbmFyeVN0cmluZyAiK3QubWVzc2FnZSk6bmV3IEVycm9yKCJTdXBwbGllZCBEYXRhIGlzIG5vdCBhIHZhbGlkIGJhc2U2NC1TdHJpbmcganNQREYuY29udmVydEJhc2U2NFRvQmluYXJ5U3RyaW5nICIpfX1yZXR1cm4gaX07dC5nZXRJbWFnZVByb3BlcnRpZXM9ZnVuY3Rpb24oZSl7dmFyIG4sYSxvPSIiO2lmKGQoZSkmJihlPXAoZSkpLCJzdHJpbmciPT10eXBlb2YgZSYmaShlKT09PXImJigiIj09PShvPWsoZSwhMSkpJiYobz10LmxvYWRGaWxlKGUpfHwiIiksZT1vKSxhPWkoZSksIWYoYSkpdGhyb3cgbmV3IEVycm9yKCJhZGRJbWFnZSBkb2VzIG5vdCBzdXBwb3J0IGZpbGVzIG9mIHR5cGUgJyIrYSsiJywgcGxlYXNlIGVuc3VyZSB0aGF0IGEgcGx1Z2luIGZvciAnIithKyInIHN1cHBvcnQgaXMgYWRkZWQuIik7aWYoIUEoKXx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fChlPVMoZSkpLCEobj10aGlzWyJwcm9jZXNzIithLnRvVXBwZXJDYXNlKCldKGUpKSl0aHJvdyBuZXcgRXJyb3IoIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWQgd2hpbHN0IHByb2Nlc3NpbmcgdGhlIGltYWdlIik7cmV0dXJuIG4uZmlsZVR5cGU9YSxufX0oTS5BUEkpLAovKioKICAgKiBAbGljZW5zZQogICAqIENvcHlyaWdodCAoYykgMjAxNCBTdGV2ZW4gU3B1bmdpbiAoVHdlbHZlVG9uZSBMTEMpICBzdGV2ZW5AdHdlbHZldG9uZS50dgogICAqCiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogICAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQogICAqLwpmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0KXtpZih2b2lkIDAhPT10JiYiIiE9dClyZXR1cm4hMH07TS5BUEkuZXZlbnRzLnB1c2goWyJhZGRQYWdlIixmdW5jdGlvbih0KXt0aGlzLmludGVybmFsLmdldFBhZ2VJbmZvKHQucGFnZU51bWJlcikucGFnZUNvbnRleHQuYW5ub3RhdGlvbnM9W119XSksdC5ldmVudHMucHVzaChbInB1dFBhZ2UiLGZ1bmN0aW9uKHQpe2Zvcih2YXIgcixuLGksYT10aGlzLmludGVybmFsLmdldENvb3JkaW5hdGVTdHJpbmcsbz10aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyxzPXRoaXMuaW50ZXJuYWwuZ2V0UGFnZUluZm9CeU9iaklkKHQub2JqSWQpLGM9dC5wYWdlQ29udGV4dC5hbm5vdGF0aW9ucyx1PSExLGw9MDtsPGMubGVuZ3RoJiYhdTtsKyspc3dpdGNoKChyPWNbbF0pLnR5cGUpe2Nhc2UibGluayI6KGUoci5vcHRpb25zLnVybCl8fGUoci5vcHRpb25zLnBhZ2VOdW1iZXIpKSYmKHU9ITApO2JyZWFrO2Nhc2UicmVmZXJlbmNlIjpjYXNlInRleHQiOmNhc2UiZnJlZXRleHQiOnU9ITB9aWYoMCE9dSl7dGhpcy5pbnRlcm5hbC53cml0ZSgiL0Fubm90cyBbIik7Zm9yKHZhciBoPTA7aDxjLmxlbmd0aDtoKyspe3I9Y1toXTt2YXIgZj10aGlzLmludGVybmFsLnBkZkVzY2FwZSxkPXRoaXMuaW50ZXJuYWwuZ2V0RW5jcnlwdG9yKHQub2JqSWQpO3N3aXRjaChyLnR5cGUpe2Nhc2UicmVmZXJlbmNlIjp0aGlzLmludGVybmFsLndyaXRlKCIgIityLm9iamVjdC5vYmpJZCsiIDAgUiAiKTticmVhaztjYXNlInRleHQiOnZhciBwPXRoaXMuaW50ZXJuYWwubmV3QWRkaXRpb25hbE9iamVjdCgpLGc9dGhpcy5pbnRlcm5hbC5uZXdBZGRpdGlvbmFsT2JqZWN0KCksbT10aGlzLmludGVybmFsLmdldEVuY3J5cHRvcihwLm9iaklkKSx2PXIudGl0bGV8fCJOb3RlIjtpPSI8PC9UeXBlIC9Bbm5vdCAvU3VidHlwZSAvVGV4dCAiKyhuPSIvUmVjdCBbIithKHIuYm91bmRzLngpKyIgIitvKHIuYm91bmRzLnkrci5ib3VuZHMuaCkrIiAiK2Eoci5ib3VuZHMueCtyLmJvdW5kcy53KSsiICIrbyhyLmJvdW5kcy55KSsiXSAiKSsiL0NvbnRlbnRzICgiK2YobShyLmNvbnRlbnRzKSkrIikiLGkrPSIgL1BvcHVwICIrZy5vYmpJZCsiIDAgUiIsaSs9IiAvUCAiK3Mub2JqSWQrIiAwIFIiLGkrPSIgL1QgKCIrZihtKHYpKSsiKSA+PiIscC5jb250ZW50PWk7dmFyIGI9cC5vYmpJZCsiIDAgUiI7aT0iPDwvVHlwZSAvQW5ub3QgL1N1YnR5cGUgL1BvcHVwICIrKG49Ii9SZWN0IFsiK2Eoci5ib3VuZHMueCszMCkrIiAiK28oci5ib3VuZHMueStyLmJvdW5kcy5oKSsiICIrYShyLmJvdW5kcy54K3IuYm91bmRzLncrMzApKyIgIitvKHIuYm91bmRzLnkpKyJdICIpKyIgL1BhcmVudCAiK2Isci5vcGVuJiYoaSs9IiAvT3BlbiB0cnVlIiksaSs9IiA+PiIsZy5jb250ZW50PWksdGhpcy5pbnRlcm5hbC53cml0ZShwLm9iaklkLCIwIFIiLGcub2JqSWQsIjAgUiIpO2JyZWFrO2Nhc2UiZnJlZXRleHQiOm49Ii9SZWN0IFsiK2Eoci5ib3VuZHMueCkrIiAiK28oci5ib3VuZHMueSkrIiAiK2Eoci5ib3VuZHMueCtyLmJvdW5kcy53KSsiICIrbyhyLmJvdW5kcy55K3IuYm91bmRzLmgpKyJdICI7dmFyIHk9ci5jb2xvcnx8IiMwMDAwMDAiO2k9Ijw8L1R5cGUgL0Fubm90IC9TdWJ0eXBlIC9GcmVlVGV4dCAiK24rIi9Db250ZW50cyAoIitmKGQoci5jb250ZW50cykpKyIpIixpKz0iIC9EUyhmb250OiBIZWx2ZXRpY2Esc2Fucy1zZXJpZiAxMi4wcHQ7IHRleHQtYWxpZ246bGVmdDsgY29sb3I6IyIreSsiKSIsaSs9IiAvQm9yZGVyIFswIDAgMF0iLGkrPSIgPj4iLHRoaXMuaW50ZXJuYWwud3JpdGUoaSk7YnJlYWs7Y2FzZSJsaW5rIjppZihyLm9wdGlvbnMubmFtZSl7dmFyIHc9dGhpcy5hbm5vdGF0aW9ucy5fbmFtZU1hcFtyLm9wdGlvbnMubmFtZV07ci5vcHRpb25zLnBhZ2VOdW1iZXI9dy5wYWdlLHIub3B0aW9ucy50b3A9dy55fWVsc2Ugci5vcHRpb25zLnRvcHx8KHIub3B0aW9ucy50b3A9MCk7aWYobj0iL1JlY3QgWyIrci5maW5hbEJvdW5kcy54KyIgIityLmZpbmFsQm91bmRzLnkrIiAiK3IuZmluYWxCb3VuZHMudysiICIrci5maW5hbEJvdW5kcy5oKyJdICIsaT0iIixyLm9wdGlvbnMudXJsKWk9Ijw8L1R5cGUgL0Fubm90IC9TdWJ0eXBlIC9MaW5rICIrbisiL0JvcmRlciBbMCAwIDBdIC9BIDw8L1MgL1VSSSAvVVJJICgiK2YoZChyLm9wdGlvbnMudXJsKSkrIikgPj4iO2Vsc2UgaWYoci5vcHRpb25zLnBhZ2VOdW1iZXIpe3N3aXRjaChpPSI8PC9UeXBlIC9Bbm5vdCAvU3VidHlwZSAvTGluayAiK24rIi9Cb3JkZXIgWzAgMCAwXSAvRGVzdCBbIit0aGlzLmludGVybmFsLmdldFBhZ2VJbmZvKHIub3B0aW9ucy5wYWdlTnVtYmVyKS5vYmpJZCsiIDAgUiIsci5vcHRpb25zLm1hZ0ZhY3Rvcj1yLm9wdGlvbnMubWFnRmFjdG9yfHwiWFlaIixyLm9wdGlvbnMubWFnRmFjdG9yKXtjYXNlIkZpdCI6aSs9IiAvRml0XSI7YnJlYWs7Y2FzZSJGaXRIIjppKz0iIC9GaXRIICIrci5vcHRpb25zLnRvcCsiXSI7YnJlYWs7Y2FzZSJGaXRWIjpyLm9wdGlvbnMubGVmdD1yLm9wdGlvbnMubGVmdHx8MCxpKz0iIC9GaXRWICIrci5vcHRpb25zLmxlZnQrIl0iO2JyZWFrO2Nhc2UiWFlaIjpkZWZhdWx0OnZhciBOPW8oci5vcHRpb25zLnRvcCk7ci5vcHRpb25zLmxlZnQ9ci5vcHRpb25zLmxlZnR8fDAsdm9pZCAwPT09ci5vcHRpb25zLnpvb20mJihyLm9wdGlvbnMuem9vbT0wKSxpKz0iIC9YWVogIityLm9wdGlvbnMubGVmdCsiICIrTisiICIrci5vcHRpb25zLnpvb20rIl0ifX0iIiE9aSYmKGkrPSIgPj4iLHRoaXMuaW50ZXJuYWwud3JpdGUoaSkpfX10aGlzLmludGVybmFsLndyaXRlKCJdIil9fV0pLHQuY3JlYXRlQW5ub3RhdGlvbj1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpO3N3aXRjaCh0LnR5cGUpe2Nhc2UibGluayI6dGhpcy5saW5rKHQuYm91bmRzLngsdC5ib3VuZHMueSx0LmJvdW5kcy53LHQuYm91bmRzLmgsdCk7YnJlYWs7Y2FzZSJ0ZXh0IjpjYXNlImZyZWV0ZXh0IjplLnBhZ2VDb250ZXh0LmFubm90YXRpb25zLnB1c2godCl9fSx0Lmxpbms9ZnVuY3Rpb24odCxlLHIsbixpKXt2YXIgYT10aGlzLmludGVybmFsLmdldEN1cnJlbnRQYWdlSW5mbygpLG89dGhpcy5pbnRlcm5hbC5nZXRDb29yZGluYXRlU3RyaW5nLHM9dGhpcy5pbnRlcm5hbC5nZXRWZXJ0aWNhbENvb3JkaW5hdGVTdHJpbmc7YS5wYWdlQ29udGV4dC5hbm5vdGF0aW9ucy5wdXNoKHtmaW5hbEJvdW5kczp7eDpvKHQpLHk6cyhlKSx3Om8odCtyKSxoOnMoZStuKX0sb3B0aW9uczppLHR5cGU6ImxpbmsifSl9LHQudGV4dFdpdGhMaW5rPWZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBpLGEsbz10aGlzLmdldFRleHRXaWR0aCh0KSxzPXRoaXMuaW50ZXJuYWwuZ2V0TGluZUhlaWdodCgpL3RoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3I7aWYodm9pZCAwIT09bi5tYXhXaWR0aCl7YT1uLm1heFdpZHRoO3ZhciBjPXRoaXMuc3BsaXRUZXh0VG9TaXplKHQsYSkubGVuZ3RoO2k9TWF0aC5jZWlsKHMqYyl9ZWxzZSBhPW8saT1zO3JldHVybiB0aGlzLnRleHQodCxlLHIsbikscis9LjIqcywiY2VudGVyIj09PW4uYWxpZ24mJihlLT1vLzIpLCJyaWdodCI9PT1uLmFsaWduJiYoZS09byksdGhpcy5saW5rKGUsci1zLGEsaSxuKSxvfSx0LmdldFRleHRXaWR0aD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVybmFsLmdldEZvbnRTaXplKCk7cmV0dXJuIHRoaXMuZ2V0U3RyaW5nVW5pdFdpZHRoKHQpKmUvdGhpcy5pbnRlcm5hbC5zY2FsZUZhY3Rvcn19KE0uQVBJKSwKLyoqCiAgICogQGxpY2Vuc2UKICAgKiBDb3B5cmlnaHQgKGMpIDIwMTcgQXJhcyBBYmJhc2kKICAgKgogICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4KICAgKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UKICAgKi8KZnVuY3Rpb24odCl7dmFyIGU9ezE1Njk6WzY1MTUyXSwxNTcwOls2NTE1Myw2NTE1NF0sMTU3MTpbNjUxNTUsNjUxNTZdLDE1NzI6WzY1MTU3LDY1MTU4XSwxNTczOls2NTE1OSw2NTE2MF0sMTU3NDpbNjUxNjEsNjUxNjIsNjUxNjMsNjUxNjRdLDE1NzU6WzY1MTY1LDY1MTY2XSwxNTc2Ols2NTE2Nyw2NTE2OCw2NTE2OSw2NTE3MF0sMTU3NzpbNjUxNzEsNjUxNzJdLDE1Nzg6WzY1MTczLDY1MTc0LDY1MTc1LDY1MTc2XSwxNTc5Ols2NTE3Nyw2NTE3OCw2NTE3OSw2NTE4MF0sMTU4MDpbNjUxODEsNjUxODIsNjUxODMsNjUxODRdLDE1ODE6WzY1MTg1LDY1MTg2LDY1MTg3LDY1MTg4XSwxNTgyOls2NTE4OSw2NTE5MCw2NTE5MSw2NTE5Ml0sMTU4MzpbNjUxOTMsNjUxOTRdLDE1ODQ6WzY1MTk1LDY1MTk2XSwxNTg1Ols2NTE5Nyw2NTE5OF0sMTU4NjpbNjUxOTksNjUyMDBdLDE1ODc6WzY1MjAxLDY1MjAyLDY1MjAzLDY1MjA0XSwxNTg4Ols2NTIwNSw2NTIwNiw2NTIwNyw2NTIwOF0sMTU4OTpbNjUyMDksNjUyMTAsNjUyMTEsNjUyMTJdLDE1OTA6WzY1MjEzLDY1MjE0LDY1MjE1LDY1MjE2XSwxNTkxOls2NTIxNyw2NTIxOCw2NTIxOSw2NTIyMF0sMTU5MjpbNjUyMjEsNjUyMjIsNjUyMjMsNjUyMjRdLDE1OTM6WzY1MjI1LDY1MjI2LDY1MjI3LDY1MjI4XSwxNTk0Ols2NTIyOSw2NTIzMCw2NTIzMSw2NTIzMl0sMTYwMTpbNjUyMzMsNjUyMzQsNjUyMzUsNjUyMzZdLDE2MDI6WzY1MjM3LDY1MjM4LDY1MjM5LDY1MjQwXSwxNjAzOls2NTI0MSw2NTI0Miw2NTI0Myw2NTI0NF0sMTYwNDpbNjUyNDUsNjUyNDYsNjUyNDcsNjUyNDhdLDE2MDU6WzY1MjQ5LDY1MjUwLDY1MjUxLDY1MjUyXSwxNjA2Ols2NTI1Myw2NTI1NCw2NTI1NSw2NTI1Nl0sMTYwNzpbNjUyNTcsNjUyNTgsNjUyNTksNjUyNjBdLDE2MDg6WzY1MjYxLDY1MjYyXSwxNjA5Ols2NTI2Myw2NTI2NCw2NDQ4OCw2NDQ4OV0sMTYxMDpbNjUyNjUsNjUyNjYsNjUyNjcsNjUyNjhdLDE2NDk6WzY0MzM2LDY0MzM3XSwxNjU1Ols2NDQ3N10sMTY1NzpbNjQzNTgsNjQzNTksNjQzNjAsNjQzNjFdLDE2NTg6WzY0MzUwLDY0MzUxLDY0MzUyLDY0MzUzXSwxNjU5Ols2NDMzOCw2NDMzOSw2NDM0MCw2NDM0MV0sMTY2MjpbNjQzNDIsNjQzNDMsNjQzNDQsNjQzNDVdLDE2NjM6WzY0MzU0LDY0MzU1LDY0MzU2LDY0MzU3XSwxNjY0Ols2NDM0Niw2NDM0Nyw2NDM0OCw2NDM0OV0sMTY2NzpbNjQzNzQsNjQzNzUsNjQzNzYsNjQzNzddLDE2Njg6WzY0MzcwLDY0MzcxLDY0MzcyLDY0MzczXSwxNjcwOls2NDM3OCw2NDM3OSw2NDM4MCw2NDM4MV0sMTY3MTpbNjQzODIsNjQzODMsNjQzODQsNjQzODVdLDE2NzI6WzY0MzkyLDY0MzkzXSwxNjc2Ols2NDM4OCw2NDM4OV0sMTY3NzpbNjQzODYsNjQzODddLDE2Nzg6WzY0MzkwLDY0MzkxXSwxNjgxOls2NDM5Niw2NDM5N10sMTY4ODpbNjQzOTQsNjQzOTVdLDE3MDA6WzY0MzYyLDY0MzYzLDY0MzY0LDY0MzY1XSwxNzAyOls2NDM2Niw2NDM2Nyw2NDM2OCw2NDM2OV0sMTcwNTpbNjQzOTgsNjQzOTksNjQ0MDAsNjQ0MDFdLDE3MDk6WzY0NDY3LDY0NDY4LDY0NDY5LDY0NDcwXSwxNzExOls2NDQwMiw2NDQwMyw2NDQwNCw2NDQwNV0sMTcxMzpbNjQ0MTAsNjQ0MTEsNjQ0MTIsNjQ0MTNdLDE3MTU6WzY0NDA2LDY0NDA3LDY0NDA4LDY0NDA5XSwxNzIyOls2NDQxNCw2NDQxNV0sMTcyMzpbNjQ0MTYsNjQ0MTcsNjQ0MTgsNjQ0MTldLDE3MjY6WzY0NDI2LDY0NDI3LDY0NDI4LDY0NDI5XSwxNzI4Ols2NDQyMCw2NDQyMV0sMTcyOTpbNjQ0MjIsNjQ0MjMsNjQ0MjQsNjQ0MjVdLDE3MzM6WzY0NDgwLDY0NDgxXSwxNzM0Ols2NDQ3Myw2NDQ3NF0sMTczNTpbNjQ0NzEsNjQ0NzJdLDE3MzY6WzY0NDc1LDY0NDc2XSwxNzM3Ols2NDQ4Miw2NDQ4M10sMTczOTpbNjQ0NzgsNjQ0NzldLDE3NDA6WzY0NTA4LDY0NTA5LDY0NTEwLDY0NTExXSwxNzQ0Ols2NDQ4NCw2NDQ4NSw2NDQ4Niw2NDQ4N10sMTc0NjpbNjQ0MzAsNjQ0MzFdLDE3NDc6WzY0NDMyLDY0NDMzXX0scj17NjUyNDc6ezY1MTU0OjY1MjY5LDY1MTU2OjY1MjcxLDY1MTYwOjY1MjczLDY1MTY2OjY1Mjc1fSw2NTI0ODp7NjUxNTQ6NjUyNzAsNjUxNTY6NjUyNzIsNjUxNjA6NjUyNzQsNjUxNjY6NjUyNzZ9LDY1MTY1Ons2NTI0Nzp7NjUyNDg6ezY1MjU4OjY1MDEwfX19LDE2MTc6ezE2MTI6NjQ2MDYsMTYxMzo2NDYwNywxNjE0OjY0NjA4LDE2MTU6NjQ2MDksMTYxNjo2NDYxMH19LG49ezE2MTI6NjQ2MDYsMTYxMzo2NDYwNywxNjE0OjY0NjA4LDE2MTU6NjQ2MDksMTYxNjo2NDYxMH0saT1bMTU3MCwxNTcxLDE1NzMsMTU3NV07dC5fX2FyYWJpY1BhcnNlcl9fPXt9O3ZhciBhPXQuX19hcmFiaWNQYXJzZXJfXy5pc0luQXJhYmljU3Vic3RpdHV0aW9uQT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09ZVt0LmNoYXJDb2RlQXQoMCldfSxvPXQuX19hcmFiaWNQYXJzZXJfXy5pc0FyYWJpY0xldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4ic3RyaW5nIj09dHlwZW9mIHQmJi9eW1x1MDYwMC1cdTA2RkZcdTA3NTAtXHUwNzdGXHUwOEEwLVx1MDhGRlx1RkI1MC1cdUZERkZcdUZFNzAtXHVGRUZGXSskLy50ZXN0KHQpfSxzPXQuX19hcmFiaWNQYXJzZXJfXy5pc0FyYWJpY0VuZExldHRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbyh0KSYmYSh0KSYmZVt0LmNoYXJDb2RlQXQoMCldLmxlbmd0aDw9Mn0sYz10Ll9fYXJhYmljUGFyc2VyX18uaXNBcmFiaWNBbGZMZXR0ZXI9ZnVuY3Rpb24odCl7cmV0dXJuIG8odCkmJmkuaW5kZXhPZih0LmNoYXJDb2RlQXQoMCkpPj0wfTt0Ll9fYXJhYmljUGFyc2VyX18uYXJhYmljTGV0dGVySGFzSXNvbGF0ZWRGb3JtPWZ1bmN0aW9uKHQpe3JldHVybiBvKHQpJiZhKHQpJiZlW3QuY2hhckNvZGVBdCgwKV0ubGVuZ3RoPj0xfTt2YXIgdT10Ll9fYXJhYmljUGFyc2VyX18uYXJhYmljTGV0dGVySGFzRmluYWxGb3JtPWZ1bmN0aW9uKHQpe3JldHVybiBvKHQpJiZhKHQpJiZlW3QuY2hhckNvZGVBdCgwKV0ubGVuZ3RoPj0yfTt0Ll9fYXJhYmljUGFyc2VyX18uYXJhYmljTGV0dGVySGFzSW5pdGlhbEZvcm09ZnVuY3Rpb24odCl7cmV0dXJuIG8odCkmJmEodCkmJmVbdC5jaGFyQ29kZUF0KDApXS5sZW5ndGg+PTN9O3ZhciBsPXQuX19hcmFiaWNQYXJzZXJfXy5hcmFiaWNMZXR0ZXJIYXNNZWRpYWxGb3JtPWZ1bmN0aW9uKHQpe3JldHVybiBvKHQpJiZhKHQpJiY0PT1lW3QuY2hhckNvZGVBdCgwKV0ubGVuZ3RofSxoPXQuX19hcmFiaWNQYXJzZXJfXy5yZXNvbHZlTGlnYXR1cmVzPWZ1bmN0aW9uKHQpe3ZhciBlPTAsbj1yLGk9IiIsYT0wO2ZvcihlPTA7ZTx0Lmxlbmd0aDtlKz0xKXZvaWQgMCE9PW5bdC5jaGFyQ29kZUF0KGUpXT8oYSsrLCJudW1iZXIiPT10eXBlb2Yobj1uW3QuY2hhckNvZGVBdChlKV0pJiYoaSs9U3RyaW5nLmZyb21DaGFyQ29kZShuKSxuPXIsYT0wKSxlPT09dC5sZW5ndGgtMSYmKG49cixpKz10LmNoYXJBdChlLShhLTEpKSxlLT1hLTEsYT0wKSk6KG49cixpKz10LmNoYXJBdChlLWEpLGUtPWEsYT0wKTtyZXR1cm4gaX07dC5fX2FyYWJpY1BhcnNlcl9fLmlzQXJhYmljRGlhY3JpdGljPWZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDAhPT10JiZ2b2lkIDAhPT1uW3QuY2hhckNvZGVBdCgwKV19O3ZhciBmPXQuX19hcmFiaWNQYXJzZXJfXy5nZXRDb3JyZWN0Rm9ybT1mdW5jdGlvbih0LGUscil7cmV0dXJuIG8odCk/ITE9PT1hKHQpPy0xOiF1KHQpfHwhbyhlKSYmIW8ocil8fCFvKHIpJiZzKGUpfHxzKHQpJiYhbyhlKXx8cyh0KSYmYyhlKXx8cyh0KSYmcyhlKT8wOmwodCkmJm8oZSkmJiFzKGUpJiZvKHIpJiZ1KHIpPzM6cyh0KXx8IW8ocik/MToyOi0xfSxkPWZ1bmN0aW9uKHQpe3ZhciByPTAsbj0wLGk9MCxhPSIiLHM9IiIsYz0iIix1PSh0PXR8fCIiKS5zcGxpdCgiXFxzKyIpLGw9W107Zm9yKHI9MDtyPHUubGVuZ3RoO3IrPTEpe2ZvcihsLnB1c2goIiIpLG49MDtuPHVbcl0ubGVuZ3RoO24rPTEpYT11W3JdW25dLHM9dVtyXVtuLTFdLGM9dVtyXVtuKzFdLG8oYSk/KGk9ZihhLHMsYyksbFtyXSs9LTEhPT1pP1N0cmluZy5mcm9tQ2hhckNvZGUoZVthLmNoYXJDb2RlQXQoMCldW2ldKTphKTpsW3JdKz1hO2xbcl09aChsW3JdKX1yZXR1cm4gbC5qb2luKCIgIil9LHA9dC5fX2FyYWJpY1BhcnNlcl9fLnByb2Nlc3NBcmFiaWM9dC5wcm9jZXNzQXJhYmljPWZ1bmN0aW9uKCl7dmFyIHQsZT0ic3RyaW5nIj09dHlwZW9mIGFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06YXJndW1lbnRzWzBdLnRleHQscj1bXTtpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgbj0wO2ZvcihyPVtdLG49MDtuPGUubGVuZ3RoO24rPTEpQXJyYXkuaXNBcnJheShlW25dKT9yLnB1c2goW2QoZVtuXVswXSksZVtuXVsxXSxlW25dWzJdXSk6ci5wdXNoKFtkKGVbbl0pXSk7dD1yfWVsc2UgdD1kKGUpO3JldHVybiJzdHJpbmciPT10eXBlb2YgYXJndW1lbnRzWzBdP3Q6KGFyZ3VtZW50c1swXS50ZXh0PXQsYXJndW1lbnRzWzBdKX07dC5ldmVudHMucHVzaChbInByZVByb2Nlc3NUZXh0IixwXSl9KE0uQVBJKSwKLyoqIEBsaWNlbnNlCiAgICoganNQREYgQXV0b3ByaW50IFBsdWdpbgogICAqCiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogICAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQogICAqLwpmdW5jdGlvbih0KXt0LmF1dG9QcmludD1mdW5jdGlvbih0KXt2YXIgZTtzd2l0Y2goKHQ9dHx8e30pLnZhcmlhbnQ9dC52YXJpYW50fHwibm9uLWNvbmZvcm0iLHQudmFyaWFudCl7Y2FzZSJqYXZhc2NyaXB0Ijp0aGlzLmFkZEpTKCJwcmludCh7fSk7Iik7YnJlYWs7Y2FzZSJub24tY29uZm9ybSI6ZGVmYXVsdDp0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInBvc3RQdXRSZXNvdXJjZXMiLChmdW5jdGlvbigpe2U9dGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKSx0aGlzLmludGVybmFsLm91dCgiPDwiKSx0aGlzLmludGVybmFsLm91dCgiL1MgL05hbWVkIiksdGhpcy5pbnRlcm5hbC5vdXQoIi9UeXBlIC9BY3Rpb24iKSx0aGlzLmludGVybmFsLm91dCgiL04gL1ByaW50IiksdGhpcy5pbnRlcm5hbC5vdXQoIj4+IiksdGhpcy5pbnRlcm5hbC5vdXQoImVuZG9iaiIpfSkpLHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicHV0Q2F0YWxvZyIsKGZ1bmN0aW9uKCl7dGhpcy5pbnRlcm5hbC5vdXQoIi9PcGVuQWN0aW9uICIrZSsiIDAgUiIpfSkpfXJldHVybiB0aGlzfX0oTS5BUEkpLAovKioKICAgKiBAbGljZW5zZQogICAqIENvcHlyaWdodCAoYykgMjAxNCBTdGV2ZW4gU3B1bmdpbiAoVHdlbHZlVG9uZSBMTEMpICBzdGV2ZW5AdHdlbHZldG9uZS50dgogICAqCiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogICAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQogICAqLwpmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbigpe3ZhciB0PXZvaWQgMDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGRmIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHR9LHNldDpmdW5jdGlvbihlKXt0PWV9fSk7dmFyIGU9MTUwO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWR0aCIse2dldDpmdW5jdGlvbigpe3JldHVybiBlfSxzZXQ6ZnVuY3Rpb24odCl7ZT1pc05hTih0KXx8ITE9PT1OdW1iZXIuaXNJbnRlZ2VyKHQpfHx0PDA/MTUwOnQsdGhpcy5nZXRDb250ZXh0KCIyZCIpLnBhZ2VXcmFwWEVuYWJsZWQmJih0aGlzLmdldENvbnRleHQoIjJkIikucGFnZVdyYXBYPWUrMSl9fSk7dmFyIHI9MzAwO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJoZWlnaHQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcn0sc2V0OmZ1bmN0aW9uKHQpe3I9aXNOYU4odCl8fCExPT09TnVtYmVyLmlzSW50ZWdlcih0KXx8dDwwPzMwMDp0LHRoaXMuZ2V0Q29udGV4dCgiMmQiKS5wYWdlV3JhcFlFbmFibGVkJiYodGhpcy5nZXRDb250ZXh0KCIyZCIpLnBhZ2VXcmFwWT1yKzEpfX0pO3ZhciBuPVtdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjaGlsZE5vZGVzIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59LHNldDpmdW5jdGlvbih0KXtuPXR9fSk7dmFyIGk9e307T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInN0eWxlIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGl9LHNldDpmdW5jdGlvbih0KXtpPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBhcmVudE5vZGUiLHt9KX07ZS5wcm90b3R5cGUuZ2V0Q29udGV4dD1mdW5jdGlvbih0LGUpe3ZhciByO2lmKCIyZCIhPT0odD10fHwiMmQiKSlyZXR1cm4gbnVsbDtmb3IociBpbiBlKXRoaXMucGRmLmNvbnRleHQyZC5oYXNPd25Qcm9wZXJ0eShyKSYmKHRoaXMucGRmLmNvbnRleHQyZFtyXT1lW3JdKTtyZXR1cm4gdGhpcy5wZGYuY29udGV4dDJkLl9jYW52YXM9dGhpcyx0aGlzLnBkZi5jb250ZXh0MmR9LGUucHJvdG90eXBlLnRvRGF0YVVSTD1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcigidG9EYXRhVVJMIGlzIG5vdCBpbXBsZW1lbnRlZC4iKX0sdC5ldmVudHMucHVzaChbImluaXRpYWxpemVkIixmdW5jdGlvbigpe3RoaXMuY2FudmFzPW5ldyBlLHRoaXMuY2FudmFzLnBkZj10aGlzfV0pfShNLkFQSSksZnVuY3Rpb24odCl7dmFyIHI9e2xlZnQ6MCx0b3A6MCxib3R0b206MCxyaWdodDowfSxuPSExLGk9ZnVuY3Rpb24oKXt2b2lkIDA9PT10aGlzLmludGVybmFsLl9fY2VsbF9fJiYodGhpcy5pbnRlcm5hbC5fX2NlbGxfXz17fSx0aGlzLmludGVybmFsLl9fY2VsbF9fLnBhZGRpbmc9Myx0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckZ1bmN0aW9uPXZvaWQgMCx0aGlzLmludGVybmFsLl9fY2VsbF9fLm1hcmdpbnM9T2JqZWN0LmFzc2lnbih7fSxyKSx0aGlzLmludGVybmFsLl9fY2VsbF9fLm1hcmdpbnMud2lkdGg9dGhpcy5nZXRQYWdlV2lkdGgoKSxhLmNhbGwodGhpcykpfSxhPWZ1bmN0aW9uKCl7dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5sYXN0Q2VsbD1uZXcgbyx0aGlzLmludGVybmFsLl9fY2VsbF9fLnBhZ2VzPTF9LG89ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHNbMF07T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIngiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB0fSxzZXQ6ZnVuY3Rpb24oZSl7dD1lfX0pO3ZhciBlPWFyZ3VtZW50c1sxXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywieSIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGV9LHNldDpmdW5jdGlvbih0KXtlPXR9fSk7dmFyIHI9YXJndW1lbnRzWzJdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWR0aCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHJ9LHNldDpmdW5jdGlvbih0KXtyPXR9fSk7dmFyIG49YXJndW1lbnRzWzNdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJoZWlnaHQiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBufSxzZXQ6ZnVuY3Rpb24odCl7bj10fX0pO3ZhciBpPWFyZ3VtZW50c1s0XTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywidGV4dCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGl9LHNldDpmdW5jdGlvbih0KXtpPXR9fSk7dmFyIGE9YXJndW1lbnRzWzVdO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lTnVtYmVyIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKHQpe2E9dH19KTt2YXIgbz1hcmd1bWVudHNbNl07cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJhbGlnbiIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG99LHNldDpmdW5jdGlvbih0KXtvPXR9fSksdGhpc307by5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG8odGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMudGV4dCx0aGlzLmxpbmVOdW1iZXIsdGhpcy5hbGlnbil9LG8ucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtyZXR1cm5bdGhpcy54LHRoaXMueSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LHRoaXMudGV4dCx0aGlzLmxpbmVOdW1iZXIsdGhpcy5hbGlnbl19LHQuc2V0SGVhZGVyRnVuY3Rpb249ZnVuY3Rpb24odCl7cmV0dXJuIGkuY2FsbCh0aGlzKSx0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckZ1bmN0aW9uPSJmdW5jdGlvbiI9PXR5cGVvZiB0P3Q6dm9pZCAwLHRoaXN9LHQuZ2V0VGV4dERpbWVuc2lvbnM9ZnVuY3Rpb24odCxlKXtpLmNhbGwodGhpcyk7dmFyIHI9KGU9ZXx8e30pLmZvbnRTaXplfHx0aGlzLmdldEZvbnRTaXplKCksbj1lLmZvbnR8fHRoaXMuZ2V0Rm9udCgpLGE9ZS5zY2FsZUZhY3Rvcnx8dGhpcy5pbnRlcm5hbC5zY2FsZUZhY3RvcixvPTAscz0wLGM9MCx1PXRoaXM7aWYoIUFycmF5LmlzQXJyYXkodCkmJiJzdHJpbmciIT10eXBlb2YgdCl7aWYoIm51bWJlciIhPXR5cGVvZiB0KXRocm93IG5ldyBFcnJvcigiZ2V0VGV4dERpbWVuc2lvbnMgZXhwZWN0cyB0ZXh0LXBhcmFtZXRlciB0byBiZSBvZiB0eXBlIFN0cmluZyBvciB0eXBlIE51bWJlciBvciBhbiBBcnJheSBvZiBTdHJpbmdzLiIpO3Q9U3RyaW5nKHQpfXZhciBsPWUubWF4V2lkdGg7bD4wPyJzdHJpbmciPT10eXBlb2YgdD90PXRoaXMuc3BsaXRUZXh0VG9TaXplKHQsbCk6IltvYmplY3QgQXJyYXldIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSYmKHQ9dC5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29uY2F0KHUuc3BsaXRUZXh0VG9TaXplKGUsbCkpfSksW10pKTp0PUFycmF5LmlzQXJyYXkodCk/dDpbdF07Zm9yKHZhciBoPTA7aDx0Lmxlbmd0aDtoKyspbzwoYz10aGlzLmdldFN0cmluZ1VuaXRXaWR0aCh0W2hdLHtmb250Om59KSpyKSYmKG89Yyk7cmV0dXJuIDAhPT1vJiYocz10Lmxlbmd0aCkse3c6by89YSxoOk1hdGgubWF4KChzKnIqdGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCktcioodGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCktMSkpL2EsMCl9fSx0LmNlbGxBZGRQYWdlPWZ1bmN0aW9uKCl7aS5jYWxsKHRoaXMpLHRoaXMuYWRkUGFnZSgpO3ZhciB0PXRoaXMuaW50ZXJuYWwuX19jZWxsX18ubWFyZ2luc3x8cjtyZXR1cm4gdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5sYXN0Q2VsbD1uZXcgbyh0LmxlZnQsdC50b3Asdm9pZCAwLHZvaWQgMCksdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5wYWdlcys9MSx0aGlzfTt2YXIgcz10LmNlbGw9ZnVuY3Rpb24oKXt2YXIgdDt0PWFyZ3VtZW50c1swXWluc3RhbmNlb2Ygbz9hcmd1bWVudHNbMF06bmV3IG8oYXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0pLGkuY2FsbCh0aGlzKTt2YXIgZT10aGlzLmludGVybmFsLl9fY2VsbF9fLmxhc3RDZWxsLGE9dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5wYWRkaW5nLHM9dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5tYXJnaW5zfHxyLGM9dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy50YWJsZUhlYWRlclJvdyx1PXRoaXMuaW50ZXJuYWwuX19jZWxsX18ucHJpbnRIZWFkZXJzO3JldHVybiB2b2lkIDAhPT1lLmxpbmVOdW1iZXImJihlLmxpbmVOdW1iZXI9PT10LmxpbmVOdW1iZXI/KHQueD0oZS54fHwwKSsoZS53aWR0aHx8MCksdC55PWUueXx8MCk6ZS55K2UuaGVpZ2h0K3QuaGVpZ2h0K3MuYm90dG9tPnRoaXMuZ2V0UGFnZUhlaWdodCgpPyh0aGlzLmNlbGxBZGRQYWdlKCksdC55PXMudG9wLHUmJmMmJih0aGlzLnByaW50SGVhZGVyUm93KHQubGluZU51bWJlciwhMCksdC55Kz1jWzBdLmhlaWdodCkpOnQueT1lLnkrZS5oZWlnaHR8fHQueSksdm9pZCAwIT09dC50ZXh0WzBdJiYodGhpcy5yZWN0KHQueCx0LnksdC53aWR0aCx0LmhlaWdodCwhMD09PW4/IkZEIjp2b2lkIDApLCJyaWdodCI9PT10LmFsaWduP3RoaXMudGV4dCh0LnRleHQsdC54K3Qud2lkdGgtYSx0LnkrYSx7YWxpZ246InJpZ2h0IixiYXNlbGluZToidG9wIn0pOiJjZW50ZXIiPT09dC5hbGlnbj90aGlzLnRleHQodC50ZXh0LHQueCt0LndpZHRoLzIsdC55K2Ese2FsaWduOiJjZW50ZXIiLGJhc2VsaW5lOiJ0b3AiLG1heFdpZHRoOnQud2lkdGgtYS1hfSk6dGhpcy50ZXh0KHQudGV4dCx0LngrYSx0LnkrYSx7YWxpZ246ImxlZnQiLGJhc2VsaW5lOiJ0b3AiLG1heFdpZHRoOnQud2lkdGgtYS1hfSkpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ubGFzdENlbGw9dCx0aGlzfTt0LnRhYmxlPWZ1bmN0aW9uKHQsbix1LGwsaCl7aWYoaS5jYWxsKHRoaXMpLCF1KXRocm93IG5ldyBFcnJvcigiTm8gZGF0YSBmb3IgUERGIHRhYmxlLiIpO3ZhciBmLGQscCxnLG09W10sdj1bXSxiPVtdLHk9e30sdz17fSxOPVtdLEw9W10sQT0oaD1ofHx7fSkuYXV0b1NpemV8fCExLHg9ITEhPT1oLnByaW50SGVhZGVycyxTPWguY3NzJiZ2b2lkIDAhPT1oLmNzc1siZm9udC1zaXplIl0/MTYqaC5jc3NbImZvbnQtc2l6ZSJdOmguZm9udFNpemV8fDEyLF89aC5tYXJnaW5zfHxPYmplY3QuYXNzaWduKHt3aWR0aDp0aGlzLmdldFBhZ2VXaWR0aCgpfSxyKSxQPSJudW1iZXIiPT10eXBlb2YgaC5wYWRkaW5nP2gucGFkZGluZzozLGs9aC5oZWFkZXJCYWNrZ3JvdW5kQ29sb3J8fCIjYzhjOGM4IixGPWguaGVhZGVyVGV4dENvbG9yfHwiIzAwMCI7aWYoYS5jYWxsKHRoaXMpLHRoaXMuaW50ZXJuYWwuX19jZWxsX18ucHJpbnRIZWFkZXJzPXgsdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5tYXJnaW5zPV8sdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy50YWJsZV9mb250X3NpemU9Uyx0aGlzLmludGVybmFsLl9fY2VsbF9fLnBhZGRpbmc9UCx0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckJhY2tncm91bmRDb2xvcj1rLHRoaXMuaW50ZXJuYWwuX19jZWxsX18uaGVhZGVyVGV4dENvbG9yPUYsdGhpcy5zZXRGb250U2l6ZShTKSxudWxsPT1sKXY9bT1PYmplY3Qua2V5cyh1WzBdKSxiPW0ubWFwKChmdW5jdGlvbigpe3JldHVybiJsZWZ0In0pKTtlbHNlIGlmKEFycmF5LmlzQXJyYXkobCkmJiJvYmplY3QiPT09ZShsWzBdKSlmb3IobT1sLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubmFtZX0pKSx2PWwubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5wcm9tcHR8fHQubmFtZXx8IiJ9KSksYj1sLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQuYWxpZ258fCJsZWZ0In0pKSxmPTA7ZjxsLmxlbmd0aDtmKz0xKXdbbFtmXS5uYW1lXT1sW2ZdLndpZHRoKigxOS4wNDk5NzYvMjUuNCk7ZWxzZSBBcnJheS5pc0FycmF5KGwpJiYic3RyaW5nIj09dHlwZW9mIGxbMF0mJih2PW09bCxiPW0ubWFwKChmdW5jdGlvbigpe3JldHVybiJsZWZ0In0pKSk7aWYoQXx8QXJyYXkuaXNBcnJheShsKSYmInN0cmluZyI9PXR5cGVvZiBsWzBdKWZvcihmPTA7ZjxtLmxlbmd0aDtmKz0xKXtmb3IoeVtnPW1bZl1dPXUubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdFtnXX0pKSx0aGlzLnNldEZvbnQodm9pZCAwLCJib2xkIiksTi5wdXNoKHRoaXMuZ2V0VGV4dERpbWVuc2lvbnModltmXSx7Zm9udFNpemU6dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy50YWJsZV9mb250X3NpemUsc2NhbGVGYWN0b3I6dGhpcy5pbnRlcm5hbC5zY2FsZUZhY3Rvcn0pLncpLGQ9eVtnXSx0aGlzLnNldEZvbnQodm9pZCAwLCJub3JtYWwiKSxwPTA7cDxkLmxlbmd0aDtwKz0xKU4ucHVzaCh0aGlzLmdldFRleHREaW1lbnNpb25zKGRbcF0se2ZvbnRTaXplOnRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVfZm9udF9zaXplLHNjYWxlRmFjdG9yOnRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3J9KS53KTt3W2ddPU1hdGgubWF4LmFwcGx5KG51bGwsTikrUCtQLE49W119aWYoeCl7dmFyIEk9e307Zm9yKGY9MDtmPG0ubGVuZ3RoO2YrPTEpSVttW2ZdXT17fSxJW21bZl1dLnRleHQ9dltmXSxJW21bZl1dLmFsaWduPWJbZl07dmFyIEM9Yy5jYWxsKHRoaXMsSSx3KTtMPW0ubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IG8odCxuLHdbZV0sQyxJW2VdLnRleHQsdm9pZCAwLElbZV0uYWxpZ24pfSkpLHRoaXMuc2V0VGFibGVIZWFkZXJSb3coTCksdGhpcy5wcmludEhlYWRlclJvdygxLCExKX12YXIgaj1sLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdFtlLm5hbWVdPWUuYWxpZ24sdH0pLHt9KTtmb3IoZj0wO2Y8dS5sZW5ndGg7Zis9MSl7InJvd1N0YXJ0ImluIGgmJmgucm93U3RhcnQgaW5zdGFuY2VvZiBGdW5jdGlvbiYmaC5yb3dTdGFydCh7cm93OmYsZGF0YTp1W2ZdfSx0aGlzKTt2YXIgTz1jLmNhbGwodGhpcyx1W2ZdLHcpO2ZvcihwPTA7cDxtLmxlbmd0aDtwKz0xKXt2YXIgQj11W2ZdW21bcF1dOyJjZWxsU3RhcnQiaW4gaCYmaC5jZWxsU3RhcnQgaW5zdGFuY2VvZiBGdW5jdGlvbiYmaC5jZWxsU3RhcnQoe3JvdzpmLGNvbDpwLGRhdGE6Qn0sdGhpcykscy5jYWxsKHRoaXMsbmV3IG8odCxuLHdbbVtwXV0sTyxCLGYrMixqW21bcF1dKSl9fXJldHVybiB0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlX3g9dCx0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlX3k9bix0aGlzfTt2YXIgYz1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXMuaW50ZXJuYWwuX19jZWxsX18ucGFkZGluZyxuPXRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVfZm9udF9zaXplLGk9dGhpcy5pbnRlcm5hbC5zY2FsZUZhY3RvcjtyZXR1cm4gT2JqZWN0LmtleXModCkubWFwKChmdW5jdGlvbihuKXt2YXIgaT10W25dO3JldHVybiB0aGlzLnNwbGl0VGV4dFRvU2l6ZShpLmhhc093blByb3BlcnR5KCJ0ZXh0Iik/aS50ZXh0OmksZVtuXS1yLXIpfSksdGhpcykubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRMaW5lSGVpZ2h0RmFjdG9yKCkqdC5sZW5ndGgqbi9pK3Ircn0pLHRoaXMpLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gTWF0aC5tYXgodCxlKX0pLDApfTt0LnNldFRhYmxlSGVhZGVyUm93PWZ1bmN0aW9uKHQpe2kuY2FsbCh0aGlzKSx0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlSGVhZGVyUm93PXR9LHQucHJpbnRIZWFkZXJSb3c9ZnVuY3Rpb24odCxlKXtpZihpLmNhbGwodGhpcyksIXRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVIZWFkZXJSb3cpdGhyb3cgbmV3IEVycm9yKCJQcm9wZXJ0eSB0YWJsZUhlYWRlclJvdyBkb2VzIG5vdCBleGlzdC4iKTt2YXIgcjtpZihuPSEwLCJmdW5jdGlvbiI9PXR5cGVvZiB0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckZ1bmN0aW9uKXt2YXIgYT10aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckZ1bmN0aW9uKHRoaXMsdGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5wYWdlcyk7dGhpcy5pbnRlcm5hbC5fX2NlbGxfXy5sYXN0Q2VsbD1uZXcgbyhhWzBdLGFbMV0sYVsyXSxhWzNdLHZvaWQgMCwtMSl9dGhpcy5zZXRGb250KHZvaWQgMCwiYm9sZCIpO2Zvcih2YXIgYz1bXSx1PTA7dTx0aGlzLmludGVybmFsLl9fY2VsbF9fLnRhYmxlSGVhZGVyUm93Lmxlbmd0aDt1Kz0xKXtyPXRoaXMuaW50ZXJuYWwuX19jZWxsX18udGFibGVIZWFkZXJSb3dbdV0uY2xvbmUoKSxlJiYoci55PXRoaXMuaW50ZXJuYWwuX19jZWxsX18ubWFyZ2lucy50b3B8fDAsYy5wdXNoKHIpKSxyLmxpbmVOdW1iZXI9dDt2YXIgbD10aGlzLmdldFRleHRDb2xvcigpO3RoaXMuc2V0VGV4dENvbG9yKHRoaXMuaW50ZXJuYWwuX19jZWxsX18uaGVhZGVyVGV4dENvbG9yKSx0aGlzLnNldEZpbGxDb2xvcih0aGlzLmludGVybmFsLl9fY2VsbF9fLmhlYWRlckJhY2tncm91bmRDb2xvcikscy5jYWxsKHRoaXMsciksdGhpcy5zZXRUZXh0Q29sb3IobCl9Yy5sZW5ndGg+MCYmdGhpcy5zZXRUYWJsZUhlYWRlclJvdyhjKSx0aGlzLnNldEZvbnQodm9pZCAwLCJub3JtYWwiKSxuPSExfX0oTS5BUEkpO3ZhciBfdD17aXRhbGljOlsiaXRhbGljIiwib2JsaXF1ZSIsIm5vcm1hbCJdLG9ibGlxdWU6WyJvYmxpcXVlIiwiaXRhbGljIiwibm9ybWFsIl0sbm9ybWFsOlsibm9ybWFsIiwib2JsaXF1ZSIsIml0YWxpYyJdfSxQdD1bInVsdHJhLWNvbmRlbnNlZCIsImV4dHJhLWNvbmRlbnNlZCIsImNvbmRlbnNlZCIsInNlbWktY29uZGVuc2VkIiwibm9ybWFsIiwic2VtaS1leHBhbmRlZCIsImV4cGFuZGVkIiwiZXh0cmEtZXhwYW5kZWQiLCJ1bHRyYS1leHBhbmRlZCJdLGt0PVN0KFB0KSxGdD1bMTAwLDIwMCwzMDAsNDAwLDUwMCw2MDAsNzAwLDgwMCw5MDBdLEl0PVN0KEZ0KTtmdW5jdGlvbiBDdCh0KXt2YXIgZT10LmZhbWlseS5yZXBsYWNlKC8ifCcvZywiIikudG9Mb3dlckNhc2UoKSxyPWZ1bmN0aW9uKHQpe3JldHVybiBfdFt0PXR8fCJub3JtYWwiXT90OiJub3JtYWwifSh0LnN0eWxlKSxuPWZ1bmN0aW9uKHQpe2lmKCF0KXJldHVybiA0MDA7aWYoIm51bWJlciI9PXR5cGVvZiB0KXJldHVybiB0Pj0xMDAmJnQ8PTkwMCYmdCUxMDA9PTA/dDo0MDA7aWYoL15cZDAwJC8udGVzdCh0KSlyZXR1cm4gcGFyc2VJbnQodCk7c3dpdGNoKHQpe2Nhc2UiYm9sZCI6cmV0dXJuIDcwMDtjYXNlIm5vcm1hbCI6ZGVmYXVsdDpyZXR1cm4gNDAwfX0odC53ZWlnaHQpLGk9ZnVuY3Rpb24odCl7cmV0dXJuIm51bWJlciI9PXR5cGVvZiBrdFt0PXR8fCJub3JtYWwiXT90OiJub3JtYWwifSh0LnN0cmV0Y2gpO3JldHVybntmYW1pbHk6ZSxzdHlsZTpyLHdlaWdodDpuLHN0cmV0Y2g6aSxzcmM6dC5zcmN8fFtdLHJlZjp0LnJlZnx8e25hbWU6ZSxzdHlsZTpbaSxyLG5dLmpvaW4oIiAiKX19fWZ1bmN0aW9uIGp0KHQsZSxyLG4pe3ZhciBpO2ZvcihpPXI7aT49MCYmaTxlLmxlbmd0aDtpKz1uKWlmKHRbZVtpXV0pcmV0dXJuIHRbZVtpXV07Zm9yKGk9cjtpPj0wJiZpPGUubGVuZ3RoO2ktPW4paWYodFtlW2ldXSlyZXR1cm4gdFtlW2ldXX12YXIgT3Q9eyJzYW5zLXNlcmlmIjoiaGVsdmV0aWNhIixmaXhlZDoiY291cmllciIsbW9ub3NwYWNlOiJjb3VyaWVyIix0ZXJtaW5hbDoiY291cmllciIsY3Vyc2l2ZToidGltZXMiLGZhbnRhc3k6InRpbWVzIixzZXJpZjoidGltZXMifSxCdD17Y2FwdGlvbjoidGltZXMiLGljb246InRpbWVzIixtZW51OiJ0aW1lcyIsIm1lc3NhZ2UtYm94IjoidGltZXMiLCJzbWFsbC1jYXB0aW9uIjoidGltZXMiLCJzdGF0dXMtYmFyIjoidGltZXMifTtmdW5jdGlvbiBNdCh0KXtyZXR1cm5bdC5zdHJldGNoLHQuc3R5bGUsdC53ZWlnaHQsdC5mYW1pbHldLmpvaW4oIiAiKX1mdW5jdGlvbiBFdCh0LGUscil7Zm9yKHZhciBuPShyPXJ8fHt9KS5kZWZhdWx0Rm9udEZhbWlseXx8InRpbWVzIixpPU9iamVjdC5hc3NpZ24oe30sT3Qsci5nZW5lcmljRm9udEZhbWlsaWVzfHx7fSksYT1udWxsLG89bnVsbCxzPTA7czxlLmxlbmd0aDsrK3MpaWYoaVsoYT1DdChlW3NdKSkuZmFtaWx5XSYmKGEuZmFtaWx5PWlbYS5mYW1pbHldKSx0Lmhhc093blByb3BlcnR5KGEuZmFtaWx5KSl7bz10W2EuZmFtaWx5XTticmVha31pZighKG89b3x8dFtuXSkpdGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgZmluZCBhIGZvbnQtZmFtaWx5IGZvciB0aGUgcnVsZSAnIitNdChhKSsiJyBhbmQgZGVmYXVsdCBmYW1pbHkgJyIrbisiJy4iKTtpZihvPWZ1bmN0aW9uKHQsZSl7aWYoZVt0XSlyZXR1cm4gZVt0XTt2YXIgcj1rdFt0XSxuPXI8PWt0Lm5vcm1hbD8tMToxLGk9anQoZSxQdCxyLG4pO2lmKCFpKXRocm93IG5ldyBFcnJvcigiQ291bGQgbm90IGZpbmQgYSBtYXRjaGluZyBmb250LXN0cmV0Y2ggdmFsdWUgZm9yICIrdCk7cmV0dXJuIGl9KGEuc3RyZXRjaCxvKSxvPWZ1bmN0aW9uKHQsZSl7aWYoZVt0XSlyZXR1cm4gZVt0XTtmb3IodmFyIHI9X3RbdF0sbj0wO248ci5sZW5ndGg7KytuKWlmKGVbcltuXV0pcmV0dXJuIGVbcltuXV07dGhyb3cgbmV3IEVycm9yKCJDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIGZvbnQtc3R5bGUgZm9yICIrdCl9KGEuc3R5bGUsbyksIShvPWZ1bmN0aW9uKHQsZSl7aWYoZVt0XSlyZXR1cm4gZVt0XTtpZig0MDA9PT10JiZlWzUwMF0pcmV0dXJuIGVbNTAwXTtpZig1MDA9PT10JiZlWzQwMF0pcmV0dXJuIGVbNDAwXTt2YXIgcj1JdFt0XSxuPWp0KGUsRnQscix0PDQwMD8tMToxKTtpZighbil0aHJvdyBuZXcgRXJyb3IoIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgZm9udC13ZWlnaHQgZm9yIHZhbHVlICIrdCk7cmV0dXJuIG59KGEud2VpZ2h0LG8pKSl0aHJvdyBuZXcgRXJyb3IoIkZhaWxlZCB0byByZXNvbHZlIGEgZm9udCBmb3IgdGhlIHJ1bGUgJyIrTXQoYSkrIicuIik7cmV0dXJuIG99ZnVuY3Rpb24gcXQodCl7cmV0dXJuIHQudHJpbUxlZnQoKX1mdW5jdGlvbiBEdCh0LGUpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7KXtpZih0LmNoYXJBdChyKT09PWUpcmV0dXJuW3Quc3Vic3RyaW5nKDAsciksdC5zdWJzdHJpbmcocisxKV07cis9MX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBSdCh0KXt2YXIgZT10Lm1hdGNoKC9eKC1bYS16X118W2Etel9dKVthLXowLTlfLV0qL2kpO3JldHVybiBudWxsPT09ZT9udWxsOltlWzBdLHQuc3Vic3RyaW5nKGVbMF0ubGVuZ3RoKV19dmFyIFR0PVsidGltZXMiXTshZnVuY3Rpb24odCl7dmFyIHIsbixhLG8scyxjLHUsbCxmLGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9dHx8e30sdGhpcy5pc1N0cm9rZVRyYW5zcGFyZW50PXQuaXNTdHJva2VUcmFuc3BhcmVudHx8ITEsdGhpcy5zdHJva2VPcGFjaXR5PXQuc3Ryb2tlT3BhY2l0eXx8MSx0aGlzLnN0cm9rZVN0eWxlPXQuc3Ryb2tlU3R5bGV8fCIjMDAwMDAwIix0aGlzLmZpbGxTdHlsZT10LmZpbGxTdHlsZXx8IiMwMDAwMDAiLHRoaXMuaXNGaWxsVHJhbnNwYXJlbnQ9dC5pc0ZpbGxUcmFuc3BhcmVudHx8ITEsdGhpcy5maWxsT3BhY2l0eT10LmZpbGxPcGFjaXR5fHwxLHRoaXMuZm9udD10LmZvbnR8fCIxMHB4IHNhbnMtc2VyaWYiLHRoaXMudGV4dEJhc2VsaW5lPXQudGV4dEJhc2VsaW5lfHwiYWxwaGFiZXRpYyIsdGhpcy50ZXh0QWxpZ249dC50ZXh0QWxpZ258fCJsZWZ0Iix0aGlzLmxpbmVXaWR0aD10LmxpbmVXaWR0aHx8MSx0aGlzLmxpbmVKb2luPXQubGluZUpvaW58fCJtaXRlciIsdGhpcy5saW5lQ2FwPXQubGluZUNhcHx8ImJ1dHQiLHRoaXMucGF0aD10LnBhdGh8fFtdLHRoaXMudHJhbnNmb3JtPXZvaWQgMCE9PXQudHJhbnNmb3JtP3QudHJhbnNmb3JtLmNsb25lKCk6bmV3IGwsdGhpcy5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb258fCJub3JtYWwiLHRoaXMuZ2xvYmFsQWxwaGE9dC5nbG9iYWxBbHBoYXx8MSx0aGlzLmNsaXBfcGF0aD10LmNsaXBfcGF0aHx8W10sdGhpcy5jdXJyZW50UG9pbnQ9dC5jdXJyZW50UG9pbnR8fG5ldyBjLHRoaXMubWl0ZXJMaW1pdD10Lm1pdGVyTGltaXR8fDEwLHRoaXMubGFzdFBvaW50PXQubGFzdFBvaW50fHxuZXcgYyx0aGlzLmxpbmVEYXNoT2Zmc2V0PXQubGluZURhc2hPZmZzZXR8fDAsdGhpcy5saW5lRGFzaD10LmxpbmVEYXNofHxbXSx0aGlzLm1hcmdpbj10Lm1hcmdpbnx8WzAsMCwwLDBdLHRoaXMucHJldlBhZ2VMYXN0RWxlbU9mZnNldD10LnByZXZQYWdlTGFzdEVsZW1PZmZzZXR8fDAsdGhpcy5pZ25vcmVDbGVhclJlY3Q9ImJvb2xlYW4iIT10eXBlb2YgdC5pZ25vcmVDbGVhclJlY3R8fHQuaWdub3JlQ2xlYXJSZWN0LHRoaXN9O3QuZXZlbnRzLnB1c2goWyJpbml0aWFsaXplZCIsZnVuY3Rpb24oKXt0aGlzLmNvbnRleHQyZD1uZXcgcCh0aGlzKSxyPXRoaXMuaW50ZXJuYWwuZjIsbj10aGlzLmludGVybmFsLmdldENvb3JkaW5hdGVTdHJpbmcsYT10aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZVN0cmluZyxvPXRoaXMuaW50ZXJuYWwuZ2V0SG9yaXpvbnRhbENvb3JkaW5hdGUscz10aGlzLmludGVybmFsLmdldFZlcnRpY2FsQ29vcmRpbmF0ZSxjPXRoaXMuaW50ZXJuYWwuUG9pbnQsdT10aGlzLmludGVybmFsLlJlY3RhbmdsZSxsPXRoaXMuaW50ZXJuYWwuTWF0cml4LGY9bmV3IGR9XSk7dmFyIHA9ZnVuY3Rpb24odCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImNhbnZhcyIse2dldDpmdW5jdGlvbigpe3JldHVybntwYXJlbnROb2RlOiExLHN0eWxlOiExfX19KTt2YXIgZT10O09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwZGYiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZX19KTt2YXIgcj0hMTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFnZVdyYXBYRW5hYmxlZCIse2dldDpmdW5jdGlvbigpe3JldHVybiByfSxzZXQ6ZnVuY3Rpb24odCl7cj1Cb29sZWFuKHQpfX0pO3ZhciBuPSExO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJwYWdlV3JhcFlFbmFibGVkIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG59LHNldDpmdW5jdGlvbih0KXtuPUJvb2xlYW4odCl9fSk7dmFyIGk9MDtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicG9zWCIse2dldDpmdW5jdGlvbigpe3JldHVybiBpfSxzZXQ6ZnVuY3Rpb24odCl7aXNOYU4odCl8fChpPXQpfX0pO3ZhciBhPTA7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInBvc1kiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKHQpe2lzTmFOKHQpfHwoYT10KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywibWFyZ2luIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGYubWFyZ2lufSxzZXQ6ZnVuY3Rpb24odCl7dmFyIGU7Im51bWJlciI9PXR5cGVvZiB0P2U9W3QsdCx0LHRdOigoZT1uZXcgQXJyYXkoNCkpWzBdPXRbMF0sZVsxXT10Lmxlbmd0aD49Mj90WzFdOmVbMF0sZVsyXT10Lmxlbmd0aD49Mz90WzJdOmVbMF0sZVszXT10Lmxlbmd0aD49ND90WzNdOmVbMV0pLGYubWFyZ2luPWV9fSk7dmFyIG89ITE7T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImF1dG9QYWdpbmciLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gb30sc2V0OmZ1bmN0aW9uKHQpe289dH19KTt2YXIgcz0wO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsYXN0QnJlYWsiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gc30sc2V0OmZ1bmN0aW9uKHQpe3M9dH19KTt2YXIgYz1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGFnZUJyZWFrcyIse2dldDpmdW5jdGlvbigpe3JldHVybiBjfSxzZXQ6ZnVuY3Rpb24odCl7Yz10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJjdHgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZn0sc2V0OmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBkJiYoZj10KX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywicGF0aCIse2dldDpmdW5jdGlvbigpe3JldHVybiBmLnBhdGh9LHNldDpmdW5jdGlvbih0KXtmLnBhdGg9dH19KTt2YXIgdT1bXTtPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiY3R4U3RhY2siLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdX0sc2V0OmZ1bmN0aW9uKHQpe3U9dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZmlsbFN0eWxlIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3R4LmZpbGxTdHlsZX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlO2U9Zyh0KSx0aGlzLmN0eC5maWxsU3R5bGU9ZS5zdHlsZSx0aGlzLmN0eC5pc0ZpbGxUcmFuc3BhcmVudD0wPT09ZS5hLHRoaXMuY3R4LmZpbGxPcGFjaXR5PWUuYSx0aGlzLnBkZi5zZXRGaWxsQ29sb3IoZS5yLGUuZyxlLmIse2E6ZS5hfSksdGhpcy5wZGYuc2V0VGV4dENvbG9yKGUucixlLmcsZS5iLHthOmUuYX0pfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJzdHJva2VTdHlsZSIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5zdHJva2VTdHlsZX0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlPWcodCk7dGhpcy5jdHguc3Ryb2tlU3R5bGU9ZS5zdHlsZSx0aGlzLmN0eC5pc1N0cm9rZVRyYW5zcGFyZW50PTA9PT1lLmEsdGhpcy5jdHguc3Ryb2tlT3BhY2l0eT1lLmEsMD09PWUuYT90aGlzLnBkZi5zZXREcmF3Q29sb3IoMjU1LDI1NSwyNTUpOihlLmEsdGhpcy5wZGYuc2V0RHJhd0NvbG9yKGUucixlLmcsZS5iKSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImxpbmVDYXAiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubGluZUNhcH0sc2V0OmZ1bmN0aW9uKHQpey0xIT09WyJidXR0Iiwicm91bmQiLCJzcXVhcmUiXS5pbmRleE9mKHQpJiYodGhpcy5jdHgubGluZUNhcD10LHRoaXMucGRmLnNldExpbmVDYXAodCkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lV2lkdGgiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubGluZVdpZHRofSxzZXQ6ZnVuY3Rpb24odCl7aXNOYU4odCl8fCh0aGlzLmN0eC5saW5lV2lkdGg9dCx0aGlzLnBkZi5zZXRMaW5lV2lkdGgodCkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lSm9pbiIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5saW5lSm9pbn0sc2V0OmZ1bmN0aW9uKHQpey0xIT09WyJiZXZlbCIsInJvdW5kIiwibWl0ZXIiXS5pbmRleE9mKHQpJiYodGhpcy5jdHgubGluZUpvaW49dCx0aGlzLnBkZi5zZXRMaW5lSm9pbih0KSl9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIm1pdGVyTGltaXQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgubWl0ZXJMaW1pdH0sc2V0OmZ1bmN0aW9uKHQpe2lzTmFOKHQpfHwodGhpcy5jdHgubWl0ZXJMaW1pdD10LHRoaXMucGRmLnNldE1pdGVyTGltaXQodCkpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ0ZXh0QmFzZWxpbmUiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHgudGV4dEJhc2VsaW5lfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5jdHgudGV4dEJhc2VsaW5lPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsInRleHRBbGlnbiIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC50ZXh0QWxpZ259LHNldDpmdW5jdGlvbih0KXstMSE9PVsicmlnaHQiLCJlbmQiLCJjZW50ZXIiLCJsZWZ0Iiwic3RhcnQiXS5pbmRleE9mKHQpJiYodGhpcy5jdHgudGV4dEFsaWduPXQpfX0pO3ZhciBsPW51bGw7ZnVuY3Rpb24gaCh0LGUpe2lmKG51bGw9PT1sKXt2YXIgcj1mdW5jdGlvbih0KXt2YXIgZT1bXTtyZXR1cm4gT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZnVuY3Rpb24ocil7dFtyXS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgbj1udWxsO3N3aXRjaCh0KXtjYXNlImJvbGQiOm49e2ZhbWlseTpyLHdlaWdodDoiYm9sZCJ9O2JyZWFrO2Nhc2UiaXRhbGljIjpuPXtmYW1pbHk6cixzdHlsZToiaXRhbGljIn07YnJlYWs7Y2FzZSJib2xkaXRhbGljIjpuPXtmYW1pbHk6cix3ZWlnaHQ6ImJvbGQiLHN0eWxlOiJpdGFsaWMifTticmVhaztjYXNlIiI6Y2FzZSJub3JtYWwiOm49e2ZhbWlseTpyfX1udWxsIT09biYmKG4ucmVmPXtuYW1lOnIsc3R5bGU6dH0sZS5wdXNoKG4pKX0pKX0pKSxlfSh0LmdldEZvbnRMaXN0KCkpO2w9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXt9LHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIG49Q3QodFtyXSksaT1uLmZhbWlseSxhPW4uc3RyZXRjaCxvPW4uc3R5bGUscz1uLndlaWdodDtlW2ldPWVbaV18fHt9LGVbaV1bYV09ZVtpXVthXXx8e30sZVtpXVthXVtvXT1lW2ldW2FdW29dfHx7fSxlW2ldW2FdW29dW3NdPW59cmV0dXJuIGV9KHIuY29uY2F0KGUpKX1yZXR1cm4gbH12YXIgcD1udWxsO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJmb250RmFjZXMiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcH0sc2V0OmZ1bmN0aW9uKHQpe2w9bnVsbCxwPXR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImZvbnQiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHguZm9udH0sc2V0OmZ1bmN0aW9uKHQpe3ZhciBlO2lmKHRoaXMuY3R4LmZvbnQ9dCxudWxsIT09KGU9L15ccyooPz0oPzooPzpbLWEtel0rXHMqKXswLDJ9KGl0YWxpY3xvYmxpcXVlKSk/KSg/PSg/Oig/OlstYS16XStccyopezAsMn0oc21hbGwtY2FwcykpPykoPz0oPzooPzpbLWEtel0rXHMqKXswLDJ9KGJvbGQoPzplcik/fGxpZ2h0ZXJ8WzEtOV0wMCkpPykoPzooPzpub3JtYWx8XDF8XDJ8XDMpXHMqKXswLDN9KCg/Onh4Py0pPyg/OnNtYWxsfGxhcmdlKXxtZWRpdW18c21hbGxlcnxsYXJnZXJ8Wy5cZF0rKD86XCV8aW58W2NlbV1tfGV4fHBbY3R4XSkpKD86XHMqXC9ccyoobm9ybWFsfFsuXGRdKyg/OlwlfGlufFtjZW1dbXxleHxwW2N0eF0pKSk/XHMqKFstXyxcIlwnXHNhLXpdKz8pXHMqJC9pLmV4ZWModCkpKXt2YXIgcj1lWzFdLG49KGVbMl0sZVszXSksaT1lWzRdLGE9KGVbNV0sZVs2XSksbz0vXihbLlxkXSspKCg/OiV8aW58W2NlbV1tfGV4fHBbY3R4XSkpJC9pLmV4ZWMoaSlbMl07aT0icHgiPT09bz9NYXRoLmZsb29yKHBhcnNlRmxvYXQoaSkqdGhpcy5wZGYuaW50ZXJuYWwuc2NhbGVGYWN0b3IpOiJlbSI9PT1vP01hdGguZmxvb3IocGFyc2VGbG9hdChpKSp0aGlzLnBkZi5nZXRGb250U2l6ZSgpKTpNYXRoLmZsb29yKHBhcnNlRmxvYXQoaSkqdGhpcy5wZGYuaW50ZXJuYWwuc2NhbGVGYWN0b3IpLHRoaXMucGRmLnNldEZvbnRTaXplKGkpO3ZhciBzPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbj1bXSxpPXQudHJpbSgpO2lmKCIiPT09aSlyZXR1cm4gVHQ7aWYoaSBpbiBCdClyZXR1cm5bQnRbaV1dO2Zvcig7IiIhPT1pOyl7c3dpdGNoKHI9bnVsbCxlPShpPXF0KGkpKS5jaGFyQXQoMCkpe2Nhc2UnIic6Y2FzZSInIjpyPUR0KGkuc3Vic3RyaW5nKDEpLGUpO2JyZWFrO2RlZmF1bHQ6cj1SdChpKX1pZihudWxsPT09cilyZXR1cm4gVHQ7aWYobi5wdXNoKHJbMF0pLCIiIT09KGk9cXQoclsxXSkpJiYiLCIhPT1pLmNoYXJBdCgwKSlyZXR1cm4gVHQ7aT1pLnJlcGxhY2UoL14sLywiIil9cmV0dXJuIG59KGEpO2lmKHRoaXMuZm9udEZhY2VzKXt2YXIgYz1FdChoKHRoaXMucGRmLHRoaXMuZm9udEZhY2VzKSxzLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJue2ZhbWlseTp0LHN0cmV0Y2g6Im5vcm1hbCIsd2VpZ2h0Om4sc3R5bGU6cn19KSkpO3RoaXMucGRmLnNldEZvbnQoYy5yZWYubmFtZSxjLnJlZi5zdHlsZSl9ZWxzZXt2YXIgdT0iIjsoImJvbGQiPT09bnx8cGFyc2VJbnQobiwxMCk+PTcwMHx8ImJvbGQiPT09cikmJih1PSJib2xkIiksIml0YWxpYyI9PT1yJiYodSs9Iml0YWxpYyIpLDA9PT11Lmxlbmd0aCYmKHU9Im5vcm1hbCIpO2Zvcih2YXIgbD0iIixmPXthcmlhbDoiSGVsdmV0aWNhIixBcmlhbDoiSGVsdmV0aWNhIix2ZXJkYW5hOiJIZWx2ZXRpY2EiLFZlcmRhbmE6IkhlbHZldGljYSIsaGVsdmV0aWNhOiJIZWx2ZXRpY2EiLEhlbHZldGljYToiSGVsdmV0aWNhIiwic2Fucy1zZXJpZiI6IkhlbHZldGljYSIsZml4ZWQ6IkNvdXJpZXIiLG1vbm9zcGFjZToiQ291cmllciIsdGVybWluYWw6IkNvdXJpZXIiLGN1cnNpdmU6IlRpbWVzIixmYW50YXN5OiJUaW1lcyIsc2VyaWY6IlRpbWVzIn0sZD0wO2Q8cy5sZW5ndGg7ZCsrKXtpZih2b2lkIDAhPT10aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250KHNbZF0sdSx7bm9GYWxsYmFjazohMCxkaXNhYmxlV2FybmluZzohMH0pKXtsPXNbZF07YnJlYWt9aWYoImJvbGRpdGFsaWMiPT09dSYmdm9pZCAwIT09dGhpcy5wZGYuaW50ZXJuYWwuZ2V0Rm9udChzW2RdLCJib2xkIix7bm9GYWxsYmFjazohMCxkaXNhYmxlV2FybmluZzohMH0pKWw9c1tkXSx1PSJib2xkIjtlbHNlIGlmKHZvaWQgMCE9PXRoaXMucGRmLmludGVybmFsLmdldEZvbnQoc1tkXSwibm9ybWFsIix7bm9GYWxsYmFjazohMCxkaXNhYmxlV2FybmluZzohMH0pKXtsPXNbZF0sdT0ibm9ybWFsIjticmVha319aWYoIiI9PT1sKWZvcih2YXIgcD0wO3A8cy5sZW5ndGg7cCsrKWlmKGZbc1twXV0pe2w9ZltzW3BdXTticmVha31sPSIiPT09bD8iVGltZXMiOmwsdGhpcy5wZGYuc2V0Rm9udChsLHUpfX19fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb259LHNldDpmdW5jdGlvbih0KXt0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb249dH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywiZ2xvYmFsQWxwaGEiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHguZ2xvYmFsQWxwaGF9LHNldDpmdW5jdGlvbih0KXt0aGlzLmN0eC5nbG9iYWxBbHBoYT10fX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lRGFzaE9mZnNldCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5saW5lRGFzaE9mZnNldH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY3R4LmxpbmVEYXNoT2Zmc2V0PXQsVC5jYWxsKHRoaXMpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJsaW5lRGFzaCIse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmN0eC5saW5lRGFzaH0sc2V0OmZ1bmN0aW9uKHQpe3RoaXMuY3R4LmxpbmVEYXNoPXQsVC5jYWxsKHRoaXMpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJpZ25vcmVDbGVhclJlY3QiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHguaWdub3JlQ2xlYXJSZWN0fSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5jdHguaWdub3JlQ2xlYXJSZWN0PUJvb2xlYW4odCl9fSl9O3AucHJvdG90eXBlLnNldExpbmVEYXNoPWZ1bmN0aW9uKHQpe3RoaXMubGluZURhc2g9dH0scC5wcm90b3R5cGUuZ2V0TGluZURhc2g9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lRGFzaC5sZW5ndGglMj90aGlzLmxpbmVEYXNoLmNvbmNhdCh0aGlzLmxpbmVEYXNoKTp0aGlzLmxpbmVEYXNoLnNsaWNlKCl9LHAucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24oKXtBLmNhbGwodGhpcywiZmlsbCIsITEpfSxwLnByb3RvdHlwZS5zdHJva2U9ZnVuY3Rpb24oKXtBLmNhbGwodGhpcywic3Ryb2tlIiwhMSl9LHAucHJvdG90eXBlLmJlZ2luUGF0aD1mdW5jdGlvbigpe3RoaXMucGF0aD1be3R5cGU6ImJlZ2luIn1dfSxwLnByb3RvdHlwZS5tb3ZlVG89ZnVuY3Rpb24odCxlKXtpZihpc05hTih0KXx8aXNOYU4oZSkpdGhyb3cgaS5lcnJvcigianNQREYuY29udGV4dDJkLm1vdmVUbzogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLm1vdmVUbyIpO3ZhciByPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IGModCxlKSk7dGhpcy5wYXRoLnB1c2goe3R5cGU6Im10Iix4OnIueCx5OnIueX0pLHRoaXMuY3R4Lmxhc3RQb2ludD1uZXcgYyh0LGUpfSxwLnByb3RvdHlwZS5jbG9zZVBhdGg9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgYygwLDApLHI9MDtmb3Iocj10aGlzLnBhdGgubGVuZ3RoLTE7LTEhPT1yO3ItLSlpZigiYmVnaW4iPT09dGhpcy5wYXRoW3JdLnR5cGUmJiJvYmplY3QiPT09ZSh0aGlzLnBhdGhbcisxXSkmJiJudW1iZXIiPT10eXBlb2YgdGhpcy5wYXRoW3IrMV0ueCl7dD1uZXcgYyh0aGlzLnBhdGhbcisxXS54LHRoaXMucGF0aFtyKzFdLnkpO2JyZWFrfXRoaXMucGF0aC5wdXNoKHt0eXBlOiJjbG9zZSJ9KSx0aGlzLmN0eC5sYXN0UG9pbnQ9bmV3IGModC54LHQueSl9LHAucHJvdG90eXBlLmxpbmVUbz1mdW5jdGlvbih0LGUpe2lmKGlzTmFOKHQpfHxpc05hTihlKSl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQubGluZVRvOiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQubGluZVRvIik7dmFyIHI9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgYyh0LGUpKTt0aGlzLnBhdGgucHVzaCh7dHlwZToibHQiLHg6ci54LHk6ci55fSksdGhpcy5jdHgubGFzdFBvaW50PW5ldyBjKHIueCxyLnkpfSxwLnByb3RvdHlwZS5jbGlwPWZ1bmN0aW9uKCl7dGhpcy5jdHguY2xpcF9wYXRoPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXRoKSksQS5jYWxsKHRoaXMsbnVsbCwhMCl9LHAucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG89ZnVuY3Rpb24odCxlLHIsbil7aWYoaXNOYU4ocil8fGlzTmFOKG4pfHxpc05hTih0KXx8aXNOYU4oZSkpdGhyb3cgaS5lcnJvcigianNQREYuY29udGV4dDJkLnF1YWRyYXRpY0N1cnZlVG86IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5xdWFkcmF0aWNDdXJ2ZVRvIik7dmFyIGE9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgYyhyLG4pKSxvPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IGModCxlKSk7dGhpcy5wYXRoLnB1c2goe3R5cGU6InFjdCIseDE6by54LHkxOm8ueSx4OmEueCx5OmEueX0pLHRoaXMuY3R4Lmxhc3RQb2ludD1uZXcgYyhhLngsYS55KX0scC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbz1mdW5jdGlvbih0LGUscixuLGEsbyl7aWYoaXNOYU4oYSl8fGlzTmFOKG8pfHxpc05hTih0KXx8aXNOYU4oZSl8fGlzTmFOKHIpfHxpc05hTihuKSl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQuYmV6aWVyQ3VydmVUbzogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmJlemllckN1cnZlVG8iKTt2YXIgcz10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBjKGEsbykpLHU9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgYyh0LGUpKSxsPXRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseVRvUG9pbnQobmV3IGMocixuKSk7dGhpcy5wYXRoLnB1c2goe3R5cGU6ImJjdCIseDE6dS54LHkxOnUueSx4MjpsLngseTI6bC55LHg6cy54LHk6cy55fSksdGhpcy5jdHgubGFzdFBvaW50PW5ldyBjKHMueCxzLnkpfSxwLnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24odCxlLHIsbixhLG8pe2lmKGlzTmFOKHQpfHxpc05hTihlKXx8aXNOYU4ocil8fGlzTmFOKG4pfHxpc05hTihhKSl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQuYXJjOiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQuYXJjIik7aWYobz1Cb29sZWFuKG8pLCF0aGlzLmN0eC50cmFuc2Zvcm0uaXNJZGVudGl0eSl7dmFyIHM9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgYyh0LGUpKTt0PXMueCxlPXMueTt2YXIgdT10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBjKDAscikpLGw9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9Qb2ludChuZXcgYygwLDApKTtyPU1hdGguc3FydChNYXRoLnBvdyh1LngtbC54LDIpK01hdGgucG93KHUueS1sLnksMikpfU1hdGguYWJzKGEtbik+PTIqTWF0aC5QSSYmKG49MCxhPTIqTWF0aC5QSSksdGhpcy5wYXRoLnB1c2goe3R5cGU6ImFyYyIseDp0LHk6ZSxyYWRpdXM6cixzdGFydEFuZ2xlOm4sZW5kQW5nbGU6YSxjb3VudGVyY2xvY2t3aXNlOm99KX0scC5wcm90b3R5cGUuYXJjVG89ZnVuY3Rpb24odCxlLHIsbixpKXt0aHJvdyBuZXcgRXJyb3IoImFyY1RvIG5vdCBpbXBsZW1lbnRlZC4iKX0scC5wcm90b3R5cGUucmVjdD1mdW5jdGlvbih0LGUscixuKXtpZihpc05hTih0KXx8aXNOYU4oZSl8fGlzTmFOKHIpfHxpc05hTihuKSl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQucmVjdDogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnJlY3QiKTt0aGlzLm1vdmVUbyh0LGUpLHRoaXMubGluZVRvKHQrcixlKSx0aGlzLmxpbmVUbyh0K3IsZStuKSx0aGlzLmxpbmVUbyh0LGUrbiksdGhpcy5saW5lVG8odCxlKSx0aGlzLmxpbmVUbyh0K3IsZSksdGhpcy5saW5lVG8odCxlKX0scC5wcm90b3R5cGUuZmlsbFJlY3Q9ZnVuY3Rpb24odCxlLHIsbil7aWYoaXNOYU4odCl8fGlzTmFOKGUpfHxpc05hTihyKXx8aXNOYU4obikpdGhyb3cgaS5lcnJvcigianNQREYuY29udGV4dDJkLmZpbGxSZWN0OiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQuZmlsbFJlY3QiKTtpZighbS5jYWxsKHRoaXMpKXt2YXIgYT17fTsiYnV0dCIhPT10aGlzLmxpbmVDYXAmJihhLmxpbmVDYXA9dGhpcy5saW5lQ2FwLHRoaXMubGluZUNhcD0iYnV0dCIpLCJtaXRlciIhPT10aGlzLmxpbmVKb2luJiYoYS5saW5lSm9pbj10aGlzLmxpbmVKb2luLHRoaXMubGluZUpvaW49Im1pdGVyIiksdGhpcy5iZWdpblBhdGgoKSx0aGlzLnJlY3QodCxlLHIsbiksdGhpcy5maWxsKCksYS5oYXNPd25Qcm9wZXJ0eSgibGluZUNhcCIpJiYodGhpcy5saW5lQ2FwPWEubGluZUNhcCksYS5oYXNPd25Qcm9wZXJ0eSgibGluZUpvaW4iKSYmKHRoaXMubGluZUpvaW49YS5saW5lSm9pbil9fSxwLnByb3RvdHlwZS5zdHJva2VSZWN0PWZ1bmN0aW9uKHQsZSxyLG4pe2lmKGlzTmFOKHQpfHxpc05hTihlKXx8aXNOYU4ocil8fGlzTmFOKG4pKXRocm93IGkuZXJyb3IoImpzUERGLmNvbnRleHQyZC5zdHJva2VSZWN0OiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQuc3Ryb2tlUmVjdCIpO3YuY2FsbCh0aGlzKXx8KHRoaXMuYmVnaW5QYXRoKCksdGhpcy5yZWN0KHQsZSxyLG4pLHRoaXMuc3Ryb2tlKCkpfSxwLnByb3RvdHlwZS5jbGVhclJlY3Q9ZnVuY3Rpb24odCxlLHIsbil7aWYoaXNOYU4odCl8fGlzTmFOKGUpfHxpc05hTihyKXx8aXNOYU4obikpdGhyb3cgaS5lcnJvcigianNQREYuY29udGV4dDJkLmNsZWFyUmVjdDogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmNsZWFyUmVjdCIpO3RoaXMuaWdub3JlQ2xlYXJSZWN0fHwodGhpcy5maWxsU3R5bGU9IiNmZmZmZmYiLHRoaXMuZmlsbFJlY3QodCxlLHIsbikpfSxwLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3Q9ImJvb2xlYW4iIT10eXBlb2YgdHx8dDtmb3IodmFyIGU9dGhpcy5wZGYuaW50ZXJuYWwuZ2V0Q3VycmVudFBhZ2VJbmZvKCkucGFnZU51bWJlcixyPTA7cjx0aGlzLnBkZi5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCk7cisrKXRoaXMucGRmLnNldFBhZ2UocisxKSx0aGlzLnBkZi5pbnRlcm5hbC5vdXQoInEiKTtpZih0aGlzLnBkZi5zZXRQYWdlKGUpLHQpe3RoaXMuY3R4LmZvbnRTaXplPXRoaXMucGRmLmludGVybmFsLmdldEZvbnRTaXplKCk7dmFyIG49bmV3IGQodGhpcy5jdHgpO3RoaXMuY3R4U3RhY2sucHVzaCh0aGlzLmN0eCksdGhpcy5jdHg9bn19LHAucHJvdG90eXBlLnJlc3RvcmU9ZnVuY3Rpb24odCl7dD0iYm9vbGVhbiIhPXR5cGVvZiB0fHx0O2Zvcih2YXIgZT10aGlzLnBkZi5pbnRlcm5hbC5nZXRDdXJyZW50UGFnZUluZm8oKS5wYWdlTnVtYmVyLHI9MDtyPHRoaXMucGRmLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKTtyKyspdGhpcy5wZGYuc2V0UGFnZShyKzEpLHRoaXMucGRmLmludGVybmFsLm91dCgiUSIpO3RoaXMucGRmLnNldFBhZ2UoZSksdCYmMCE9PXRoaXMuY3R4U3RhY2subGVuZ3RoJiYodGhpcy5jdHg9dGhpcy5jdHhTdGFjay5wb3AoKSx0aGlzLmZpbGxTdHlsZT10aGlzLmN0eC5maWxsU3R5bGUsdGhpcy5zdHJva2VTdHlsZT10aGlzLmN0eC5zdHJva2VTdHlsZSx0aGlzLmZvbnQ9dGhpcy5jdHguZm9udCx0aGlzLmxpbmVDYXA9dGhpcy5jdHgubGluZUNhcCx0aGlzLmxpbmVXaWR0aD10aGlzLmN0eC5saW5lV2lkdGgsdGhpcy5saW5lSm9pbj10aGlzLmN0eC5saW5lSm9pbix0aGlzLmxpbmVEYXNoPXRoaXMuY3R4LmxpbmVEYXNoLHRoaXMubGluZURhc2hPZmZzZXQ9dGhpcy5jdHgubGluZURhc2hPZmZzZXQpfSxwLnByb3RvdHlwZS50b0RhdGFVUkw9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoInRvRGF0YVVybCBub3QgaW1wbGVtZW50ZWQuIil9O3ZhciBnPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpO2lmKCEwPT09dC5pc0NhbnZhc0dyYWRpZW50JiYodD10LmdldENvbG9yKCkpLCF0KXJldHVybntyOjAsZzowLGI6MCxhOjAsc3R5bGU6dH07aWYoL3RyYW5zcGFyZW50fHJnYmFccypcKFxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKjArXHMqXCkvLnRlc3QodCkpZT0wLHI9MCxuPTAsaT0wO2Vsc2V7dmFyIGE9L3JnYlxzKlwoXHMqKFxkKylccyosXHMqKFxkKylccyosXHMqKFxkKylccypcKS8uZXhlYyh0KTtpZihudWxsIT09YSllPXBhcnNlSW50KGFbMV0pLHI9cGFyc2VJbnQoYVsyXSksbj1wYXJzZUludChhWzNdKSxpPTE7ZWxzZSBpZihudWxsIT09KGE9L3JnYmFccypcKFxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihcZCspXHMqLFxzKihbXGQuXSspXHMqXCkvLmV4ZWModCkpKWU9cGFyc2VJbnQoYVsxXSkscj1wYXJzZUludChhWzJdKSxuPXBhcnNlSW50KGFbM10pLGk9cGFyc2VGbG9hdChhWzRdKTtlbHNle2lmKGk9MSwic3RyaW5nIj09dHlwZW9mIHQmJiIjIiE9PXQuY2hhckF0KDApKXt2YXIgbz1uZXcgaCh0KTt0PW8ub2s/by50b0hleCgpOiIjMDAwMDAwIn00PT09dC5sZW5ndGg/KGU9dC5zdWJzdHJpbmcoMSwyKSxlKz1lLHI9dC5zdWJzdHJpbmcoMiwzKSxyKz1yLG49dC5zdWJzdHJpbmcoMyw0KSxuKz1uKTooZT10LnN1YnN0cmluZygxLDMpLHI9dC5zdWJzdHJpbmcoMyw1KSxuPXQuc3Vic3RyaW5nKDUsNykpLGU9cGFyc2VJbnQoZSwxNikscj1wYXJzZUludChyLDE2KSxuPXBhcnNlSW50KG4sMTYpfX1yZXR1cm57cjplLGc6cixiOm4sYTppLHN0eWxlOnR9fSxtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3R4LmlzRmlsbFRyYW5zcGFyZW50fHwwPT10aGlzLmdsb2JhbEFscGhhfSx2PWZ1bmN0aW9uKCl7cmV0dXJuIEJvb2xlYW4odGhpcy5jdHguaXNTdHJva2VUcmFuc3BhcmVudHx8MD09dGhpcy5nbG9iYWxBbHBoYSl9O3AucHJvdG90eXBlLmZpbGxUZXh0PWZ1bmN0aW9uKHQsZSxyLG4pe2lmKGlzTmFOKGUpfHxpc05hTihyKXx8InN0cmluZyIhPXR5cGVvZiB0KXRocm93IGkuZXJyb3IoImpzUERGLmNvbnRleHQyZC5maWxsVGV4dDogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLmZpbGxUZXh0Iik7aWYobj1pc05hTihuKT92b2lkIDA6biwhbS5jYWxsKHRoaXMpKXt2YXIgYT1xKHRoaXMuY3R4LnRyYW5zZm9ybS5yb3RhdGlvbiksbz10aGlzLmN0eC50cmFuc2Zvcm0uc2NhbGVYO0MuY2FsbCh0aGlzLHt0ZXh0OnQseDplLHk6cixzY2FsZTpvLGFuZ2xlOmEsYWxpZ246dGhpcy50ZXh0QWxpZ24sbWF4V2lkdGg6bn0pfX0scC5wcm90b3R5cGUuc3Ryb2tlVGV4dD1mdW5jdGlvbih0LGUscixuKXtpZihpc05hTihlKXx8aXNOYU4ocil8fCJzdHJpbmciIT10eXBlb2YgdCl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQuc3Ryb2tlVGV4dDogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnN0cm9rZVRleHQiKTtpZighdi5jYWxsKHRoaXMpKXtuPWlzTmFOKG4pP3ZvaWQgMDpuO3ZhciBhPXEodGhpcy5jdHgudHJhbnNmb3JtLnJvdGF0aW9uKSxvPXRoaXMuY3R4LnRyYW5zZm9ybS5zY2FsZVg7Qy5jYWxsKHRoaXMse3RleHQ6dCx4OmUseTpyLHNjYWxlOm8scmVuZGVyaW5nTW9kZToic3Ryb2tlIixhbmdsZTphLGFsaWduOnRoaXMudGV4dEFsaWduLG1heFdpZHRoOm59KX19LHAucHJvdG90eXBlLm1lYXN1cmVUZXh0PWZ1bmN0aW9uKHQpe2lmKCJzdHJpbmciIT10eXBlb2YgdCl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQubWVhc3VyZVRleHQ6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC5tZWFzdXJlVGV4dCIpO3ZhciBlPXRoaXMucGRmLHI9dGhpcy5wZGYuaW50ZXJuYWwuc2NhbGVGYWN0b3Isbj1lLmludGVybmFsLmdldEZvbnRTaXplKCksYT1lLmdldFN0cmluZ1VuaXRXaWR0aCh0KSpuL2UuaW50ZXJuYWwuc2NhbGVGYWN0b3Isbz1mdW5jdGlvbih0KXt2YXIgZT0odD10fHx7fSkud2lkdGh8fDA7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCJ3aWR0aCIse2dldDpmdW5jdGlvbigpe3JldHVybiBlfX0pLHRoaXN9O3JldHVybiBuZXcgbyh7d2lkdGg6YSo9TWF0aC5yb3VuZCg5NipyLzcyKjFlNCkvMWU0fSl9LHAucHJvdG90eXBlLnNjYWxlPWZ1bmN0aW9uKHQsZSl7aWYoaXNOYU4odCl8fGlzTmFOKGUpKXRocm93IGkuZXJyb3IoImpzUERGLmNvbnRleHQyZC5zY2FsZTogSW52YWxpZCBhcmd1bWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBwYXNzZWQgdG8ganNQREYuY29udGV4dDJkLnNjYWxlIik7dmFyIHI9bmV3IGwodCwwLDAsZSwwLDApO3RoaXMuY3R4LnRyYW5zZm9ybT10aGlzLmN0eC50cmFuc2Zvcm0ubXVsdGlwbHkocil9LHAucHJvdG90eXBlLnJvdGF0ZT1mdW5jdGlvbih0KXtpZihpc05hTih0KSl0aHJvdyBpLmVycm9yKCJqc1BERi5jb250ZXh0MmQucm90YXRlOiBJbnZhbGlkIGFyZ3VtZW50cyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnRzIHBhc3NlZCB0byBqc1BERi5jb250ZXh0MmQucm90YXRlIik7dmFyIGU9bmV3IGwoTWF0aC5jb3ModCksTWF0aC5zaW4odCksLU1hdGguc2luKHQpLE1hdGguY29zKHQpLDAsMCk7dGhpcy5jdHgudHJhbnNmb3JtPXRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseShlKX0scC5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKHQsZSl7aWYoaXNOYU4odCl8fGlzTmFOKGUpKXRocm93IGkuZXJyb3IoImpzUERGLmNvbnRleHQyZC50cmFuc2xhdGU6IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC50cmFuc2xhdGUiKTt2YXIgcj1uZXcgbCgxLDAsMCwxLHQsZSk7dGhpcy5jdHgudHJhbnNmb3JtPXRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseShyKX0scC5wcm90b3R5cGUudHJhbnNmb3JtPWZ1bmN0aW9uKHQsZSxyLG4sYSxvKXtpZihpc05hTih0KXx8aXNOYU4oZSl8fGlzTmFOKHIpfHxpc05hTihuKXx8aXNOYU4oYSl8fGlzTmFOKG8pKXRocm93IGkuZXJyb3IoImpzUERGLmNvbnRleHQyZC50cmFuc2Zvcm06IEludmFsaWQgYXJndW1lbnRzIixhcmd1bWVudHMpLG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgcGFzc2VkIHRvIGpzUERGLmNvbnRleHQyZC50cmFuc2Zvcm0iKTt2YXIgcz1uZXcgbCh0LGUscixuLGEsbyk7dGhpcy5jdHgudHJhbnNmb3JtPXRoaXMuY3R4LnRyYW5zZm9ybS5tdWx0aXBseShzKX0scC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtPWZ1bmN0aW9uKHQsZSxyLG4saSxhKXt0PWlzTmFOKHQpPzE6dCxlPWlzTmFOKGUpPzA6ZSxyPWlzTmFOKHIpPzA6cixuPWlzTmFOKG4pPzE6bixpPWlzTmFOKGkpPzA6aSxhPWlzTmFOKGEpPzA6YSx0aGlzLmN0eC50cmFuc2Zvcm09bmV3IGwodCxlLHIsbixpLGEpfTt2YXIgYj1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcmdpblswXT4wfHx0aGlzLm1hcmdpblsxXT4wfHx0aGlzLm1hcmdpblsyXT4wfHx0aGlzLm1hcmdpblszXT4wfTtwLnByb3RvdHlwZS5kcmF3SW1hZ2U9ZnVuY3Rpb24odCxlLHIsbixpLGEsbyxzLGMpe3ZhciBoPXRoaXMucGRmLmdldEltYWdlUHJvcGVydGllcyh0KSxmPTEsZD0xLHA9MSxnPTE7dm9pZCAwIT09biYmdm9pZCAwIT09cyYmKHA9cy9uLGc9Yy9pLGY9aC53aWR0aC9uKnMvbixkPWguaGVpZ2h0L2kqYy9pKSx2b2lkIDA9PT1hJiYoYT1lLG89cixlPTAscj0wKSx2b2lkIDAhPT1uJiZ2b2lkIDA9PT1zJiYocz1uLGM9aSksdm9pZCAwPT09biYmdm9pZCAwPT09cyYmKHM9aC53aWR0aCxjPWguaGVpZ2h0KTtmb3IodmFyIG0sdj10aGlzLmN0eC50cmFuc2Zvcm0uZGVjb21wb3NlKCksdz1xKHYucm90YXRlLnNoeCksQT1uZXcgbCxTPShBPShBPShBPUEubXVsdGlwbHkodi50cmFuc2xhdGUpKS5tdWx0aXBseSh2LnNrZXcpKS5tdWx0aXBseSh2LnNjYWxlKSkuYXBwbHlUb1JlY3RhbmdsZShuZXcgdShhLWUqcCxvLXIqZyxuKmYsaSpkKSksXz15LmNhbGwodGhpcyxTKSxQPVtdLGs9MDtrPF8ubGVuZ3RoO2srPTEpLTE9PT1QLmluZGV4T2YoX1trXSkmJlAucHVzaChfW2tdKTtpZihMKFApLHRoaXMuYXV0b1BhZ2luZylmb3IodmFyIEY9UFswXSxJPVBbUC5sZW5ndGgtMV0sQz1GO0M8SSsxO0MrKyl7dGhpcy5wZGYuc2V0UGFnZShDKTt2YXIgaj10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aC10aGlzLm1hcmdpblszXS10aGlzLm1hcmdpblsxXSxPPTE9PT1DP3RoaXMucG9zWSt0aGlzLm1hcmdpblswXTp0aGlzLm1hcmdpblswXSxCPXRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodC10aGlzLnBvc1ktdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sTT10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQtdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sRT0xPT09Qz8wOkIrKEMtMikqTTtpZigwIT09dGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCl7dmFyIEQ9dGhpcy5wYXRoO209SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmN0eC5jbGlwX3BhdGgpKSx0aGlzLnBhdGg9TihtLHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtRStPK3RoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQpLHguY2FsbCh0aGlzLCJmaWxsIiwhMCksdGhpcy5wYXRoPUR9dmFyIFI9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShTKSk7Uj1OKFtSXSx0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLUUrTyt0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0KVswXTt2YXIgVD0oQz5GfHxDPEkpJiZiLmNhbGwodGhpcyk7VCYmKHRoaXMucGRmLnNhdmVHcmFwaGljc1N0YXRlKCksdGhpcy5wZGYucmVjdCh0aGlzLm1hcmdpblszXSx0aGlzLm1hcmdpblswXSxqLE0sbnVsbCkuY2xpcCgpLmRpc2NhcmRQYXRoKCkpLHRoaXMucGRmLmFkZEltYWdlKHQsIkpQRUciLFIueCxSLnksUi53LFIuaCxudWxsLG51bGwsdyksVCYmdGhpcy5wZGYucmVzdG9yZUdyYXBoaWNzU3RhdGUoKX1lbHNlIHRoaXMucGRmLmFkZEltYWdlKHQsIkpQRUciLFMueCxTLnksUy53LFMuaCxudWxsLG51bGwsdyl9O3ZhciB5PWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1bXTtlPWV8fHRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLndpZHRoLHI9cnx8dGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0LXRoaXMubWFyZ2luWzBdLXRoaXMubWFyZ2luWzJdO3ZhciBpPXRoaXMucG9zWSt0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0O3N3aXRjaCh0LnR5cGUpe2RlZmF1bHQ6Y2FzZSJtdCI6Y2FzZSJsdCI6bi5wdXNoKE1hdGguZmxvb3IoKHQueStpKS9yKSsxKTticmVhaztjYXNlImFyYyI6bi5wdXNoKE1hdGguZmxvb3IoKHQueStpLXQucmFkaXVzKS9yKSsxKSxuLnB1c2goTWF0aC5mbG9vcigodC55K2krdC5yYWRpdXMpL3IpKzEpO2JyZWFrO2Nhc2UicWN0Ijp2YXIgYT1EKHRoaXMuY3R4Lmxhc3RQb2ludC54LHRoaXMuY3R4Lmxhc3RQb2ludC55LHQueDEsdC55MSx0LngsdC55KTtuLnB1c2goTWF0aC5mbG9vcigoYS55K2kpL3IpKzEpLG4ucHVzaChNYXRoLmZsb29yKChhLnkrYS5oK2kpL3IpKzEpO2JyZWFrO2Nhc2UiYmN0Ijp2YXIgbz1SKHRoaXMuY3R4Lmxhc3RQb2ludC54LHRoaXMuY3R4Lmxhc3RQb2ludC55LHQueDEsdC55MSx0LngyLHQueTIsdC54LHQueSk7bi5wdXNoKE1hdGguZmxvb3IoKG8ueStpKS9yKSsxKSxuLnB1c2goTWF0aC5mbG9vcigoby55K28uaCtpKS9yKSsxKTticmVhaztjYXNlInJlY3QiOm4ucHVzaChNYXRoLmZsb29yKCh0LnkraSkvcikrMSksbi5wdXNoKE1hdGguZmxvb3IoKHQueSt0LmgraSkvcikrMSl9Zm9yKHZhciBzPTA7czxuLmxlbmd0aDtzKz0xKWZvcig7dGhpcy5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpPG5bc107KXcuY2FsbCh0aGlzKTtyZXR1cm4gbn0sdz1mdW5jdGlvbigpe3ZhciB0PXRoaXMuZmlsbFN0eWxlLGU9dGhpcy5zdHJva2VTdHlsZSxyPXRoaXMuZm9udCxuPXRoaXMubGluZUNhcCxpPXRoaXMubGluZVdpZHRoLGE9dGhpcy5saW5lSm9pbjt0aGlzLnBkZi5hZGRQYWdlKCksdGhpcy5maWxsU3R5bGU9dCx0aGlzLnN0cm9rZVN0eWxlPWUsdGhpcy5mb250PXIsdGhpcy5saW5lQ2FwPW4sdGhpcy5saW5lV2lkdGg9aSx0aGlzLmxpbmVKb2luPWF9LE49ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXN3aXRjaCh0W25dLnR5cGUpe2Nhc2UiYmN0Ijp0W25dLngyKz1lLHRbbl0ueTIrPXI7Y2FzZSJxY3QiOnRbbl0ueDErPWUsdFtuXS55MSs9cjtjYXNlIm10IjpjYXNlImx0IjpjYXNlImFyYyI6ZGVmYXVsdDp0W25dLngrPWUsdFtuXS55Kz1yfXJldHVybiB0fSxMPWZ1bmN0aW9uKHQpe3JldHVybiB0LnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtZX0pKX0sQT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcixuLGk9dGhpcy5maWxsU3R5bGUsYT10aGlzLnN0cm9rZVN0eWxlLG89dGhpcy5saW5lQ2FwLHM9dGhpcy5saW5lV2lkdGgsYz1NYXRoLmFicyhzKnRoaXMuY3R4LnRyYW5zZm9ybS5zY2FsZVgpLHU9dGhpcy5saW5lSm9pbixsPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5wYXRoKSksaD1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMucGF0aCkpLGY9W10sZD0wO2Q8aC5sZW5ndGg7ZCsrKWlmKHZvaWQgMCE9PWhbZF0ueClmb3IodmFyIHA9eS5jYWxsKHRoaXMsaFtkXSksZz0wO2c8cC5sZW5ndGg7Zys9MSktMT09PWYuaW5kZXhPZihwW2ddKSYmZi5wdXNoKHBbZ10pO2Zvcih2YXIgbT0wO208Zi5sZW5ndGg7bSsrKWZvcig7dGhpcy5wZGYuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpPGZbbV07KXcuY2FsbCh0aGlzKTtpZihMKGYpLHRoaXMuYXV0b1BhZ2luZylmb3IodmFyIHY9ZlswXSxBPWZbZi5sZW5ndGgtMV0sUz12O1M8QSsxO1MrKyl7dGhpcy5wZGYuc2V0UGFnZShTKSx0aGlzLmZpbGxTdHlsZT1pLHRoaXMuc3Ryb2tlU3R5bGU9YSx0aGlzLmxpbmVDYXA9byx0aGlzLmxpbmVXaWR0aD1jLHRoaXMubGluZUpvaW49dTt2YXIgXz10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS53aWR0aC10aGlzLm1hcmdpblszXS10aGlzLm1hcmdpblsxXSxQPTE9PT1TP3RoaXMucG9zWSt0aGlzLm1hcmdpblswXTp0aGlzLm1hcmdpblswXSxrPXRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodC10aGlzLnBvc1ktdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sRj10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQtdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sST0xPT09Uz8wOmsrKFMtMikqRjtpZigwIT09dGhpcy5jdHguY2xpcF9wYXRoLmxlbmd0aCl7dmFyIEM9dGhpcy5wYXRoO3I9SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmN0eC5jbGlwX3BhdGgpKSx0aGlzLnBhdGg9TihyLHRoaXMucG9zWCt0aGlzLm1hcmdpblszXSwtSStQK3RoaXMuY3R4LnByZXZQYWdlTGFzdEVsZW1PZmZzZXQpLHguY2FsbCh0aGlzLHQsITApLHRoaXMucGF0aD1DfWlmKG49SlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsKSksdGhpcy5wYXRoPU4obix0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLUkrUCt0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0KSwhMT09PWV8fDA9PT1TKXt2YXIgaj0oUz52fHxTPEEpJiZiLmNhbGwodGhpcyk7aiYmKHRoaXMucGRmLnNhdmVHcmFwaGljc1N0YXRlKCksdGhpcy5wZGYucmVjdCh0aGlzLm1hcmdpblszXSx0aGlzLm1hcmdpblswXSxfLEYsbnVsbCkuY2xpcCgpLmRpc2NhcmRQYXRoKCkpLHguY2FsbCh0aGlzLHQsZSksaiYmdGhpcy5wZGYucmVzdG9yZUdyYXBoaWNzU3RhdGUoKX10aGlzLmxpbmVXaWR0aD1zfWVsc2UgdGhpcy5saW5lV2lkdGg9Yyx4LmNhbGwodGhpcyx0LGUpLHRoaXMubGluZVdpZHRoPXM7dGhpcy5wYXRoPWx9LHg9ZnVuY3Rpb24odCxlKXtpZigoInN0cm9rZSIhPT10fHxlfHwhdi5jYWxsKHRoaXMpKSYmKCJzdHJva2UiPT09dHx8ZXx8IW0uY2FsbCh0aGlzKSkpe2Zvcih2YXIgcixuLGk9W10sYT10aGlzLnBhdGgsbz0wO288YS5sZW5ndGg7bysrKXt2YXIgcz1hW29dO3N3aXRjaChzLnR5cGUpe2Nhc2UiYmVnaW4iOmkucHVzaCh7YmVnaW46ITB9KTticmVhaztjYXNlImNsb3NlIjppLnB1c2goe2Nsb3NlOiEwfSk7YnJlYWs7Y2FzZSJtdCI6aS5wdXNoKHtzdGFydDpzLGRlbHRhczpbXSxhYnM6W119KTticmVhaztjYXNlImx0Ijp2YXIgYz1pLmxlbmd0aDtpZihhW28tMV0mJiFpc05hTihhW28tMV0ueCkmJihyPVtzLngtYVtvLTFdLngscy55LWFbby0xXS55XSxjPjApKWZvcig7Yz49MDtjLS0paWYoITAhPT1pW2MtMV0uY2xvc2UmJiEwIT09aVtjLTFdLmJlZ2luKXtpW2MtMV0uZGVsdGFzLnB1c2gociksaVtjLTFdLmFicy5wdXNoKHMpO2JyZWFrfWJyZWFrO2Nhc2UiYmN0IjpyPVtzLngxLWFbby0xXS54LHMueTEtYVtvLTFdLnkscy54Mi1hW28tMV0ueCxzLnkyLWFbby0xXS55LHMueC1hW28tMV0ueCxzLnktYVtvLTFdLnldLGlbaS5sZW5ndGgtMV0uZGVsdGFzLnB1c2gocik7YnJlYWs7Y2FzZSJxY3QiOnZhciB1PWFbby0xXS54KzIvMyoocy54MS1hW28tMV0ueCksbD1hW28tMV0ueSsyLzMqKHMueTEtYVtvLTFdLnkpLGg9cy54KzIvMyoocy54MS1zLngpLGY9cy55KzIvMyoocy55MS1zLnkpLGQ9cy54LHA9cy55O3I9W3UtYVtvLTFdLngsbC1hW28tMV0ueSxoLWFbby0xXS54LGYtYVtvLTFdLnksZC1hW28tMV0ueCxwLWFbby0xXS55XSxpW2kubGVuZ3RoLTFdLmRlbHRhcy5wdXNoKHIpO2JyZWFrO2Nhc2UiYXJjIjppLnB1c2goe2RlbHRhczpbXSxhYnM6W10sYXJjOiEwfSksQXJyYXkuaXNBcnJheShpW2kubGVuZ3RoLTFdLmFicykmJmlbaS5sZW5ndGgtMV0uYWJzLnB1c2gocyl9fW49ZT9udWxsOiJzdHJva2UiPT09dD8ic3Ryb2tlIjoiZmlsbCI7Zm9yKHZhciBnPSExLGI9MDtiPGkubGVuZ3RoO2IrKylpZihpW2JdLmFyYylmb3IodmFyIHk9aVtiXS5hYnMsdz0wO3c8eS5sZW5ndGg7dysrKXt2YXIgTj15W3ddOyJhcmMiPT09Ti50eXBlP1AuY2FsbCh0aGlzLE4ueCxOLnksTi5yYWRpdXMsTi5zdGFydEFuZ2xlLE4uZW5kQW5nbGUsTi5jb3VudGVyY2xvY2t3aXNlLHZvaWQgMCxlLCFnKTpqLmNhbGwodGhpcyxOLngsTi55KSxnPSEwfWVsc2UgaWYoITA9PT1pW2JdLmNsb3NlKXRoaXMucGRmLmludGVybmFsLm91dCgiaCIpLGc9ITE7ZWxzZSBpZighMCE9PWlbYl0uYmVnaW4pe3ZhciBMPWlbYl0uc3RhcnQueCxBPWlbYl0uc3RhcnQueTtPLmNhbGwodGhpcyxpW2JdLmRlbHRhcyxMLEEpLGc9ITB9biYmay5jYWxsKHRoaXMsbiksZSYmRi5jYWxsKHRoaXMpfX0sUz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250U2l6ZSgpL3RoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yLHI9ZSoodGhpcy5wZGYuaW50ZXJuYWwuZ2V0TGluZUhlaWdodEZhY3RvcigpLTEpO3N3aXRjaCh0aGlzLmN0eC50ZXh0QmFzZWxpbmUpe2Nhc2UiYm90dG9tIjpyZXR1cm4gdC1yO2Nhc2UidG9wIjpyZXR1cm4gdCtlLXI7Y2FzZSJoYW5naW5nIjpyZXR1cm4gdCtlLTIqcjtjYXNlIm1pZGRsZSI6cmV0dXJuIHQrZS8yLXI7Y2FzZSJpZGVvZ3JhcGhpYyI6cmV0dXJuIHQ7Y2FzZSJhbHBoYWJldGljIjpkZWZhdWx0OnJldHVybiB0fX0sXz1mdW5jdGlvbih0KXtyZXR1cm4gdCt0aGlzLnBkZi5pbnRlcm5hbC5nZXRGb250U2l6ZSgpL3RoaXMucGRmLmludGVybmFsLnNjYWxlRmFjdG9yKih0aGlzLnBkZi5pbnRlcm5hbC5nZXRMaW5lSGVpZ2h0RmFjdG9yKCktMSl9O3AucHJvdG90eXBlLmNyZWF0ZUxpbmVhckdyYWRpZW50PWZ1bmN0aW9uKCl7dmFyIHQ9ZnVuY3Rpb24oKXt9O3JldHVybiB0LmNvbG9yU3RvcHM9W10sdC5hZGRDb2xvclN0b3A9ZnVuY3Rpb24odCxlKXt0aGlzLmNvbG9yU3RvcHMucHVzaChbdCxlXSl9LHQuZ2V0Q29sb3I9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuY29sb3JTdG9wcy5sZW5ndGg/IiMwMDAwMDAiOnRoaXMuY29sb3JTdG9wc1swXVsxXX0sdC5pc0NhbnZhc0dyYWRpZW50PSEwLHR9LHAucHJvdG90eXBlLmNyZWF0ZVBhdHRlcm49ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJHcmFkaWVudCgpfSxwLnByb3RvdHlwZS5jcmVhdGVSYWRpYWxHcmFkaWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KCl9O3ZhciBQPWZ1bmN0aW9uKHQsZSxyLG4saSxhLG8scyxjKXtmb3IodmFyIHU9TS5jYWxsKHRoaXMscixuLGksYSksbD0wO2w8dS5sZW5ndGg7bCsrKXt2YXIgaD11W2xdOzA9PT1sJiYoYz9JLmNhbGwodGhpcyxoLngxK3QsaC55MStlKTpqLmNhbGwodGhpcyxoLngxK3QsaC55MStlKSksQi5jYWxsKHRoaXMsdCxlLGgueDIsaC55MixoLngzLGgueTMsaC54NCxoLnk0KX1zP0YuY2FsbCh0aGlzKTprLmNhbGwodGhpcyxvKX0saz1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSJzdHJva2UiOnRoaXMucGRmLmludGVybmFsLm91dCgiUyIpO2JyZWFrO2Nhc2UiZmlsbCI6dGhpcy5wZGYuaW50ZXJuYWwub3V0KCJmIil9fSxGPWZ1bmN0aW9uKCl7dGhpcy5wZGYuY2xpcCgpLHRoaXMucGRmLmRpc2NhcmRQYXRoKCl9LEk9ZnVuY3Rpb24odCxlKXt0aGlzLnBkZi5pbnRlcm5hbC5vdXQobih0KSsiICIrYShlKSsiIG0iKX0sQz1mdW5jdGlvbih0KXt2YXIgZTtzd2l0Y2godC5hbGlnbil7Y2FzZSJyaWdodCI6Y2FzZSJlbmQiOmU9InJpZ2h0IjticmVhaztjYXNlImNlbnRlciI6ZT0iY2VudGVyIjticmVhaztjYXNlImxlZnQiOmNhc2Uic3RhcnQiOmRlZmF1bHQ6ZT0ibGVmdCJ9dmFyIHI9dGhpcy5wZGYuZ2V0VGV4dERpbWVuc2lvbnModC50ZXh0KSxuPVMuY2FsbCh0aGlzLHQueSksaT1fLmNhbGwodGhpcyxuKS1yLmgsYT10aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHlUb1BvaW50KG5ldyBjKHQueCxuKSksbz10aGlzLmN0eC50cmFuc2Zvcm0uZGVjb21wb3NlKCkscz1uZXcgbDtzPShzPShzPXMubXVsdGlwbHkoby50cmFuc2xhdGUpKS5tdWx0aXBseShvLnNrZXcpKS5tdWx0aXBseShvLnNjYWxlKTtmb3IodmFyIGgsZixkLHA9dGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5VG9SZWN0YW5nbGUobmV3IHUodC54LG4sci53LHIuaCkpLGc9cy5hcHBseVRvUmVjdGFuZ2xlKG5ldyB1KHQueCxpLHIudyxyLmgpKSxtPXkuY2FsbCh0aGlzLGcpLHY9W10sdz0wO3c8bS5sZW5ndGg7dys9MSktMT09PXYuaW5kZXhPZihtW3ddKSYmdi5wdXNoKG1bd10pO2lmKEwodiksdGhpcy5hdXRvUGFnaW5nKWZvcih2YXIgQT12WzBdLFA9dlt2Lmxlbmd0aC0xXSxrPUE7azxQKzE7aysrKXt0aGlzLnBkZi5zZXRQYWdlKGspO3ZhciBGPTE9PT1rP3RoaXMucG9zWSt0aGlzLm1hcmdpblswXTp0aGlzLm1hcmdpblswXSxJPXRoaXMucGRmLmludGVybmFsLnBhZ2VTaXplLmhlaWdodC10aGlzLnBvc1ktdGhpcy5tYXJnaW5bMF0tdGhpcy5tYXJnaW5bMl0sQz10aGlzLnBkZi5pbnRlcm5hbC5wYWdlU2l6ZS5oZWlnaHQtdGhpcy5tYXJnaW5bMl0saj1DLXRoaXMubWFyZ2luWzBdLE89dGhpcy5wZGYuaW50ZXJuYWwucGFnZVNpemUud2lkdGgtdGhpcy5tYXJnaW5bMV0sQj1PLXRoaXMubWFyZ2luWzNdLE09MT09PWs/MDpJKyhrLTIpKmo7aWYoMCE9PXRoaXMuY3R4LmNsaXBfcGF0aC5sZW5ndGgpe3ZhciBFPXRoaXMucGF0aDtoPUpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5jdHguY2xpcF9wYXRoKSksdGhpcy5wYXRoPU4oaCx0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLTEqTStGKSx4LmNhbGwodGhpcywiZmlsbCIsITApLHRoaXMucGF0aD1FfXZhciBxPU4oW0pTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZykpXSx0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLU0rRit0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0KVswXTt0LnNjYWxlPj0uMDEmJihmPXRoaXMucGRmLmludGVybmFsLmdldEZvbnRTaXplKCksdGhpcy5wZGYuc2V0Rm9udFNpemUoZip0LnNjYWxlKSxkPXRoaXMubGluZVdpZHRoLHRoaXMubGluZVdpZHRoPWQqdC5zY2FsZSk7dmFyIEQ9InRleHQiIT09dGhpcy5hdXRvUGFnaW5nO2lmKER8fHEueStxLmg8PUMpe2lmKER8fHEueT49RiYmcS54PD1PKXt2YXIgUj1EP3QudGV4dDp0aGlzLnBkZi5zcGxpdFRleHRUb1NpemUodC50ZXh0LHQubWF4V2lkdGh8fE8tcS54KVswXSxUPU4oW0pTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocCkpXSx0aGlzLnBvc1grdGhpcy5tYXJnaW5bM10sLU0rRit0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0KVswXSxVPUQmJihrPkF8fGs8UCkmJmIuY2FsbCh0aGlzKTtVJiYodGhpcy5wZGYuc2F2ZUdyYXBoaWNzU3RhdGUoKSx0aGlzLnBkZi5yZWN0KHRoaXMubWFyZ2luWzNdLHRoaXMubWFyZ2luWzBdLEIsaixudWxsKS5jbGlwKCkuZGlzY2FyZFBhdGgoKSksdGhpcy5wZGYudGV4dChSLFQueCxULnkse2FuZ2xlOnQuYW5nbGUsYWxpZ246ZSxyZW5kZXJpbmdNb2RlOnQucmVuZGVyaW5nTW9kZX0pLFUmJnRoaXMucGRmLnJlc3RvcmVHcmFwaGljc1N0YXRlKCl9fWVsc2UgcS55PEMmJih0aGlzLmN0eC5wcmV2UGFnZUxhc3RFbGVtT2Zmc2V0Kz1DLXEueSk7dC5zY2FsZT49LjAxJiYodGhpcy5wZGYuc2V0Rm9udFNpemUoZiksdGhpcy5saW5lV2lkdGg9ZCl9ZWxzZSB0LnNjYWxlPj0uMDEmJihmPXRoaXMucGRmLmludGVybmFsLmdldEZvbnRTaXplKCksdGhpcy5wZGYuc2V0Rm9udFNpemUoZip0LnNjYWxlKSxkPXRoaXMubGluZVdpZHRoLHRoaXMubGluZVdpZHRoPWQqdC5zY2FsZSksdGhpcy5wZGYudGV4dCh0LnRleHQsYS54K3RoaXMucG9zWCxhLnkrdGhpcy5wb3NZLHthbmdsZTp0LmFuZ2xlLGFsaWduOmUscmVuZGVyaW5nTW9kZTp0LnJlbmRlcmluZ01vZGUsbWF4V2lkdGg6dC5tYXhXaWR0aH0pLHQuc2NhbGU+PS4wMSYmKHRoaXMucGRmLnNldEZvbnRTaXplKGYpLHRoaXMubGluZVdpZHRoPWQpfSxqPWZ1bmN0aW9uKHQsZSxyLGkpe3I9cnx8MCxpPWl8fDAsdGhpcy5wZGYuaW50ZXJuYWwub3V0KG4odCtyKSsiICIrYShlK2kpKyIgbCIpfSxPPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdGhpcy5wZGYubGluZXModCxlLHIsbnVsbCxudWxsKX0sQj1mdW5jdGlvbih0LGUsbixpLGEsYyx1LGwpe3RoaXMucGRmLmludGVybmFsLm91dChbcihvKG4rdCkpLHIocyhpK2UpKSxyKG8oYSt0KSkscihzKGMrZSkpLHIobyh1K3QpKSxyKHMobCtlKSksImMiXS5qb2luKCIgIikpfSxNPWZ1bmN0aW9uKHQsZSxyLG4pe2Zvcih2YXIgaT0yKk1hdGguUEksYT1NYXRoLlBJLzI7ZT5yOyllLT1pO3ZhciBvPU1hdGguYWJzKHItZSk7bzxpJiZuJiYobz1pLW8pO2Zvcih2YXIgcz1bXSxjPW4/LTE6MSx1PWU7bz4xZS01Oyl7dmFyIGw9dStjKk1hdGgubWluKG8sYSk7cy5wdXNoKEUuY2FsbCh0aGlzLHQsdSxsKSksby09TWF0aC5hYnMobC11KSx1PWx9cmV0dXJuIHN9LEU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPShyLWUpLzIsaT10Kk1hdGguY29zKG4pLGE9dCpNYXRoLnNpbihuKSxvPWkscz0tYSxjPW8qbytzKnMsdT1jK28qaStzKmEsbD00LzMqKE1hdGguc3FydCgyKmMqdSktdSkvKG8qYS1zKmkpLGg9by1sKnMsZj1zK2wqbyxkPWgscD0tZixnPW4rZSxtPU1hdGguY29zKGcpLHY9TWF0aC5zaW4oZyk7cmV0dXJue3gxOnQqTWF0aC5jb3MoZSkseTE6dCpNYXRoLnNpbihlKSx4MjpoKm0tZip2LHkyOmgqditmKm0seDM6ZCptLXAqdix5MzpkKnYrcCptLHg0OnQqTWF0aC5jb3MocikseTQ6dCpNYXRoLnNpbihyKX19LHE9ZnVuY3Rpb24odCl7cmV0dXJuIDE4MCp0L01hdGguUEl9LEQ9ZnVuY3Rpb24odCxlLHIsbixpLGEpe3ZhciBvPXQrLjUqKHItdCkscz1lKy41KihuLWUpLGM9aSsuNSooci1pKSxsPWErLjUqKG4tYSksaD1NYXRoLm1pbih0LGksbyxjKSxmPU1hdGgubWF4KHQsaSxvLGMpLGQ9TWF0aC5taW4oZSxhLHMsbCkscD1NYXRoLm1heChlLGEscyxsKTtyZXR1cm4gbmV3IHUoaCxkLGYtaCxwLWQpfSxSPWZ1bmN0aW9uKHQsZSxyLG4saSxhLG8scyl7dmFyIGMsbCxoLGYsZCxwLGcsbSx2LGIseSx3LE4sTCxBPXItdCx4PW4tZSxTPWktcixfPWEtbixQPW8taSxrPXMtYTtmb3IobD0wO2w8NDE7bCsrKXY9KGc9KGg9dCsoYz1sLzQwKSpBKStjKigoZD1yK2MqUyktaCkpK2MqKGQrYyooaStjKlAtZCktZyksYj0obT0oZj1lK2MqeCkrYyooKHA9bitjKl8pLWYpKStjKihwK2MqKGErYyprLXApLW0pLDA9PWw/KHk9dix3PWIsTj12LEw9Yik6KHk9TWF0aC5taW4oeSx2KSx3PU1hdGgubWluKHcsYiksTj1NYXRoLm1heChOLHYpLEw9TWF0aC5tYXgoTCxiKSk7cmV0dXJuIG5ldyB1KE1hdGgucm91bmQoeSksTWF0aC5yb3VuZCh3KSxNYXRoLnJvdW5kKE4teSksTWF0aC5yb3VuZChMLXcpKX0sVD1mdW5jdGlvbigpe2lmKHRoaXMucHJldkxpbmVEYXNofHx0aGlzLmN0eC5saW5lRGFzaC5sZW5ndGh8fHRoaXMuY3R4LmxpbmVEYXNoT2Zmc2V0KXt2YXIgdCxlLHI9KHQ9dGhpcy5jdHgubGluZURhc2gsZT10aGlzLmN0eC5saW5lRGFzaE9mZnNldCxKU09OLnN0cmluZ2lmeSh7bGluZURhc2g6dCxsaW5lRGFzaE9mZnNldDplfSkpO3RoaXMucHJldkxpbmVEYXNoIT09ciYmKHRoaXMucGRmLnNldExpbmVEYXNoKHRoaXMuY3R4LmxpbmVEYXNoLHRoaXMuY3R4LmxpbmVEYXNoT2Zmc2V0KSx0aGlzLnByZXZMaW5lRGFzaD1yKX19fShNLkFQSSk7dHJ5e3JlcXVpcmUoIndvcmtlcl90aHJlYWRzIikuV29ya2VyfWNhdGNoKHQpe312YXIgVXQ9VWludDhBcnJheSx6dD1VaW50MTZBcnJheSxIdD1VaW50MzJBcnJheSxXdD1uZXcgVXQoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMCwwLDAsMF0pLFZ0PW5ldyBVdChbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdKSxHdD1uZXcgVXQoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxZdD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1uZXcgenQoMzEpLG49MDtuPDMxOysrbilyW25dPWUrPTE8PHRbbi0xXTt2YXIgaT1uZXcgSHQoclszMF0pO2ZvcihuPTE7bjwzMDsrK24pZm9yKHZhciBhPXJbbl07YTxyW24rMV07KythKWlbYV09YS1yW25dPDw1fG47cmV0dXJuW3IsaV19LEp0PVl0KFd0LDIpLFh0PUp0WzBdLEt0PUp0WzFdO1h0WzI4XT0yNTgsS3RbMjU4XT0yODtmb3IodmFyIFp0PVl0KFZ0LDApLCR0PVp0WzBdLFF0PVp0WzFdLHRlPW5ldyB6dCgzMjc2OCksZWU9MDtlZTwzMjc2ODsrK2VlKXt2YXIgcmU9KDQzNjkwJmVlKT4+PjF8KDIxODQ1JmVlKTw8MTtyZT0oNjE2ODAmKHJlPSg1MjQyOCZyZSk+Pj4yfCgxMzEwNyZyZSk8PDIpKT4+PjR8KDM4NTUmcmUpPDw0LHRlW2VlXT0oKDY1MjgwJnJlKT4+Pjh8KDI1NSZyZSk8PDgpPj4+MX12YXIgbmU9ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbj10Lmxlbmd0aCxpPTAsYT1uZXcgenQoZSk7aTxuOysraSkrK2FbdFtpXS0xXTt2YXIgbyxzPW5ldyB6dChlKTtmb3IoaT0wO2k8ZTsrK2kpc1tpXT1zW2ktMV0rYVtpLTFdPDwxO2lmKHIpe289bmV3IHp0KDE8PGUpO3ZhciBjPTE1LWU7Zm9yKGk9MDtpPG47KytpKWlmKHRbaV0pZm9yKHZhciB1PWk8PDR8dFtpXSxsPWUtdFtpXSxoPXNbdFtpXS0xXSsrPDxsLGY9aHwoMTw8bCktMTtoPD1mOysraClvW3RlW2hdPj4+Y109dX1lbHNlIGZvcihvPW5ldyB6dChuKSxpPTA7aTxuOysraSlvW2ldPXRlW3NbdFtpXS0xXSsrXT4+PjE1LXRbaV07cmV0dXJuIG99LGllPW5ldyBVdCgyODgpO2ZvcihlZT0wO2VlPDE0NDsrK2VlKWllW2VlXT04O2ZvcihlZT0xNDQ7ZWU8MjU2OysrZWUpaWVbZWVdPTk7Zm9yKGVlPTI1NjtlZTwyODA7KytlZSlpZVtlZV09Nztmb3IoZWU9MjgwO2VlPDI4ODsrK2VlKWllW2VlXT04O3ZhciBhZT1uZXcgVXQoMzIpO2ZvcihlZT0wO2VlPDMyOysrZWUpYWVbZWVdPTU7dmFyIG9lPW5lKGllLDksMCksc2U9bmUoaWUsOSwxKSxjZT1uZShhZSw1LDApLHVlPW5lKGFlLDUsMSksbGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRbMF0scj0xO3I8dC5sZW5ndGg7KytyKXRbcl0+ZSYmKGU9dFtyXSk7cmV0dXJuIGV9LGhlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1lLzg+PjA7cmV0dXJuKHRbbl18dFtuKzFdPDw4KT4+Pig3JmUpJnJ9LGZlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9ZS84Pj4wO3JldHVybih0W3JdfHRbcisxXTw8OHx0W3IrMl08PDE2KT4+Pig3JmUpfSxkZT1mdW5jdGlvbih0KXtyZXR1cm4odC84Pj4wKSsoNyZ0JiYxKX0scGU9ZnVuY3Rpb24odCxlLHIpeyhudWxsPT1lfHxlPDApJiYoZT0wKSwobnVsbD09cnx8cj50Lmxlbmd0aCkmJihyPXQubGVuZ3RoKTt2YXIgbj1uZXcodCBpbnN0YW5jZW9mIHp0P3p0OnQgaW5zdGFuY2VvZiBIdD9IdDpVdCkoci1lKTtyZXR1cm4gbi5zZXQodC5zdWJhcnJheShlLHIpKSxufSxnZT1mdW5jdGlvbih0LGUscil7cjw8PTcmZTt2YXIgbj1lLzg+PjA7dFtuXXw9cix0W24rMV18PXI+Pj44fSxtZT1mdW5jdGlvbih0LGUscil7cjw8PTcmZTt2YXIgbj1lLzg+PjA7dFtuXXw9cix0W24rMV18PXI+Pj44LHRbbisyXXw9cj4+PjE2fSx2ZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pdFtuXSYmci5wdXNoKHtzOm4sZjp0W25dfSk7dmFyIGk9ci5sZW5ndGgsYT1yLnNsaWNlKCk7aWYoIWkpcmV0dXJuW25ldyBVdCgwKSwwXTtpZigxPT1pKXt2YXIgbz1uZXcgVXQoclswXS5zKzEpO3JldHVybiBvW3JbMF0uc109MSxbbywxXX1yLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZi1lLmZ9KSksci5wdXNoKHtzOi0xLGY6MjUwMDF9KTt2YXIgcz1yWzBdLGM9clsxXSx1PTAsbD0xLGg9Mjtmb3IoclswXT17czotMSxmOnMuZitjLmYsbDpzLHI6Y307bCE9aS0xOylzPXJbclt1XS5mPHJbaF0uZj91Kys6aCsrXSxjPXJbdSE9bCYmclt1XS5mPHJbaF0uZj91Kys6aCsrXSxyW2wrK109e3M6LTEsZjpzLmYrYy5mLGw6cyxyOmN9O3ZhciBmPWFbMF0ucztmb3Iobj0xO248aTsrK24pYVtuXS5zPmYmJihmPWFbbl0ucyk7dmFyIGQ9bmV3IHp0KGYrMSkscD1iZShyW2wtMV0sZCwwKTtpZihwPmUpe249MDt2YXIgZz0wLG09cC1lLHY9MTw8bTtmb3IoYS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiBkW2Uuc10tZFt0LnNdfHx0LmYtZS5mfSkpO248aTsrK24pe3ZhciBiPWFbbl0ucztpZighKGRbYl0+ZSkpYnJlYWs7Zys9di0oMTw8cC1kW2JdKSxkW2JdPWV9Zm9yKGc+Pj49bTtnPjA7KXt2YXIgeT1hW25dLnM7ZFt5XTxlP2ctPTE8PGUtZFt5XSsrLTE6KytufWZvcig7bj49MCYmZzstLW4pe3ZhciB3PWFbbl0ucztkW3ddPT1lJiYoLS1kW3ddLCsrZyl9cD1lfXJldHVybltuZXcgVXQoZCkscF19LGJlPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4tMT09dC5zP01hdGgubWF4KGJlKHQubCxlLHIrMSksYmUodC5yLGUscisxKSk6ZVt0LnNdPXJ9LHllPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aDtlJiYhdFstLWVdOyk7Zm9yKHZhciByPW5ldyB6dCgrK2UpLG49MCxpPXRbMF0sYT0xLG89ZnVuY3Rpb24odCl7cltuKytdPXR9LHM9MTtzPD1lOysrcylpZih0W3NdPT1pJiZzIT1lKSsrYTtlbHNle2lmKCFpJiZhPjIpe2Zvcig7YT4xMzg7YS09MTM4KW8oMzI3NTQpO2E+MiYmKG8oYT4xMD9hLTExPDw1fDI4NjkwOmEtMzw8NXwxMjMwNSksYT0wKX1lbHNlIGlmKGE+Myl7Zm9yKG8oaSksLS1hO2E+NjthLT02KW8oODMwNCk7YT4yJiYobyhhLTM8PDV8ODIwOCksYT0wKX1mb3IoO2EtLTspbyhpKTthPTEsaT10W3NdfXJldHVybltyLnN1YmFycmF5KDAsbiksZV19LHdlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByPTAsbj0wO248ZS5sZW5ndGg7KytuKXIrPXRbbl0qZVtuXTtyZXR1cm4gcn0sTmU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIubGVuZ3RoLGk9ZGUoZSsyKTt0W2ldPTI1NSZuLHRbaSsxXT1uPj4+OCx0W2krMl09MjU1XnRbaV0sdFtpKzNdPTI1NV50W2krMV07Zm9yKHZhciBhPTA7YTxuOysrYSl0W2krYSs0XT1yW2FdO3JldHVybiA4KihpKzQrbil9LExlPWZ1bmN0aW9uKHQsZSxyLG4saSxhLG8scyxjLHUsbCl7Z2UoZSxsKyssciksKytpWzI1Nl07Zm9yKHZhciBoPXZlKGksMTUpLGY9aFswXSxkPWhbMV0scD12ZShhLDE1KSxnPXBbMF0sbT1wWzFdLHY9eWUoZiksYj12WzBdLHk9dlsxXSx3PXllKGcpLE49d1swXSxMPXdbMV0sQT1uZXcgenQoMTkpLHg9MDt4PGIubGVuZ3RoOysreClBWzMxJmJbeF1dKys7Zm9yKHg9MDt4PE4ubGVuZ3RoOysreClBWzMxJk5beF1dKys7Zm9yKHZhciBTPXZlKEEsNyksXz1TWzBdLFA9U1sxXSxrPTE5O2s+NCYmIV9bR3Rbay0xXV07LS1rKTt2YXIgRixJLEMsaixPPXUrNTw8MyxCPXdlKGksaWUpK3dlKGEsYWUpK28sTT13ZShpLGYpK3dlKGEsZykrbysxNCszKmsrd2UoQSxfKSsoMipBWzE2XSszKkFbMTddKzcqQVsxOF0pO2lmKE88PUImJk88PU0pcmV0dXJuIE5lKGUsbCx0LnN1YmFycmF5KGMsYyt1KSk7aWYoZ2UoZSxsLDErKE08QikpLGwrPTIsTTxCKXtGPW5lKGYsZCwwKSxJPWYsQz1uZShnLG0sMCksaj1nO3ZhciBFPW5lKF8sUCwwKTtnZShlLGwseS0yNTcpLGdlKGUsbCs1LEwtMSksZ2UoZSxsKzEwLGstNCksbCs9MTQ7Zm9yKHg9MDt4PGs7Kyt4KWdlKGUsbCszKngsX1tHdFt4XV0pO2wrPTMqaztmb3IodmFyIHE9W2IsTl0sRD0wO0Q8MjsrK0Qpe3ZhciBSPXFbRF07Zm9yKHg9MDt4PFIubGVuZ3RoOysreCl7dmFyIFQ9MzEmUlt4XTtnZShlLGwsRVtUXSksbCs9X1tUXSxUPjE1JiYoZ2UoZSxsLFJbeF0+Pj41JjEyNyksbCs9Ult4XT4+PjEyKX19fWVsc2UgRj1vZSxJPWllLEM9Y2Usaj1hZTtmb3IoeD0wO3g8czsrK3gpaWYoblt4XT4yNTUpe1Q9blt4XT4+PjE4JjMxO21lKGUsbCxGW1QrMjU3XSksbCs9SVtUKzI1N10sVD43JiYoZ2UoZSxsLG5beF0+Pj4yMyYzMSksbCs9V3RbVF0pO3ZhciBVPTMxJm5beF07bWUoZSxsLENbVV0pLGwrPWpbVV0sVT4zJiYobWUoZSxsLG5beF0+Pj41JjgxOTEpLGwrPVZ0W1VdKX1lbHNlIG1lKGUsbCxGW25beF1dKSxsKz1JW25beF1dO3JldHVybiBtZShlLGwsRlsyNTZdKSxsK0lbMjU2XX0sQWU9bmV3IEh0KFs2NTU0MCwxMzEwODAsMTMxMDg4LDEzMTEwNCwyNjIxNzYsMTA0ODcwNCwxMDQ4ODMyLDIxMTQ1NjAsMjExNzYzMl0pLHhlPW5ldyBVdCgwKSxTZT1mdW5jdGlvbih0LGUscixuLGkpe3JldHVybiBmdW5jdGlvbih0LGUscixuLGksYSl7dmFyIG89dC5sZW5ndGgscz1uZXcgVXQobitvKzUqKDErTWF0aC5mbG9vcihvLzdlMykpK2kpLGM9cy5zdWJhcnJheShuLHMubGVuZ3RoLWkpLHU9MDtpZighZXx8bzw4KWZvcih2YXIgbD0wO2w8PW87bCs9NjU1MzUpe3ZhciBoPWwrNjU1MzU7aDxvP3U9TmUoYyx1LHQuc3ViYXJyYXkobCxoKSk6KGNbbF09YSx1PU5lKGMsdSx0LnN1YmFycmF5KGwsbykpKX1lbHNle2Zvcih2YXIgZj1BZVtlLTFdLGQ9Zj4+PjEzLHA9ODE5MSZmLGc9KDE8PHIpLTEsbT1uZXcgenQoMzI3NjgpLHY9bmV3IHp0KGcrMSksYj1NYXRoLmNlaWwoci8zKSx5PTIqYix3PWZ1bmN0aW9uKGUpe3JldHVybih0W2VdXnRbZSsxXTw8Yl50W2UrMl08PHkpJmd9LE49bmV3IEh0KDI1ZTMpLEw9bmV3IHp0KDI4OCksQT1uZXcgenQoMzIpLHg9MCxTPTAsXz0obD0wLDApLFA9MCxrPTA7bDxvOysrbCl7dmFyIEY9dyhsKSxJPTMyNzY3JmwsQz12W0ZdO2lmKG1bSV09Qyx2W0ZdPUksUDw9bCl7dmFyIGo9by1sO2lmKCh4PjdlM3x8Xz4yNDU3NikmJmo+NDIzKXt1PUxlKHQsYywwLE4sTCxBLFMsXyxrLGwtayx1KSxfPXg9Uz0wLGs9bDtmb3IodmFyIE89MDtPPDI4NjsrK08pTFtPXT0wO2ZvcihPPTA7TzwzMDsrK08pQVtPXT0wfXZhciBCPTIsTT0wLEU9cCxxPUktQyYzMjc2NztpZihqPjImJkY9PXcobC1xKSlmb3IodmFyIEQ9TWF0aC5taW4oZCxqKS0xLFI9TWF0aC5taW4oMzI3NjcsbCksVD1NYXRoLm1pbigyNTgsaik7cTw9UiYmLS1FJiZJIT1DOyl7aWYodFtsK0JdPT10W2wrQi1xXSl7Zm9yKHZhciBVPTA7VTxUJiZ0W2wrVV09PXRbbCtVLXFdOysrVSk7aWYoVT5CKXtpZihCPVUsTT1xLFU+RClicmVhazt2YXIgej1NYXRoLm1pbihxLFUtMiksSD0wO2ZvcihPPTA7Tzx6OysrTyl7dmFyIFc9bC1xK08rMzI3NjgmMzI3NjcsVj1XLW1bV10rMzI3NjgmMzI3Njc7Vj5IJiYoSD1WLEM9Vyl9fX1xKz0oST1DKS0oQz1tW0ldKSszMjc2OCYzMjc2N31pZihNKXtOW18rK109MjY4NDM1NDU2fEt0W0JdPDwxOHxRdFtNXTt2YXIgRz0zMSZLdFtCXSxZPTMxJlF0W01dO1MrPVd0W0ddK1Z0W1ldLCsrTFsyNTcrR10sKytBW1ldLFA9bCtCLCsreH1lbHNlIE5bXysrXT10W2xdLCsrTFt0W2xdXX19dT1MZSh0LGMsYSxOLEwsQSxTLF8sayxsLWssdSksYXx8KHU9TmUoYyx1LHhlKSl9cmV0dXJuIHBlKHMsMCxuK2RlKHUpK2kpfSh0LG51bGw9PWUubGV2ZWw/NjplLmxldmVsLG51bGw9PWUubWVtP01hdGguY2VpbCgxLjUqTWF0aC5tYXgoOCxNYXRoLm1pbigxMyxNYXRoLmxvZyh0Lmxlbmd0aCkpKSk6MTIrZS5tZW0scixuLCFpKX07ZnVuY3Rpb24gX2UodCxlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIHI9ZnVuY3Rpb24oKXt2YXIgdD0xLGU9MDtyZXR1cm57cDpmdW5jdGlvbihyKXtmb3IodmFyIG49dCxpPWUsYT1yLmxlbmd0aCxvPTA7byE9YTspe2Zvcih2YXIgcz1NYXRoLm1pbihvKzU1NTIsYSk7bzxzOysrbylpKz1uKz1yW29dO24lPTY1NTIxLGklPTY1NTIxfXQ9bixlPWl9LGQ6ZnVuY3Rpb24oKXtyZXR1cm4odD4+Pjg8PDE2fCgyNTUmZSk8PDh8ZT4+PjgpKzIqKCgyNTUmdCk8PDIzKX19fSgpO3IucCh0KTt2YXIgbj1TZSh0LGUsMiw0KTtyZXR1cm4gZnVuY3Rpb24odCxlKXt2YXIgcj1lLmxldmVsLG49MD09cj8wOnI8Nj8xOjk9PXI/MzoyO3RbMF09MTIwLHRbMV09bjw8Nnwobj8zMi0yKm46MSl9KG4sZSksZnVuY3Rpb24odCxlLHIpe2Zvcig7cjsrK2UpdFtlXT1yLHI+Pj49OH0obixuLmxlbmd0aC00LHIuZCgpKSxufWZ1bmN0aW9uIFBlKHQsZSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj10Lmxlbmd0aCxpPSFlfHxyLGE9IXJ8fHIuaTtyfHwocj17fSksZXx8KGU9bmV3IFV0KDMqbikpO3ZhciBvPWZ1bmN0aW9uKHQpe3ZhciByPWUubGVuZ3RoO2lmKHQ+cil7dmFyIG49bmV3IFV0KE1hdGgubWF4KDIqcix0KSk7bi5zZXQoZSksZT1ufX0scz1yLmZ8fDAsYz1yLnB8fDAsdT1yLmJ8fDAsbD1yLmwsaD1yLmQsZj1yLm0sZD1yLm4scD04Km47ZG97aWYoIWwpe3IuZj1zPWhlKHQsYywxKTt2YXIgZz1oZSh0LGMrMSwzKTtpZihjKz0zLCFnKXt2YXIgbT10WyhQPWRlKGMpKzQpLTRdfHRbUC0zXTw8OCx2PVArbTtpZih2Pm4pe2lmKGEpdGhyb3cidW5leHBlY3RlZCBFT0YiO2JyZWFrfWkmJm8odSttKSxlLnNldCh0LnN1YmFycmF5KFAsdiksdSksci5iPXUrPW0sci5wPWM9OCp2O2NvbnRpbnVlfWlmKDE9PWcpbD1zZSxoPXVlLGY9OSxkPTU7ZWxzZXtpZigyIT1nKXRocm93ImludmFsaWQgYmxvY2sgdHlwZSI7dmFyIGI9aGUodCxjLDMxKSsyNTcseT1oZSh0LGMrMTAsMTUpKzQsdz1iK2hlKHQsYys1LDMxKSsxO2MrPTE0O2Zvcih2YXIgTj1uZXcgVXQodyksTD1uZXcgVXQoMTkpLEE9MDtBPHk7KytBKUxbR3RbQV1dPWhlKHQsYyszKkEsNyk7Yys9Myp5O3ZhciB4PWxlKEwpLFM9KDE8PHgpLTE7aWYoIWEmJmMrdyooeCs3KT5wKWJyZWFrO3ZhciBfPW5lKEwseCwxKTtmb3IoQT0wO0E8dzspe3ZhciBQLGs9X1toZSh0LGMsUyldO2lmKGMrPTE1JmssKFA9az4+PjQpPDE2KU5bQSsrXT1QO2Vsc2V7dmFyIEY9MCxJPTA7Zm9yKDE2PT1QPyhJPTMraGUodCxjLDMpLGMrPTIsRj1OW0EtMV0pOjE3PT1QPyhJPTMraGUodCxjLDcpLGMrPTMpOjE4PT1QJiYoST0xMStoZSh0LGMsMTI3KSxjKz03KTtJLS07KU5bQSsrXT1GfX12YXIgQz1OLnN1YmFycmF5KDAsYiksaj1OLnN1YmFycmF5KGIpO2Y9bGUoQyksZD1sZShqKSxsPW5lKEMsZiwxKSxoPW5lKGosZCwxKX1pZihjPnApdGhyb3cidW5leHBlY3RlZCBFT0YifWkmJm8odSsxMzEwNzIpO2Zvcih2YXIgTz0oMTw8ZiktMSxCPSgxPDxkKS0xLE09ZitkKzE4O2F8fGMrTTxwOyl7dmFyIEU9KEY9bFtmZSh0LGMpJk9dKT4+PjQ7aWYoKGMrPTE1JkYpPnApdGhyb3cidW5leHBlY3RlZCBFT0YiO2lmKCFGKXRocm93ImludmFsaWQgbGVuZ3RoL2xpdGVyYWwiO2lmKEU8MjU2KWVbdSsrXT1FO2Vsc2V7aWYoMjU2PT1FKXtsPW51bGw7YnJlYWt9dmFyIHE9RS0yNTQ7aWYoRT4yNjQpe3ZhciBEPVd0W0E9RS0yNTddO3E9aGUodCxjLCgxPDxEKS0xKStYdFtBXSxjKz1EfXZhciBSPWhbZmUodCxjKSZCXSxUPVI+Pj40O2lmKCFSKXRocm93ImludmFsaWQgZGlzdGFuY2UiO2MrPTE1JlI7aj0kdFtUXTtpZihUPjMpe0Q9VnRbVF07ais9ZmUodCxjKSYoMTw8RCktMSxjKz1EfWlmKGM+cCl0aHJvdyJ1bmV4cGVjdGVkIEVPRiI7aSYmbyh1KzEzMTA3Mik7Zm9yKHZhciBVPXUrcTt1PFU7dSs9NCllW3VdPWVbdS1qXSxlW3UrMV09ZVt1KzEtal0sZVt1KzJdPWVbdSsyLWpdLGVbdSszXT1lW3UrMy1qXTt1PVV9fXIubD1sLHIucD1jLHIuYj11LGwmJihzPTEsci5tPWYsci5kPWgsci5uPWQpfXdoaWxlKCFzKTtyZXR1cm4gdT09ZS5sZW5ndGg/ZTpwZShlLDAsdSl9KChmdW5jdGlvbih0KXtpZig4IT0oMTUmdFswXSl8fHRbMF0+Pj40Pjd8fCh0WzBdPDw4fHRbMV0pJTMxKXRocm93ImludmFsaWQgemxpYiBkYXRhIjtpZigzMiZ0WzFdKXRocm93ImludmFsaWQgemxpYiBkYXRhOiBwcmVzZXQgZGljdGlvbmFyaWVzIG5vdCBzdXBwb3J0ZWQifSh0KSx0LnN1YmFycmF5KDIsLTQpKSxlKX0KLyoqCiAgICogQGxpY2Vuc2UKICAgKiBqc1BERiBmaWx0ZXJzIFBsdWdJbgogICAqIENvcHlyaWdodCAoYykgMjAxNCBBcmFzIEFiYmFzaQogICAqCiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogICAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQogICAqLyFmdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0KXt2YXIgZSxyLG4saSxhLG8scyxjLHUsbDtmb3IoL1teXHgwMC1ceEZGXS8udGVzdCh0KSxyPVtdLG49MCxpPSh0Kz1lPSJcMFwwXDBcMCIuc2xpY2UodC5sZW5ndGglNHx8NCkpLmxlbmd0aDtpPm47bis9NCkwIT09KGE9KHQuY2hhckNvZGVBdChuKTw8MjQpKyh0LmNoYXJDb2RlQXQobisxKTw8MTYpKyh0LmNoYXJDb2RlQXQobisyKTw8OCkrdC5jaGFyQ29kZUF0KG4rMykpPyhvPShhPSgoYT0oKGE9KChhPShhLShsPWElODUpKS84NSktKHU9YSU4NSkpLzg1KS0oYz1hJTg1KSkvODUpLShzPWElODUpKS84NSklODUsci5wdXNoKG8rMzMscyszMyxjKzMzLHUrMzMsbCszMykpOnIucHVzaCgxMjIpO3JldHVybiBmdW5jdGlvbih0LGUpe2Zvcih2YXIgcj1lO3I+MDtyLS0pdC5wb3AoKX0ocixlLmxlbmd0aCksU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcscikrIn4+In0scj1mdW5jdGlvbih0KXt2YXIgZSxyLG4saSxhLG89U3RyaW5nLHM9Imxlbmd0aCIsYz0yNTUsdT0iY2hhckNvZGVBdCIsbD0ic2xpY2UiLGg9InJlcGxhY2UiO2Zvcih0W2xdKC0yKSx0PXRbbF0oMCwtMilbaF0oL1xzL2csIiIpW2hdKCJ6IiwiISEhISEiKSxuPVtdLGk9MCxhPSh0Kz1lPSJ1dXV1dSJbbF0odFtzXSU1fHw1KSlbc107YT5pO2krPTUpcj01MjIwMDYyNSoodFt1XShpKS0zMykrNjE0MTI1Kih0W3VdKGkrMSktMzMpKzcyMjUqKHRbdV0oaSsyKS0zMykrODUqKHRbdV0oaSszKS0zMykrKHRbdV0oaSs0KS0zMyksbi5wdXNoKGMmcj4+MjQsYyZyPj4xNixjJnI+PjgsYyZyKTtyZXR1cm4gZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9ZTtyPjA7ci0tKXQucG9wKCl9KG4sZVtzXSksby5mcm9tQ2hhckNvZGUuYXBwbHkobyxuKX0sbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgUmVnRXhwKC9eKFswLTlBLUZhLWZdezJ9KSskLyk7aWYoLTEhPT0odD10LnJlcGxhY2UoL1xzL2csIiIpKS5pbmRleE9mKCI+IikmJih0PXQuc3Vic3RyKDAsdC5pbmRleE9mKCI+IikpKSx0Lmxlbmd0aCUyJiYodCs9IjAiKSwhMT09PWUudGVzdCh0KSlyZXR1cm4iIjtmb3IodmFyIHI9IiIsbj0wO248dC5sZW5ndGg7bis9MilyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKCIweCIrKHRbbl0rdFtuKzFdKSk7cmV0dXJuIHJ9LGk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoKSxyPXQubGVuZ3RoO3ItLTspZVtyXT10LmNoYXJDb2RlQXQocik7cmV0dXJuIHQ9KGU9X2UoZSkpLnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtTdHJpbmcuZnJvbUNoYXJDb2RlKGUpfSksIiIpfTt0LnByb2Nlc3NEYXRhQnlGaWx0ZXJzPWZ1bmN0aW9uKHQsYSl7dmFyIG89MCxzPXR8fCIiLGM9W107Zm9yKCJzdHJpbmciPT10eXBlb2YoYT1hfHxbXSkmJihhPVthXSksbz0wO288YS5sZW5ndGg7bys9MSlzd2l0Y2goYVtvXSl7Y2FzZSJBU0NJSTg1RGVjb2RlIjpjYXNlIi9BU0NJSTg1RGVjb2RlIjpzPXIocyksYy5wdXNoKCIvQVNDSUk4NUVuY29kZSIpO2JyZWFrO2Nhc2UiQVNDSUk4NUVuY29kZSI6Y2FzZSIvQVNDSUk4NUVuY29kZSI6cz1lKHMpLGMucHVzaCgiL0FTQ0lJODVEZWNvZGUiKTticmVhaztjYXNlIkFTQ0lJSGV4RGVjb2RlIjpjYXNlIi9BU0NJSUhleERlY29kZSI6cz1uKHMpLGMucHVzaCgiL0FTQ0lJSGV4RW5jb2RlIik7YnJlYWs7Y2FzZSJBU0NJSUhleEVuY29kZSI6Y2FzZSIvQVNDSUlIZXhFbmNvZGUiOnM9cy5zcGxpdCgiIikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4oIjAiK3QuY2hhckNvZGVBdCgpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTIpfSkpLmpvaW4oIiIpKyI+IixjLnB1c2goIi9BU0NJSUhleERlY29kZSIpO2JyZWFrO2Nhc2UiRmxhdGVFbmNvZGUiOmNhc2UiL0ZsYXRlRW5jb2RlIjpzPWkocyksYy5wdXNoKCIvRmxhdGVEZWNvZGUiKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcignVGhlIGZpbHRlcjogIicrYVtvXSsnIiBpcyBub3QgaW1wbGVtZW50ZWQnKX1yZXR1cm57ZGF0YTpzLHJldmVyc2VDaGFpbjpjLnJldmVyc2UoKS5qb2luKCIgIil9fX0oTS5BUEkpLAovKioKICAgKiBAbGljZW5zZQogICAqIGpzUERGIGZpbGVsb2FkaW5nIFBsdWdJbgogICAqIENvcHlyaWdodCAoYykgMjAxOCBBcmFzIEFiYmFzaSAoYXJhcy5hYmJhc2lAZ21haWwuY29tKQogICAqCiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLgogICAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZQogICAqLwpmdW5jdGlvbih0KXt0LmxvYWRGaWxlPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZnVuY3Rpb24odCxlLHIpe2U9ITEhPT1lLHI9ImZ1bmN0aW9uIj09dHlwZW9mIHI/cjpmdW5jdGlvbigpe307dmFyIG49dm9pZCAwO3RyeXtuPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1uZXcgWE1MSHR0cFJlcXVlc3QsaT0wLGE9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGgscj1bXSxuPVN0cmluZy5mcm9tQ2hhckNvZGU7Zm9yKGk9MDtpPGU7aSs9MSlyLnB1c2gobigyNTUmdC5jaGFyQ29kZUF0KGkpKSk7cmV0dXJuIHIuam9pbigiIil9O2lmKG4ub3BlbigiR0VUIix0LCFlKSxuLm92ZXJyaWRlTWltZVR5cGUoInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWQiKSwhMT09PWUmJihuLm9ubG9hZD1mdW5jdGlvbigpezIwMD09PW4uc3RhdHVzP3IoYSh0aGlzLnJlc3BvbnNlVGV4dCkpOnIodm9pZCAwKX0pLG4uc2VuZChudWxsKSxlJiYyMDA9PT1uLnN0YXR1cylyZXR1cm4gYShuLnJlc3BvbnNlVGV4dCl9KHQsZSxyKX1jYXRjaCh0KXt9cmV0dXJuIG59KHQsZSxyKX0sdC5sb2FkSW1hZ2VGaWxlPXQubG9hZEZpbGV9KE0uQVBJKSxmdW5jdGlvbihuKXtmdW5jdGlvbiBpKCl7cmV0dXJuKHIuaHRtbDJjYW52YXM/UHJvbWlzZS5yZXNvbHZlKHIuaHRtbDJjYW52YXMpOiJvYmplY3QiPT09KHZvaWQgMD09PXQ/InVuZGVmaW5lZCI6ZSh0KSkmJiJ1bmRlZmluZWQiIT10eXBlb2YgbW9kdWxlP25ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3RyeXt0KHJlcXVpcmUoImh0bWwyY2FudmFzIikpfWNhdGNoKHQpe2UodCl9fSkpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dHJ5e3JlcXVpcmUoWyJodG1sMmNhbnZhcyJdLHQpfWNhdGNoKHQpe2UodCl9fSkpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcigiQ291bGQgbm90IGxvYWQgaHRtbDJjYW52YXMiKSkpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCJDb3VsZCBub3QgbG9hZCBodG1sMmNhbnZhczogIit0KSl9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVmYXVsdD90LmRlZmF1bHQ6dH0pKX1mdW5jdGlvbiBhKCl7cmV0dXJuKHIuRE9NUHVyaWZ5P1Byb21pc2UucmVzb2x2ZShyLkRPTVB1cmlmeSk6Im9iamVjdCI9PT0odm9pZCAwPT09dD8idW5kZWZpbmVkIjplKHQpKSYmInVuZGVmaW5lZCIhPXR5cGVvZiBtb2R1bGU/bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dHJ5e3QocmVxdWlyZSgiZG9tcHVyaWZ5IikpfWNhdGNoKHQpe2UodCl9fSkpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dHJ5e3JlcXVpcmUoWyJkb21wdXJpZnkiXSx0KX1jYXRjaCh0KXtlKHQpfX0pKTpQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoIkNvdWxkIG5vdCBsb2FkIGRvbXB1cmlmeSIpKSkuY2F0Y2goKGZ1bmN0aW9uKHQpe3JldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoIkNvdWxkIG5vdCBsb2FkIGRvbXB1cmlmeTogIit0KSl9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVmYXVsdD90LmRlZmF1bHQ6dH0pKX12YXIgbz1mdW5jdGlvbih0KXt2YXIgcj1lKHQpO3JldHVybiJ1bmRlZmluZWQiPT09cj8idW5kZWZpbmVkIjoic3RyaW5nIj09PXJ8fHQgaW5zdGFuY2VvZiBTdHJpbmc/InN0cmluZyI6Im51bWJlciI9PT1yfHx0IGluc3RhbmNlb2YgTnVtYmVyPyJudW1iZXIiOiJmdW5jdGlvbiI9PT1yfHx0IGluc3RhbmNlb2YgRnVuY3Rpb24/ImZ1bmN0aW9uIjp0JiZ0LmNvbnN0cnVjdG9yPT09QXJyYXk/ImFycmF5Ijp0JiYxPT09dC5ub2RlVHlwZT8iZWxlbWVudCI6Im9iamVjdCI9PT1yPyJvYmplY3QiOiJ1bmtub3duIn0scz1mdW5jdGlvbih0LGUpe3ZhciByPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodCk7Zm9yKHZhciBuIGluIGUuY2xhc3NOYW1lJiYoci5jbGFzc05hbWU9ZS5jbGFzc05hbWUpLGUuaW5uZXJIVE1MJiZlLmRvbXB1cmlmeSYmKHIuaW5uZXJIVE1MPWUuZG9tcHVyaWZ5LnNhbml0aXplKGUuaW5uZXJIVE1MKSksZS5zdHlsZSlyLnN0eWxlW25dPWUuc3R5bGVbbl07cmV0dXJuIHJ9LGM9ZnVuY3Rpb24gdChlKXt2YXIgcj1PYmplY3QuYXNzaWduKHQuY29udmVydChQcm9taXNlLnJlc29sdmUoKSksSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0LnRlbXBsYXRlKSkpLG49dC5jb252ZXJ0KFByb21pc2UucmVzb2x2ZSgpLHIpO3JldHVybiBuPShuPW4uc2V0UHJvZ3Jlc3MoMSx0LDEsW3RdKSkuc2V0KGUpfTsoYy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShQcm9taXNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWMsYy5jb252ZXJ0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuX19wcm90b19fPWV8fGMucHJvdG90eXBlLHR9LGMudGVtcGxhdGU9e3Byb3A6e3NyYzpudWxsLGNvbnRhaW5lcjpudWxsLG92ZXJsYXk6bnVsbCxjYW52YXM6bnVsbCxpbWc6bnVsbCxwZGY6bnVsbCxwYWdlU2l6ZTpudWxsLGNhbGxiYWNrOmZ1bmN0aW9uKCl7fX0scHJvZ3Jlc3M6e3ZhbDowLHN0YXRlOm51bGwsbjowLHN0YWNrOltdfSxvcHQ6e2ZpbGVuYW1lOiJmaWxlLnBkZiIsbWFyZ2luOlswLDAsMCwwXSxlbmFibGVMaW5rczohMCx4OjAseTowLGh0bWwyY2FudmFzOnt9LGpzUERGOnt9LGJhY2tncm91bmRDb2xvcjoidHJhbnNwYXJlbnQifX0sYy5wcm90b3R5cGUuZnJvbT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRoZW4oKGZ1bmN0aW9uKCl7c3dpdGNoKGU9ZXx8ZnVuY3Rpb24odCl7c3dpdGNoKG8odCkpe2Nhc2Uic3RyaW5nIjpyZXR1cm4ic3RyaW5nIjtjYXNlImVsZW1lbnQiOnJldHVybiJjYW52YXMiPT09dC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpPyJjYW52YXMiOiJlbGVtZW50IjtkZWZhdWx0OnJldHVybiJ1bmtub3duIn19KHQpKXtjYXNlInN0cmluZyI6cmV0dXJuIHRoaXMudGhlbihhKS50aGVuKChmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZXQoe3NyYzpzKCJkaXYiLHtpbm5lckhUTUw6dCxkb21wdXJpZnk6ZX0pfSl9KSk7Y2FzZSJlbGVtZW50IjpyZXR1cm4gdGhpcy5zZXQoe3NyYzp0fSk7Y2FzZSJjYW52YXMiOnJldHVybiB0aGlzLnNldCh7Y2FudmFzOnR9KTtjYXNlImltZyI6cmV0dXJuIHRoaXMuc2V0KHtpbWc6dH0pO2RlZmF1bHQ6cmV0dXJuIHRoaXMuZXJyb3IoIlVua25vd24gc291cmNlIHR5cGUuIil9fSkpfSxjLnByb3RvdHlwZS50bz1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSJjb250YWluZXIiOnJldHVybiB0aGlzLnRvQ29udGFpbmVyKCk7Y2FzZSJjYW52YXMiOnJldHVybiB0aGlzLnRvQ2FudmFzKCk7Y2FzZSJpbWciOnJldHVybiB0aGlzLnRvSW1nKCk7Y2FzZSJwZGYiOnJldHVybiB0aGlzLnRvUGRmKCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5lcnJvcigiSW52YWxpZCB0YXJnZXQuIil9fSxjLnByb3RvdHlwZS50b0NvbnRhaW5lcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3Auc3JjfHx0aGlzLmVycm9yKCJDYW5ub3QgZHVwbGljYXRlIC0gbm8gc291cmNlIEhUTUwuIil9LGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcC5wYWdlU2l6ZXx8dGhpcy5zZXRQYWdlU2l6ZSgpfV0pLnRoZW4oKGZ1bmN0aW9uKCl7dmFyIHQ9e3Bvc2l0aW9uOiJyZWxhdGl2ZSIsZGlzcGxheToiaW5saW5lLWJsb2NrIix3aWR0aDooIm51bWJlciIhPXR5cGVvZiB0aGlzLm9wdC53aWR0aHx8aXNOYU4odGhpcy5vcHQud2lkdGgpfHwibnVtYmVyIiE9dHlwZW9mIHRoaXMub3B0LndpbmRvd1dpZHRofHxpc05hTih0aGlzLm9wdC53aW5kb3dXaWR0aCk/TWF0aC5tYXgodGhpcy5wcm9wLnNyYy5jbGllbnRXaWR0aCx0aGlzLnByb3Auc3JjLnNjcm9sbFdpZHRoLHRoaXMucHJvcC5zcmMub2Zmc2V0V2lkdGgpOnRoaXMub3B0LndpbmRvd1dpZHRoKSsicHgiLGxlZnQ6MCxyaWdodDowLHRvcDowLG1hcmdpbjoiYXV0byIsYmFja2dyb3VuZENvbG9yOnRoaXMub3B0LmJhY2tncm91bmRDb2xvcn0sZT1mdW5jdGlvbiB0KGUscil7Zm9yKHZhciBuPTM9PT1lLm5vZGVUeXBlP2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKGUubm9kZVZhbHVlKTplLmNsb25lTm9kZSghMSksaT1lLmZpcnN0Q2hpbGQ7aTtpPWkubmV4dFNpYmxpbmcpITAhPT1yJiYxPT09aS5ub2RlVHlwZSYmIlNDUklQVCI9PT1pLm5vZGVOYW1lfHxuLmFwcGVuZENoaWxkKHQoaSxyKSk7cmV0dXJuIDE9PT1lLm5vZGVUeXBlJiYoIkNBTlZBUyI9PT1lLm5vZGVOYW1lPyhuLndpZHRoPWUud2lkdGgsbi5oZWlnaHQ9ZS5oZWlnaHQsbi5nZXRDb250ZXh0KCIyZCIpLmRyYXdJbWFnZShlLDAsMCkpOiJURVhUQVJFQSIhPT1lLm5vZGVOYW1lJiYiU0VMRUNUIiE9PWUubm9kZU5hbWV8fChuLnZhbHVlPWUudmFsdWUpLG4uYWRkRXZlbnRMaXN0ZW5lcigibG9hZCIsKGZ1bmN0aW9uKCl7bi5zY3JvbGxUb3A9ZS5zY3JvbGxUb3Asbi5zY3JvbGxMZWZ0PWUuc2Nyb2xsTGVmdH0pLCEwKSksbn0odGhpcy5wcm9wLnNyYyx0aGlzLm9wdC5odG1sMmNhbnZhcy5qYXZhc2NyaXB0RW5hYmxlZCk7IkJPRFkiPT09ZS50YWdOYW1lJiYodC5oZWlnaHQ9TWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQsZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCxkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vZmZzZXRIZWlnaHQpKyJweCIpLHRoaXMucHJvcC5vdmVybGF5PXMoImRpdiIse2NsYXNzTmFtZToiaHRtbDJwZGZfX292ZXJsYXkiLHN0eWxlOntwb3NpdGlvbjoiZml4ZWQiLG92ZXJmbG93OiJoaWRkZW4iLHpJbmRleDoxZTMsbGVmdDoiLTEwMDAwMHB4IixyaWdodDowLGJvdHRvbTowLHRvcDowfX0pLHRoaXMucHJvcC5jb250YWluZXI9cygiZGl2Iix7Y2xhc3NOYW1lOiJodG1sMnBkZl9fY29udGFpbmVyIixzdHlsZTp0fSksdGhpcy5wcm9wLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlKSx0aGlzLnByb3AuY29udGFpbmVyLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQocygiZGl2Iix7c3R5bGU6e2NsZWFyOiJib3RoIixib3JkZXI6IjAgbm9uZSB0cmFuc3BhcmVudCIsbWFyZ2luOjAscGFkZGluZzowLGhlaWdodDowfX0pKSx0aGlzLnByb3AuY29udGFpbmVyLnN0eWxlLmZsb2F0PSJub25lIix0aGlzLnByb3Aub3ZlcmxheS5hcHBlbmRDaGlsZCh0aGlzLnByb3AuY29udGFpbmVyKSxkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucHJvcC5vdmVybGF5KSx0aGlzLnByb3AuY29udGFpbmVyLmZpcnN0Q2hpbGQuc3R5bGUucG9zaXRpb249InJlbGF0aXZlIix0aGlzLnByb3AuY29udGFpbmVyLmhlaWdodD1NYXRoLm1heCh0aGlzLnByb3AuY29udGFpbmVyLmZpcnN0Q2hpbGQuY2xpZW50SGVpZ2h0LHRoaXMucHJvcC5jb250YWluZXIuZmlyc3RDaGlsZC5zY3JvbGxIZWlnaHQsdGhpcy5wcm9wLmNvbnRhaW5lci5maXJzdENoaWxkLm9mZnNldEhlaWdodCkrInB4In0pKX0sYy5wcm90b3R5cGUudG9DYW52YXM9ZnVuY3Rpb24oKXt2YXIgdD1bZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuYm9keS5jb250YWlucyh0aGlzLnByb3AuY29udGFpbmVyKXx8dGhpcy50b0NvbnRhaW5lcigpfV07cmV0dXJuIHRoaXMudGhlbkxpc3QodCkudGhlbihpKS50aGVuKChmdW5jdGlvbih0KXt2YXIgZT1PYmplY3QuYXNzaWduKHt9LHRoaXMub3B0Lmh0bWwyY2FudmFzKTtyZXR1cm4gZGVsZXRlIGUub25yZW5kZXJlZCx0KHRoaXMucHJvcC5jb250YWluZXIsZSl9KSkudGhlbigoZnVuY3Rpb24odCl7KHRoaXMub3B0Lmh0bWwyY2FudmFzLm9ucmVuZGVyZWR8fGZ1bmN0aW9uKCl7fSkodCksdGhpcy5wcm9wLmNhbnZhcz10LGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5wcm9wLm92ZXJsYXkpfSkpfSxjLnByb3RvdHlwZS50b0NvbnRleHQyZD1mdW5jdGlvbigpe3ZhciB0PVtmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMucHJvcC5jb250YWluZXIpfHx0aGlzLnRvQ29udGFpbmVyKCl9XTtyZXR1cm4gdGhpcy50aGVuTGlzdCh0KS50aGVuKGkpLnRoZW4oKGZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMub3B0LmpzUERGLHI9dGhpcy5vcHQuZm9udEZhY2VzLG49Im51bWJlciIhPXR5cGVvZiB0aGlzLm9wdC53aWR0aHx8aXNOYU4odGhpcy5vcHQud2lkdGgpfHwibnVtYmVyIiE9dHlwZW9mIHRoaXMub3B0LndpbmRvd1dpZHRofHxpc05hTih0aGlzLm9wdC53aW5kb3dXaWR0aCk/MTp0aGlzLm9wdC53aWR0aC90aGlzLm9wdC53aW5kb3dXaWR0aCxpPU9iamVjdC5hc3NpZ24oe2FzeW5jOiEwLGFsbG93VGFpbnQ6ITAsc2NhbGU6bixzY3JvbGxYOnRoaXMub3B0LnNjcm9sbFh8fDAsc2Nyb2xsWTp0aGlzLm9wdC5zY3JvbGxZfHwwLGJhY2tncm91bmRDb2xvcjoiI2ZmZmZmZiIsaW1hZ2VUaW1lb3V0OjE1ZTMsbG9nZ2luZzohMCxwcm94eTpudWxsLHJlbW92ZUNvbnRhaW5lcjohMCxmb3JlaWduT2JqZWN0UmVuZGVyaW5nOiExLHVzZUNPUlM6ITF9LHRoaXMub3B0Lmh0bWwyY2FudmFzKTtpZihkZWxldGUgaS5vbnJlbmRlcmVkLGUuY29udGV4dDJkLmF1dG9QYWdpbmc9dm9pZCAwPT09dGhpcy5vcHQuYXV0b1BhZ2luZ3x8dGhpcy5vcHQuYXV0b1BhZ2luZyxlLmNvbnRleHQyZC5wb3NYPXRoaXMub3B0LngsZS5jb250ZXh0MmQucG9zWT10aGlzLm9wdC55LGUuY29udGV4dDJkLm1hcmdpbj10aGlzLm9wdC5tYXJnaW4sZS5jb250ZXh0MmQuZm9udEZhY2VzPXIscilmb3IodmFyIGE9MDthPHIubGVuZ3RoOysrYSl7dmFyIG89clthXSxzPW8uc3JjLmZpbmQoKGZ1bmN0aW9uKHQpe3JldHVybiJ0cnVldHlwZSI9PT10LmZvcm1hdH0pKTtzJiZlLmFkZEZvbnQocy51cmwsby5yZWYubmFtZSxvLnJlZi5zdHlsZSl9cmV0dXJuIGkud2luZG93SGVpZ2h0PWkud2luZG93SGVpZ2h0fHwwLGkud2luZG93SGVpZ2h0PTA9PWkud2luZG93SGVpZ2h0P01hdGgubWF4KHRoaXMucHJvcC5jb250YWluZXIuY2xpZW50SGVpZ2h0LHRoaXMucHJvcC5jb250YWluZXIuc2Nyb2xsSGVpZ2h0LHRoaXMucHJvcC5jb250YWluZXIub2Zmc2V0SGVpZ2h0KTppLndpbmRvd0hlaWdodCxlLmNvbnRleHQyZC5zYXZlKCEwKSx0KHRoaXMucHJvcC5jb250YWluZXIsaSl9KSkudGhlbigoZnVuY3Rpb24odCl7dGhpcy5vcHQuanNQREYuY29udGV4dDJkLnJlc3RvcmUoITApLCh0aGlzLm9wdC5odG1sMmNhbnZhcy5vbnJlbmRlcmVkfHxmdW5jdGlvbigpe30pKHQpLHRoaXMucHJvcC5jYW52YXM9dCxkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMucHJvcC5vdmVybGF5KX0pKX0sYy5wcm90b3R5cGUudG9JbWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50aGVuTGlzdChbZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wLmNhbnZhc3x8dGhpcy50b0NhbnZhcygpfV0pLnRoZW4oKGZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wcm9wLmNhbnZhcy50b0RhdGFVUkwoImltYWdlLyIrdGhpcy5vcHQuaW1hZ2UudHlwZSx0aGlzLm9wdC5pbWFnZS5xdWFsaXR5KTt0aGlzLnByb3AuaW1nPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpLHRoaXMucHJvcC5pbWcuc3JjPXR9KSl9LGMucHJvdG90eXBlLnRvUGRmPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudGhlbkxpc3QoW2Z1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9Db250ZXh0MmQoKX1dKS50aGVuKChmdW5jdGlvbigpe3RoaXMucHJvcC5wZGY9dGhpcy5wcm9wLnBkZnx8dGhpcy5vcHQuanNQREZ9KSl9LGMucHJvdG90eXBlLm91dHB1dD1mdW5jdGlvbih0LGUscil7cmV0dXJuImltZyI9PT0ocj1yfHwicGRmIikudG9Mb3dlckNhc2UoKXx8ImltYWdlIj09PXIudG9Mb3dlckNhc2UoKT90aGlzLm91dHB1dEltZyh0LGUpOnRoaXMub3V0cHV0UGRmKHQsZSl9LGMucHJvdG90eXBlLm91dHB1dFBkZj1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmfHx0aGlzLnRvUGRmKCl9XSkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wLnBkZi5vdXRwdXQodCxlKX0pKX0sYy5wcm90b3R5cGUub3V0cHV0SW1nPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AuaW1nfHx0aGlzLnRvSW1nKCl9XSkudGhlbigoZnVuY3Rpb24oKXtzd2l0Y2godCl7Y2FzZSB2b2lkIDA6Y2FzZSJpbWciOnJldHVybiB0aGlzLnByb3AuaW1nO2Nhc2UiZGF0YXVyaXN0cmluZyI6Y2FzZSJkYXRhdXJsc3RyaW5nIjpyZXR1cm4gdGhpcy5wcm9wLmltZy5zcmM7Y2FzZSJkYXRhdXJpIjpjYXNlImRhdGF1cmwiOnJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5ocmVmPXRoaXMucHJvcC5pbWcuc3JjO2RlZmF1bHQ6dGhyb3cnSW1hZ2Ugb3V0cHV0IHR5cGUgIicrdCsnIiBpcyBub3Qgc3VwcG9ydGVkLid9fSkpfSxjLnByb3RvdHlwZS5zYXZlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmfHx0aGlzLnRvUGRmKCl9XSkuc2V0KHQ/e2ZpbGVuYW1lOnR9Om51bGwpLnRoZW4oKGZ1bmN0aW9uKCl7dGhpcy5wcm9wLnBkZi5zYXZlKHRoaXMub3B0LmZpbGVuYW1lKX0pKX0sYy5wcm90b3R5cGUuZG9DYWxsYmFjaz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KFtmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3AucGRmfHx0aGlzLnRvUGRmKCl9XSkudGhlbigoZnVuY3Rpb24oKXt0aGlzLnByb3AuY2FsbGJhY2sodGhpcy5wcm9wLnBkZil9KSl9LGMucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtpZigib2JqZWN0IiE9PW8odCkpcmV0dXJuIHRoaXM7dmFyIGU9T2JqZWN0LmtleXModHx8e30pLm1hcCgoZnVuY3Rpb24oZSl7aWYoZSBpbiBjLnRlbXBsYXRlLnByb3ApcmV0dXJuIGZ1bmN0aW9uKCl7dGhpcy5wcm9wW2VdPXRbZV19O3N3aXRjaChlKXtjYXNlIm1hcmdpbiI6cmV0dXJuIHRoaXMuc2V0TWFyZ2luLmJpbmQodGhpcyx0Lm1hcmdpbik7Y2FzZSJqc1BERiI6cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3B0LmpzUERGPXQuanNQREYsdGhpcy5zZXRQYWdlU2l6ZSgpfTtjYXNlInBhZ2VTaXplIjpyZXR1cm4gdGhpcy5zZXRQYWdlU2l6ZS5iaW5kKHRoaXMsdC5wYWdlU2l6ZSk7ZGVmYXVsdDpyZXR1cm4gZnVuY3Rpb24oKXt0aGlzLm9wdFtlXT10W2VdfX19KSx0aGlzKTtyZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbigpe3JldHVybiB0aGlzLnRoZW5MaXN0KGUpfSkpfSxjLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbigpe3ZhciByPXQgaW4gYy50ZW1wbGF0ZS5wcm9wP3RoaXMucHJvcFt0XTp0aGlzLm9wdFt0XTtyZXR1cm4gZT9lKHIpOnJ9KSl9LGMucHJvdG90eXBlLnNldE1hcmdpbj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbigpe3N3aXRjaChvKHQpKXtjYXNlIm51bWJlciI6dD1bdCx0LHQsdF07Y2FzZSJhcnJheSI6aWYoMj09PXQubGVuZ3RoJiYodD1bdFswXSx0WzFdLHRbMF0sdFsxXV0pLDQ9PT10Lmxlbmd0aClicmVhaztkZWZhdWx0OnJldHVybiB0aGlzLmVycm9yKCJJbnZhbGlkIG1hcmdpbiBhcnJheS4iKX10aGlzLm9wdC5tYXJnaW49dH0pKS50aGVuKHRoaXMuc2V0UGFnZVNpemUpfSxjLnByb3RvdHlwZS5zZXRQYWdlU2l6ZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQsZSl7cmV0dXJuIE1hdGguZmxvb3IodCplLzcyKjk2KX1yZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbigpeyh0PXR8fE0uZ2V0UGFnZVNpemUodGhpcy5vcHQuanNQREYpKS5oYXNPd25Qcm9wZXJ0eSgiaW5uZXIiKXx8KHQuaW5uZXI9e3dpZHRoOnQud2lkdGgtdGhpcy5vcHQubWFyZ2luWzFdLXRoaXMub3B0Lm1hcmdpblszXSxoZWlnaHQ6dC5oZWlnaHQtdGhpcy5vcHQubWFyZ2luWzBdLXRoaXMub3B0Lm1hcmdpblsyXX0sdC5pbm5lci5weD17d2lkdGg6ZSh0LmlubmVyLndpZHRoLHQuayksaGVpZ2h0OmUodC5pbm5lci5oZWlnaHQsdC5rKX0sdC5pbm5lci5yYXRpbz10LmlubmVyLmhlaWdodC90LmlubmVyLndpZHRoKSx0aGlzLnByb3AucGFnZVNpemU9dH0pKX0sYy5wcm90b3R5cGUuc2V0UHJvZ3Jlc3M9ZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuIG51bGwhPXQmJih0aGlzLnByb2dyZXNzLnZhbD10KSxudWxsIT1lJiYodGhpcy5wcm9ncmVzcy5zdGF0ZT1lKSxudWxsIT1yJiYodGhpcy5wcm9ncmVzcy5uPXIpLG51bGwhPW4mJih0aGlzLnByb2dyZXNzLnN0YWNrPW4pLHRoaXMucHJvZ3Jlc3MucmF0aW89dGhpcy5wcm9ncmVzcy52YWwvdGhpcy5wcm9ncmVzcy5zdGF0ZSx0aGlzfSxjLnByb3RvdHlwZS51cGRhdGVQcm9ncmVzcz1mdW5jdGlvbih0LGUscixuKXtyZXR1cm4gdGhpcy5zZXRQcm9ncmVzcyh0P3RoaXMucHJvZ3Jlc3MudmFsK3Q6bnVsbCxlfHxudWxsLHI/dGhpcy5wcm9ncmVzcy5uK3I6bnVsbCxuP3RoaXMucHJvZ3Jlc3Muc3RhY2suY29uY2F0KG4pOm51bGwpfSxjLnByb3RvdHlwZS50aGVuPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcztyZXR1cm4gdGhpcy50aGVuQ29yZSh0LGUsKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIudXBkYXRlUHJvZ3Jlc3MobnVsbCxudWxsLDEsW3RdKSxQcm9taXNlLnByb3RvdHlwZS50aGVuLmNhbGwodGhpcywoZnVuY3Rpb24oZSl7cmV0dXJuIHIudXBkYXRlUHJvZ3Jlc3MobnVsbCx0KSxlfSkpLnRoZW4odCxlKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gci51cGRhdGVQcm9ncmVzcygxKSx0fSkpfSkpfSxjLnByb3RvdHlwZS50aGVuQ29yZT1mdW5jdGlvbih0LGUscil7cj1yfHxQcm9taXNlLnByb3RvdHlwZS50aGVuO3QmJih0PXQuYmluZCh0aGlzKSksZSYmKGU9ZS5iaW5kKHRoaXMpKTt2YXIgbj0tMSE9PVByb21pc2UudG9TdHJpbmcoKS5pbmRleE9mKCJbbmF0aXZlIGNvZGVdIikmJiJQcm9taXNlIj09PVByb21pc2UubmFtZT90aGlzOmMuY29udmVydChPYmplY3QuYXNzaWduKHt9LHRoaXMpLFByb21pc2UucHJvdG90eXBlKSxpPXIuY2FsbChuLHQsZSk7cmV0dXJuIGMuY29udmVydChpLHRoaXMuX19wcm90b19fKX0sYy5wcm90b3R5cGUudGhlbkV4dGVybmFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFByb21pc2UucHJvdG90eXBlLnRoZW4uY2FsbCh0aGlzLHQsZSl9LGMucHJvdG90eXBlLnRoZW5MaXN0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHQuZm9yRWFjaCgoZnVuY3Rpb24odCl7ZT1lLnRoZW5Db3JlKHQpfSkpLGV9LGMucHJvdG90eXBlLmNhdGNoPWZ1bmN0aW9uKHQpe3QmJih0PXQuYmluZCh0aGlzKSk7dmFyIGU9UHJvbWlzZS5wcm90b3R5cGUuY2F0Y2guY2FsbCh0aGlzLHQpO3JldHVybiBjLmNvbnZlcnQoZSx0aGlzKX0sYy5wcm90b3R5cGUuY2F0Y2hFeHRlcm5hbD1mdW5jdGlvbih0KXtyZXR1cm4gUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2guY2FsbCh0aGlzLHQpfSxjLnByb3RvdHlwZS5lcnJvcj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy50aGVuKChmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcih0KX0pKX0sYy5wcm90b3R5cGUudXNpbmc9Yy5wcm90b3R5cGUuc2V0LGMucHJvdG90eXBlLnNhdmVBcz1jLnByb3RvdHlwZS5zYXZlLGMucHJvdG90eXBlLmV4cG9ydD1jLnByb3RvdHlwZS5vdXRwdXQsYy5wcm90b3R5cGUucnVuPWMucHJvdG90eXBlLnRoZW4sTS5nZXRQYWdlU2l6ZT1mdW5jdGlvbih0LHIsbil7aWYoIm9iamVjdCI9PT1lKHQpKXt2YXIgaT10O3Q9aS5vcmllbnRhdGlvbixyPWkudW5pdHx8cixuPWkuZm9ybWF0fHxufXI9cnx8Im1tIixuPW58fCJhNCIsdD0oIiIrKHR8fCJQIikpLnRvTG93ZXJDYXNlKCk7dmFyIGEsbz0oIiIrbikudG9Mb3dlckNhc2UoKSxzPXthMDpbMjM4My45NCwzMzcwLjM5XSxhMTpbMTY4My43OCwyMzgzLjk0XSxhMjpbMTE5MC41NSwxNjgzLjc4XSxhMzpbODQxLjg5LDExOTAuNTVdLGE0Ols1OTUuMjgsODQxLjg5XSxhNTpbNDE5LjUzLDU5NS4yOF0sYTY6WzI5Ny42NCw0MTkuNTNdLGE3OlsyMDkuNzYsMjk3LjY0XSxhODpbMTQ3LjQsMjA5Ljc2XSxhOTpbMTA0Ljg4LDE0Ny40XSxhMTA6WzczLjcsMTA0Ljg4XSxiMDpbMjgzNC42NSw0MDA4LjE5XSxiMTpbMjAwNC4wOSwyODM0LjY1XSxiMjpbMTQxNy4zMiwyMDA0LjA5XSxiMzpbMTAwMC42MywxNDE3LjMyXSxiNDpbNzA4LjY2LDEwMDAuNjNdLGI1Ols0OTguOSw3MDguNjZdLGI2OlszNTQuMzMsNDk4LjldLGI3OlsyNDkuNDUsMzU0LjMzXSxiODpbMTc1Ljc1LDI0OS40NV0sYjk6WzEyNC43MiwxNzUuNzVdLGIxMDpbODcuODcsMTI0LjcyXSxjMDpbMjU5OS4zNywzNjc2LjU0XSxjMTpbMTgzNi44NSwyNTk5LjM3XSxjMjpbMTI5OC4yNywxODM2Ljg1XSxjMzpbOTE4LjQzLDEyOTguMjddLGM0Ols2NDkuMTMsOTE4LjQzXSxjNTpbNDU5LjIxLDY0OS4xM10sYzY6WzMyMy4xNSw0NTkuMjFdLGM3OlsyMjkuNjEsMzIzLjE1XSxjODpbMTYxLjU3LDIyOS42MV0sYzk6WzExMy4zOSwxNjEuNTddLGMxMDpbNzkuMzcsMTEzLjM5XSxkbDpbMzExLjgxLDYyMy42Ml0sbGV0dGVyOls2MTIsNzkyXSwiZ292ZXJubWVudC1sZXR0ZXIiOls1NzYsNzU2XSxsZWdhbDpbNjEyLDEwMDhdLCJqdW5pb3ItbGVnYWwiOls1NzYsMzYwXSxsZWRnZXI6WzEyMjQsNzkyXSx0YWJsb2lkOls3OTIsMTIyNF0sImNyZWRpdC1jYXJkIjpbMTUzLDI0M119O3N3aXRjaChyKXtjYXNlInB0IjphPTE7YnJlYWs7Y2FzZSJtbSI6YT03Mi8yNS40O2JyZWFrO2Nhc2UiY20iOmE9NzIvMi41NDticmVhaztjYXNlImluIjphPTcyO2JyZWFrO2Nhc2UicHgiOmE9Ljc1O2JyZWFrO2Nhc2UicGMiOmNhc2UiZW0iOmE9MTI7YnJlYWs7Y2FzZSJleCI6YT02O2JyZWFrO2RlZmF1bHQ6dGhyb3ciSW52YWxpZCB1bml0OiAiK3J9dmFyIGMsdT0wLGw9MDtpZihzLmhhc093blByb3BlcnR5KG8pKXU9c1tvXVsxXS9hLGw9c1tvXVswXS9hO2Vsc2UgdHJ5e3U9blsxXSxsPW5bMF19Y2F0Y2godCl7dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGZvcm1hdDogIituKX1pZigicCI9PT10fHwicG9ydHJhaXQiPT09dCl0PSJwIixsPnUmJihjPWwsbD11LHU9Yyk7ZWxzZXtpZigibCIhPT10JiYibGFuZHNjYXBlIiE9PXQpdGhyb3ciSW52YWxpZCBvcmllbnRhdGlvbjogIit0O3Q9ImwiLHU+bCYmKGM9bCxsPXUsdT1jKX1yZXR1cm57d2lkdGg6bCxoZWlnaHQ6dSx1bml0OnIsazphLG9yaWVudGF0aW9uOnR9fSxuLmh0bWw9ZnVuY3Rpb24odCxlKXsoZT1lfHx7fSkuY2FsbGJhY2s9ZS5jYWxsYmFja3x8ZnVuY3Rpb24oKXt9LGUuaHRtbDJjYW52YXM9ZS5odG1sMmNhbnZhc3x8e30sZS5odG1sMmNhbnZhcy5jYW52YXM9ZS5odG1sMmNhbnZhcy5jYW52YXN8fHRoaXMuY2FudmFzLGUuanNQREY9ZS5qc1BERnx8dGhpcyxlLmZvbnRGYWNlcz1lLmZvbnRGYWNlcz9lLmZvbnRGYWNlcy5tYXAoQ3QpOm51bGw7dmFyIHI9bmV3IGMoZSk7cmV0dXJuIGUud29ya2VyP3I6ci5mcm9tKHQpLmRvQ2FsbGJhY2soKX19KE0uQVBJKSwKLyoqCiAgICogQGxpY2Vuc2UKICAgKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIENvcHlyaWdodCAoYykgMjAxMyBZb3Vzc2VmIEJlZGRhZCwgeW91c3NlZi5iZWRkYWRAZ21haWwuY29tCiAgICoKICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcKICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKICAgKiAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCiAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAogICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwogICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0bwogICAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgKgogICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlCiAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICoKICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwKICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORAogICAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUKICAgKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OCiAgICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OCiAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKi8KZnVuY3Rpb24odCl7dmFyIGUscixuO3QuYWRkSlM9ZnVuY3Rpb24odCl7cmV0dXJuIG49dCx0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInBvc3RQdXRSZXNvdXJjZXMiLChmdW5jdGlvbigpe2U9dGhpcy5pbnRlcm5hbC5uZXdPYmplY3QoKSx0aGlzLmludGVybmFsLm91dCgiPDwiKSx0aGlzLmludGVybmFsLm91dCgiL05hbWVzIFsoRW1iZWRkZWRKUykgIisoZSsxKSsiIDAgUl0iKSx0aGlzLmludGVybmFsLm91dCgiPj4iKSx0aGlzLmludGVybmFsLm91dCgiZW5kb2JqIikscj10aGlzLmludGVybmFsLm5ld09iamVjdCgpLHRoaXMuaW50ZXJuYWwub3V0KCI8PCIpLHRoaXMuaW50ZXJuYWwub3V0KCIvUyAvSmF2YVNjcmlwdCIpLHRoaXMuaW50ZXJuYWwub3V0KCIvSlMgKCIrbisiKSIpLHRoaXMuaW50ZXJuYWwub3V0KCI+PiIpLHRoaXMuaW50ZXJuYWwub3V0KCJlbmRvYmoiKX0pKSx0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInB1dENhdGFsb2ciLChmdW5jdGlvbigpe3ZvaWQgMCE9PWUmJnZvaWQgMCE9PXImJnRoaXMuaW50ZXJuYWwub3V0KCIvTmFtZXMgPDwvSmF2YVNjcmlwdCAiK2UrIiAwIFI+PiIpfSkpLHRoaXN9fShNLkFQSSksCi8qKgogICAqIEBsaWNlbnNlCiAgICogQ29weXJpZ2h0IChjKSAyMDE0IFN0ZXZlbiBTcHVuZ2luIChUd2VsdmVUb25lIExMQykgIHN0ZXZlbkB0d2VsdmV0b25lLnR2CiAgICoKICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAgICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAgICovCmZ1bmN0aW9uKHQpe3ZhciBlO3QuZXZlbnRzLnB1c2goWyJwb3N0UHV0UmVzb3VyY2VzIixmdW5jdGlvbigpe3ZhciB0PXRoaXMscj0vXihcZCspIDAgb2JqJC87aWYodGhpcy5vdXRsaW5lLnJvb3QuY2hpbGRyZW4ubGVuZ3RoPjApZm9yKHZhciBuPXQub3V0bGluZS5yZW5kZXIoKS5zcGxpdCgvXHJcbi8pLGk9MDtpPG4ubGVuZ3RoO2krKyl7dmFyIGE9bltpXSxvPXIuZXhlYyhhKTtpZihudWxsIT1vKXt2YXIgcz1vWzFdO3QuaW50ZXJuYWwubmV3T2JqZWN0RGVmZXJyZWRCZWdpbihzLCExKX10LmludGVybmFsLndyaXRlKGEpfWlmKHRoaXMub3V0bGluZS5jcmVhdGVOYW1lZERlc3RpbmF0aW9ucyl7dmFyIGM9dGhpcy5pbnRlcm5hbC5wYWdlcy5sZW5ndGgsdT1bXTtmb3IoaT0wO2k8YztpKyspe3ZhciBsPXQuaW50ZXJuYWwubmV3T2JqZWN0KCk7dS5wdXNoKGwpO3ZhciBoPXQuaW50ZXJuYWwuZ2V0UGFnZUluZm8oaSsxKTt0LmludGVybmFsLndyaXRlKCI8PCAvRFsiK2gub2JqSWQrIiAwIFIgL1hZWiBudWxsIG51bGwgbnVsbF0+PiBlbmRvYmoiKX12YXIgZj10LmludGVybmFsLm5ld09iamVjdCgpO3QuaW50ZXJuYWwud3JpdGUoIjw8IC9OYW1lcyBbICIpO2ZvcihpPTA7aTx1Lmxlbmd0aDtpKyspdC5pbnRlcm5hbC53cml0ZSgiKHBhZ2VfIisoaSsxKSsiKSIrdVtpXSsiIDAgUiIpO3QuaW50ZXJuYWwud3JpdGUoIiBdID4+IiwiZW5kb2JqIiksZT10LmludGVybmFsLm5ld09iamVjdCgpLHQuaW50ZXJuYWwud3JpdGUoIjw8IC9EZXN0cyAiK2YrIiAwIFIiKSx0LmludGVybmFsLndyaXRlKCI+PiIsImVuZG9iaiIpfX1dKSx0LmV2ZW50cy5wdXNoKFsicHV0Q2F0YWxvZyIsZnVuY3Rpb24oKXt0aGlzLm91dGxpbmUucm9vdC5jaGlsZHJlbi5sZW5ndGg+MCYmKHRoaXMuaW50ZXJuYWwud3JpdGUoIi9PdXRsaW5lcyIsdGhpcy5vdXRsaW5lLm1ha2VSZWYodGhpcy5vdXRsaW5lLnJvb3QpKSx0aGlzLm91dGxpbmUuY3JlYXRlTmFtZWREZXN0aW5hdGlvbnMmJnRoaXMuaW50ZXJuYWwud3JpdGUoIi9OYW1lcyAiK2UrIiAwIFIiKSl9XSksdC5ldmVudHMucHVzaChbImluaXRpYWxpemVkIixmdW5jdGlvbigpe3ZhciB0PXRoaXM7dC5vdXRsaW5lPXtjcmVhdGVOYW1lZERlc3RpbmF0aW9uczohMSxyb290OntjaGlsZHJlbjpbXX19LHQub3V0bGluZS5hZGQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXt0aXRsZTplLG9wdGlvbnM6cixjaGlsZHJlbjpbXX07cmV0dXJuIG51bGw9PXQmJih0PXRoaXMucm9vdCksdC5jaGlsZHJlbi5wdXNoKG4pLG59LHQub3V0bGluZS5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jdHg9e30sdGhpcy5jdHgudmFsPSIiLHRoaXMuY3R4LnBkZj10LHRoaXMuZ2VuSWRzX3IodGhpcy5yb290KSx0aGlzLnJlbmRlclJvb3QodGhpcy5yb290KSx0aGlzLnJlbmRlckl0ZW1zKHRoaXMucm9vdCksdGhpcy5jdHgudmFsfSx0Lm91dGxpbmUuZ2VuSWRzX3I9ZnVuY3Rpb24oZSl7ZS5pZD10LmludGVybmFsLm5ld09iamVjdERlZmVycmVkKCk7Zm9yKHZhciByPTA7cjxlLmNoaWxkcmVuLmxlbmd0aDtyKyspdGhpcy5nZW5JZHNfcihlLmNoaWxkcmVuW3JdKX0sdC5vdXRsaW5lLnJlbmRlclJvb3Q9ZnVuY3Rpb24odCl7dGhpcy5vYmpTdGFydCh0KSx0aGlzLmxpbmUoIi9UeXBlIC9PdXRsaW5lcyIpLHQuY2hpbGRyZW4ubGVuZ3RoPjAmJih0aGlzLmxpbmUoIi9GaXJzdCAiK3RoaXMubWFrZVJlZih0LmNoaWxkcmVuWzBdKSksdGhpcy5saW5lKCIvTGFzdCAiK3RoaXMubWFrZVJlZih0LmNoaWxkcmVuW3QuY2hpbGRyZW4ubGVuZ3RoLTFdKSkpLHRoaXMubGluZSgiL0NvdW50ICIrdGhpcy5jb3VudF9yKHtjb3VudDowfSx0KSksdGhpcy5vYmpFbmQoKX0sdC5vdXRsaW5lLnJlbmRlckl0ZW1zPWZ1bmN0aW9uKGUpe2Zvcih2YXIgcj10aGlzLmN0eC5wZGYuaW50ZXJuYWwuZ2V0VmVydGljYWxDb29yZGluYXRlU3RyaW5nLG49MDtuPGUuY2hpbGRyZW4ubGVuZ3RoO24rKyl7dmFyIGk9ZS5jaGlsZHJlbltuXTt0aGlzLm9ialN0YXJ0KGkpLHRoaXMubGluZSgiL1RpdGxlICIrdGhpcy5tYWtlU3RyaW5nKGkudGl0bGUpKSx0aGlzLmxpbmUoIi9QYXJlbnQgIit0aGlzLm1ha2VSZWYoZSkpLG4+MCYmdGhpcy5saW5lKCIvUHJldiAiK3RoaXMubWFrZVJlZihlLmNoaWxkcmVuW24tMV0pKSxuPGUuY2hpbGRyZW4ubGVuZ3RoLTEmJnRoaXMubGluZSgiL05leHQgIit0aGlzLm1ha2VSZWYoZS5jaGlsZHJlbltuKzFdKSksaS5jaGlsZHJlbi5sZW5ndGg+MCYmKHRoaXMubGluZSgiL0ZpcnN0ICIrdGhpcy5tYWtlUmVmKGkuY2hpbGRyZW5bMF0pKSx0aGlzLmxpbmUoIi9MYXN0ICIrdGhpcy5tYWtlUmVmKGkuY2hpbGRyZW5baS5jaGlsZHJlbi5sZW5ndGgtMV0pKSk7dmFyIGE9dGhpcy5jb3VudD10aGlzLmNvdW50X3Ioe2NvdW50OjB9LGkpO2lmKGE+MCYmdGhpcy5saW5lKCIvQ291bnQgIithKSxpLm9wdGlvbnMmJmkub3B0aW9ucy5wYWdlTnVtYmVyKXt2YXIgbz10LmludGVybmFsLmdldFBhZ2VJbmZvKGkub3B0aW9ucy5wYWdlTnVtYmVyKTt0aGlzLmxpbmUoIi9EZXN0IFsiK28ub2JqSWQrIiAwIFIgL1hZWiAwICIrcigwKSsiIDBdIil9dGhpcy5vYmpFbmQoKX1mb3IodmFyIHM9MDtzPGUuY2hpbGRyZW4ubGVuZ3RoO3MrKyl0aGlzLnJlbmRlckl0ZW1zKGUuY2hpbGRyZW5bc10pfSx0Lm91dGxpbmUubGluZT1mdW5jdGlvbih0KXt0aGlzLmN0eC52YWwrPXQrIlxyXG4ifSx0Lm91dGxpbmUubWFrZVJlZj1mdW5jdGlvbih0KXtyZXR1cm4gdC5pZCsiIDAgUiJ9LHQub3V0bGluZS5tYWtlU3RyaW5nPWZ1bmN0aW9uKGUpe3JldHVybiIoIit0LmludGVybmFsLnBkZkVzY2FwZShlKSsiKSJ9LHQub3V0bGluZS5vYmpTdGFydD1mdW5jdGlvbih0KXt0aGlzLmN0eC52YWwrPSJcclxuIit0LmlkKyIgMCBvYmpcclxuPDxcclxuIn0sdC5vdXRsaW5lLm9iakVuZD1mdW5jdGlvbigpe3RoaXMuY3R4LnZhbCs9Ij4+IFxyXG5lbmRvYmpcclxuIn0sdC5vdXRsaW5lLmNvdW50X3I9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9MDtyPGUuY2hpbGRyZW4ubGVuZ3RoO3IrKyl0LmNvdW50KyssdGhpcy5jb3VudF9yKHQsZS5jaGlsZHJlbltyXSk7cmV0dXJuIHQuY291bnR9fV0pfShNLkFQSSksCi8qKgogICAqIEBsaWNlbnNlCiAgICoKICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAgICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAgICovCmZ1bmN0aW9uKHQpe3ZhciBlPVsxOTIsMTkzLDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5XTt0LnByb2Nlc3NKUEVHPWZ1bmN0aW9uKHQscixuLGksYSxvKXt2YXIgcyxjPXRoaXMuZGVjb2RlLkRDVF9ERUNPREUsdT1udWxsO2lmKCJzdHJpbmciPT10eXBlb2YgdHx8dGhpcy5fX2FkZGltYWdlX18uaXNBcnJheUJ1ZmZlcih0KXx8dGhpcy5fX2FkZGltYWdlX18uaXNBcnJheUJ1ZmZlclZpZXcodCkpe3N3aXRjaCh0PWF8fHQsdD10aGlzLl9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyKHQpP25ldyBVaW50OEFycmF5KHQpOnQsKHM9ZnVuY3Rpb24odCl7Zm9yKHZhciByLG49MjU2KnQuY2hhckNvZGVBdCg0KSt0LmNoYXJDb2RlQXQoNSksaT10Lmxlbmd0aCxhPXt3aWR0aDowLGhlaWdodDowLG51bWNvbXBvbmVudHM6MX0sbz00O288aTtvKz0yKXtpZihvKz1uLC0xIT09ZS5pbmRleE9mKHQuY2hhckNvZGVBdChvKzEpKSl7cj0yNTYqdC5jaGFyQ29kZUF0KG8rNSkrdC5jaGFyQ29kZUF0KG8rNiksYT17d2lkdGg6MjU2KnQuY2hhckNvZGVBdChvKzcpK3QuY2hhckNvZGVBdChvKzgpLGhlaWdodDpyLG51bWNvbXBvbmVudHM6dC5jaGFyQ29kZUF0KG8rOSl9O2JyZWFrfW49MjU2KnQuY2hhckNvZGVBdChvKzIpK3QuY2hhckNvZGVBdChvKzMpfXJldHVybiBhfSh0PXRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3KHQpP3RoaXMuX19hZGRpbWFnZV9fLmFycmF5QnVmZmVyVG9CaW5hcnlTdHJpbmcodCk6dCkpLm51bWNvbXBvbmVudHMpe2Nhc2UgMTpvPXRoaXMuY29sb3Jfc3BhY2VzLkRFVklDRV9HUkFZO2JyZWFrO2Nhc2UgNDpvPXRoaXMuY29sb3Jfc3BhY2VzLkRFVklDRV9DTVlLO2JyZWFrO2Nhc2UgMzpvPXRoaXMuY29sb3Jfc3BhY2VzLkRFVklDRV9SR0J9dT17ZGF0YTp0LHdpZHRoOnMud2lkdGgsaGVpZ2h0OnMuaGVpZ2h0LGNvbG9yU3BhY2U6byxiaXRzUGVyQ29tcG9uZW50OjgsZmlsdGVyOmMsaW5kZXg6cixhbGlhczpufX1yZXR1cm4gdX19KE0uQVBJKTt2YXIga2UsRmUsSWUsQ2UsamUsT2U9ZnVuY3Rpb24oKXt2YXIgdCxlLG47ZnVuY3Rpb24gaSh0KXt2YXIgZSxyLG4saSxhLG8scyxjLHUsbCxoLGYsZCxwO2Zvcih0aGlzLmRhdGE9dCx0aGlzLnBvcz04LHRoaXMucGFsZXR0ZT1bXSx0aGlzLmltZ0RhdGE9W10sdGhpcy50cmFuc3BhcmVuY3k9e30sdGhpcy5hbmltYXRpb249bnVsbCx0aGlzLnRleHQ9e30sbz1udWxsOzspe3N3aXRjaChlPXRoaXMucmVhZFVJbnQzMigpLHU9ZnVuY3Rpb24oKXt2YXIgdCxlO2ZvcihlPVtdLHQ9MDt0PDQ7Kyt0KWUucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKHRoaXMuZGF0YVt0aGlzLnBvcysrXSkpO3JldHVybiBlfS5jYWxsKHRoaXMpLmpvaW4oIiIpKXtjYXNlIklIRFIiOnRoaXMud2lkdGg9dGhpcy5yZWFkVUludDMyKCksdGhpcy5oZWlnaHQ9dGhpcy5yZWFkVUludDMyKCksdGhpcy5iaXRzPXRoaXMuZGF0YVt0aGlzLnBvcysrXSx0aGlzLmNvbG9yVHlwZT10aGlzLmRhdGFbdGhpcy5wb3MrK10sdGhpcy5jb21wcmVzc2lvbk1ldGhvZD10aGlzLmRhdGFbdGhpcy5wb3MrK10sdGhpcy5maWx0ZXJNZXRob2Q9dGhpcy5kYXRhW3RoaXMucG9zKytdLHRoaXMuaW50ZXJsYWNlTWV0aG9kPXRoaXMuZGF0YVt0aGlzLnBvcysrXTticmVhaztjYXNlImFjVEwiOnRoaXMuYW5pbWF0aW9uPXtudW1GcmFtZXM6dGhpcy5yZWFkVUludDMyKCksbnVtUGxheXM6dGhpcy5yZWFkVUludDMyKCl8fDEvMCxmcmFtZXM6W119O2JyZWFrO2Nhc2UiUExURSI6dGhpcy5wYWxldHRlPXRoaXMucmVhZChlKTticmVhaztjYXNlImZjVEwiOm8mJnRoaXMuYW5pbWF0aW9uLmZyYW1lcy5wdXNoKG8pLHRoaXMucG9zKz00LG89e3dpZHRoOnRoaXMucmVhZFVJbnQzMigpLGhlaWdodDp0aGlzLnJlYWRVSW50MzIoKSx4T2Zmc2V0OnRoaXMucmVhZFVJbnQzMigpLHlPZmZzZXQ6dGhpcy5yZWFkVUludDMyKCl9LGE9dGhpcy5yZWFkVUludDE2KCksaT10aGlzLnJlYWRVSW50MTYoKXx8MTAwLG8uZGVsYXk9MWUzKmEvaSxvLmRpc3Bvc2VPcD10aGlzLmRhdGFbdGhpcy5wb3MrK10sby5ibGVuZE9wPXRoaXMuZGF0YVt0aGlzLnBvcysrXSxvLmRhdGE9W107YnJlYWs7Y2FzZSJJREFUIjpjYXNlImZkQVQiOmZvcigiZmRBVCI9PT11JiYodGhpcy5wb3MrPTQsZS09NCksdD0obnVsbCE9bz9vLmRhdGE6dm9pZCAwKXx8dGhpcy5pbWdEYXRhLGY9MDswPD1lP2Y8ZTpmPmU7MDw9ZT8rK2Y6LS1mKXQucHVzaCh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO2JyZWFrO2Nhc2UidFJOUyI6c3dpdGNoKHRoaXMudHJhbnNwYXJlbmN5PXt9LHRoaXMuY29sb3JUeXBlKXtjYXNlIDM6aWYobj10aGlzLnBhbGV0dGUubGVuZ3RoLzMsdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZD10aGlzLnJlYWQoZSksdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZC5sZW5ndGg+bil0aHJvdyBuZXcgRXJyb3IoIk1vcmUgdHJhbnNwYXJlbnQgY29sb3JzIHRoYW4gcGFsZXR0ZSBzaXplIik7aWYoKGw9bi10aGlzLnRyYW5zcGFyZW5jeS5pbmRleGVkLmxlbmd0aCk+MClmb3IoZD0wOzA8PWw/ZDxsOmQ+bDswPD1sPysrZDotLWQpdGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZC5wdXNoKDI1NSk7YnJlYWs7Y2FzZSAwOnRoaXMudHJhbnNwYXJlbmN5LmdyYXlzY2FsZT10aGlzLnJlYWQoZSlbMF07YnJlYWs7Y2FzZSAyOnRoaXMudHJhbnNwYXJlbmN5LnJnYj10aGlzLnJlYWQoZSl9YnJlYWs7Y2FzZSJ0RVh0IjpzPShoPXRoaXMucmVhZChlKSkuaW5kZXhPZigwKSxjPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGguc2xpY2UoMCxzKSksdGhpcy50ZXh0W2NdPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLGguc2xpY2UocysxKSk7YnJlYWs7Y2FzZSJJRU5EIjpyZXR1cm4gbyYmdGhpcy5hbmltYXRpb24uZnJhbWVzLnB1c2gobyksdGhpcy5jb2xvcnM9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb2xvclR5cGUpe2Nhc2UgMDpjYXNlIDM6Y2FzZSA0OnJldHVybiAxO2Nhc2UgMjpjYXNlIDY6cmV0dXJuIDN9fS5jYWxsKHRoaXMpLHRoaXMuaGFzQWxwaGFDaGFubmVsPTQ9PT0ocD10aGlzLmNvbG9yVHlwZSl8fDY9PT1wLHI9dGhpcy5jb2xvcnMrKHRoaXMuaGFzQWxwaGFDaGFubmVsPzE6MCksdGhpcy5waXhlbEJpdGxlbmd0aD10aGlzLmJpdHMqcix0aGlzLmNvbG9yU3BhY2U9ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb2xvcnMpe2Nhc2UgMTpyZXR1cm4iRGV2aWNlR3JheSI7Y2FzZSAzOnJldHVybiJEZXZpY2VSR0IifX0uY2FsbCh0aGlzKSx2b2lkKHRoaXMuaW1nRGF0YT1uZXcgVWludDhBcnJheSh0aGlzLmltZ0RhdGEpKTtkZWZhdWx0OnRoaXMucG9zKz1lfWlmKHRoaXMucG9zKz00LHRoaXMucG9zPnRoaXMuZGF0YS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCJJbmNvbXBsZXRlIG9yIGNvcnJ1cHQgUE5HIGZpbGUiKX19aS5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXt2YXIgZSxyO2ZvcihyPVtdLGU9MDswPD10P2U8dDplPnQ7MDw9dD8rK2U6LS1lKXIucHVzaCh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO3JldHVybiByfSxpLnByb3RvdHlwZS5yZWFkVUludDMyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXTw8MjR8dGhpcy5kYXRhW3RoaXMucG9zKytdPDwxNnx0aGlzLmRhdGFbdGhpcy5wb3MrK108PDh8dGhpcy5kYXRhW3RoaXMucG9zKytdfSxpLnByb3RvdHlwZS5yZWFkVUludDE2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXTw8OHx0aGlzLmRhdGFbdGhpcy5wb3MrK119LGkucHJvdG90eXBlLmRlY29kZVBpeGVscz1mdW5jdGlvbih0KXt2YXIgZT10aGlzLnBpeGVsQml0bGVuZ3RoLzgscj1uZXcgVWludDhBcnJheSh0aGlzLndpZHRoKnRoaXMuaGVpZ2h0KmUpLG49MCxpPXRoaXM7aWYobnVsbD09dCYmKHQ9dGhpcy5pbWdEYXRhKSwwPT09dC5sZW5ndGgpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2Z1bmN0aW9uIGEoYSxvLHMsYyl7dmFyIHUsbCxoLGYsZCxwLGcsbSx2LGIseSx3LE4sTCxBLHgsUyxfLFAsayxGLEk9TWF0aC5jZWlsKChpLndpZHRoLWEpL3MpLEM9TWF0aC5jZWlsKChpLmhlaWdodC1vKS9jKSxqPWkud2lkdGg9PUkmJmkuaGVpZ2h0PT1DO2ZvcihMPWUqSSx3PWo/cjpuZXcgVWludDhBcnJheShMKkMpLHA9dC5sZW5ndGgsTj0wLGw9MDtOPEMmJm48cDspe3N3aXRjaCh0W24rK10pe2Nhc2UgMDpmb3IoZj1TPTA7UzxMO2Y9Uys9MSl3W2wrK109dFtuKytdO2JyZWFrO2Nhc2UgMTpmb3IoZj1fPTA7XzxMO2Y9Xys9MSl1PXRbbisrXSxkPWY8ZT8wOndbbC1lXSx3W2wrK109KHUrZCklMjU2O2JyZWFrO2Nhc2UgMjpmb3IoZj1QPTA7UDxMO2Y9UCs9MSl1PXRbbisrXSxoPShmLWYlZSkvZSxBPU4mJndbKE4tMSkqTCtoKmUrZiVlXSx3W2wrK109KEErdSklMjU2O2JyZWFrO2Nhc2UgMzpmb3IoZj1rPTA7azxMO2Y9ays9MSl1PXRbbisrXSxoPShmLWYlZSkvZSxkPWY8ZT8wOndbbC1lXSxBPU4mJndbKE4tMSkqTCtoKmUrZiVlXSx3W2wrK109KHUrTWF0aC5mbG9vcigoZCtBKS8yKSklMjU2O2JyZWFrO2Nhc2UgNDpmb3IoZj1GPTA7RjxMO2Y9Ris9MSl1PXRbbisrXSxoPShmLWYlZSkvZSxkPWY8ZT8wOndbbC1lXSwwPT09Tj9BPXg9MDooQT13WyhOLTEpKkwraCplK2YlZV0seD1oJiZ3WyhOLTEpKkwrKGgtMSkqZStmJWVdKSxnPWQrQS14LG09TWF0aC5hYnMoZy1kKSxiPU1hdGguYWJzKGctQSkseT1NYXRoLmFicyhnLXgpLHY9bTw9YiYmbTw9eT9kOmI8PXk/QTp4LHdbbCsrXT0odSt2KSUyNTY7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgZmlsdGVyIGFsZ29yaXRobTogIit0W24tMV0pfWlmKCFqKXt2YXIgTz0oKG8rTipjKSppLndpZHRoK2EpKmUsQj1OKkw7Zm9yKGY9MDtmPEk7Zis9MSl7Zm9yKHZhciBNPTA7TTxlO00rPTEpcltPKytdPXdbQisrXTtPKz0ocy0xKSplfX1OKyt9fXJldHVybiB0PVBlKHQpLDE9PWkuaW50ZXJsYWNlTWV0aG9kPyhhKDAsMCw4LDgpLGEoNCwwLDgsOCksYSgwLDQsNCw4KSxhKDIsMCw0LDQpLGEoMCwyLDIsNCksYSgxLDAsMiwyKSxhKDAsMSwxLDIpKTphKDAsMCwxLDEpLHJ9LGkucHJvdG90eXBlLmRlY29kZVBhbGV0dGU9ZnVuY3Rpb24oKXt2YXIgdCxlLHIsbixpLGEsbyxzLGM7Zm9yKHI9dGhpcy5wYWxldHRlLGE9dGhpcy50cmFuc3BhcmVuY3kuaW5kZXhlZHx8W10saT1uZXcgVWludDhBcnJheSgoYS5sZW5ndGh8fDApK3IubGVuZ3RoKSxuPTAsdD0wLGU9bz0wLHM9ci5sZW5ndGg7bzxzO2U9bys9MylpW24rK109cltlXSxpW24rK109cltlKzFdLGlbbisrXT1yW2UrMl0saVtuKytdPW51bGwhPShjPWFbdCsrXSk/YzoyNTU7cmV0dXJuIGl9LGkucHJvdG90eXBlLmNvcHlUb0ltYWdlRGF0YT1mdW5jdGlvbih0LGUpe3ZhciByLG4saSxhLG8scyxjLHUsbCxoLGY7aWYobj10aGlzLmNvbG9ycyxsPW51bGwscj10aGlzLmhhc0FscGhhQ2hhbm5lbCx0aGlzLnBhbGV0dGUubGVuZ3RoJiYobD1udWxsIT0oZj10aGlzLl9kZWNvZGVkUGFsZXR0ZSk/Zjp0aGlzLl9kZWNvZGVkUGFsZXR0ZT10aGlzLmRlY29kZVBhbGV0dGUoKSxuPTQscj0hMCksdT0oaT10LmRhdGF8fHQpLmxlbmd0aCxvPWx8fGUsYT1zPTAsMT09PW4pZm9yKDthPHU7KWM9bD80KmVbYS80XTpzLGg9b1tjKytdLGlbYSsrXT1oLGlbYSsrXT1oLGlbYSsrXT1oLGlbYSsrXT1yP29bYysrXToyNTUscz1jO2Vsc2UgZm9yKDthPHU7KWM9bD80KmVbYS80XTpzLGlbYSsrXT1vW2MrK10saVthKytdPW9bYysrXSxpW2ErK109b1tjKytdLGlbYSsrXT1yP29bYysrXToyNTUscz1jfSxpLnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4gdD1uZXcgVWludDhBcnJheSh0aGlzLndpZHRoKnRoaXMuaGVpZ2h0KjQpLHRoaXMuY29weVRvSW1hZ2VEYXRhKHQsdGhpcy5kZWNvZGVQaXhlbHMoKSksdH07dmFyIGE9ZnVuY3Rpb24oKXtpZigiW29iamVjdCBXaW5kb3ddIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyKSl7dHJ5e2U9ci5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKSxuPWUuZ2V0Q29udGV4dCgiMmQiKX1jYXRjaCh0KXtyZXR1cm4hMX1yZXR1cm4hMH1yZXR1cm4hMX07cmV0dXJuIGEoKSx0PWZ1bmN0aW9uKHQpe3ZhciByO2lmKCEwPT09YSgpKXJldHVybiBuLndpZHRoPXQud2lkdGgsbi5oZWlnaHQ9dC5oZWlnaHQsbi5jbGVhclJlY3QoMCwwLHQud2lkdGgsdC5oZWlnaHQpLG4ucHV0SW1hZ2VEYXRhKHQsMCwwKSwocj1uZXcgSW1hZ2UpLnNyYz1lLnRvRGF0YVVSTCgpLHI7dGhyb3cgbmV3IEVycm9yKCJUaGlzIG1ldGhvZCByZXF1aXJlcyBhIEJyb3dzZXIgd2l0aCBDYW52YXMtY2FwYWJpbGl0eS4iKX0saS5wcm90b3R5cGUuZGVjb2RlRnJhbWVzPWZ1bmN0aW9uKGUpe3ZhciByLG4saSxhLG8scyxjLHU7aWYodGhpcy5hbmltYXRpb24pe2Zvcih1PVtdLG49bz0wLHM9KGM9dGhpcy5hbmltYXRpb24uZnJhbWVzKS5sZW5ndGg7bzxzO249KytvKXI9Y1tuXSxpPWUuY3JlYXRlSW1hZ2VEYXRhKHIud2lkdGgsci5oZWlnaHQpLGE9dGhpcy5kZWNvZGVQaXhlbHMobmV3IFVpbnQ4QXJyYXkoci5kYXRhKSksdGhpcy5jb3B5VG9JbWFnZURhdGEoaSxhKSxyLmltYWdlRGF0YT1pLHUucHVzaChyLmltYWdlPXQoaSkpO3JldHVybiB1fX0saS5wcm90b3R5cGUucmVuZGVyRnJhbWU9ZnVuY3Rpb24odCxlKXt2YXIgcixuLGk7cmV0dXJuIHI9KG49dGhpcy5hbmltYXRpb24uZnJhbWVzKVtlXSxpPW5bZS0xXSwwPT09ZSYmdC5jbGVhclJlY3QoMCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpLDE9PT0obnVsbCE9aT9pLmRpc3Bvc2VPcDp2b2lkIDApP3QuY2xlYXJSZWN0KGkueE9mZnNldCxpLnlPZmZzZXQsaS53aWR0aCxpLmhlaWdodCk6Mj09PShudWxsIT1pP2kuZGlzcG9zZU9wOnZvaWQgMCkmJnQucHV0SW1hZ2VEYXRhKGkuaW1hZ2VEYXRhLGkueE9mZnNldCxpLnlPZmZzZXQpLDA9PT1yLmJsZW5kT3AmJnQuY2xlYXJSZWN0KHIueE9mZnNldCxyLnlPZmZzZXQsci53aWR0aCxyLmhlaWdodCksdC5kcmF3SW1hZ2Uoci5pbWFnZSxyLnhPZmZzZXQsci55T2Zmc2V0KX0saS5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbih0KXt2YXIgZSxyLG4saSxhLG8scz10aGlzO3JldHVybiByPTAsbz10aGlzLmFuaW1hdGlvbixpPW8ubnVtRnJhbWVzLG49by5mcmFtZXMsYT1vLm51bVBsYXlzLChlPWZ1bmN0aW9uKCl7dmFyIG8sYztpZihvPXIrKyVpLGM9bltvXSxzLnJlbmRlckZyYW1lKHQsbyksaT4xJiZyL2k8YSlyZXR1cm4gcy5hbmltYXRpb24uX3RpbWVvdXQ9c2V0VGltZW91dChlLGMuZGVsYXkpfSkoKX0saS5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbj1mdW5jdGlvbigpe3ZhciB0O3JldHVybiBjbGVhclRpbWVvdXQobnVsbCE9KHQ9dGhpcy5hbmltYXRpb24pP3QuX3RpbWVvdXQ6dm9pZCAwKX0saS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKHQpe3ZhciBlLHI7cmV0dXJuIHQuX3BuZyYmdC5fcG5nLnN0b3BBbmltYXRpb24oKSx0Ll9wbmc9dGhpcyx0LndpZHRoPXRoaXMud2lkdGgsdC5oZWlnaHQ9dGhpcy5oZWlnaHQsZT10LmdldENvbnRleHQoIjJkIiksdGhpcy5hbmltYXRpb24/KHRoaXMuZGVjb2RlRnJhbWVzKGUpLHRoaXMuYW5pbWF0ZShlKSk6KHI9ZS5jcmVhdGVJbWFnZURhdGEodGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5jb3B5VG9JbWFnZURhdGEocix0aGlzLmRlY29kZVBpeGVscygpKSxlLnB1dEltYWdlRGF0YShyLDAsMCkpfSxpfSgpOwovKioKICAgKiBAbGljZW5zZQogICAqCiAgICogQ29weXJpZ2h0IChjKSAyMDE0IEphbWVzIFJvYmIsIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW1lc2Jyb2JiCiAgICoKICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcKICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKICAgKiAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCiAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAogICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwogICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0bwogICAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgKgogICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlCiAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICoKICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwKICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORAogICAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUKICAgKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OCiAgICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OCiAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKi8KLyoqCiAgICogQGxpY2Vuc2UKICAgKiAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuCiAgICoKICAgKiBodHRwczovL2dpdGh1Yi5jb20vZGVhbm0vb21nZ2lmCiAgICoKICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5CiAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJlIiksIHRvCiAgICogZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUKICAgKiByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3IKICAgKiBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcwogICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICoKICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbgogICAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgogICAqCiAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwKICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUKICAgKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCiAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcKICAgKiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTCiAgICogSU4gVEhFIFNPRlRXQVJFLgogICAqCiAgICogb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2RlciwKICAgKiBpbmNsdWRpbmcgYW5pbWF0aW9uIGFuZCBjb21wcmVzc2lvbi4gIEl0IGRvZXMgbm90IHJlbHkgb24gYW55IHNwZWNpZmljCiAgICogdW5kZXJseWluZyBzeXN0ZW0sIHNvIHNob3VsZCBydW4gaW4gdGhlIGJyb3dzZXIsIE5vZGUsIG9yIFBsYXNrLgogICAqLwpmdW5jdGlvbiBCZSh0KXt2YXIgZT0wO2lmKDcxIT09dFtlKytdfHw3MyE9PXRbZSsrXXx8NzAhPT10W2UrK118fDU2IT09dFtlKytdfHw1NiE9KHRbZSsrXSsxJjI1Myl8fDk3IT09dFtlKytdKXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBHSUYgODdhLzg5YSBoZWFkZXIuIik7dmFyIHI9dFtlKytdfHRbZSsrXTw8OCxuPXRbZSsrXXx0W2UrK108PDgsaT10W2UrK10sYT1pPj43LG89MTw8KDcmaSkrMTt0W2UrK107dFtlKytdO3ZhciBzPW51bGwsYz1udWxsO2EmJihzPWUsYz1vLGUrPTMqbyk7dmFyIHU9ITAsbD1bXSxoPTAsZj1udWxsLGQ9MCxwPW51bGw7Zm9yKHRoaXMud2lkdGg9cix0aGlzLmhlaWdodD1uO3UmJmU8dC5sZW5ndGg7KXN3aXRjaCh0W2UrK10pe2Nhc2UgMzM6c3dpdGNoKHRbZSsrXSl7Y2FzZSAyNTU6aWYoMTEhPT10W2VdfHw3OD09dFtlKzFdJiY2OT09dFtlKzJdJiY4ND09dFtlKzNdJiY4Mz09dFtlKzRdJiY2Nz09dFtlKzVdJiY2NT09dFtlKzZdJiY4MD09dFtlKzddJiY2OT09dFtlKzhdJiY1MD09dFtlKzldJiY0Nj09dFtlKzEwXSYmNDg9PXRbZSsxMV0mJjM9PXRbZSsxMl0mJjE9PXRbZSsxM10mJjA9PXRbZSsxNl0pZSs9MTQscD10W2UrK118dFtlKytdPDw4LGUrKztlbHNlIGZvcihlKz0xMjs7KXtpZighKChQPXRbZSsrXSk+PTApKXRocm93IEVycm9yKCJJbnZhbGlkIGJsb2NrIHNpemUiKTtpZigwPT09UClicmVhaztlKz1QfWJyZWFrO2Nhc2UgMjQ5OmlmKDQhPT10W2UrK118fDAhPT10W2UrNF0pdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGdyYXBoaWNzIGV4dGVuc2lvbiBibG9jay4iKTt2YXIgZz10W2UrK107aD10W2UrK118dFtlKytdPDw4LGY9dFtlKytdLDA9PSgxJmcpJiYoZj1udWxsKSxkPWc+PjImNyxlKys7YnJlYWs7Y2FzZSAyNTQ6Zm9yKDs7KXtpZighKChQPXRbZSsrXSk+PTApKXRocm93IEVycm9yKCJJbnZhbGlkIGJsb2NrIHNpemUiKTtpZigwPT09UClicmVhaztlKz1QfWJyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGdyYXBoaWMgY29udHJvbCBsYWJlbDogMHgiK3RbZS0xXS50b1N0cmluZygxNikpfWJyZWFrO2Nhc2UgNDQ6dmFyIG09dFtlKytdfHRbZSsrXTw8OCx2PXRbZSsrXXx0W2UrK108PDgsYj10W2UrK118dFtlKytdPDw4LHk9dFtlKytdfHRbZSsrXTw8OCx3PXRbZSsrXSxOPXc+PjYmMSxMPTE8PCg3JncpKzEsQT1zLHg9YyxTPSExO2lmKHc+Pjcpe1M9ITA7QT1lLHg9TCxlKz0zKkx9dmFyIF89ZTtmb3IoZSsrOzspe3ZhciBQO2lmKCEoKFA9dFtlKytdKT49MCkpdGhyb3cgRXJyb3IoIkludmFsaWQgYmxvY2sgc2l6ZSIpO2lmKDA9PT1QKWJyZWFrO2UrPVB9bC5wdXNoKHt4Om0seTp2LHdpZHRoOmIsaGVpZ2h0OnksaGFzX2xvY2FsX3BhbGV0dGU6UyxwYWxldHRlX29mZnNldDpBLHBhbGV0dGVfc2l6ZTp4LGRhdGFfb2Zmc2V0Ol8sZGF0YV9sZW5ndGg6ZS1fLHRyYW5zcGFyZW50X2luZGV4OmYsaW50ZXJsYWNlZDohIU4sZGVsYXk6aCxkaXNwb3NhbDpkfSk7YnJlYWs7Y2FzZSA1OTp1PSExO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKCJVbmtub3duIGdpZiBibG9jazogMHgiK3RbZS0xXS50b1N0cmluZygxNikpfXRoaXMubnVtRnJhbWVzPWZ1bmN0aW9uKCl7cmV0dXJuIGwubGVuZ3RofSx0aGlzLmxvb3BDb3VudD1mdW5jdGlvbigpe3JldHVybiBwfSx0aGlzLmZyYW1lSW5mbz1mdW5jdGlvbih0KXtpZih0PDB8fHQ+PWwubGVuZ3RoKXRocm93IG5ldyBFcnJvcigiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLiIpO3JldHVybiBsW3RdfSx0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkE9ZnVuY3Rpb24oZSxuKXt2YXIgaT10aGlzLmZyYW1lSW5mbyhlKSxhPWkud2lkdGgqaS5oZWlnaHQsbz1uZXcgVWludDhBcnJheShhKTtNZSh0LGkuZGF0YV9vZmZzZXQsbyxhKTt2YXIgcz1pLnBhbGV0dGVfb2Zmc2V0LGM9aS50cmFuc3BhcmVudF9pbmRleDtudWxsPT09YyYmKGM9MjU2KTt2YXIgdT1pLndpZHRoLGw9ci11LGg9dSxmPTQqKGkueSpyK2kueCksZD00KigoaS55K2kuaGVpZ2h0KSpyK2kueCkscD1mLGc9NCpsOyEwPT09aS5pbnRlcmxhY2VkJiYoZys9NCpyKjcpO2Zvcih2YXIgbT04LHY9MCxiPW8ubGVuZ3RoO3Y8YjsrK3Ype3ZhciB5PW9bdl07aWYoMD09PWgmJihoPXUsKHArPWcpPj1kJiYoZz00KmwrNCpyKihtLTEpLHA9ZisodStsKSoobTw8MSksbT4+PTEpKSx5PT09YylwKz00O2Vsc2V7dmFyIHc9dFtzKzMqeV0sTj10W3MrMyp5KzFdLEw9dFtzKzMqeSsyXTtuW3ArK109TCxuW3ArK109TixuW3ArK109dyxuW3ArK109MjU1fS0taH19LHRoaXMuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQT1mdW5jdGlvbihlLG4pe3ZhciBpPXRoaXMuZnJhbWVJbmZvKGUpLGE9aS53aWR0aCppLmhlaWdodCxvPW5ldyBVaW50OEFycmF5KGEpO01lKHQsaS5kYXRhX29mZnNldCxvLGEpO3ZhciBzPWkucGFsZXR0ZV9vZmZzZXQsYz1pLnRyYW5zcGFyZW50X2luZGV4O251bGw9PT1jJiYoYz0yNTYpO3ZhciB1PWkud2lkdGgsbD1yLXUsaD11LGY9NCooaS55KnIraS54KSxkPTQqKChpLnkraS5oZWlnaHQpKnIraS54KSxwPWYsZz00Kmw7ITA9PT1pLmludGVybGFjZWQmJihnKz00KnIqNyk7Zm9yKHZhciBtPTgsdj0wLGI9by5sZW5ndGg7djxiOysrdil7dmFyIHk9b1t2XTtpZigwPT09aCYmKGg9dSwocCs9Zyk+PWQmJihnPTQqbCs0KnIqKG0tMSkscD1mKyh1K2wpKihtPDwxKSxtPj49MSkpLHk9PT1jKXArPTQ7ZWxzZXt2YXIgdz10W3MrMyp5XSxOPXRbcyszKnkrMV0sTD10W3MrMyp5KzJdO25bcCsrXT13LG5bcCsrXT1OLG5bcCsrXT1MLG5bcCsrXT0yNTV9LS1ofX19ZnVuY3Rpb24gTWUodCxlLHIsbil7Zm9yKHZhciBhPXRbZSsrXSxvPTE8PGEscz1vKzEsYz1zKzEsdT1hKzEsbD0oMTw8dSktMSxoPTAsZj0wLGQ9MCxwPXRbZSsrXSxnPW5ldyBJbnQzMkFycmF5KDQwOTYpLG09bnVsbDs7KXtmb3IoO2g8MTYmJjAhPT1wOylmfD10W2UrK108PGgsaCs9OCwxPT09cD9wPXRbZSsrXTotLXA7aWYoaDx1KWJyZWFrO3ZhciB2PWYmbDtpZihmPj49dSxoLT11LHYhPT1vKXtpZih2PT09cylicmVhaztmb3IodmFyIGI9djxjP3Y6bSx5PTAsdz1iO3c+bzspdz1nW3ddPj44LCsreTt2YXIgTj13O2lmKGQreSsoYiE9PXY/MTowKT5uKXJldHVybiB2b2lkIGkubG9nKCJXYXJuaW5nLCBnaWYgc3RyZWFtIGxvbmdlciB0aGFuIGV4cGVjdGVkLiIpO3JbZCsrXT1OO3ZhciBMPWQrPXk7Zm9yKGIhPT12JiYocltkKytdPU4pLHc9Yjt5LS07KXc9Z1t3XSxyWy0tTF09MjU1Jncsdz4+PTg7bnVsbCE9PW0mJmM8NDA5NiYmKGdbYysrXT1tPDw4fE4sYz49bCsxJiZ1PDEyJiYoKyt1LGw9bDw8MXwxKSksbT12fWVsc2UgYz1zKzEsbD0oMTw8KHU9YSsxKSktMSxtPW51bGx9cmV0dXJuIGQhPT1uJiZpLmxvZygiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuIikscn0KLyoqCiAgICogQGxpY2Vuc2UKICAgIENvcHlyaWdodCAoYykgMjAwOCwgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQKICAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuCgogICAgUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IAogICAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZQogICAgbWV0OgoKICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCAKICAgICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci4KICAgIAogICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodAogICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIAogICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLgogICAgCiAgICAqIE5laXRoZXIgdGhlIG5hbWUgb2YgQWRvYmUgU3lzdGVtcyBJbmNvcnBvcmF0ZWQgbm9yIHRoZSBuYW1lcyBvZiBpdHMgCiAgICAgIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIAogICAgICB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLgoKICAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgIkFTCiAgICBJUyIgQU5EIEFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sCiAgICBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSCiAgICBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SIAogICAgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsCiAgICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sCiAgICBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IKICAgIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0YKICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HCiAgICBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMKICAgIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLgogICovZnVuY3Rpb24gRWUodCl7dmFyIGUscixuLGksYSxvPU1hdGguZmxvb3Iscz1uZXcgQXJyYXkoNjQpLGM9bmV3IEFycmF5KDY0KSx1PW5ldyBBcnJheSg2NCksbD1uZXcgQXJyYXkoNjQpLGg9bmV3IEFycmF5KDY1NTM1KSxmPW5ldyBBcnJheSg2NTUzNSksZD1uZXcgQXJyYXkoNjQpLHA9bmV3IEFycmF5KDY0KSxnPVtdLG09MCx2PTcsYj1uZXcgQXJyYXkoNjQpLHk9bmV3IEFycmF5KDY0KSx3PW5ldyBBcnJheSg2NCksTj1uZXcgQXJyYXkoMjU2KSxMPW5ldyBBcnJheSgyMDQ4KSxBPVswLDEsNSw2LDE0LDE1LDI3LDI4LDIsNCw3LDEzLDE2LDI2LDI5LDQyLDMsOCwxMiwxNywyNSwzMCw0MSw0Myw5LDExLDE4LDI0LDMxLDQwLDQ0LDUzLDEwLDE5LDIzLDMyLDM5LDQ1LDUyLDU0LDIwLDIyLDMzLDM4LDQ2LDUxLDU1LDYwLDIxLDM0LDM3LDQ3LDUwLDU2LDU5LDYxLDM1LDM2LDQ4LDQ5LDU3LDU4LDYyLDYzXSx4PVswLDAsMSw1LDEsMSwxLDEsMSwxLDAsMCwwLDAsMCwwLDBdLFM9WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTFdLF89WzAsMCwyLDEsMywzLDIsNCwzLDUsNSw0LDQsMCwwLDEsMTI1XSxQPVsxLDIsMywwLDQsMTcsNSwxOCwzMyw0OSw2NSw2LDE5LDgxLDk3LDcsMzQsMTEzLDIwLDUwLDEyOSwxNDUsMTYxLDgsMzUsNjYsMTc3LDE5MywyMSw4MiwyMDksMjQwLDM2LDUxLDk4LDExNCwxMzAsOSwxMCwyMiwyMywyNCwyNSwyNiwzNywzOCwzOSw0MCw0MSw0Miw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMzEsMTMyLDEzMywxMzQsMTM1LDEzNiwxMzcsMTM4LDE0NiwxNDcsMTQ4LDE0OSwxNTAsMTUxLDE1MiwxNTMsMTU0LDE2MiwxNjMsMTY0LDE2NSwxNjYsMTY3LDE2OCwxNjksMTcwLDE3OCwxNzksMTgwLDE4MSwxODIsMTgzLDE4NCwxODUsMTg2LDE5NCwxOTUsMTk2LDE5NywxOTgsMTk5LDIwMCwyMDEsMjAyLDIxMCwyMTEsMjEyLDIxMywyMTQsMjE1LDIxNiwyMTcsMjE4LDIyNSwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyNDEsMjQyLDI0MywyNDQsMjQ1LDI0NiwyNDcsMjQ4LDI0OSwyNTBdLGs9WzAsMCwzLDEsMSwxLDEsMSwxLDEsMSwxLDAsMCwwLDAsMF0sRj1bMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMV0sST1bMCwwLDIsMSwyLDQsNCwzLDQsNyw1LDQsNCwwLDEsMiwxMTldLEM9WzAsMSwyLDMsMTcsNCw1LDMzLDQ5LDYsMTgsNjUsODEsNyw5NywxMTMsMTksMzQsNTAsMTI5LDgsMjAsNjYsMTQ1LDE2MSwxNzcsMTkzLDksMzUsNTEsODIsMjQwLDIxLDk4LDExNCwyMDksMTAsMjIsMzYsNTIsMjI1LDM3LDI0MSwyMywyNCwyNSwyNiwzOCwzOSw0MCw0MSw0Miw1Myw1NCw1NSw1Niw1Nyw1OCw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwxMzAsMTMxLDEzMiwxMzMsMTM0LDEzNSwxMzYsMTM3LDEzOCwxNDYsMTQ3LDE0OCwxNDksMTUwLDE1MSwxNTIsMTUzLDE1NCwxNjIsMTYzLDE2NCwxNjUsMTY2LDE2NywxNjgsMTY5LDE3MCwxNzgsMTc5LDE4MCwxODEsMTgyLDE4MywxODQsMTg1LDE4NiwxOTQsMTk1LDE5NiwxOTcsMTk4LDE5OSwyMDAsMjAxLDIwMiwyMTAsMjExLDIxMiwyMTMsMjE0LDIxNSwyMTYsMjE3LDIxOCwyMjYsMjI3LDIyOCwyMjksMjMwLDIzMSwyMzIsMjMzLDIzNCwyNDIsMjQzLDI0NCwyNDUsMjQ2LDI0NywyNDgsMjQ5LDI1MF07ZnVuY3Rpb24gaih0LGUpe2Zvcih2YXIgcj0wLG49MCxpPW5ldyBBcnJheSxhPTE7YTw9MTY7YSsrKXtmb3IodmFyIG89MTtvPD10W2FdO28rKylpW2Vbbl1dPVtdLGlbZVtuXV1bMF09cixpW2Vbbl1dWzFdPWEsbisrLHIrKztyKj0yfXJldHVybiBpfWZ1bmN0aW9uIE8odCl7Zm9yKHZhciBlPXRbMF0scj10WzFdLTE7cj49MDspZSYxPDxyJiYobXw9MTw8diksci0tLC0tdjwwJiYoMjU1PT1tPyhCKDI1NSksQigwKSk6QihtKSx2PTcsbT0wKX1mdW5jdGlvbiBCKHQpe2cucHVzaCh0KX1mdW5jdGlvbiBNKHQpe0IodD4+OCYyNTUpLEIoMjU1JnQpfWZ1bmN0aW9uIEUodCxlLHIsbixpKXtmb3IodmFyIGEsbz1pWzBdLHM9aVsyNDBdLGM9ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksYSxvLHMsYyx1LGwsaCxmPTA7Zm9yKGw9MDtsPDg7KytsKXtyPXRbZl0sbj10W2YrMV0saT10W2YrMl0sYT10W2YrM10sbz10W2YrNF0scz10W2YrNV0sYz10W2YrNl07dmFyIHA9cisodT10W2YrN10pLGc9ci11LG09bitjLHY9bi1jLGI9aStzLHk9aS1zLHc9YStvLE49YS1vLEw9cCt3LEE9cC13LHg9bStiLFM9bS1iO3RbZl09TCt4LHRbZis0XT1MLXg7dmFyIF89LjcwNzEwNjc4MSooUytBKTt0W2YrMl09QStfLHRbZis2XT1BLV87dmFyIFA9LjM4MjY4MzQzMyooKEw9Tit5KS0oUz12K2cpKSxrPS41NDExOTYxKkwrUCxGPTEuMzA2NTYyOTY1KlMrUCxJPS43MDcxMDY3ODEqKHg9eSt2KSxDPWcrSSxqPWctSTt0W2YrNV09aitrLHRbZiszXT1qLWssdFtmKzFdPUMrRix0W2YrN109Qy1GLGYrPTh9Zm9yKGY9MCxsPTA7bDw4OysrbCl7cj10W2ZdLG49dFtmKzhdLGk9dFtmKzE2XSxhPXRbZisyNF0sbz10W2YrMzJdLHM9dFtmKzQwXSxjPXRbZis0OF07dmFyIE89cisodT10W2YrNTZdKSxCPXItdSxNPW4rYyxFPW4tYyxxPWkrcyxEPWktcyxSPWErbyxUPWEtbyxVPU8rUix6PU8tUixIPU0rcSxXPU0tcTt0W2ZdPVUrSCx0W2YrMzJdPVUtSDt2YXIgVj0uNzA3MTA2NzgxKihXK3opO3RbZisxNl09eitWLHRbZis0OF09ei1WO3ZhciBHPS4zODI2ODM0MzMqKChVPVQrRCktKFc9RStCKSksWT0uNTQxMTk2MSpVK0csSj0xLjMwNjU2Mjk2NSpXK0csWD0uNzA3MTA2NzgxKihIPUQrRSksSz1CK1gsWj1CLVg7dFtmKzQwXT1aK1ksdFtmKzI0XT1aLVksdFtmKzhdPUsrSix0W2YrNTZdPUstSixmKyt9Zm9yKGw9MDtsPDY0OysrbCloPXRbbF0qZVtsXSxkW2xdPWg+MD9oKy41fDA6aC0uNXwwO3JldHVybiBkfSh0LGUpLHU9MDt1PDY0OysrdSlwW0FbdV1dPWNbdV07dmFyIGw9cFswXS1yO3I9cFswXSwwPT1sP08oblswXSk6KE8obltmW2E9MzI3NjcrbF1dKSxPKGhbYV0pKTtmb3IodmFyIGc9NjM7Zz4wJiYwPT1wW2ddOylnLS07aWYoMD09ZylyZXR1cm4gTyhvKSxyO2Zvcih2YXIgbSx2PTE7djw9Zzspe2Zvcih2YXIgYj12OzA9PXBbdl0mJnY8PWc7KSsrdjt2YXIgeT12LWI7aWYoeT49MTYpe209eT4+NDtmb3IodmFyIHc9MTt3PD1tOysrdylPKHMpO3kmPTE1fWE9MzI3NjcrcFt2XSxPKGlbKHk8PDQpK2ZbYV1dKSxPKGhbYV0pLHYrK31yZXR1cm4gNjMhPWcmJk8obykscn1mdW5jdGlvbiBxKHQpeyh0PU1hdGgubWluKE1hdGgubWF4KHQsMSksMTAwKSxhIT10KSYmKCFmdW5jdGlvbih0KXtmb3IodmFyIGU9WzE2LDExLDEwLDE2LDI0LDQwLDUxLDYxLDEyLDEyLDE0LDE5LDI2LDU4LDYwLDU1LDE0LDEzLDE2LDI0LDQwLDU3LDY5LDU2LDE0LDE3LDIyLDI5LDUxLDg3LDgwLDYyLDE4LDIyLDM3LDU2LDY4LDEwOSwxMDMsNzcsMjQsMzUsNTUsNjQsODEsMTA0LDExMyw5Miw0OSw2NCw3OCw4NywxMDMsMTIxLDEyMCwxMDEsNzIsOTIsOTUsOTgsMTEyLDEwMCwxMDMsOTldLHI9MDtyPDY0O3IrKyl7dmFyIG49bygoZVtyXSp0KzUwKS8xMDApO249TWF0aC5taW4oTWF0aC5tYXgobiwxKSwyNTUpLHNbQVtyXV09bn1mb3IodmFyIGk9WzE3LDE4LDI0LDQ3LDk5LDk5LDk5LDk5LDE4LDIxLDI2LDY2LDk5LDk5LDk5LDk5LDI0LDI2LDU2LDk5LDk5LDk5LDk5LDk5LDQ3LDY2LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5LDk5XSxhPTA7YTw2NDthKyspe3ZhciBoPW8oKGlbYV0qdCs1MCkvMTAwKTtoPU1hdGgubWluKE1hdGgubWF4KGgsMSksMjU1KSxjW0FbYV1dPWh9Zm9yKHZhciBmPVsxLDEuMzg3MDM5ODQ1LDEuMzA2NTYyOTY1LDEuMTc1ODc1NjAyLDEsLjc4NTY5NDk1OCwuNTQxMTk2MSwuMjc1ODk5Mzc5XSxkPTAscD0wO3A8ODtwKyspZm9yKHZhciBnPTA7Zzw4O2crKyl1W2RdPTEvKHNbQVtkXV0qZltwXSpmW2ddKjgpLGxbZF09MS8oY1tBW2RdXSpmW3BdKmZbZ10qOCksZCsrfSh0PDUwP01hdGguZmxvb3IoNWUzL3QpOk1hdGguZmxvb3IoMjAwLTIqdCkpLGE9dCl9dGhpcy5lbmNvZGU9ZnVuY3Rpb24odCxhKXthJiZxKGEpLGc9bmV3IEFycmF5LG09MCx2PTcsTSg2NTQ5NiksTSg2NTUwNCksTSgxNiksQig3NCksQig3MCksQig3MyksQig3MCksQigwKSxCKDEpLEIoMSksQigwKSxNKDEpLE0oMSksQigwKSxCKDApLGZ1bmN0aW9uKCl7TSg2NTQ5OSksTSgxMzIpLEIoMCk7Zm9yKHZhciB0PTA7dDw2NDt0KyspQihzW3RdKTtCKDEpO2Zvcih2YXIgZT0wO2U8NjQ7ZSsrKUIoY1tlXSl9KCksZnVuY3Rpb24odCxlKXtNKDY1NDcyKSxNKDE3KSxCKDgpLE0oZSksTSh0KSxCKDMpLEIoMSksQigxNyksQigwKSxCKDIpLEIoMTcpLEIoMSksQigzKSxCKDE3KSxCKDEpfSh0LndpZHRoLHQuaGVpZ2h0KSxmdW5jdGlvbigpe00oNjU0NzYpLE0oNDE4KSxCKDApO2Zvcih2YXIgdD0wO3Q8MTY7dCsrKUIoeFt0KzFdKTtmb3IodmFyIGU9MDtlPD0xMTtlKyspQihTW2VdKTtCKDE2KTtmb3IodmFyIHI9MDtyPDE2O3IrKylCKF9bcisxXSk7Zm9yKHZhciBuPTA7bjw9MTYxO24rKylCKFBbbl0pO0IoMSk7Zm9yKHZhciBpPTA7aTwxNjtpKyspQihrW2krMV0pO2Zvcih2YXIgYT0wO2E8PTExO2ErKylCKEZbYV0pO0IoMTcpO2Zvcih2YXIgbz0wO288MTY7bysrKUIoSVtvKzFdKTtmb3IodmFyIHM9MDtzPD0xNjE7cysrKUIoQ1tzXSl9KCksTSg2NTQ5OCksTSgxMiksQigzKSxCKDEpLEIoMCksQigyKSxCKDE3KSxCKDMpLEIoMTcpLEIoMCksQig2MyksQigwKTt2YXIgbz0wLGg9MCxmPTA7bT0wLHY9Nyx0aGlzLmVuY29kZS5kaXNwbGF5TmFtZT0iX2VuY29kZV8iO2Zvcih2YXIgZCxwLE4sQSxqLEQsUixULFUsej10LmRhdGEsSD10LndpZHRoLFc9dC5oZWlnaHQsVj00KkgsRz0wO0c8Vzspe2ZvcihkPTA7ZDxWOyl7Zm9yKGo9VipHK2QsUj0tMSxUPTAsVT0wO1U8NjQ7VSsrKUQ9aisoVD1VPj4zKSpWKyhSPTQqKDcmVSkpLEcrVD49VyYmKEQtPVYqKEcrMStULVcpKSxkK1I+PVYmJihELT1kK1ItVis0KSxwPXpbRCsrXSxOPXpbRCsrXSxBPXpbRCsrXSxiW1VdPShMW3BdK0xbTisyNTY+PjBdK0xbQSs1MTI+PjBdPj4xNiktMTI4LHlbVV09KExbcCs3Njg+PjBdK0xbTisxMDI0Pj4wXStMW0ErMTI4MD4+MF0+PjE2KS0xMjgsd1tVXT0oTFtwKzEyODA+PjBdK0xbTisxNTM2Pj4wXStMW0ErMTc5Mj4+MF0+PjE2KS0xMjg7bz1FKGIsdSxvLGUsbiksaD1FKHksbCxoLHIsaSksZj1FKHcsbCxmLHIsaSksZCs9MzJ9Rys9OH1pZih2Pj0wKXt2YXIgWT1bXTtZWzFdPXYrMSxZWzBdPSgxPDx2KzEpLTEsTyhZKX1yZXR1cm4gTSg2NTQ5NyksbmV3IFVpbnQ4QXJyYXkoZyl9LHQ9dHx8NTAsZnVuY3Rpb24oKXtmb3IodmFyIHQ9U3RyaW5nLmZyb21DaGFyQ29kZSxlPTA7ZTwyNTY7ZSsrKU5bZV09dChlKX0oKSxlPWooeCxTKSxyPWooayxGKSxuPWooXyxQKSxpPWooSSxDKSxmdW5jdGlvbigpe2Zvcih2YXIgdD0xLGU9MixyPTE7cjw9MTU7cisrKXtmb3IodmFyIG49dDtuPGU7bisrKWZbMzI3Njcrbl09cixoWzMyNzY3K25dPVtdLGhbMzI3Njcrbl1bMV09cixoWzMyNzY3K25dWzBdPW47Zm9yKHZhciBpPS0oZS0xKTtpPD0tdDtpKyspZlszMjc2NytpXT1yLGhbMzI3NjcraV09W10saFszMjc2NytpXVsxXT1yLGhbMzI3NjcraV1bMF09ZS0xK2k7dDw8PTEsZTw8PTF9fSgpLGZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDwyNTY7dCsrKUxbdF09MTk1OTUqdCxMW3QrMjU2Pj4wXT0zODQ3MCp0LExbdCs1MTI+PjBdPTc0NzEqdCszMjc2OCxMW3QrNzY4Pj4wXT0tMTEwNTkqdCxMW3QrMTAyND4+MF09LTIxNzA5KnQsTFt0KzEyODA+PjBdPTMyNzY4KnQrODQyMTM3NSxMW3QrMTUzNj4+MF09LTI3NDM5KnQsTFt0KzE3OTI+PjBdPS01MzI5KnR9KCkscSh0KX0KLyoqCiAgICogQGxpY2Vuc2UKICAgKiBDb3B5cmlnaHQgKGMpIDIwMTcgQXJhcyBBYmJhc2kKICAgKgogICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4KICAgKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UKICAgKi9mdW5jdGlvbiBxZSh0LGUpe2lmKHRoaXMucG9zPTAsdGhpcy5idWZmZXI9dCx0aGlzLmRhdGF2PW5ldyBEYXRhVmlldyh0LmJ1ZmZlciksdGhpcy5pc193aXRoX2FscGhhPSEhZSx0aGlzLmJvdHRvbV91cD0hMCx0aGlzLmZsYWc9U3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmJ1ZmZlclswXSkrU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmJ1ZmZlclsxXSksdGhpcy5wb3MrPTIsLTE9PT1bIkJNIiwiQkEiLCJDSSIsIkNQIiwiSUMiLCJQVCJdLmluZGV4T2YodGhpcy5mbGFnKSl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgQk1QIEZpbGUiKTt0aGlzLnBhcnNlSGVhZGVyKCksdGhpcy5wYXJzZUJHUigpfWZ1bmN0aW9uIERlKHQpe2Z1bmN0aW9uIGUodCl7aWYoIXQpdGhyb3cgRXJyb3IoImFzc2VydCA6UCIpfWZ1bmN0aW9uIHIodCxlLHIpe2Zvcih2YXIgbj0wOzQ+bjtuKyspaWYodFtlK25dIT1yLmNoYXJDb2RlQXQobikpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gbih0LGUscixuLGkpe2Zvcih2YXIgYT0wO2E8aTthKyspdFtlK2FdPXJbbithXX1mdW5jdGlvbiBpKHQsZSxyLG4pe2Zvcih2YXIgaT0wO2k8bjtpKyspdFtlK2ldPXJ9ZnVuY3Rpb24gYSh0KXtyZXR1cm4gbmV3IEludDMyQXJyYXkodCl9ZnVuY3Rpb24gbyh0LGUpe2Zvcih2YXIgcj1bXSxuPTA7bjx0O24rKylyLnB1c2gobmV3IGUpO3JldHVybiByfWZ1bmN0aW9uIHModCxlKXt2YXIgcj1bXTtyZXR1cm4gZnVuY3Rpb24gdChyLG4saSl7Zm9yKHZhciBhPWlbbl0sbz0wO288YSYmKHIucHVzaChpLmxlbmd0aD5uKzE/W106bmV3IGUpLCEoaS5sZW5ndGg8bisxKSk7bysrKXQocltvXSxuKzEsaSl9KHIsMCx0KSxyfXZhciBjPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcztmdW5jdGlvbiBjKHQsZSl7Zm9yKHZhciByPTE8PGUtMT4+PjA7dCZyOylyPj4+PTE7cmV0dXJuIHI/KHQmci0xKStyOnR9ZnVuY3Rpb24gdSh0LHIsbixpLGEpe2UoIShpJW4pKTtkb3t0W3IrKGktPW4pXT1hfXdoaWxlKDA8aSl9ZnVuY3Rpb24gbCh0LHIsbixpLG8pe2lmKGUoMjMyOD49byksNTEyPj1vKXZhciBzPWEoNTEyKTtlbHNlIGlmKG51bGw9PShzPWEobykpKXJldHVybiAwO3JldHVybiBmdW5jdGlvbih0LHIsbixpLG8scyl7dmFyIGwsZixkPXIscD0xPDxuLGc9YSgxNiksbT1hKDE2KTtmb3IoZSgwIT1vKSxlKG51bGwhPWkpLGUobnVsbCE9dCksZSgwPG4pLGY9MDtmPG87KytmKXtpZigxNTxpW2ZdKXJldHVybiAwOysrZ1tpW2ZdXX1pZihnWzBdPT1vKXJldHVybiAwO2ZvcihtWzFdPTAsbD0xOzE1Pmw7KytsKXtpZihnW2xdPjE8PGwpcmV0dXJuIDA7bVtsKzFdPW1bbF0rZ1tsXX1mb3IoZj0wO2Y8bzsrK2YpbD1pW2ZdLDA8aVtmXSYmKHNbbVtsXSsrXT1mKTtpZigxPT1tWzE1XSlyZXR1cm4oaT1uZXcgaCkuZz0wLGkudmFsdWU9c1swXSx1KHQsZCwxLHAsaSkscDt2YXIgdixiPS0xLHk9cC0xLHc9MCxOPTEsTD0xLEE9MTw8bjtmb3IoZj0wLGw9MSxvPTI7bDw9bjsrK2wsbzw8PTEpe2lmKE4rPUw8PD0xLDA+KEwtPWdbbF0pKXJldHVybiAwO2Zvcig7MDxnW2xdOy0tZ1tsXSkoaT1uZXcgaCkuZz1sLGkudmFsdWU9c1tmKytdLHUodCxkK3csbyxBLGkpLHc9Yyh3LGwpfWZvcihsPW4rMSxvPTI7MTU+PWw7KytsLG88PD0xKXtpZihOKz1MPDw9MSwwPihMLT1nW2xdKSlyZXR1cm4gMDtmb3IoOzA8Z1tsXTstLWdbbF0pe2lmKGk9bmV3IGgsKHcmeSkhPWIpe2ZvcihkKz1BLHY9MTw8KGI9bCktbjsxNT5iJiYhKDA+PSh2LT1nW2JdKSk7KSsrYix2PDw9MTtwKz1BPTE8PCh2PWItbiksdFtyKyhiPXcmeSldLmc9dituLHRbcitiXS52YWx1ZT1kLXItYn1pLmc9bC1uLGkudmFsdWU9c1tmKytdLHUodCxkKyh3Pj5uKSxvLEEsaSksdz1jKHcsbCl9fXJldHVybiBOIT0yKm1bMTVdLTE/MDpwfSh0LHIsbixpLG8scyl9ZnVuY3Rpb24gaCgpe3RoaXMudmFsdWU9dGhpcy5nPTB9ZnVuY3Rpb24gZigpe3RoaXMudmFsdWU9dGhpcy5nPTB9ZnVuY3Rpb24gZCgpe3RoaXMuRz1vKDUsaCksdGhpcy5IPWEoNSksdGhpcy5qYz10aGlzLlFiPXRoaXMucWI9dGhpcy5uZD0wLHRoaXMucGQ9byhEcixmKX1mdW5jdGlvbiBwKHQscixuLGkpe2UobnVsbCE9dCksZShudWxsIT1yKSxlKDIxNDc0ODM2NDg+aSksdC5DYT0yNTQsdC5JPTAsdC5iPS04LHQuS2E9MCx0Lm9hPXIsdC5wYT1uLHQuSmQ9cix0LlljPW4raSx0LlpjPTQ8PWk/bitpLTQrMTpuLF8odCl9ZnVuY3Rpb24gZyh0LGUpe2Zvcih2YXIgcj0wOzA8ZS0tOylyfD1rKHQsMTI4KTw8ZTtyZXR1cm4gcn1mdW5jdGlvbiBtKHQsZSl7dmFyIHI9Zyh0LGUpO3JldHVybiBQKHQpPy1yOnJ9ZnVuY3Rpb24gdih0LHIsbixpKXt2YXIgYSxvPTA7Zm9yKGUobnVsbCE9dCksZShudWxsIT1yKSxlKDQyOTQ5NjcyODg+aSksdC5TYj1pLHQuUmE9MCx0LnU9MCx0Lmg9MCw0PGkmJihpPTQpLGE9MDthPGk7KythKW8rPXJbbithXTw8OCphO3QuUmE9byx0LmJiPWksdC5vYT1yLHQucGE9bn1mdW5jdGlvbiBiKHQpe2Zvcig7ODw9dC51JiZ0LmJiPHQuU2I7KXQuUmE+Pj49OCx0LlJhKz10Lm9hW3QucGErdC5iYl08PFVyLTg+Pj4wLCsrdC5iYix0LnUtPTg7QSh0KSYmKHQuaD0xLHQudT0wKX1mdW5jdGlvbiB5KHQscil7aWYoZSgwPD1yKSwhdC5oJiZyPD1Ucil7dmFyIG49TCh0KSZScltyXTtyZXR1cm4gdC51Kz1yLGIodCksbn1yZXR1cm4gdC5oPTEsdC51PTB9ZnVuY3Rpb24gdygpe3RoaXMuYj10aGlzLkNhPXRoaXMuST0wLHRoaXMub2E9W10sdGhpcy5wYT0wLHRoaXMuSmQ9W10sdGhpcy5ZYz0wLHRoaXMuWmM9W10sdGhpcy5LYT0wfWZ1bmN0aW9uIE4oKXt0aGlzLlJhPTAsdGhpcy5vYT1bXSx0aGlzLmg9dGhpcy51PXRoaXMuYmI9dGhpcy5TYj10aGlzLnBhPTB9ZnVuY3Rpb24gTCh0KXtyZXR1cm4gdC5SYT4+Pih0LnUmVXItMSk+Pj4wfWZ1bmN0aW9uIEEodCl7cmV0dXJuIGUodC5iYjw9dC5TYiksdC5ofHx0LmJiPT10LlNiJiZ0LnU+VXJ9ZnVuY3Rpb24geCh0LGUpe3QudT1lLHQuaD1BKHQpfWZ1bmN0aW9uIFModCl7dC51Pj16ciYmKGUodC51Pj16ciksYih0KSl9ZnVuY3Rpb24gXyh0KXtlKG51bGwhPXQmJm51bGwhPXQub2EpLHQucGE8dC5aYz8odC5JPSh0Lm9hW3QucGErK118dC5JPDw4KT4+PjAsdC5iKz04KTooZShudWxsIT10JiZudWxsIT10Lm9hKSx0LnBhPHQuWWM/KHQuYis9OCx0Lkk9dC5vYVt0LnBhKytdfHQuSTw8OCk6dC5LYT90LmI9MDoodC5JPDw9OCx0LmIrPTgsdC5LYT0xKSl9ZnVuY3Rpb24gUCh0KXtyZXR1cm4gZyh0LDEpfWZ1bmN0aW9uIGsodCxlKXt2YXIgcj10LkNhOzA+dC5iJiZfKHQpO3ZhciBuPXQuYixpPXIqZT4+PjgsYT0odC5JPj4+bj5pKSswO2ZvcihhPyhyLT1pLHQuSS09aSsxPDxuPj4+MCk6cj1pKzEsbj1yLGk9MDsyNTY8PW47KWkrPTgsbj4+PTg7cmV0dXJuIG49N15pK0hyW25dLHQuYi09bix0LkNhPShyPDxuKS0xLGF9ZnVuY3Rpb24gRih0LGUscil7dFtlKzBdPXI+PjI0JjI1NSx0W2UrMV09cj4+MTYmMjU1LHRbZSsyXT1yPj44JjI1NSx0W2UrM109cj4+MCYyNTV9ZnVuY3Rpb24gSSh0LGUpe3JldHVybiB0W2UrMF08PDB8dFtlKzFdPDw4fWZ1bmN0aW9uIEModCxlKXtyZXR1cm4gSSh0LGUpfHRbZSsyXTw8MTZ9ZnVuY3Rpb24gaih0LGUpe3JldHVybiBJKHQsZSl8SSh0LGUrMik8PDE2fWZ1bmN0aW9uIE8odCxyKXt2YXIgbj0xPDxyO3JldHVybiBlKG51bGwhPXQpLGUoMDxyKSx0Llg9YShuKSxudWxsPT10Llg/MDoodC5NYj0zMi1yLHQuWGE9ciwxKX1mdW5jdGlvbiBCKHQscil7ZShudWxsIT10KSxlKG51bGwhPXIpLGUodC5YYT09ci5YYSksbihyLlgsMCx0LlgsMCwxPDxyLlhhKX1mdW5jdGlvbiBNKCl7dGhpcy5YPVtdLHRoaXMuWGE9dGhpcy5NYj0wfWZ1bmN0aW9uIEUodCxyLG4saSl7ZShudWxsIT1uKSxlKG51bGwhPWkpO3ZhciBhPW5bMF0sbz1pWzBdO3JldHVybiAwPT1hJiYoYT0odCpvK3IvMikvciksMD09byYmKG89KHIqYSt0LzIpL3QpLDA+PWF8fDA+PW8/MDooblswXT1hLGlbMF09bywxKX1mdW5jdGlvbiBxKHQsZSl7cmV0dXJuIHQrKDE8PGUpLTE+Pj5lfWZ1bmN0aW9uIEQodCxlKXtyZXR1cm4oKDQyNzgyNTUzNjAmdCkrKDQyNzgyNTUzNjAmZSk+Pj4wJjQyNzgyNTUzNjApKygoMTY3MTE5MzUmdCkrKDE2NzExOTM1JmUpPj4+MCYxNjcxMTkzNSk+Pj4wfWZ1bmN0aW9uIFIoZSxyKXt0W3JdPWZ1bmN0aW9uKHIsbixpLGEsbyxzLGMpe3ZhciB1O2Zvcih1PTA7dTxvOysrdSl7dmFyIGw9dFtlXShzW2MrdS0xXSxpLGErdSk7c1tjK3VdPUQocltuK3VdLGwpfX19ZnVuY3Rpb24gVCgpe3RoaXMudWQ9dGhpcy5oZD10aGlzLmpkPTB9ZnVuY3Rpb24gVSh0LGUpe3JldHVybigoNDI3ODEyNDI4NiYodF5lKSk+Pj4xKSsodCZlKT4+PjB9ZnVuY3Rpb24geih0KXtyZXR1cm4gMDw9dCYmMjU2PnQ/dDowPnQ/MDoyNTU8dD8yNTU6dm9pZCAwfWZ1bmN0aW9uIEgodCxlKXtyZXR1cm4geih0Kyh0LWUrLjU+PjEpKX1mdW5jdGlvbiBXKHQsZSxyKXtyZXR1cm4gTWF0aC5hYnMoZS1yKS1NYXRoLmFicyh0LXIpfWZ1bmN0aW9uIFYodCxlLHIsbixpLGEsbyl7Zm9yKG49YVtvLTFdLHI9MDtyPGk7KytyKWFbbytyXT1uPUQodFtlK3JdLG4pfWZ1bmN0aW9uIEcodCxlLHIsbixpKXt2YXIgYTtmb3IoYT0wO2E8cjsrK2Epe3ZhciBvPXRbZSthXSxzPW8+PjgmMjU1LGM9MTY3MTE5MzUmKGM9KGM9MTY3MTE5MzUmbykrKChzPDwxNikrcykpO25baSthXT0oNDI3ODI1NTM2MCZvKStjPj4+MH19ZnVuY3Rpb24gWSh0LGUpe2UuamQ9dD4+MCYyNTUsZS5oZD10Pj44JjI1NSxlLnVkPXQ+PjE2JjI1NX1mdW5jdGlvbiBKKHQsZSxyLG4saSxhKXt2YXIgbztmb3Iobz0wO288bjsrK28pe3ZhciBzPWVbcitvXSxjPXM+Pj44LHU9cyxsPTI1NSYobD0obD1zPj4+MTYpKygodC5qZDw8MjQ+PjI0KSooYzw8MjQ+PjI0KT4+PjUpKTt1PTI1NSYodT0odT11KygodC5oZDw8MjQ+PjI0KSooYzw8MjQ+PjI0KT4+PjUpKSsoKHQudWQ8PDI0Pj4yNCkqKGw8PDI0Pj4yNCk+Pj41KSk7aVthK29dPSg0Mjc4MjU1MzYwJnMpKyhsPDwxNikrdX19ZnVuY3Rpb24gWChlLHIsbixpLGEpe3Rbcl09ZnVuY3Rpb24odCxlLHIsbixvLHMsYyx1LGwpe2ZvcihuPWM7bjx1Oysrbilmb3IoYz0wO2M8bDsrK2Mpb1tzKytdPWEocltpKHRbZSsrXSldKX0sdFtlXT1mdW5jdGlvbihlLHIsbyxzLGMsdSxsKXt2YXIgaD04Pj5lLmIsZj1lLkVhLGQ9ZS5LWzBdLHA9ZS53O2lmKDg+aClmb3IoZT0oMTw8ZS5iKS0xLHA9KDE8PGgpLTE7cjxvOysrcil7dmFyIGcsbT0wO2ZvcihnPTA7ZzxmOysrZylnJmV8fChtPWkoc1tjKytdKSksdVtsKytdPWEoZFttJnBdKSxtPj49aH1lbHNlIHRbIlZQOExNYXBDb2xvciIrbl0ocyxjLGQscCx1LGwscixvLGYpfX1mdW5jdGlvbiBLKHQsZSxyLG4saSl7Zm9yKHI9ZStyO2U8cjspe3ZhciBhPXRbZSsrXTtuW2krK109YT4+MTYmMjU1LG5baSsrXT1hPj44JjI1NSxuW2krK109YT4+MCYyNTV9fWZ1bmN0aW9uIFoodCxlLHIsbixpKXtmb3Iocj1lK3I7ZTxyOyl7dmFyIGE9dFtlKytdO25baSsrXT1hPj4xNiYyNTUsbltpKytdPWE+PjgmMjU1LG5baSsrXT1hPj4wJjI1NSxuW2krK109YT4+MjQmMjU1fX1mdW5jdGlvbiAkKHQsZSxyLG4saSl7Zm9yKHI9ZStyO2U8cjspe3ZhciBhPShvPXRbZSsrXSk+PjE2JjI0MHxvPj4xMiYxNSxvPW8+PjAmMjQwfG8+PjI4JjE1O25baSsrXT1hLG5baSsrXT1vfX1mdW5jdGlvbiBRKHQsZSxyLG4saSl7Zm9yKHI9ZStyO2U8cjspe3ZhciBhPShvPXRbZSsrXSk+PjE2JjI0OHxvPj4xMyY3LG89bz4+NSYyMjR8bz4+MyYzMTtuW2krK109YSxuW2krK109b319ZnVuY3Rpb24gdHQodCxlLHIsbixpKXtmb3Iocj1lK3I7ZTxyOyl7dmFyIGE9dFtlKytdO25baSsrXT1hPj4wJjI1NSxuW2krK109YT4+OCYyNTUsbltpKytdPWE+PjE2JjI1NX19ZnVuY3Rpb24gZXQodCxlLHIsaSxhLG8pe2lmKDA9PW8pZm9yKHI9ZStyO2U8cjspRihpLCgobz10W2UrK10pWzBdPj4yNHxvWzFdPj44JjY1MjgwfG9bMl08PDgmMTY3MTE2ODB8b1szXTw8MjQpPj4+MCksYSs9MzI7ZWxzZSBuKGksYSx0LGUscil9ZnVuY3Rpb24gcnQoZSxyKXt0W3JdWzBdPXRbZSsiMCJdLHRbcl1bMV09dFtlKyIxIl0sdFtyXVsyXT10W2UrIjIiXSx0W3JdWzNdPXRbZSsiMyJdLHRbcl1bNF09dFtlKyI0Il0sdFtyXVs1XT10W2UrIjUiXSx0W3JdWzZdPXRbZSsiNiJdLHRbcl1bN109dFtlKyI3Il0sdFtyXVs4XT10W2UrIjgiXSx0W3JdWzldPXRbZSsiOSJdLHRbcl1bMTBdPXRbZSsiMTAiXSx0W3JdWzExXT10W2UrIjExIl0sdFtyXVsxMl09dFtlKyIxMiJdLHRbcl1bMTNdPXRbZSsiMTMiXSx0W3JdWzE0XT10W2UrIjAiXSx0W3JdWzE1XT10W2UrIjAiXX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gdD09SG58fHQ9PVdufHx0PT1Wbnx8dD09R259ZnVuY3Rpb24gaXQoKXt0aGlzLmViPVtdLHRoaXMuc2l6ZT10aGlzLkE9dGhpcy5mYj0wfWZ1bmN0aW9uIGF0KCl7dGhpcy55PVtdLHRoaXMuZj1bXSx0aGlzLmVhPVtdLHRoaXMuRj1bXSx0aGlzLlRjPXRoaXMuRWQ9dGhpcy5DZD10aGlzLkZkPXRoaXMubGI9dGhpcy5EYj10aGlzLkFiPXRoaXMuZmE9dGhpcy5KPXRoaXMuVz10aGlzLk49dGhpcy5PPTB9ZnVuY3Rpb24gb3QoKXt0aGlzLlJkPXRoaXMuaGVpZ2h0PXRoaXMud2lkdGg9dGhpcy5TPTAsdGhpcy5mPXt9LHRoaXMuZi5SR0JBPW5ldyBpdCx0aGlzLmYua2I9bmV3IGF0LHRoaXMuc2Q9bnVsbH1mdW5jdGlvbiBzdCgpe3RoaXMud2lkdGg9WzBdLHRoaXMuaGVpZ2h0PVswXSx0aGlzLlBkPVswXSx0aGlzLlFkPVswXSx0aGlzLmZvcm1hdD1bMF19ZnVuY3Rpb24gY3QoKXt0aGlzLklkPXRoaXMuZmQ9dGhpcy5NZD10aGlzLmhiPXRoaXMuaWI9dGhpcy5kYT10aGlzLmJkPXRoaXMuY2Q9dGhpcy5qPXRoaXMudj10aGlzLkRhPXRoaXMuU2Q9dGhpcy5vYj0wfWZ1bmN0aW9uIHV0KHQpe3JldHVybiBhbGVydCgidG9kbzpXZWJQU2FtcGxlclByb2Nlc3NQbGFuZSIpLHQuVH1mdW5jdGlvbiBsdCh0LGUpe3ZhciByPXQuVCxpPWUuYmEuZi5SR0JBLGE9aS5lYixvPWkuZmIrdC5rYSppLkEscz12aVtlLmJhLlNdLGM9dC55LHU9dC5PLGw9dC5mLGg9dC5OLGY9dC5lYSxkPXQuVyxwPWUuY2MsZz1lLmRjLG09ZS5NYyx2PWUuTmMsYj10LmthLHk9dC5rYSt0LlQsdz10LlUsTj13KzE+PjE7Zm9yKDA9PWI/cyhjLHUsbnVsbCxudWxsLGwsaCxmLGQsbCxoLGYsZCxhLG8sbnVsbCxudWxsLHcpOihzKGUuZWMsZS5mYyxjLHUscCxnLG0sdixsLGgsZixkLGEsby1pLkEsYSxvLHcpLCsrcik7YisyPHk7Yis9MilwPWwsZz1oLG09Zix2PWQsaCs9dC5SYyxkKz10LlJjLG8rPTIqaS5BLHMoYywodSs9Mip0LmZhKS10LmZhLGMsdSxwLGcsbSx2LGwsaCxmLGQsYSxvLWkuQSxhLG8sdyk7cmV0dXJuIHUrPXQuZmEsdC5qK3k8dC5vPyhuKGUuZWMsZS5mYyxjLHUsdyksbihlLmNjLGUuZGMsbCxoLE4pLG4oZS5NYyxlLk5jLGYsZCxOKSxyLS0pOjEmeXx8cyhjLHUsbnVsbCxudWxsLGwsaCxmLGQsbCxoLGYsZCxhLG8raS5BLG51bGwsbnVsbCx3KSxyfWZ1bmN0aW9uIGh0KHQscixuKXt2YXIgaT10LkYsYT1bdC5KXTtpZihudWxsIT1pKXt2YXIgbz10LlUscz1yLmJhLlMsYz1zPT1Ubnx8cz09Vm47cj1yLmJhLmYuUkdCQTt2YXIgdT1bMF0sbD10LmthO3VbMF09dC5ULHQuS2ImJigwPT1sPy0tdVswXTooLS1sLGFbMF0tPXQud2lkdGgpLHQuait0LmthK3QuVD09dC5vJiYodVswXT10Lm8tdC5qLWwpKTt2YXIgaD1yLmViO2w9ci5mYitsKnIuQTt0PVNuKGksYVswXSx0LndpZHRoLG8sdSxoLGwrKGM/MDozKSxyLkEpLGUobj09dSksdCYmbnQocykmJkFuKGgsbCxjLG8sdSxyLkEpfXJldHVybiAwfWZ1bmN0aW9uIGZ0KHQpe3ZhciBlPXQubWEscj1lLmJhLlMsbj0xMT5yLGk9cj09cW58fHI9PVJufHxyPT1Ubnx8cj09VW58fDEyPT1yfHxudChyKTtpZihlLm1lbW9yeT1udWxsLGUuSWI9bnVsbCxlLkpiPW51bGwsZS5OZD1udWxsLCFNcihlLk9hLHQsaT8xMToxMikpcmV0dXJuIDA7aWYoaSYmbnQocikmJmJyKCksdC5kYSlhbGVydCgidG9kbzp1c2Vfc2NhbGluZyIpO2Vsc2V7aWYobil7aWYoZS5JYj11dCx0LktiKXtpZihyPXQuVSsxPj4xLGUubWVtb3J5PWEodC5VKzIqciksbnVsbD09ZS5tZW1vcnkpcmV0dXJuIDA7ZS5lYz1lLm1lbW9yeSxlLmZjPTAsZS5jYz1lLmVjLGUuZGM9ZS5mYyt0LlUsZS5NYz1lLmNjLGUuTmM9ZS5kYytyLGUuSWI9bHQsYnIoKX19ZWxzZSBhbGVydCgidG9kbzpFbWl0WVVWIik7aSYmKGUuSmI9aHQsbiYmbXIoKSl9aWYobiYmIUNpKXtmb3IodD0wOzI1Nj50OysrdClqaVt0XT04OTg1OCoodC0xMjgpK19pPj5TaSxNaVt0XT0tMjIwMTQqKHQtMTI4KStfaSxCaVt0XT0tNDU3NzMqKHQtMTI4KSxPaVt0XT0xMTM2MTgqKHQtMTI4KStfaT4+U2k7Zm9yKHQ9UGk7dDxraTsrK3QpZT03NjI4MyoodC0xNikrX2k+PlNpLEVpW3QtUGldPVZ0KGUsMjU1KSxxaVt0LVBpXT1WdChlKzg+PjQsMTUpO0NpPTF9cmV0dXJuIDF9ZnVuY3Rpb24gZHQodCl7dmFyIHI9dC5tYSxuPXQuVSxpPXQuVDtyZXR1cm4gZSghKDEmdC5rYSkpLDA+PW58fDA+PWk/MDoobj1yLkliKHQsciksbnVsbCE9ci5KYiYmci5KYih0LHIsbiksci5EYys9biwxKX1mdW5jdGlvbiBwdCh0KXt0Lm1hLm1lbW9yeT1udWxsfWZ1bmN0aW9uIGd0KHQsZSxyLG4pe3JldHVybiA0NyE9eSh0LDgpPzA6KGVbMF09eSh0LDE0KSsxLHJbMF09eSh0LDE0KSsxLG5bMF09eSh0LDEpLDAhPXkodCwzKT8wOiF0LmgpfWZ1bmN0aW9uIG10KHQsZSl7aWYoND50KXJldHVybiB0KzE7dmFyIHI9dC0yPj4xO3JldHVybigyKygxJnQpPDxyKSt5KGUscikrMX1mdW5jdGlvbiB2dCh0LGUpe3JldHVybiAxMjA8ZT9lLTEyMDoxPD0ocj0oKHI9JG5bZS0xXSk+PjQpKnQrKDgtKDE1JnIpKSk/cjoxO3ZhciByfWZ1bmN0aW9uIGJ0KHQsZSxyKXt2YXIgbj1MKHIpLGk9dFtlKz0yNTUmbl0uZy04O3JldHVybiAwPGkmJih4KHIsci51KzgpLG49TChyKSxlKz10W2VdLnZhbHVlLGUrPW4mKDE8PGkpLTEpLHgocixyLnUrdFtlXS5nKSx0W2VdLnZhbHVlfWZ1bmN0aW9uIHl0KHQscixuKXtyZXR1cm4gbi5nKz10Lmcsbi52YWx1ZSs9dC52YWx1ZTw8cj4+PjAsZSg4Pj1uLmcpLHQuZ31mdW5jdGlvbiB3dCh0LHIsbil7dmFyIGk9dC54YztyZXR1cm4gZSgocj0wPT1pPzA6dC52Y1t0Lm1kKihuPj5pKSsocj4+aSldKTx0LldiKSx0LllhW3JdfWZ1bmN0aW9uIE50KHQscixpLGEpe3ZhciBvPXQuYWIscz10LmMqcixjPXQuQztyPWMrcjt2YXIgdT1pLGw9YTtmb3IoYT10LlRhLGk9dC5VYTswPG8tLTspe3ZhciBoPXQuZ2Nbb10sZj1jLGQ9cixwPXUsZz1sLG09KGw9YSx1PWksaC5FYSk7c3dpdGNoKGUoZjxkKSxlKGQ8PWgubmMpLGguaGMpe2Nhc2UgMjpHcihwLGcsKGQtZikqbSxsLHUpO2JyZWFrO2Nhc2UgMDp2YXIgdj1mLGI9ZCx5PWwsdz11LE49KF89aCkuRWE7MD09diYmKFdyKHAsZyxudWxsLG51bGwsMSx5LHcpLFYocCxnKzEsMCwwLE4tMSx5LHcrMSksZys9Tix3Kz1OLCsrdik7Zm9yKHZhciBMPTE8PF8uYixBPUwtMSx4PXEoTixfLmIpLFM9Xy5LLF89Xy53Kyh2Pj5fLmIpKng7djxiOyl7dmFyIFA9UyxrPV8sRj0xO2ZvcihWcihwLGcseSx3LU4sMSx5LHcpO0Y8Tjspe3ZhciBJPShGJn5BKStMO0k+TiYmKEk9TiksKDAsWnJbUFtrKytdPj44JjE1XSkocCxnKyArRix5LHcrRi1OLEktRix5LHcrRiksRj1JfWcrPU4sdys9TiwrK3YmQXx8KF8rPXgpfWQhPWgubmMmJm4obCx1LW0sbCx1KyhkLWYtMSkqbSxtKTticmVhaztjYXNlIDE6Zm9yKG09cCxiPWcsTj0ocD1oLkVhKS0odz1wJn4oeT0oZz0xPDxoLmIpLTEpKSx2PXEocCxoLmIpLEw9aC5LLGg9aC53KyhmPj5oLmIpKnY7ZjxkOyl7Zm9yKEE9TCx4PWgsUz1uZXcgVCxfPWIrdyxQPWIrcDtiPF87KVkoQVt4KytdLFMpLCRyKFMsbSxiLGcsbCx1KSxiKz1nLHUrPWc7YjxQJiYoWShBW3grK10sUyksJHIoUyxtLGIsTixsLHUpLGIrPU4sdSs9TiksKytmJnl8fChoKz12KX1icmVhaztjYXNlIDM6aWYocD09bCYmZz09dSYmMDxoLmIpe2ZvcihiPWwscD1tPXUrKGQtZikqbS0odz0oZC1mKSpxKGguRWEsaC5iKSksZz1sLHk9dSx2PVtdLHc9KE49dyktMTswPD13Oy0tdyl2W3ddPWdbeSt3XTtmb3Iodz1OLTE7MDw9dzstLXcpYltwK3ddPXZbd107WXIoaCxmLGQsbCxtLGwsdSl9ZWxzZSBZcihoLGYsZCxwLGcsbCx1KX11PWEsbD1pfWwhPWkmJm4oYSxpLHUsbCxzKX1mdW5jdGlvbiBMdCh0LHIpe3ZhciBuPXQuVixpPXQuQmErdC5jKnQuQyxhPXItdC5DO2lmKGUocjw9dC5sLm8pLGUoMTY+PWEpLDA8YSl7dmFyIG89dC5sLHM9dC5UYSxjPXQuVWEsdT1vLndpZHRoO2lmKE50KHQsYSxuLGkpLGE9Yz1bY10sZSgobj10LkMpPChpPXIpKSxlKG8udjxvLnZhKSxpPm8ubyYmKGk9by5vKSxuPG8uail7dmFyIGw9by5qLW47bj1vLmo7YVswXSs9bCp1fWlmKG4+PWk/bj0wOihhWzBdKz00Km8udixvLmthPW4tby5qLG8uVT1vLnZhLW8udixvLlQ9aS1uLG49MSksbil7aWYoYz1jWzBdLDExPihuPXQuY2EpLlMpe3ZhciBoPW4uZi5SR0JBLGY9KGk9bi5TLGE9by5VLG89by5ULGw9aC5lYixoLkEpLGQ9bztmb3IoaD1oLmZiK3QuTWEqaC5BOzA8ZC0tOyl7dmFyIHA9cyxnPWMsbT1hLHY9bCxiPWg7c3dpdGNoKGkpe2Nhc2UgRW46UXIocCxnLG0sdixiKTticmVhaztjYXNlIHFuOnRuKHAsZyxtLHYsYik7YnJlYWs7Y2FzZSBIbjp0bihwLGcsbSx2LGIpLEFuKHYsYiwwLG0sMSwwKTticmVhaztjYXNlIERuOm5uKHAsZyxtLHYsYik7YnJlYWs7Y2FzZSBSbjpldChwLGcsbSx2LGIsMSk7YnJlYWs7Y2FzZSBXbjpldChwLGcsbSx2LGIsMSksQW4odixiLDAsbSwxLDApO2JyZWFrO2Nhc2UgVG46ZXQocCxnLG0sdixiLDApO2JyZWFrO2Nhc2UgVm46ZXQocCxnLG0sdixiLDApLEFuKHYsYiwxLG0sMSwwKTticmVhaztjYXNlIFVuOmVuKHAsZyxtLHYsYik7YnJlYWs7Y2FzZSBHbjplbihwLGcsbSx2LGIpLHhuKHYsYixtLDEsMCk7YnJlYWs7Y2FzZSB6bjpybihwLGcsbSx2LGIpO2JyZWFrO2RlZmF1bHQ6ZSgwKX1jKz11LGgrPWZ9dC5NYSs9b31lbHNlIGFsZXJ0KCJ0b2RvOkVtaXRSZXNjYWxlZFJvd3NZVVZBIik7ZSh0Lk1hPD1uLmhlaWdodCl9fXQuQz1yLGUodC5DPD10LmkpfWZ1bmN0aW9uIEF0KHQpe3ZhciBlO2lmKDA8dC51YSlyZXR1cm4gMDtmb3IoZT0wO2U8dC5XYjsrK2Upe3ZhciByPXQuWWFbZV0uRyxuPXQuWWFbZV0uSDtpZigwPHJbMV1bblsxXSswXS5nfHwwPHJbMl1bblsyXSswXS5nfHwwPHJbM11bblszXSswXS5nKXJldHVybiAwfXJldHVybiAxfWZ1bmN0aW9uIHh0KHQscixuLGksYSxvKXtpZigwIT10Llope3ZhciBzPXQucWQsYz10LnJkO2ZvcihlKG51bGwhPW1pW3QuWl0pO3I8bjsrK3IpbWlbdC5aXShzLGMsaSxhLGksYSxvKSxzPWksYz1hLGErPW87dC5xZD1zLHQucmQ9Y319ZnVuY3Rpb24gU3QodCxyKXt2YXIgbj10LmwubWEsaT0wPT1uLlp8fDE9PW4uWj90Lmwuajp0LkM7aT10LkM8aT9pOnQuQztpZihlKHI8PXQubC5vKSxyPmkpe3ZhciBhPXQubC53aWR0aCxvPW4uY2Escz1uLnRiK2EqaSxjPXQuVix1PXQuQmErdC5jKmksbD10LmdjO2UoMT09dC5hYiksZSgzPT1sWzBdLmhjKSxYcihsWzBdLGkscixjLHUsbyxzKSx4dChuLGkscixvLHMsYSl9dC5DPXQuTWE9cn1mdW5jdGlvbiBfdCh0LHIsbixpLGEsbyxzKXt2YXIgYz10LiQvaSx1PXQuJCVpLGw9dC5tLGg9dC5zLGY9bit0LiQsZD1mO2E9bitpKmE7dmFyIHA9bitpKm8sZz0yODAraC51YSxtPXQuUGI/YzoxNjc3NzIxNix2PTA8aC51YT9oLldhOm51bGwsYj1oLndjLHk9ZjxwP3d0KGgsdSxjKTpudWxsO2UodC5DPG8pLGUocDw9YSk7dmFyIHc9ITE7dDpmb3IoOzspe2Zvcig7d3x8ZjxwOyl7dmFyIE49MDtpZihjPj1tKXt2YXIgXz1mLW47ZSgobT10KS5QYiksbS53ZD1tLm0sbS54ZD1fLDA8bS5zLnVhJiZCKG0ucy5XYSxtLnMudmIpLG09Yyt0aX1pZih1JmJ8fCh5PXd0KGgsdSxjKSksZShudWxsIT15KSx5LlFiJiYocltmXT15LnFiLHc9ITApLCF3KWlmKFMobCkseS5qYyl7Tj1sLF89cjt2YXIgUD1mLGs9eS5wZFtMKE4pJkRyLTFdO2UoeS5qYyksMjU2PmsuZz8oeChOLE4udStrLmcpLF9bUF09ay52YWx1ZSxOPTApOih4KE4sTi51K2suZy0yNTYpLGUoMjU2PD1rLnZhbHVlKSxOPWsudmFsdWUpLDA9PU4mJih3PSEwKX1lbHNlIE49YnQoeS5HWzBdLHkuSFswXSxsKTtpZihsLmgpYnJlYWs7aWYod3x8MjU2Pk4pe2lmKCF3KWlmKHkubmQpcltmXT0oeS5xYnxOPDw4KT4+PjA7ZWxzZXtpZihTKGwpLHc9YnQoeS5HWzFdLHkuSFsxXSxsKSxTKGwpLF89YnQoeS5HWzJdLHkuSFsyXSxsKSxQPWJ0KHkuR1szXSx5LkhbM10sbCksbC5oKWJyZWFrO3JbZl09KFA8PDI0fHc8PDE2fE48PDh8Xyk+Pj4wfWlmKHc9ITEsKytmLCsrdT49aSYmKHU9MCwrK2MsbnVsbCE9cyYmYzw9byYmIShjJTE2KSYmcyh0LGMpLG51bGwhPXYpKWZvcig7ZDxmOylOPXJbZCsrXSx2LlhbKDUwNjgzMjgyOSpOJjQyOTQ5NjcyOTUpPj4+di5NYl09Tn1lbHNlIGlmKDI4MD5OKXtpZihOPW10KE4tMjU2LGwpLF89YnQoeS5HWzRdLHkuSFs0XSxsKSxTKGwpLF89dnQoaSxfPW10KF8sbCkpLGwuaClicmVhaztpZihmLW48X3x8YS1mPE4pYnJlYWsgdDtmb3IoUD0wO1A8TjsrK1ApcltmK1BdPXJbZitQLV9dO2ZvcihmKz1OLHUrPU47dT49aTspdS09aSwrK2MsbnVsbCE9cyYmYzw9byYmIShjJTE2KSYmcyh0LGMpO2lmKGUoZjw9YSksdSZiJiYoeT13dChoLHUsYykpLG51bGwhPXYpZm9yKDtkPGY7KU49cltkKytdLHYuWFsoNTA2ODMyODI5Kk4mNDI5NDk2NzI5NSk+Pj52Lk1iXT1OfWVsc2V7aWYoIShOPGcpKWJyZWFrIHQ7Zm9yKHc9Ti0yODAsZShudWxsIT12KTtkPGY7KU49cltkKytdLHYuWFsoNTA2ODMyODI5Kk4mNDI5NDk2NzI5NSk+Pj52Lk1iXT1OO049ZixlKCEodz4+PihfPXYpLlhhKSkscltOXT1fLlhbd10sdz0hMH13fHxlKGwuaD09QShsKSl9aWYodC5QYiYmbC5oJiZmPGEpZSh0Lm0uaCksdC5hPTUsdC5tPXQud2QsdC4kPXQueGQsMDx0LnMudWEmJkIodC5zLnZiLHQucy5XYSk7ZWxzZXtpZihsLmgpYnJlYWsgdDtudWxsIT1zJiZzKHQsYz5vP286YyksdC5hPTAsdC4kPWYtbn1yZXR1cm4gMX1yZXR1cm4gdC5hPTMsMH1mdW5jdGlvbiBQdCh0KXtlKG51bGwhPXQpLHQudmM9bnVsbCx0LnljPW51bGwsdC5ZYT1udWxsO3ZhciByPXQuV2E7bnVsbCE9ciYmKHIuWD1udWxsKSx0LnZiPW51bGwsZShudWxsIT10KX1mdW5jdGlvbiBrdCgpe3ZhciBlPW5ldyBvcjtyZXR1cm4gbnVsbD09ZT9udWxsOihlLmE9MCxlLnhiPWdpLHJ0KCJQcmVkaWN0b3IiLCJWUDhMUHJlZGljdG9ycyIpLHJ0KCJQcmVkaWN0b3IiLCJWUDhMUHJlZGljdG9yc19DIikscnQoIlByZWRpY3RvckFkZCIsIlZQOExQcmVkaWN0b3JzQWRkIikscnQoIlByZWRpY3RvckFkZCIsIlZQOExQcmVkaWN0b3JzQWRkX0MiKSxHcj1HLCRyPUosUXI9Syx0bj1aLGVuPSQscm49USxubj10dCx0LlZQOExNYXBDb2xvcjMyYj1Kcix0LlZQOExNYXBDb2xvcjhiPUtyLGUpfWZ1bmN0aW9uIEZ0KHQscixuLHMsYyl7dmFyIHU9MSxmPVt0XSxwPVtyXSxnPXMubSxtPXMucyx2PW51bGwsYj0wO3Q6Zm9yKDs7KXtpZihuKWZvcig7dSYmeShnLDEpOyl7dmFyIHc9ZixOPXAsQT1zLF89MSxQPUEubSxrPUEuZ2NbQS5hYl0sRj15KFAsMik7aWYoQS5PYyYxPDxGKXU9MDtlbHNle3N3aXRjaChBLk9jfD0xPDxGLGsuaGM9RixrLkVhPXdbMF0say5uYz1OWzBdLGsuSz1bbnVsbF0sKytBLmFiLGUoND49QS5hYiksRil7Y2FzZSAwOmNhc2UgMTprLmI9eShQLDMpKzIsXz1GdChxKGsuRWEsay5iKSxxKGsubmMsay5iKSwwLEEsay5LKSxrLks9ay5LWzBdO2JyZWFrO2Nhc2UgMzp2YXIgSSxDPXkoUCw4KSsxLGo9MTY8Qz8wOjQ8Qz8xOjI8Qz8yOjM7aWYod1swXT1xKGsuRWEsaiksay5iPWosST1fPUZ0KEMsMSwwLEEsay5LKSl7dmFyIEIsTT1DLEU9ayxSPTE8PCg4Pj5FLmIpLFQ9YShSKTtpZihudWxsPT1UKUk9MDtlbHNle3ZhciBVPUUuS1swXSx6PUUudztmb3IoVFswXT1FLktbMF1bMF0sQj0xO0I8MSpNOysrQilUW0JdPUQoVVt6K0JdLFRbQi0xXSk7Zm9yKDtCPDQqUjsrK0IpVFtCXT0wO0UuS1swXT1udWxsLEUuS1swXT1ULEk9MX19Xz1JO2JyZWFrO2Nhc2UgMjpicmVhaztkZWZhdWx0OmUoMCl9dT1ffX1pZihmPWZbMF0scD1wWzBdLHUmJnkoZywxKSYmISh1PTE8PShiPXkoZyw0KSkmJjExPj1iKSl7cy5hPTM7YnJlYWsgdH12YXIgSDtpZihIPXUpZTp7dmFyIFcsVixHLFk9cyxKPWYsWD1wLEs9YixaPW4sJD1ZLm0sUT1ZLnMsdHQ9W251bGxdLGV0PTEscnQ9MCxudD1RbltLXTtyOmZvcig7Oyl7aWYoWiYmeSgkLDEpKXt2YXIgaXQ9eSgkLDMpKzIsYXQ9cShKLGl0KSxvdD1xKFgsaXQpLHN0PWF0Km90O2lmKCFGdChhdCxvdCwwLFksdHQpKWJyZWFrIHI7Zm9yKHR0PXR0WzBdLFEueGM9aXQsVz0wO1c8c3Q7KytXKXt2YXIgY3Q9dHRbV10+PjgmNjU1MzU7dHRbV109Y3QsY3Q+PWV0JiYoZXQ9Y3QrMSl9fWlmKCQuaClicmVhayByO2ZvcihWPTA7NT5WOysrVil7dmFyIHV0PVhuW1ZdOyFWJiYwPEsmJih1dCs9MTw8SykscnQ8dXQmJihydD11dCl9dmFyIGx0PW8oZXQqbnQsaCksaHQ9ZXQsZnQ9byhodCxkKTtpZihudWxsPT1mdCl2YXIgZHQ9bnVsbDtlbHNlIGUoNjU1MzY+PWh0KSxkdD1mdDt2YXIgcHQ9YShydCk7aWYobnVsbD09ZHR8fG51bGw9PXB0fHxudWxsPT1sdCl7WS5hPTE7YnJlYWsgcn12YXIgZ3Q9bHQ7Zm9yKFc9Rz0wO1c8ZXQ7KytXKXt2YXIgbXQ9ZHRbV10sdnQ9bXQuRyxidD1tdC5ILHd0PTAsTnQ9MSxMdD0wO2ZvcihWPTA7NT5WOysrVil7dXQ9WG5bVl0sdnRbVl09Z3QsYnRbVl09RywhViYmMDxLJiYodXQrPTE8PEspO246e3ZhciBBdCx4dD11dCxTdD1ZLGt0PXB0LEl0PWd0LEN0PUcsanQ9MCxPdD1TdC5tLEJ0PXkoT3QsMSk7aWYoaShrdCwwLDAseHQpLEJ0KXt2YXIgTXQ9eShPdCwxKSsxLEV0PXkoT3QsMSkscXQ9eShPdCwwPT1FdD8xOjgpO2t0W3F0XT0xLDI9PU10JiYoa3RbcXQ9eShPdCw4KV09MSk7dmFyIER0PTF9ZWxzZXt2YXIgUnQ9YSgxOSksVHQ9eShPdCw0KSs0O2lmKDE5PFR0KXtTdC5hPTM7dmFyIFV0PTA7YnJlYWsgbn1mb3IoQXQ9MDtBdDxUdDsrK0F0KVJ0W1puW0F0XV09eShPdCwzKTt2YXIgenQ9dm9pZCAwLEh0PXZvaWQgMCxXdD1TdCxWdD1SdCxHdD14dCxZdD1rdCxKdD0wLFh0PVd0Lm0sS3Q9OCxadD1vKDEyOCxoKTtpOmZvcig7bChadCwwLDcsVnQsMTkpOyl7aWYoeShYdCwxKSl7dmFyICR0PTIrMip5KFh0LDMpO2lmKCh6dD0yK3koWHQsJHQpKT5HdClicmVhayBpfWVsc2UgenQ9R3Q7Zm9yKEh0PTA7SHQ8R3QmJnp0LS07KXtTKFh0KTt2YXIgUXQ9WnRbMCsoMTI3JkwoWHQpKV07eChYdCxYdC51K1F0LmcpO3ZhciB0ZT1RdC52YWx1ZTtpZigxNj50ZSlZdFtIdCsrXT10ZSwwIT10ZSYmKEt0PXRlKTtlbHNle3ZhciBlZT0xNj09dGUscmU9dGUtMTYsbmU9Sm5bcmVdLGllPXkoWHQsWW5bcmVdKStuZTtpZihIdCtpZT5HdClicmVhayBpO2Zvcih2YXIgYWU9ZWU/S3Q6MDswPGllLS07KVl0W0h0KytdPWFlfX1KdD0xO2JyZWFrIGl9SnR8fChXdC5hPTMpLER0PUp0fShEdD1EdCYmIU90LmgpJiYoanQ9bChJdCxDdCw4LGt0LHh0KSksRHQmJjAhPWp0P1V0PWp0OihTdC5hPTMsVXQ9MCl9aWYoMD09VXQpYnJlYWsgcjtpZihOdCYmMT09S25bVl0mJihOdD0wPT1ndFtHXS5nKSx3dCs9Z3RbR10uZyxHKz1VdCwzPj1WKXt2YXIgb2Usc2U9cHRbMF07Zm9yKG9lPTE7b2U8dXQ7KytvZSlwdFtvZV0+c2UmJihzZT1wdFtvZV0pO0x0Kz1zZX19aWYobXQubmQ9TnQsbXQuUWI9MCxOdCYmKG10LnFiPSh2dFszXVtidFszXSswXS52YWx1ZTw8MjR8dnRbMV1bYnRbMV0rMF0udmFsdWU8PDE2fHZ0WzJdW2J0WzJdKzBdLnZhbHVlKT4+PjAsMD09d3QmJjI1Nj52dFswXVtidFswXSswXS52YWx1ZSYmKG10LlFiPTEsbXQucWIrPXZ0WzBdW2J0WzBdKzBdLnZhbHVlPDw4KSksbXQuamM9IW10LlFiJiY2Pkx0LG10LmpjKXt2YXIgY2UsdWU9bXQ7Zm9yKGNlPTA7Y2U8RHI7KytjZSl7dmFyIGxlPWNlLGhlPXVlLnBkW2xlXSxmZT11ZS5HWzBdW3VlLkhbMF0rbGVdOzI1Njw9ZmUudmFsdWU/KGhlLmc9ZmUuZysyNTYsaGUudmFsdWU9ZmUudmFsdWUpOihoZS5nPTAsaGUudmFsdWU9MCxsZT4+PXl0KGZlLDgsaGUpLGxlPj49eXQodWUuR1sxXVt1ZS5IWzFdK2xlXSwxNixoZSksbGU+Pj15dCh1ZS5HWzJdW3VlLkhbMl0rbGVdLDAsaGUpLHl0KHVlLkdbM11bdWUuSFszXStsZV0sMjQsaGUpKX19fVEudmM9dHQsUS5XYj1ldCxRLllhPWR0LFEueWM9bHQsSD0xO2JyZWFrIGV9SD0wfWlmKCEodT1IKSl7cy5hPTM7YnJlYWsgdH1pZigwPGIpe2lmKG0udWE9MTw8YiwhTyhtLldhLGIpKXtzLmE9MSx1PTA7YnJlYWsgdH19ZWxzZSBtLnVhPTA7dmFyIGRlPXMscGU9ZixnZT1wLG1lPWRlLnMsdmU9bWUueGM7aWYoZGUuYz1wZSxkZS5pPWdlLG1lLm1kPXEocGUsdmUpLG1lLndjPTA9PXZlPy0xOigxPDx2ZSktMSxuKXtzLnhiPXBpO2JyZWFrIHR9aWYobnVsbD09KHY9YShmKnApKSl7cy5hPTEsdT0wO2JyZWFrIHR9dT0odT1fdChzLHYsMCxmLHAscCxudWxsKSkmJiFnLmg7YnJlYWsgdH1yZXR1cm4gdT8obnVsbCE9Yz9jWzBdPXY6KGUobnVsbD09diksZShuKSkscy4kPTAsbnx8UHQobSkpOlB0KG0pLHV9ZnVuY3Rpb24gSXQodCxyKXt2YXIgbj10LmMqdC5pLGk9bityKzE2KnI7cmV0dXJuIGUodC5jPD1yKSx0LlY9YShpKSxudWxsPT10LlY/KHQuVGE9bnVsbCx0LlVhPTAsdC5hPTEsMCk6KHQuVGE9dC5WLHQuVWE9dC5CYStuK3IsMSl9ZnVuY3Rpb24gQ3QodCxyKXt2YXIgbj10LkMsaT1yLW4sYT10LlYsbz10LkJhK3QuYypuO2ZvcihlKHI8PXQubC5vKTswPGk7KXt2YXIgcz0xNjxpPzE2OmksYz10LmwubWEsdT10Lmwud2lkdGgsbD11KnMsaD1jLmNhLGY9Yy50Yit1Km4sZD10LlRhLHA9dC5VYTtOdCh0LHMsYSxvKSxfbihkLHAsaCxmLGwpLHh0KGMsbixuK3MsaCxmLHUpLGktPXMsYSs9cyp0LmMsbis9c31lKG49PXIpLHQuQz10Lk1hPXJ9ZnVuY3Rpb24ganQoKXt0aGlzLnViPXRoaXMueWQ9dGhpcy50ZD10aGlzLlJiPTB9ZnVuY3Rpb24gT3QoKXt0aGlzLktkPXRoaXMuTGQ9dGhpcy5VZD10aGlzLlRkPXRoaXMuaT10aGlzLmM9MH1mdW5jdGlvbiBCdCgpe3RoaXMuRmI9dGhpcy5CYj10aGlzLkNiPTAsdGhpcy5aYj1hKDQpLHRoaXMuTGI9YSg0KX1mdW5jdGlvbiBNdCgpe3RoaXMuWWI9ZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gZnVuY3Rpb24gdChlLHIsbil7Zm9yKHZhciBpPW5bcl0sYT0wO2E8aSYmKGUucHVzaChuLmxlbmd0aD5yKzE/W106MCksIShuLmxlbmd0aDxyKzEpKTthKyspdChlW2FdLHIrMSxuKX0odCwwLFszLDExXSksdH0oKX1mdW5jdGlvbiBFdCgpe3RoaXMuamI9YSgzKSx0aGlzLldjPXMoWzQsOF0sTXQpLHRoaXMuWGM9cyhbNCwxN10sTXQpfWZ1bmN0aW9uIHF0KCl7dGhpcy5QYz10aGlzLndiPXRoaXMuVGI9dGhpcy56ZD0wLHRoaXMudmQ9bmV3IGEoNCksdGhpcy5vZD1uZXcgYSg0KX1mdW5jdGlvbiBEdCgpe3RoaXMubGQ9dGhpcy5MYT10aGlzLmRkPXRoaXMudGM9MH1mdW5jdGlvbiBSdCgpe3RoaXMuTmE9dGhpcy5sYT0wfWZ1bmN0aW9uIFR0KCl7dGhpcy5TYz1bMCwwXSx0aGlzLkViPVswLDBdLHRoaXMuUWM9WzAsMF0sdGhpcy5pYT10aGlzLmxjPTB9ZnVuY3Rpb24gVXQoKXt0aGlzLmFkPWEoMzg0KSx0aGlzLlphPTAsdGhpcy5PYj1hKDE2KSx0aGlzLiRiPXRoaXMuQWQ9dGhpcy5pYT10aGlzLkdjPXRoaXMuSGM9dGhpcy5EZD0wfWZ1bmN0aW9uIHp0KCl7dGhpcy51Yz10aGlzLk09dGhpcy5OYj0wLHRoaXMud2E9QXJyYXkobmV3IER0KSx0aGlzLlk9MCx0aGlzLnlhPUFycmF5KG5ldyBVdCksdGhpcy5hYT0wLHRoaXMubD1uZXcgR3R9ZnVuY3Rpb24gSHQoKXt0aGlzLnk9YSgxNiksdGhpcy5mPWEoOCksdGhpcy5lYT1hKDgpfWZ1bmN0aW9uIFd0KCl7dGhpcy5jYj10aGlzLmE9MCx0aGlzLnNjPSIiLHRoaXMubT1uZXcgdyx0aGlzLk9kPW5ldyBqdCx0aGlzLktjPW5ldyBPdCx0aGlzLmVkPW5ldyBxdCx0aGlzLlFhPW5ldyBCdCx0aGlzLkljPXRoaXMuJGM9dGhpcy5BYT0wLHRoaXMuRD1uZXcgenQsdGhpcy5YYj10aGlzLlZhPXRoaXMuSGI9dGhpcy56Yj10aGlzLnliPXRoaXMuVWI9dGhpcy56YT0wLHRoaXMuSmM9byg4LHcpLHRoaXMuaWE9MCx0aGlzLnBiPW8oNCxUdCksdGhpcy5QYT1uZXcgRXQsdGhpcy5CZD10aGlzLmtjPTAsdGhpcy5BYz1bXSx0aGlzLkJjPTAsdGhpcy56Yz1bMCwwLDAsMF0sdGhpcy5HZD1BcnJheShuZXcgSHQpLHRoaXMuSGQ9MCx0aGlzLnJiPUFycmF5KG5ldyBSdCksdGhpcy5zYj0wLHRoaXMud2E9QXJyYXkobmV3IER0KSx0aGlzLlk9MCx0aGlzLm9jPVtdLHRoaXMucGM9MCx0aGlzLnNhPVtdLHRoaXMudGE9MCx0aGlzLnFhPVtdLHRoaXMucmE9MCx0aGlzLkhhPVtdLHRoaXMuQj10aGlzLlI9dGhpcy5JYT0wLHRoaXMuRWM9W10sdGhpcy5NPXRoaXMuamE9dGhpcy5WYj10aGlzLkZjPTAsdGhpcy55YT1BcnJheShuZXcgVXQpLHRoaXMuTD10aGlzLmFhPTAsdGhpcy5nZD1zKFs0LDJdLER0KSx0aGlzLmdhPW51bGwsdGhpcy5GYT1bXSx0aGlzLkNjPXRoaXMucWM9dGhpcy5QPTAsdGhpcy5HYj1bXSx0aGlzLlVjPTAsdGhpcy5tYj1bXSx0aGlzLm5iPTAsdGhpcy5yYz1bXSx0aGlzLkdhPXRoaXMuVmM9MH1mdW5jdGlvbiBWdCh0LGUpe3JldHVybiAwPnQ/MDp0PmU/ZTp0fWZ1bmN0aW9uIEd0KCl7dGhpcy5UPXRoaXMuVT10aGlzLmthPXRoaXMuaGVpZ2h0PXRoaXMud2lkdGg9MCx0aGlzLnk9W10sdGhpcy5mPVtdLHRoaXMuZWE9W10sdGhpcy5SYz10aGlzLmZhPXRoaXMuVz10aGlzLk49dGhpcy5PPTAsdGhpcy5tYT0idm9pZCIsdGhpcy5wdXQ9IlZQOElvUHV0SG9vayIsdGhpcy5hYz0iVlA4SW9TZXR1cEhvb2siLHRoaXMuYmM9IlZQOElvVGVhcmRvd25Ib29rIix0aGlzLmhhPXRoaXMuS2I9MCx0aGlzLmRhdGE9W10sdGhpcy5oYj10aGlzLmliPXRoaXMuZGE9dGhpcy5vPXRoaXMuaj10aGlzLnZhPXRoaXMudj10aGlzLkRhPXRoaXMub2I9dGhpcy53PTAsdGhpcy5GPVtdLHRoaXMuSj0wfWZ1bmN0aW9uIFl0KCl7dmFyIHQ9bmV3IFd0O3JldHVybiBudWxsIT10JiYodC5hPTAsdC5zYz0iT0siLHQuY2I9MCx0LlhiPTAsbml8fChuaT1adCkpLHR9ZnVuY3Rpb24gSnQodCxlLHIpe3JldHVybiAwPT10LmEmJih0LmE9ZSx0LnNjPXIsdC5jYj0wKSwwfWZ1bmN0aW9uIFh0KHQsZSxyKXtyZXR1cm4gMzw9ciYmMTU3PT10W2UrMF0mJjE9PXRbZSsxXSYmNDI9PXRbZSsyXX1mdW5jdGlvbiBLdCh0LHIpe2lmKG51bGw9PXQpcmV0dXJuIDA7aWYodC5hPTAsdC5zYz0iT0siLG51bGw9PXIpcmV0dXJuIEp0KHQsMiwibnVsbCBWUDhJbyBwYXNzZWQgdG8gVlA4R2V0SGVhZGVycygpIik7dmFyIG49ci5kYXRhLGE9ci53LG89ci5oYTtpZig0Pm8pcmV0dXJuIEp0KHQsNywiVHJ1bmNhdGVkIGhlYWRlci4iKTt2YXIgcz1uW2ErMF18blthKzFdPDw4fG5bYSsyXTw8MTYsYz10Lk9kO2lmKGMuUmI9ISgxJnMpLGMudGQ9cz4+MSY3LGMueWQ9cz4+NCYxLGMudWI9cz4+NSwzPGMudGQpcmV0dXJuIEp0KHQsMywiSW5jb3JyZWN0IGtleWZyYW1lIHBhcmFtZXRlcnMuIik7aWYoIWMueWQpcmV0dXJuIEp0KHQsNCwiRnJhbWUgbm90IGRpc3BsYXlhYmxlLiIpO2ErPTMsby09Mzt2YXIgdT10LktjO2lmKGMuUmIpe2lmKDc+bylyZXR1cm4gSnQodCw3LCJjYW5ub3QgcGFyc2UgcGljdHVyZSBoZWFkZXIiKTtpZighWHQobixhLG8pKXJldHVybiBKdCh0LDMsIkJhZCBjb2RlIHdvcmQiKTt1LmM9MTYzODMmKG5bYSs0XTw8OHxuW2ErM10pLHUuVGQ9blthKzRdPj42LHUuaT0xNjM4MyYoblthKzZdPDw4fG5bYSs1XSksdS5VZD1uW2ErNl0+PjYsYSs9NyxvLT03LHQuemE9dS5jKzE1Pj40LHQuVWI9dS5pKzE1Pj40LHIud2lkdGg9dS5jLHIuaGVpZ2h0PXUuaSxyLkRhPTAsci5qPTAsci52PTAsci52YT1yLndpZHRoLHIubz1yLmhlaWdodCxyLmRhPTAsci5pYj1yLndpZHRoLHIuaGI9ci5oZWlnaHQsci5VPXIud2lkdGgsci5UPXIuaGVpZ2h0LGkoKHM9dC5QYSkuamIsMCwyNTUscy5qYi5sZW5ndGgpLGUobnVsbCE9KHM9dC5RYSkpLHMuQ2I9MCxzLkJiPTAscy5GYj0xLGkocy5aYiwwLDAscy5aYi5sZW5ndGgpLGkocy5MYiwwLDAscy5MYil9aWYoYy51Yj5vKXJldHVybiBKdCh0LDcsImJhZCBwYXJ0aXRpb24gbGVuZ3RoIik7cChzPXQubSxuLGEsYy51YiksYSs9Yy51YixvLT1jLnViLGMuUmImJih1LkxkPVAocyksdS5LZD1QKHMpKSx1PXQuUWE7dmFyIGwsaD10LlBhO2lmKGUobnVsbCE9cyksZShudWxsIT11KSx1LkNiPVAocyksdS5DYil7aWYodS5CYj1QKHMpLFAocykpe2Zvcih1LkZiPVAocyksbD0wOzQ+bDsrK2wpdS5aYltsXT1QKHMpP20ocyw3KTowO2ZvcihsPTA7ND5sOysrbCl1LkxiW2xdPVAocyk/bShzLDYpOjB9aWYodS5CYilmb3IobD0wOzM+bDsrK2wpaC5qYltsXT1QKHMpP2cocyw4KToyNTV9ZWxzZSB1LkJiPTA7aWYocy5LYSlyZXR1cm4gSnQodCwzLCJjYW5ub3QgcGFyc2Ugc2VnbWVudCBoZWFkZXIiKTtpZigodT10LmVkKS56ZD1QKHMpLHUuVGI9ZyhzLDYpLHUud2I9ZyhzLDMpLHUuUGM9UChzKSx1LlBjJiZQKHMpKXtmb3IoaD0wOzQ+aDsrK2gpUChzKSYmKHUudmRbaF09bShzLDYpKTtmb3IoaD0wOzQ+aDsrK2gpUChzKSYmKHUub2RbaF09bShzLDYpKX1pZih0Lkw9MD09dS5UYj8wOnUuemQ/MToyLHMuS2EpcmV0dXJuIEp0KHQsMywiY2Fubm90IHBhcnNlIGZpbHRlciBoZWFkZXIiKTt2YXIgZj1vO2lmKG89bD1hLGE9bCtmLHU9Zix0LlhiPSgxPDxnKHQubSwyKSktMSxmPDMqKGg9dC5YYikpbj03O2Vsc2V7Zm9yKGwrPTMqaCx1LT0zKmgsZj0wO2Y8aDsrK2Ype3ZhciBkPW5bbyswXXxuW28rMV08PDh8bltvKzJdPDwxNjtkPnUmJihkPXUpLHAodC5KY1srZl0sbixsLGQpLGwrPWQsdS09ZCxvKz0zfXAodC5KY1sraF0sbixsLHUpLG49bDxhPzA6NX1pZigwIT1uKXJldHVybiBKdCh0LG4sImNhbm5vdCBwYXJzZSBwYXJ0aXRpb25zIik7Zm9yKG49ZyhsPXQubSw3KSxvPVAobCk/bShsLDQpOjAsYT1QKGwpP20obCw0KTowLHU9UChsKT9tKGwsNCk6MCxoPVAobCk/bShsLDQpOjAsbD1QKGwpP20obCw0KTowLGY9dC5RYSxkPTA7ND5kOysrZCl7aWYoZi5DYil7dmFyIHY9Zi5aYltkXTtmLkZifHwodis9bil9ZWxzZXtpZigwPGQpe3QucGJbZF09dC5wYlswXTtjb250aW51ZX12PW59dmFyIGI9dC5wYltkXTtiLlNjWzBdPWVpW1Z0KHYrbywxMjcpXSxiLlNjWzFdPXJpW1Z0KHYrMCwxMjcpXSxiLkViWzBdPTIqZWlbVnQodithLDEyNyldLGIuRWJbMV09MTAxNTgxKnJpW1Z0KHYrdSwxMjcpXT4+MTYsOD5iLkViWzFdJiYoYi5FYlsxXT04KSxiLlFjWzBdPWVpW1Z0KHYraCwxMTcpXSxiLlFjWzFdPXJpW1Z0KHYrbCwxMjcpXSxiLmxjPXYrbH1pZighYy5SYilyZXR1cm4gSnQodCw0LCJOb3QgYSBrZXkgZnJhbWUuIik7Zm9yKFAocyksYz10LlBhLG49MDs0Pm47KytuKXtmb3Iobz0wOzg+bzsrK28pZm9yKGE9MDszPmE7KythKWZvcih1PTA7MTE+dTsrK3UpaD1rKHMsdWlbbl1bb11bYV1bdV0pP2cocyw4KTpzaVtuXVtvXVthXVt1XSxjLldjW25dW29dLlliW2FdW3VdPWg7Zm9yKG89MDsxNz5vOysrbyljLlhjW25dW29dPWMuV2Nbbl1bbGlbb11dfXJldHVybiB0LmtjPVAocyksdC5rYyYmKHQuQmQ9ZyhzLDgpKSx0LmNiPTF9ZnVuY3Rpb24gWnQodCxlLHIsbixpLGEsbyl7dmFyIHM9ZVtpXS5ZYltyXTtmb3Iocj0wOzE2Pmk7KytpKXtpZighayh0LHNbciswXSkpcmV0dXJuIGk7Zm9yKDshayh0LHNbcisxXSk7KWlmKHM9ZVsrK2ldLlliWzBdLHI9MCwxNj09aSlyZXR1cm4gMTY7dmFyIGM9ZVtpKzFdLlliO2lmKGsodCxzW3IrMl0pKXt2YXIgdT10LGw9MDtpZihrKHUsKGY9cylbKGg9cikrM10pKWlmKGsodSxmW2grNl0pKXtmb3Iocz0wLGg9MioobD1rKHUsZltoKzhdKSkrKGY9ayh1LGZbaCs5K2xdKSksbD0wLGY9aWlbaF07ZltzXTsrK3MpbCs9bCtrKHUsZltzXSk7bCs9MysoODw8aCl9ZWxzZSBrKHUsZltoKzddKT8obD03KzIqayh1LDE2NSksbCs9ayh1LDE0NSkpOmw9NStrKHUsMTU5KTtlbHNlIGw9ayh1LGZbaCs0XSk/MytrKHUsZltoKzVdKToyO3M9Y1syXX1lbHNlIGw9MSxzPWNbMV07Yz1vK2FpW2ldLDA+KHU9dCkuYiYmXyh1KTt2YXIgaCxmPXUuYixkPShoPXUuQ2E+PjEpLSh1Lkk+PmYpPj4zMTstLXUuYix1LkNhKz1kLHUuQ2F8PTEsdS5JLT0oaCsxJmQpPDxmLGFbY109KChsXmQpLWQpKm5bKDA8aSkrMF19cmV0dXJuIDE2fWZ1bmN0aW9uICR0KHQpe3ZhciBlPXQucmJbdC5zYi0xXTtlLmxhPTAsZS5OYT0wLGkodC56YywwLDAsdC56Yy5sZW5ndGgpLHQuamE9MH1mdW5jdGlvbiBRdCh0LHIpe2lmKG51bGw9PXQpcmV0dXJuIDA7aWYobnVsbD09cilyZXR1cm4gSnQodCwyLCJOVUxMIFZQOElvIHBhcmFtZXRlciBpbiBWUDhEZWNvZGUoKS4iKTtpZighdC5jYiYmIUt0KHQscikpcmV0dXJuIDA7aWYoZSh0LmNiKSxudWxsPT1yLmFjfHxyLmFjKHIpKXtyLm9iJiYodC5MPTApO3ZhciBzPVJpW3QuTF07aWYoMj09dC5MPyh0LnliPTAsdC56Yj0wKToodC55Yj1yLnYtcz4+NCx0LnpiPXIuai1zPj40LDA+dC55YiYmKHQueWI9MCksMD50LnpiJiYodC56Yj0wKSksdC5WYT1yLm8rMTUrcz4+NCx0LkhiPXIudmErMTUrcz4+NCx0LkhiPnQuemEmJih0LkhiPXQuemEpLHQuVmE+dC5VYiYmKHQuVmE9dC5VYiksMDx0Lkwpe3ZhciBjPXQuZWQ7Zm9yKHM9MDs0PnM7KytzKXt2YXIgdTtpZih0LlFhLkNiKXt2YXIgbD10LlFhLkxiW3NdO3QuUWEuRmJ8fChsKz1jLlRiKX1lbHNlIGw9Yy5UYjtmb3IodT0wOzE+PXU7Kyt1KXt2YXIgaD10LmdkW3NdW3VdLGY9bDtpZihjLlBjJiYoZis9Yy52ZFswXSx1JiYoZis9Yy5vZFswXSkpLDA8KGY9MD5mPzA6NjM8Zj82MzpmKSl7dmFyIGQ9ZjswPGMud2ImJigoZD00PGMud2I/ZD4+MjpkPj4xKT45LWMud2ImJihkPTktYy53YikpLDE+ZCYmKGQ9MSksaC5kZD1kLGgudGM9MipmK2QsaC5sZD00MDw9Zj8yOjE1PD1mPzE6MH1lbHNlIGgudGM9MDtoLkxhPXV9fX1zPTB9ZWxzZSBKdCh0LDYsIkZyYW1lIHNldHVwIGZhaWxlZCIpLHM9dC5hO2lmKHM9MD09cyl7aWYocyl7dC4kYz0wLDA8dC5BYXx8KHQuSWM9VWkpO3Q6e3M9dC5JYztjPTQqKGQ9dC56YSk7dmFyIHA9MzIqZCxnPWQrMSxtPTA8dC5MP2QqKDA8dC5BYT8yOjEpOjAsdj0oMj09dC5BYT8yOjEpKmQ7aWYoKGg9Yys4MzIrKHU9MyooMTYqcytSaVt0LkxdKS8yKnApKyhsPW51bGwhPXQuRmEmJjA8dC5GYS5sZW5ndGg/dC5LYy5jKnQuS2MuaTowKSkhPWgpcz0wO2Vsc2V7aWYoaD50LlZiKXtpZih0LlZiPTAsdC5FYz1hKGgpLHQuRmM9MCxudWxsPT10LkVjKXtzPUp0KHQsMSwibm8gbWVtb3J5IGR1cmluZyBmcmFtZSBpbml0aWFsaXphdGlvbi4iKTticmVhayB0fXQuVmI9aH1oPXQuRWMsZj10LkZjLHQuQWM9aCx0LkJjPWYsZis9Yyx0LkdkPW8ocCxIdCksdC5IZD0wLHQucmI9byhnKzEsUnQpLHQuc2I9MSx0LndhPW0/byhtLER0KTpudWxsLHQuWT0wLHQuRC5OYj0wLHQuRC53YT10LndhLHQuRC5ZPXQuWSwwPHQuQWEmJih0LkQuWSs9ZCksZSghMCksdC5vYz1oLHQucGM9ZixmKz04MzIsdC55YT1vKHYsVXQpLHQuYWE9MCx0LkQueWE9dC55YSx0LkQuYWE9dC5hYSwyPT10LkFhJiYodC5ELmFhKz1kKSx0LlI9MTYqZCx0LkI9OCpkLGQ9KHA9UmlbdC5MXSkqdC5SLHA9cC8yKnQuQix0LnNhPWgsdC50YT1mK2QsdC5xYT10LnNhLHQucmE9dC50YSsxNipzKnQuUitwLHQuSGE9dC5xYSx0LklhPXQucmErOCpzKnQuQitwLHQuJGM9MCxmKz11LHQubWI9bD9oOm51bGwsdC5uYj1sP2Y6bnVsbCxlKGYrbDw9dC5GYyt0LlZiKSwkdCh0KSxpKHQuQWMsdC5CYywwLGMpLHM9MX19aWYocyl7aWYoci5rYT0wLHIueT10LnNhLHIuTz10LnRhLHIuZj10LnFhLHIuTj10LnJhLHIuZWE9dC5IYSxyLlZkPXQuSWEsci5mYT10LlIsci5SYz10LkIsci5GPW51bGwsci5KPTAsIUNuKXtmb3Iocz0tMjU1OzI1NT49czsrK3MpUG5bMjU1K3NdPTA+cz8tczpzO2ZvcihzPS0xMDIwOzEwMjA+PXM7KytzKWtuWzEwMjArc109LTEyOD5zPy0xMjg6MTI3PHM/MTI3OnM7Zm9yKHM9LTExMjsxMTI+PXM7KytzKUZuWzExMitzXT0tMTY+cz8tMTY6MTU8cz8xNTpzO2ZvcihzPS0yNTU7NTEwPj1zOysrcylJblsyNTUrc109MD5zPzA6MjU1PHM/MjU1OnM7Q249MX1hbj11ZSxvbj1hZSxjbj1vZSx1bj1zZSxsbj1jZSxzbj1pZSxobj1KZSxmbj1YZSxkbj0kZSxwbj1RZSxnbj1LZSxtbj1aZSx2bj10cixibj1lcix5bj16ZSx3bj1IZSxObj1XZSxMbj1WZSxmaVswXT14ZSxmaVsxXT1oZSxmaVsyXT1MZSxmaVszXT1BZSxmaVs0XT1TZSxmaVs1XT1QZSxmaVs2XT1fZSxmaVs3XT1rZSxmaVs4XT1JZSxmaVs5XT1GZSxoaVswXT12ZSxoaVsxXT1kZSxoaVsyXT1wZSxoaVszXT1nZSxoaVs0XT1iZSxoaVs1XT15ZSxoaVs2XT13ZSxkaVswXT1CZSxkaVsxXT1mZSxkaVsyXT1DZSxkaVszXT1qZSxkaVs0XT1FZSxkaVs1XT1NZSxkaVs2XT1xZSxzPTF9ZWxzZSBzPTB9cyYmKHM9ZnVuY3Rpb24odCxyKXtmb3IodC5NPTA7dC5NPHQuVmE7Kyt0Lk0pe3ZhciBvLHM9dC5KY1t0Lk0mdC5YYl0sYz10Lm0sdT10O2ZvcihvPTA7bzx1LnphOysrbyl7dmFyIGw9YyxoPXUsZj1oLkFjLGQ9aC5CYys0Km8scD1oLnpjLGc9aC55YVtoLmFhK29dO2lmKGguUWEuQmI/Zy4kYj1rKGwsaC5QYS5qYlswXSk/MitrKGwsaC5QYS5qYlsyXSk6ayhsLGguUGEuamJbMV0pOmcuJGI9MCxoLmtjJiYoZy5BZD1rKGwsaC5CZCkpLGcuWmE9IWsobCwxNDUpKzAsZy5aYSl7dmFyIG09Zy5PYix2PTA7Zm9yKGg9MDs0Pmg7KytoKXt2YXIgYix5PXBbMCtoXTtmb3IoYj0wOzQ+YjsrK2Ipe3k9Y2lbZltkK2JdXVt5XTtmb3IodmFyIHc9b2lbayhsLHlbMF0pXTswPHc7KXc9b2lbMip3K2sobCx5W3ddKV07eT0tdyxmW2QrYl09eX1uKG0sdixmLGQsNCksdis9NCxwWzAraF09eX19ZWxzZSB5PWsobCwxNTYpP2sobCwxMjgpPzE6MzprKGwsMTYzKT8yOjAsZy5PYlswXT15LGkoZixkLHksNCksaShwLDAseSw0KTtnLkRkPWsobCwxNDIpP2sobCwxMTQpP2sobCwxODMpPzE6MzoyOjB9aWYodS5tLkthKXJldHVybiBKdCh0LDcsIlByZW1hdHVyZSBlbmQtb2YtcGFydGl0aW9uMCBlbmNvdW50ZXJlZC4iKTtmb3IoO3QuamE8dC56YTsrK3QuamEpe2lmKHU9cyxsPShjPXQpLnJiW2Muc2ItMV0sZj1jLnJiW2Muc2IrYy5qYV0sbz1jLnlhW2MuYWErYy5qYV0sZD1jLmtjP28uQWQ6MClsLmxhPWYubGE9MCxvLlphfHwobC5OYT1mLk5hPTApLG8uSGM9MCxvLkdjPTAsby5pYT0wO2Vsc2V7dmFyIE4sTDtsPWYsZj11LGQ9Yy5QYS5YYyxwPWMueWFbYy5hYStjLmphXSxnPWMucGJbcC4kYl07aWYoaD1wLmFkLG09MCx2PWMucmJbYy5zYi0xXSx5PWI9MCxpKGgsbSwwLDM4NCkscC5aYSl2YXIgQT0wLHg9ZFszXTtlbHNle3c9YSgxNik7dmFyIFM9bC5OYSt2Lk5hO2lmKFM9bmkoZixkWzFdLFMsZy5FYiwwLHcsMCksbC5OYT12Lk5hPSgwPFMpKzAsMTxTKWFuKHcsMCxoLG0pO2Vsc2V7dmFyIF89d1swXSszPj4zO2Zvcih3PTA7MjU2Pnc7dys9MTYpaFttK3ddPV99QT0xLHg9ZFswXX12YXIgUD0xNSZsLmxhLEY9MTUmdi5sYTtmb3Iodz0wOzQ+dzsrK3cpe3ZhciBJPTEmRjtmb3IoXz1MPTA7ND5fOysrXylQPVA+PjF8KEk9KFM9bmkoZix4LFM9SSsoMSZQKSxnLlNjLEEsaCxtKSk+QSk8PDcsTD1MPDwyfCgzPFM/MzoxPFM/MjowIT1oW20rMF0pLG0rPTE2O1A+Pj00LEY9Rj4+MXxJPDw3LGI9KGI8PDh8TCk+Pj4wfWZvcih4PVAsQT1GPj40LE49MDs0Pk47Tis9Mil7Zm9yKEw9MCxQPWwubGE+PjQrTixGPXYubGE+PjQrTix3PTA7Mj53Oysrdyl7Zm9yKEk9MSZGLF89MDsyPl87KytfKVM9SSsoMSZQKSxQPVA+PjF8KEk9MDwoUz1uaShmLGRbMl0sUyxnLlFjLDAsaCxtKSkpPDwzLEw9TDw8MnwoMzxTPzM6MTxTPzI6MCE9aFttKzBdKSxtKz0xNjtQPj49MixGPUY+PjF8STw8NX15fD1MPDw0Kk4seHw9UDw8NDw8TixBfD0oMjQwJkYpPDxOfWwubGE9eCx2LmxhPUEscC5IYz1iLHAuR2M9eSxwLmlhPTQzNjkwJnk/MDpnLmlhLGQ9IShifHkpfWlmKDA8Yy5MJiYoYy53YVtjLlkrYy5qYV09Yy5nZFtvLiRiXVtvLlphXSxjLndhW2MuWStjLmphXS5MYXw9IWQpLHUuS2EpcmV0dXJuIEp0KHQsNywiUHJlbWF0dXJlIGVuZC1vZi1maWxlIGVuY291bnRlcmVkLiIpfWlmKCR0KHQpLGM9cix1PTEsbz0ocz10KS5ELGw9MDxzLkwmJnMuTT49cy56YiYmcy5NPD1zLlZhLDA9PXMuQWEpdDp7aWYoby5NPXMuTSxvLnVjPWwsT3IocyxvKSx1PTEsbz0oTD1zLkQpLk5iLGw9KHk9Umlbcy5MXSkqcy5SLGY9eS8yKnMuQix3PTE2Km8qcy5SLF89OCpvKnMuQixkPXMuc2EscD1zLnRhLWwrdyxnPXMucWEsaD1zLnJhLWYrXyxtPXMuSGEsdj1zLklhLWYrXyxGPTA9PShQPUwuTSksYj1QPj1zLlZhLTEsMj09cy5BYSYmT3IocyxMKSxMLnVjKWZvcihJPShTPXMpLkQuTSxlKFMuRC51YyksTD1TLnliO0w8Uy5IYjsrK0wpe0E9TCx4PUk7dmFyIEM9KGo9KFU9UykuRCkuTmI7Tj1VLlI7dmFyIGo9ai53YVtqLlkrQV0sTz1VLnNhLEI9VS50YSsxNipDKk4rMTYqQSxNPWouZGQsRT1qLnRjO2lmKDAhPUUpaWYoZSgzPD1FKSwxPT1VLkwpMDxBJiZ3bihPLEIsTixFKzQpLGouTGEmJkxuKE8sQixOLEUpLDA8eCYmeW4oTyxCLE4sRSs0KSxqLkxhJiZObihPLEIsTixFKTtlbHNle3ZhciBxPVUuQixEPVUucWEsUj1VLnJhKzgqQypxKzgqQSxUPVUuSGEsVT1VLklhKzgqQypxKzgqQTtDPWoubGQ7MDxBJiYoZm4oTyxCLE4sRSs0LE0sQykscG4oRCxSLFQsVSxxLEUrNCxNLEMpKSxqLkxhJiYobW4oTyxCLE4sRSxNLEMpLGJuKEQsUixULFUscSxFLE0sQykpLDA8eCYmKGhuKE8sQixOLEUrNCxNLEMpLGRuKEQsUixULFUscSxFKzQsTSxDKSksai5MYSYmKGduKE8sQixOLEUsTSxDKSx2bihELFIsVCxVLHEsRSxNLEMpKX19aWYocy5pYSYmYWxlcnQoInRvZG86RGl0aGVyUm93IiksbnVsbCE9Yy5wdXQpe2lmKEw9MTYqUCxQPTE2KihQKzEpLEY/KGMueT1zLnNhLGMuTz1zLnRhK3csYy5mPXMucWEsYy5OPXMucmErXyxjLmVhPXMuSGEsYy5XPXMuSWErXyk6KEwtPXksYy55PWQsYy5PPXAsYy5mPWcsYy5OPWgsYy5lYT1tLGMuVz12KSxifHwoUC09eSksUD5jLm8mJihQPWMubyksYy5GPW51bGwsYy5KPW51bGwsbnVsbCE9cy5GYSYmMDxzLkZhLmxlbmd0aCYmTDxQJiYoYy5KPWhyKHMsYyxMLFAtTCksYy5GPXMubWIsbnVsbD09Yy5GJiYwPT1jLkYubGVuZ3RoKSl7dT1KdChzLDMsIkNvdWxkIG5vdCBkZWNvZGUgYWxwaGEgZGF0YS4iKTticmVhayB0fUw8Yy5qJiYoeT1jLmotTCxMPWMuaixlKCEoMSZ5KSksYy5PKz1zLlIqeSxjLk4rPXMuQiooeT4+MSksYy5XKz1zLkIqKHk+PjEpLG51bGwhPWMuRiYmKGMuSis9Yy53aWR0aCp5KSksTDxQJiYoYy5PKz1jLnYsYy5OKz1jLnY+PjEsYy5XKz1jLnY+PjEsbnVsbCE9Yy5GJiYoYy5KKz1jLnYpLGMua2E9TC1jLmosYy5VPWMudmEtYy52LGMuVD1QLUwsdT1jLnB1dChjKSl9bysxIT1zLkljfHxifHwobihzLnNhLHMudGEtbCxkLHArMTYqcy5SLGwpLG4ocy5xYSxzLnJhLWYsZyxoKzgqcy5CLGYpLG4ocy5IYSxzLklhLWYsbSx2Kzgqcy5CLGYpKX1pZighdSlyZXR1cm4gSnQodCw2LCJPdXRwdXQgYWJvcnRlZC4iKX1yZXR1cm4gMX0odCxyKSksbnVsbCE9ci5iYyYmci5iYyhyKSxzJj0xfXJldHVybiBzPyh0LmNiPTAscyk6MH1mdW5jdGlvbiB0ZSh0LGUscixuLGkpe2k9dFtlK3IrMzIqbl0rKGk+PjMpLHRbZStyKzMyKm5dPS0yNTYmaT8wPmk/MDoyNTU6aX1mdW5jdGlvbiBlZSh0LGUscixuLGksYSl7dGUodCxlLDAscixuK2kpLHRlKHQsZSwxLHIsbithKSx0ZSh0LGUsMixyLG4tYSksdGUodCxlLDMscixuLWkpfWZ1bmN0aW9uIHJlKHQpe3JldHVybigyMDA5MSp0Pj4xNikrdH1mdW5jdGlvbiBuZSh0LGUscixuKXt2YXIgaSxvPTAscz1hKDE2KTtmb3IoaT0wOzQ+aTsrK2kpe3ZhciBjPXRbZSswXSt0W2UrOF0sdT10W2UrMF0tdFtlKzhdLGw9KDM1NDY4KnRbZSs0XT4+MTYpLXJlKHRbZSsxMl0pLGg9cmUodFtlKzRdKSsoMzU0NjgqdFtlKzEyXT4+MTYpO3NbbyswXT1jK2gsc1tvKzFdPXUrbCxzW28rMl09dS1sLHNbbyszXT1jLWgsbys9NCxlKyt9Zm9yKGk9bz0wOzQ+aTsrK2kpYz0odD1zW28rMF0rNCkrc1tvKzhdLHU9dC1zW28rOF0sbD0oMzU0Njgqc1tvKzRdPj4xNiktcmUoc1tvKzEyXSksdGUocixuLDAsMCxjKyhoPXJlKHNbbys0XSkrKDM1NDY4KnNbbysxMl0+PjE2KSkpLHRlKHIsbiwxLDAsdStsKSx0ZShyLG4sMiwwLHUtbCksdGUocixuLDMsMCxjLWgpLG8rKyxuKz0zMn1mdW5jdGlvbiBpZSh0LGUscixuKXt2YXIgaT10W2UrMF0rNCxhPTM1NDY4KnRbZSs0XT4+MTYsbz1yZSh0W2UrNF0pLHM9MzU0NjgqdFtlKzFdPj4xNjtlZShyLG4sMCxpK28sdD1yZSh0W2UrMV0pLHMpLGVlKHIsbiwxLGkrYSx0LHMpLGVlKHIsbiwyLGktYSx0LHMpLGVlKHIsbiwzLGktbyx0LHMpfWZ1bmN0aW9uIGFlKHQsZSxyLG4saSl7bmUodCxlLHIsbiksaSYmbmUodCxlKzE2LHIsbis0KX1mdW5jdGlvbiBvZSh0LGUscixuKXtvbih0LGUrMCxyLG4sMSksb24odCxlKzMyLHIsbisxMjgsMSl9ZnVuY3Rpb24gc2UodCxlLHIsbil7dmFyIGk7Zm9yKHQ9dFtlKzBdKzQsaT0wOzQ+aTsrK2kpZm9yKGU9MDs0PmU7KytlKXRlKHIsbixlLGksdCl9ZnVuY3Rpb24gY2UodCxlLHIsbil7dFtlKzBdJiZ1bih0LGUrMCxyLG4pLHRbZSsxNl0mJnVuKHQsZSsxNixyLG4rNCksdFtlKzMyXSYmdW4odCxlKzMyLHIsbisxMjgpLHRbZSs0OF0mJnVuKHQsZSs0OCxyLG4rMTI4KzQpfWZ1bmN0aW9uIHVlKHQsZSxyLG4pe3ZhciBpLG89YSgxNik7Zm9yKGk9MDs0Pmk7KytpKXt2YXIgcz10W2UrMCtpXSt0W2UrMTIraV0sYz10W2UrNCtpXSt0W2UrOCtpXSx1PXRbZSs0K2ldLXRbZSs4K2ldLGw9dFtlKzAraV0tdFtlKzEyK2ldO29bMCtpXT1zK2Msb1s4K2ldPXMtYyxvWzQraV09bCt1LG9bMTIraV09bC11fWZvcihpPTA7ND5pOysraSlzPSh0PW9bMCs0KmldKzMpK29bMys0KmldLGM9b1sxKzQqaV0rb1syKzQqaV0sdT1vWzErNCppXS1vWzIrNCppXSxsPXQtb1szKzQqaV0scltuKzBdPXMrYz4+MyxyW24rMTZdPWwrdT4+MyxyW24rMzJdPXMtYz4+MyxyW24rNDhdPWwtdT4+MyxuKz02NH1mdW5jdGlvbiBsZSh0LGUscil7dmFyIG4saT1lLTMyLGE9Qm4sbz0yNTUtdFtpLTFdO2ZvcihuPTA7bjxyOysrbil7dmFyIHMsYz1hLHU9byt0W2UtMV07Zm9yKHM9MDtzPHI7KytzKXRbZStzXT1jW3UrdFtpK3NdXTtlKz0zMn19ZnVuY3Rpb24gaGUodCxlKXtsZSh0LGUsNCl9ZnVuY3Rpb24gZmUodCxlKXtsZSh0LGUsOCl9ZnVuY3Rpb24gZGUodCxlKXtsZSh0LGUsMTYpfWZ1bmN0aW9uIHBlKHQsZSl7dmFyIHI7Zm9yKHI9MDsxNj5yOysrciluKHQsZSszMipyLHQsZS0zMiwxNil9ZnVuY3Rpb24gZ2UodCxlKXt2YXIgcjtmb3Iocj0xNjswPHI7LS1yKWkodCxlLHRbZS0xXSwxNiksZSs9MzJ9ZnVuY3Rpb24gbWUodCxlLHIpe3ZhciBuO2ZvcihuPTA7MTY+bjsrK24paShlLHIrMzIqbix0LDE2KX1mdW5jdGlvbiB2ZSh0LGUpe3ZhciByLG49MTY7Zm9yKHI9MDsxNj5yOysrciluKz10W2UtMSszMipyXSt0W2Urci0zMl07bWUobj4+NSx0LGUpfWZ1bmN0aW9uIGJlKHQsZSl7dmFyIHIsbj04O2ZvcihyPTA7MTY+cjsrK3Ipbis9dFtlLTErMzIqcl07bWUobj4+NCx0LGUpfWZ1bmN0aW9uIHllKHQsZSl7dmFyIHIsbj04O2ZvcihyPTA7MTY+cjsrK3Ipbis9dFtlK3ItMzJdO21lKG4+PjQsdCxlKX1mdW5jdGlvbiB3ZSh0LGUpe21lKDEyOCx0LGUpfWZ1bmN0aW9uIE5lKHQsZSxyKXtyZXR1cm4gdCsyKmUrcisyPj4yfWZ1bmN0aW9uIExlKHQsZSl7dmFyIHIsaT1lLTMyO2k9bmV3IFVpbnQ4QXJyYXkoW05lKHRbaS0xXSx0W2krMF0sdFtpKzFdKSxOZSh0W2krMF0sdFtpKzFdLHRbaSsyXSksTmUodFtpKzFdLHRbaSsyXSx0W2krM10pLE5lKHRbaSsyXSx0W2krM10sdFtpKzRdKV0pO2ZvcihyPTA7ND5yOysrciluKHQsZSszMipyLGksMCxpLmxlbmd0aCl9ZnVuY3Rpb24gQWUodCxlKXt2YXIgcj10W2UtMV0sbj10W2UtMSszMl0saT10W2UtMSs2NF0sYT10W2UtMSs5Nl07Rih0LGUrMCwxNjg0MzAwOSpOZSh0W2UtMS0zMl0scixuKSksRih0LGUrMzIsMTY4NDMwMDkqTmUocixuLGkpKSxGKHQsZSs2NCwxNjg0MzAwOSpOZShuLGksYSkpLEYodCxlKzk2LDE2ODQzMDA5Kk5lKGksYSxhKSl9ZnVuY3Rpb24geGUodCxlKXt2YXIgcixuPTQ7Zm9yKHI9MDs0PnI7KytyKW4rPXRbZStyLTMyXSt0W2UtMSszMipyXTtmb3Iobj4+PTMscj0wOzQ+cjsrK3IpaSh0LGUrMzIqcixuLDQpfWZ1bmN0aW9uIFNlKHQsZSl7dmFyIHI9dFtlLTErMF0sbj10W2UtMSszMl0saT10W2UtMSs2NF0sYT10W2UtMS0zMl0sbz10W2UrMC0zMl0scz10W2UrMS0zMl0sYz10W2UrMi0zMl0sdT10W2UrMy0zMl07dFtlKzArOTZdPU5lKG4saSx0W2UtMSs5Nl0pLHRbZSsxKzk2XT10W2UrMCs2NF09TmUocixuLGkpLHRbZSsyKzk2XT10W2UrMSs2NF09dFtlKzArMzJdPU5lKGEscixuKSx0W2UrMys5Nl09dFtlKzIrNjRdPXRbZSsxKzMyXT10W2UrMCswXT1OZShvLGEsciksdFtlKzMrNjRdPXRbZSsyKzMyXT10W2UrMSswXT1OZShzLG8sYSksdFtlKzMrMzJdPXRbZSsyKzBdPU5lKGMscyxvKSx0W2UrMyswXT1OZSh1LGMscyl9ZnVuY3Rpb24gX2UodCxlKXt2YXIgcj10W2UrMS0zMl0sbj10W2UrMi0zMl0saT10W2UrMy0zMl0sYT10W2UrNC0zMl0sbz10W2UrNS0zMl0scz10W2UrNi0zMl0sYz10W2UrNy0zMl07dFtlKzArMF09TmUodFtlKzAtMzJdLHIsbiksdFtlKzErMF09dFtlKzArMzJdPU5lKHIsbixpKSx0W2UrMiswXT10W2UrMSszMl09dFtlKzArNjRdPU5lKG4saSxhKSx0W2UrMyswXT10W2UrMiszMl09dFtlKzErNjRdPXRbZSswKzk2XT1OZShpLGEsbyksdFtlKzMrMzJdPXRbZSsyKzY0XT10W2UrMSs5Nl09TmUoYSxvLHMpLHRbZSszKzY0XT10W2UrMis5Nl09TmUobyxzLGMpLHRbZSszKzk2XT1OZShzLGMsYyl9ZnVuY3Rpb24gUGUodCxlKXt2YXIgcj10W2UtMSswXSxuPXRbZS0xKzMyXSxpPXRbZS0xKzY0XSxhPXRbZS0xLTMyXSxvPXRbZSswLTMyXSxzPXRbZSsxLTMyXSxjPXRbZSsyLTMyXSx1PXRbZSszLTMyXTt0W2UrMCswXT10W2UrMSs2NF09YStvKzE+PjEsdFtlKzErMF09dFtlKzIrNjRdPW8rcysxPj4xLHRbZSsyKzBdPXRbZSszKzY0XT1zK2MrMT4+MSx0W2UrMyswXT1jK3UrMT4+MSx0W2UrMCs5Nl09TmUoaSxuLHIpLHRbZSswKzY0XT1OZShuLHIsYSksdFtlKzArMzJdPXRbZSsxKzk2XT1OZShyLGEsbyksdFtlKzErMzJdPXRbZSsyKzk2XT1OZShhLG8scyksdFtlKzIrMzJdPXRbZSszKzk2XT1OZShvLHMsYyksdFtlKzMrMzJdPU5lKHMsYyx1KX1mdW5jdGlvbiBrZSh0LGUpe3ZhciByPXRbZSswLTMyXSxuPXRbZSsxLTMyXSxpPXRbZSsyLTMyXSxhPXRbZSszLTMyXSxvPXRbZSs0LTMyXSxzPXRbZSs1LTMyXSxjPXRbZSs2LTMyXSx1PXRbZSs3LTMyXTt0W2UrMCswXT1yK24rMT4+MSx0W2UrMSswXT10W2UrMCs2NF09bitpKzE+PjEsdFtlKzIrMF09dFtlKzErNjRdPWkrYSsxPj4xLHRbZSszKzBdPXRbZSsyKzY0XT1hK28rMT4+MSx0W2UrMCszMl09TmUocixuLGkpLHRbZSsxKzMyXT10W2UrMCs5Nl09TmUobixpLGEpLHRbZSsyKzMyXT10W2UrMSs5Nl09TmUoaSxhLG8pLHRbZSszKzMyXT10W2UrMis5Nl09TmUoYSxvLHMpLHRbZSszKzY0XT1OZShvLHMsYyksdFtlKzMrOTZdPU5lKHMsYyx1KX1mdW5jdGlvbiBGZSh0LGUpe3ZhciByPXRbZS0xKzBdLG49dFtlLTErMzJdLGk9dFtlLTErNjRdLGE9dFtlLTErOTZdO3RbZSswKzBdPXIrbisxPj4xLHRbZSsyKzBdPXRbZSswKzMyXT1uK2krMT4+MSx0W2UrMiszMl09dFtlKzArNjRdPWkrYSsxPj4xLHRbZSsxKzBdPU5lKHIsbixpKSx0W2UrMyswXT10W2UrMSszMl09TmUobixpLGEpLHRbZSszKzMyXT10W2UrMSs2NF09TmUoaSxhLGEpLHRbZSszKzY0XT10W2UrMis2NF09dFtlKzArOTZdPXRbZSsxKzk2XT10W2UrMis5Nl09dFtlKzMrOTZdPWF9ZnVuY3Rpb24gSWUodCxlKXt2YXIgcj10W2UtMSswXSxuPXRbZS0xKzMyXSxpPXRbZS0xKzY0XSxhPXRbZS0xKzk2XSxvPXRbZS0xLTMyXSxzPXRbZSswLTMyXSxjPXRbZSsxLTMyXSx1PXRbZSsyLTMyXTt0W2UrMCswXT10W2UrMiszMl09citvKzE+PjEsdFtlKzArMzJdPXRbZSsyKzY0XT1uK3IrMT4+MSx0W2UrMCs2NF09dFtlKzIrOTZdPWkrbisxPj4xLHRbZSswKzk2XT1hK2krMT4+MSx0W2UrMyswXT1OZShzLGMsdSksdFtlKzIrMF09TmUobyxzLGMpLHRbZSsxKzBdPXRbZSszKzMyXT1OZShyLG8scyksdFtlKzErMzJdPXRbZSszKzY0XT1OZShuLHIsbyksdFtlKzErNjRdPXRbZSszKzk2XT1OZShpLG4sciksdFtlKzErOTZdPU5lKGEsaSxuKX1mdW5jdGlvbiBDZSh0LGUpe3ZhciByO2ZvcihyPTA7OD5yOysrciluKHQsZSszMipyLHQsZS0zMiw4KX1mdW5jdGlvbiBqZSh0LGUpe3ZhciByO2ZvcihyPTA7OD5yOysrcilpKHQsZSx0W2UtMV0sOCksZSs9MzJ9ZnVuY3Rpb24gT2UodCxlLHIpe3ZhciBuO2ZvcihuPTA7OD5uOysrbilpKGUsciszMipuLHQsOCl9ZnVuY3Rpb24gQmUodCxlKXt2YXIgcixuPTg7Zm9yKHI9MDs4PnI7KytyKW4rPXRbZStyLTMyXSt0W2UtMSszMipyXTtPZShuPj40LHQsZSl9ZnVuY3Rpb24gTWUodCxlKXt2YXIgcixuPTQ7Zm9yKHI9MDs4PnI7KytyKW4rPXRbZStyLTMyXTtPZShuPj4zLHQsZSl9ZnVuY3Rpb24gRWUodCxlKXt2YXIgcixuPTQ7Zm9yKHI9MDs4PnI7KytyKW4rPXRbZS0xKzMyKnJdO09lKG4+PjMsdCxlKX1mdW5jdGlvbiBxZSh0LGUpe09lKDEyOCx0LGUpfWZ1bmN0aW9uIERlKHQsZSxyKXt2YXIgbj10W2Utcl0saT10W2UrMF0sYT0zKihpLW4pK2puWzEwMjArdFtlLTIqcl0tdFtlK3JdXSxvPU9uWzExMisoYSs0Pj4zKV07dFtlLXJdPUJuWzI1NStuK09uWzExMisoYSszPj4zKV1dLHRbZSswXT1CblsyNTUraS1vXX1mdW5jdGlvbiBSZSh0LGUscixuKXt2YXIgaT10W2UrMF0sYT10W2Urcl07cmV0dXJuIE1uWzI1NSt0W2UtMipyXS10W2Utcl1dPm58fE1uWzI1NSthLWldPm59ZnVuY3Rpb24gVGUodCxlLHIsbil7cmV0dXJuIDQqTW5bMjU1K3RbZS1yXS10W2UrMF1dK01uWzI1NSt0W2UtMipyXS10W2Urcl1dPD1ufWZ1bmN0aW9uIFVlKHQsZSxyLG4saSl7dmFyIGE9dFtlLTMqcl0sbz10W2UtMipyXSxzPXRbZS1yXSxjPXRbZSswXSx1PXRbZStyXSxsPXRbZSsyKnJdLGg9dFtlKzMqcl07cmV0dXJuIDQqTW5bMjU1K3MtY10rTW5bMjU1K28tdV0+bj8wOk1uWzI1NSt0W2UtNCpyXS1hXTw9aSYmTW5bMjU1K2Etb108PWkmJk1uWzI1NStvLXNdPD1pJiZNblsyNTUraC1sXTw9aSYmTW5bMjU1K2wtdV08PWkmJk1uWzI1NSt1LWNdPD1pfWZ1bmN0aW9uIHplKHQsZSxyLG4pe3ZhciBpPTIqbisxO2ZvcihuPTA7MTY+bjsrK24pVGUodCxlK24scixpKSYmRGUodCxlK24scil9ZnVuY3Rpb24gSGUodCxlLHIsbil7dmFyIGk9MipuKzE7Zm9yKG49MDsxNj5uOysrbilUZSh0LGUrbipyLDEsaSkmJkRlKHQsZStuKnIsMSl9ZnVuY3Rpb24gV2UodCxlLHIsbil7dmFyIGk7Zm9yKGk9MzswPGk7LS1pKXplKHQsZSs9NCpyLHIsbil9ZnVuY3Rpb24gVmUodCxlLHIsbil7dmFyIGk7Zm9yKGk9MzswPGk7LS1pKUhlKHQsZSs9NCxyLG4pfWZ1bmN0aW9uIEdlKHQsZSxyLG4saSxhLG8scyl7Zm9yKGE9MiphKzE7MDxpLS07KXtpZihVZSh0LGUscixhLG8pKWlmKFJlKHQsZSxyLHMpKURlKHQsZSxyKTtlbHNle3ZhciBjPXQsdT1lLGw9cixoPWNbdS0yKmxdLGY9Y1t1LWxdLGQ9Y1t1KzBdLHA9Y1t1K2xdLGc9Y1t1KzIqbF0sbT0yNyooYj1qblsxMDIwKzMqKGQtZikram5bMTAyMCtoLXBdXSkrNjM+Pjcsdj0xOCpiKzYzPj43LGI9OSpiKzYzPj43O2NbdS0zKmxdPUJuWzI1NStjW3UtMypsXStiXSxjW3UtMipsXT1CblsyNTUraCt2XSxjW3UtbF09Qm5bMjU1K2YrbV0sY1t1KzBdPUJuWzI1NStkLW1dLGNbdStsXT1CblsyNTUrcC12XSxjW3UrMipsXT1CblsyNTUrZy1iXX1lKz1ufX1mdW5jdGlvbiBZZSh0LGUscixuLGksYSxvLHMpe2ZvcihhPTIqYSsxOzA8aS0tOyl7aWYoVWUodCxlLHIsYSxvKSlpZihSZSh0LGUscixzKSlEZSh0LGUscik7ZWxzZXt2YXIgYz10LHU9ZSxsPXIsaD1jW3UtbF0sZj1jW3UrMF0sZD1jW3UrbF0scD1PblsxMTIrKChnPTMqKGYtaCkpKzQ+PjMpXSxnPU9uWzExMisoZyszPj4zKV0sbT1wKzE+PjE7Y1t1LTIqbF09Qm5bMjU1K2NbdS0yKmxdK21dLGNbdS1sXT1CblsyNTUraCtnXSxjW3UrMF09Qm5bMjU1K2YtcF0sY1t1K2xdPUJuWzI1NStkLW1dfWUrPW59fWZ1bmN0aW9uIEplKHQsZSxyLG4saSxhKXtHZSh0LGUsciwxLDE2LG4saSxhKX1mdW5jdGlvbiBYZSh0LGUscixuLGksYSl7R2UodCxlLDEsciwxNixuLGksYSl9ZnVuY3Rpb24gS2UodCxlLHIsbixpLGEpe3ZhciBvO2ZvcihvPTM7MDxvOy0tbylZZSh0LGUrPTQqcixyLDEsMTYsbixpLGEpfWZ1bmN0aW9uIFplKHQsZSxyLG4saSxhKXt2YXIgbztmb3Iobz0zOzA8bzstLW8pWWUodCxlKz00LDEsciwxNixuLGksYSl9ZnVuY3Rpb24gJGUodCxlLHIsbixpLGEsbyxzKXtHZSh0LGUsaSwxLDgsYSxvLHMpLEdlKHIsbixpLDEsOCxhLG8scyl9ZnVuY3Rpb24gUWUodCxlLHIsbixpLGEsbyxzKXtHZSh0LGUsMSxpLDgsYSxvLHMpLEdlKHIsbiwxLGksOCxhLG8scyl9ZnVuY3Rpb24gdHIodCxlLHIsbixpLGEsbyxzKXtZZSh0LGUrNCppLGksMSw4LGEsbyxzKSxZZShyLG4rNCppLGksMSw4LGEsbyxzKX1mdW5jdGlvbiBlcih0LGUscixuLGksYSxvLHMpe1llKHQsZSs0LDEsaSw4LGEsbyxzKSxZZShyLG4rNCwxLGksOCxhLG8scyl9ZnVuY3Rpb24gcnIoKXt0aGlzLmJhPW5ldyBvdCx0aGlzLmVjPVtdLHRoaXMuY2M9W10sdGhpcy5NYz1bXSx0aGlzLkRjPXRoaXMuTmM9dGhpcy5kYz10aGlzLmZjPTAsdGhpcy5PYT1uZXcgY3QsdGhpcy5tZW1vcnk9MCx0aGlzLkliPSJPdXRwdXRGdW5jIix0aGlzLkpiPSJPdXRwdXRBbHBoYUZ1bmMiLHRoaXMuTmQ9Ik91dHB1dFJvd0Z1bmMifWZ1bmN0aW9uIG5yKCl7dGhpcy5kYXRhPVtdLHRoaXMub2Zmc2V0PXRoaXMua2Q9dGhpcy5oYT10aGlzLnc9MCx0aGlzLm5hPVtdLHRoaXMueGE9dGhpcy5nYj10aGlzLkphPXRoaXMuU2E9dGhpcy5QPTB9ZnVuY3Rpb24gaXIoKXt0aGlzLm5jPXRoaXMuRWE9dGhpcy5iPXRoaXMuaGM9MCx0aGlzLks9W10sdGhpcy53PTB9ZnVuY3Rpb24gYXIoKXt0aGlzLnVhPTAsdGhpcy5XYT1uZXcgTSx0aGlzLnZiPW5ldyBNLHRoaXMubWQ9dGhpcy54Yz10aGlzLndjPTAsdGhpcy52Yz1bXSx0aGlzLldiPTAsdGhpcy5ZYT1uZXcgZCx0aGlzLnljPW5ldyBofWZ1bmN0aW9uIG9yKCl7dGhpcy54Yj10aGlzLmE9MCx0aGlzLmw9bmV3IEd0LHRoaXMuY2E9bmV3IG90LHRoaXMuVj1bXSx0aGlzLkJhPTAsdGhpcy5UYT1bXSx0aGlzLlVhPTAsdGhpcy5tPW5ldyBOLHRoaXMuUGI9MCx0aGlzLndkPW5ldyBOLHRoaXMuTWE9dGhpcy4kPXRoaXMuQz10aGlzLmk9dGhpcy5jPXRoaXMueGQ9MCx0aGlzLnM9bmV3IGFyLHRoaXMuYWI9MCx0aGlzLmdjPW8oNCxpciksdGhpcy5PYz0wfWZ1bmN0aW9uIHNyKCl7dGhpcy5MYz10aGlzLlo9dGhpcy4kYT10aGlzLmk9dGhpcy5jPTAsdGhpcy5sPW5ldyBHdCx0aGlzLmljPTAsdGhpcy5jYT1bXSx0aGlzLnRiPTAsdGhpcy5xZD1udWxsLHRoaXMucmQ9MH1mdW5jdGlvbiBjcih0LGUscixuLGksYSxvKXtmb3IodD1udWxsPT10PzA6dFtlKzBdLGU9MDtlPG87KytlKWlbYStlXT10K3JbbitlXSYyNTUsdD1pW2ErZV19ZnVuY3Rpb24gdXIodCxlLHIsbixpLGEsbyl7dmFyIHM7aWYobnVsbD09dCljcihudWxsLG51bGwscixuLGksYSxvKTtlbHNlIGZvcihzPTA7czxvOysrcylpW2Erc109dFtlK3NdK3JbbitzXSYyNTV9ZnVuY3Rpb24gbHIodCxlLHIsbixpLGEsbyl7aWYobnVsbD09dCljcihudWxsLG51bGwscixuLGksYSxvKTtlbHNle3ZhciBzLGM9dFtlKzBdLHU9YyxsPWM7Zm9yKHM9MDtzPG87KytzKXU9bCsoYz10W2Urc10pLXUsbD1yW24rc10rKC0yNTYmdT8wPnU/MDoyNTU6dSkmMjU1LHU9YyxpW2Erc109bH19ZnVuY3Rpb24gaHIodCxyLGksbyl7dmFyIHM9ci53aWR0aCxjPXIubztpZihlKG51bGwhPXQmJm51bGwhPXIpLDA+aXx8MD49b3x8aStvPmMpcmV0dXJuIG51bGw7aWYoIXQuQ2Mpe2lmKG51bGw9PXQuZ2Epe3ZhciB1O2lmKHQuZ2E9bmV3IHNyLCh1PW51bGw9PXQuZ2EpfHwodT1yLndpZHRoKnIubyxlKDA9PXQuR2IubGVuZ3RoKSx0LkdiPWEodSksdC5VYz0wLG51bGw9PXQuR2I/dT0wOih0Lm1iPXQuR2IsdC5uYj10LlVjLHQucmM9bnVsbCx1PTEpLHU9IXUpLCF1KXt1PXQuZ2E7dmFyIGw9dC5GYSxoPXQuUCxmPXQucWMsZD10Lm1iLHA9dC5uYixnPWgrMSxtPWYtMSxiPXUubDtpZihlKG51bGwhPWwmJm51bGwhPWQmJm51bGwhPXIpLG1pWzBdPW51bGwsbWlbMV09Y3IsbWlbMl09dXIsbWlbM109bHIsdS5jYT1kLHUudGI9cCx1LmM9ci53aWR0aCx1Lmk9ci5oZWlnaHQsZSgwPHUuYyYmMDx1LmkpLDE+PWYpcj0wO2Vsc2UgaWYodS4kYT1sW2grMF0+PjAmMyx1Llo9bFtoKzBdPj4yJjMsdS5MYz1sW2grMF0+PjQmMyxoPWxbaCswXT4+NiYzLDA+dS4kYXx8MTx1LiRhfHw0PD11Llp8fDE8dS5MY3x8aClyPTA7ZWxzZSBpZihiLnB1dD1kdCxiLmFjPWZ0LGIuYmM9cHQsYi5tYT11LGIud2lkdGg9ci53aWR0aCxiLmhlaWdodD1yLmhlaWdodCxiLkRhPXIuRGEsYi52PXIudixiLnZhPXIudmEsYi5qPXIuaixiLm89ci5vLHUuJGEpdDp7ZSgxPT11LiRhKSxyPWt0KCk7ZTpmb3IoOzspe2lmKG51bGw9PXIpe3I9MDticmVhayB0fWlmKGUobnVsbCE9dSksdS5tYz1yLHIuYz11LmMsci5pPXUuaSxyLmw9dS5sLHIubC5tYT11LHIubC53aWR0aD11LmMsci5sLmhlaWdodD11Lmksci5hPTAsdihyLm0sbCxnLG0pLCFGdCh1LmMsdS5pLDEscixudWxsKSlicmVhayBlO2lmKDE9PXIuYWImJjM9PXIuZ2NbMF0uaGMmJkF0KHIucyk/KHUuaWM9MSxsPXIuYypyLmksci5UYT1udWxsLHIuVWE9MCxyLlY9YShsKSxyLkJhPTAsbnVsbD09ci5WPyhyLmE9MSxyPTApOnI9MSk6KHUuaWM9MCxyPUl0KHIsdS5jKSksIXIpYnJlYWsgZTtyPTE7YnJlYWsgdH11Lm1jPW51bGwscj0wfWVsc2Ugcj1tPj11LmMqdS5pO3U9IXJ9aWYodSlyZXR1cm4gbnVsbDsxIT10LmdhLkxjP3QuR2E9MDpvPWMtaX1lKG51bGwhPXQuZ2EpLGUoaStvPD1jKTt0OntpZihyPShsPXQuZ2EpLmMsYz1sLmwubywwPT1sLiRhKXtpZihnPXQucmMsbT10LlZjLGI9dC5GYSxoPXQuUCsxK2kqcixmPXQubWIsZD10Lm5iK2kqcixlKGg8PXQuUCt0LnFjKSwwIT1sLlopZm9yKGUobnVsbCE9bWlbbC5aXSksdT0wO3U8bzsrK3UpbWlbbC5aXShnLG0sYixoLGYsZCxyKSxnPWYsbT1kLGQrPXIsaCs9cjtlbHNlIGZvcih1PTA7dTxvOysrdSluKGYsZCxiLGgsciksZz1mLG09ZCxkKz1yLGgrPXI7dC5yYz1nLHQuVmM9bX1lbHNle2lmKGUobnVsbCE9bC5tYykscj1pK28sZShudWxsIT0odT1sLm1jKSksZShyPD11LmkpLHUuQz49cilyPTE7ZWxzZSBpZihsLmljfHxtcigpLGwuaWMpe2w9dS5WLGc9dS5CYSxtPXUuYzt2YXIgeT11Lmksdz0oYj0xLGg9dS4kL20sZj11LiQlbSxkPXUubSxwPXUucyx1LiQpLE49bSp5LEw9bSpyLHg9cC53YyxfPXc8TD93dChwLGYsaCk6bnVsbDtlKHc8PU4pLGUocjw9eSksZShBdChwKSk7ZTpmb3IoOzspe2Zvcig7IWQuaCYmdzxMOyl7aWYoZiZ4fHwoXz13dChwLGYsaCkpLGUobnVsbCE9XyksUyhkKSwyNTY+KHk9YnQoXy5HWzBdLF8uSFswXSxkKSkpbFtnK3ddPXksKyt3LCsrZj49bSYmKGY9MCwrK2g8PXImJiEoaCUxNikmJlN0KHUsaCkpO2Vsc2V7aWYoISgyODA+eSkpe2I9MDticmVhayBlfXk9bXQoeS0yNTYsZCk7dmFyIFAsaz1idChfLkdbNF0sXy5IWzRdLGQpO2lmKFMoZCksISh3Pj0oaz12dChtLGs9bXQoayxkKSkpJiZOLXc+PXkpKXtiPTA7YnJlYWsgZX1mb3IoUD0wO1A8eTsrK1ApbFtnK3crUF09bFtnK3crUC1rXTtmb3Iodys9eSxmKz15O2Y+PW07KWYtPW0sKytoPD1yJiYhKGglMTYpJiZTdCh1LGgpO3c8TCYmZiZ4JiYoXz13dChwLGYsaCkpfWUoZC5oPT1BKGQpKX1TdCh1LGg+cj9yOmgpO2JyZWFrIGV9IWJ8fGQuaCYmdzxOPyhiPTAsdS5hPWQuaD81OjMpOnUuJD13LHI9Yn1lbHNlIHI9X3QodSx1LlYsdS5CYSx1LmMsdS5pLHIsQ3QpO2lmKCFyKXtvPTA7YnJlYWsgdH19aStvPj1jJiYodC5DYz0xKSxvPTF9aWYoIW8pcmV0dXJuIG51bGw7aWYodC5DYyYmKG51bGwhPShvPXQuZ2EpJiYoby5tYz1udWxsKSx0LmdhPW51bGwsMDx0LkdhKSlyZXR1cm4gYWxlcnQoInRvZG86V2ViUERlcXVhbnRpemVMZXZlbHMiKSxudWxsfXJldHVybiB0Lm5iK2kqc31mdW5jdGlvbiBmcih0LGUscixuLGksYSl7Zm9yKDswPGktLTspe3ZhciBvLHM9dCxjPWUrKHI/MTowKSx1PXQsbD1lKyhyPzA6Myk7Zm9yKG89MDtvPG47KytvKXt2YXIgaD11W2wrNCpvXTsyNTUhPWgmJihoKj0zMjg5NyxzW2MrNCpvKzBdPXNbYys0Km8rMF0qaD4+MjMsc1tjKzQqbysxXT1zW2MrNCpvKzFdKmg+PjIzLHNbYys0Km8rMl09c1tjKzQqbysyXSpoPj4yMyl9ZSs9YX19ZnVuY3Rpb24gZHIodCxlLHIsbixpKXtmb3IoOzA8bi0tOyl7dmFyIGE7Zm9yKGE9MDthPHI7KythKXt2YXIgbz10W2UrMiphKzBdLHM9MTUmKHU9dFtlKzIqYSsxXSksYz00MzY5KnMsdT0oMjQwJnV8dT4+NCkqYz4+MTY7dFtlKzIqYSswXT0oMjQwJm98bz4+NCkqYz4+MTYmMjQwfCgxNSZvfG88PDQpKmM+PjE2Pj40JjE1LHRbZSsyKmErMV09MjQwJnV8c31lKz1pfX1mdW5jdGlvbiBwcih0LGUscixuLGksYSxvLHMpe3ZhciBjLHUsbD0yNTU7Zm9yKHU9MDt1PGk7Kyt1KXtmb3IoYz0wO2M8bjsrK2Mpe3ZhciBoPXRbZStjXTthW28rNCpjXT1oLGwmPWh9ZSs9cixvKz1zfXJldHVybiAyNTUhPWx9ZnVuY3Rpb24gZ3IodCxlLHIsbixpKXt2YXIgYTtmb3IoYT0wO2E8aTsrK2EpcltuK2FdPXRbZSthXT4+OH1mdW5jdGlvbiBtcigpe0FuPWZyLHhuPWRyLFNuPXByLF9uPWdyfWZ1bmN0aW9uIHZyKHIsbixpKXt0W3JdPWZ1bmN0aW9uKHQscixhLG8scyxjLHUsbCxoLGYsZCxwLGcsbSx2LGIseSl7dmFyIHcsTj15LTE+PjEsTD1zW2MrMF18dVtsKzBdPDwxNixBPWhbZiswXXxkW3ArMF08PDE2O2UobnVsbCE9dCk7dmFyIHg9MypMK0ErMTMxMDc0Pj4yO2ZvcihuKHRbciswXSwyNTUmeCx4Pj4xNixnLG0pLG51bGwhPWEmJih4PTMqQStMKzEzMTA3ND4+MixuKGFbbyswXSwyNTUmeCx4Pj4xNix2LGIpKSx3PTE7dzw9TjsrK3cpe3ZhciBTPXNbYyt3XXx1W2wrd108PDE2LF89aFtmK3ddfGRbcCt3XTw8MTYsUD1MK1MrQStfKzUyNDI5NixrPVArMiooUytBKT4+Mzt4PWsrTD4+MSxMPShQPVArMiooTCtfKT4+MykrUz4+MSxuKHRbcisyKnctMV0sMjU1JngseD4+MTYsZyxtKygyKnctMSkqaSksbih0W3IrMip3LTBdLDI1NSZMLEw+PjE2LGcsbSsoMip3LTApKmkpLG51bGwhPWEmJih4PVArQT4+MSxMPWsrXz4+MSxuKGFbbysyKnctMV0sMjU1JngseD4+MTYsdixiKygyKnctMSkqaSksbihhW28rMip3KzBdLDI1NSZMLEw+PjE2LHYsYisoMip3KzApKmkpKSxMPVMsQT1ffTEmeXx8KHg9MypMK0ErMTMxMDc0Pj4yLG4odFtyK3ktMV0sMjU1JngseD4+MTYsZyxtKyh5LTEpKmkpLG51bGwhPWEmJih4PTMqQStMKzEzMTA3ND4+MixuKGFbbyt5LTFdLDI1NSZ4LHg+PjE2LHYsYisoeS0xKSppKSkpfX1mdW5jdGlvbiBicigpe3ZpW0VuXT1iaSx2aVtxbl09d2ksdmlbRG5dPXlpLHZpW1JuXT1OaSx2aVtUbl09TGksdmlbVW5dPUFpLHZpW3puXT14aSx2aVtIbl09d2ksdmlbV25dPU5pLHZpW1ZuXT1MaSx2aVtHbl09QWl9ZnVuY3Rpb24geXIodCl7cmV0dXJuIHQmfklpPzA+dD8wOjI1NTp0Pj5GaX1mdW5jdGlvbiB3cih0LGUpe3JldHVybiB5cigoMTkwNzcqdD4+OCkrKDI2MTQ5KmU+PjgpLTE0MjM0KX1mdW5jdGlvbiBOcih0LGUscil7cmV0dXJuIHlyKCgxOTA3Nyp0Pj44KS0oNjQxOSplPj44KS0oMTMzMjAqcj4+OCkrODcwOCl9ZnVuY3Rpb24gTHIodCxlKXtyZXR1cm4geXIoKDE5MDc3KnQ+PjgpKygzMzA1MCplPj44KS0xNzY4NSl9ZnVuY3Rpb24gQXIodCxlLHIsbixpKXtuW2krMF09d3IodCxyKSxuW2krMV09TnIodCxlLHIpLG5baSsyXT1Mcih0LGUpfWZ1bmN0aW9uIHhyKHQsZSxyLG4saSl7bltpKzBdPUxyKHQsZSksbltpKzFdPU5yKHQsZSxyKSxuW2krMl09d3IodCxyKX1mdW5jdGlvbiBTcih0LGUscixuLGkpe3ZhciBhPU5yKHQsZSxyKTtlPWE8PDMmMjI0fExyKHQsZSk+PjMsbltpKzBdPTI0OCZ3cih0LHIpfGE+PjUsbltpKzFdPWV9ZnVuY3Rpb24gX3IodCxlLHIsbixpKXt2YXIgYT0yNDAmTHIodCxlKXwxNTtuW2krMF09MjQwJndyKHQscil8TnIodCxlLHIpPj40LG5baSsxXT1hfWZ1bmN0aW9uIFByKHQsZSxyLG4saSl7bltpKzBdPTI1NSxBcih0LGUscixuLGkrMSl9ZnVuY3Rpb24ga3IodCxlLHIsbixpKXt4cih0LGUscixuLGkpLG5baSszXT0yNTV9ZnVuY3Rpb24gRnIodCxlLHIsbixpKXtBcih0LGUscixuLGkpLG5baSszXT0yNTV9ZnVuY3Rpb24gVnQodCxlKXtyZXR1cm4gMD50PzA6dD5lP2U6dH1mdW5jdGlvbiBJcihlLHIsbil7dFtlXT1mdW5jdGlvbih0LGUsaSxhLG8scyxjLHUsbCl7Zm9yKHZhciBoPXUrKC0yJmwpKm47dSE9aDspcih0W2UrMF0saVthKzBdLG9bcyswXSxjLHUpLHIodFtlKzFdLGlbYSswXSxvW3MrMF0sYyx1K24pLGUrPTIsKythLCsrcyx1Kz0yKm47MSZsJiZyKHRbZSswXSxpW2ErMF0sb1tzKzBdLGMsdSl9fWZ1bmN0aW9uIENyKHQsZSxyKXtyZXR1cm4gMD09cj8wPT10PzA9PWU/Njo1OjA9PWU/NDowOnJ9ZnVuY3Rpb24ganIodCxlLHIsbixpKXtzd2l0Y2godD4+PjMwKXtjYXNlIDM6b24oZSxyLG4saSwwKTticmVhaztjYXNlIDI6c24oZSxyLG4saSk7YnJlYWs7Y2FzZSAxOnVuKGUscixuLGkpfX1mdW5jdGlvbiBPcih0LGUpe3ZhciByLGEsbz1lLk0scz1lLk5iLGM9dC5vYyx1PXQucGMrNDAsbD10Lm9jLGg9dC5wYys1ODQsZj10Lm9jLGQ9dC5wYys2MDA7Zm9yKHI9MDsxNj5yOysrciljW3UrMzIqci0xXT0xMjk7Zm9yKHI9MDs4PnI7KytyKWxbaCszMipyLTFdPTEyOSxmW2QrMzIqci0xXT0xMjk7Zm9yKDA8bz9jW3UtMS0zMl09bFtoLTEtMzJdPWZbZC0xLTMyXT0xMjk6KGkoYyx1LTMyLTEsMTI3LDIxKSxpKGwsaC0zMi0xLDEyNyw5KSxpKGYsZC0zMi0xLDEyNyw5KSksYT0wO2E8dC56YTsrK2Epe3ZhciBwPWUueWFbZS5hYSthXTtpZigwPGEpe2ZvcihyPS0xOzE2PnI7KytyKW4oYyx1KzMyKnItNCxjLHUrMzIqcisxMiw0KTtmb3Iocj0tMTs4PnI7KytyKW4obCxoKzMyKnItNCxsLGgrMzIqcis0LDQpLG4oZixkKzMyKnItNCxmLGQrMzIqcis0LDQpfXZhciBnPXQuR2QsbT10LkhkK2Esdj1wLmFkLGI9cC5IYztpZigwPG8mJihuKGMsdS0zMixnW21dLnksMCwxNiksbihsLGgtMzIsZ1ttXS5mLDAsOCksbihmLGQtMzIsZ1ttXS5lYSwwLDgpKSxwLlphKXt2YXIgeT1jLHc9dS0zMisxNjtmb3IoMDxvJiYoYT49dC56YS0xP2koeSx3LGdbbV0ueVsxNV0sNCk6bih5LHcsZ1ttKzFdLnksMCw0KSkscj0wOzQ+cjtyKyspeVt3KzEyOCtyXT15W3crMjU2K3JdPXlbdyszODQrcl09eVt3KzArcl07Zm9yKHI9MDsxNj5yOysrcixiPDw9Mil5PWMsdz11K0RpW3JdLGZpW3AuT2Jbcl1dKHksdyksanIoYix2LDE2KityLHksdyl9ZWxzZSBpZih5PUNyKGEsbyxwLk9iWzBdKSxoaVt5XShjLHUpLDAhPWIpZm9yKHI9MDsxNj5yOysrcixiPDw9MilqcihiLHYsMTYqK3IsYyx1K0RpW3JdKTtmb3Iocj1wLkdjLHk9Q3IoYSxvLHAuRGQpLGRpW3ldKGwsaCksZGlbeV0oZixkKSxiPXYseT1sLHc9aCwyNTUmKHA9cj4+MCkmJigxNzAmcD9jbihiLDI1Nix5LHcpOmxuKGIsMjU2LHksdykpLHA9ZixiPWQsMjU1JihyPj49OCkmJigxNzAmcj9jbih2LDMyMCxwLGIpOmxuKHYsMzIwLHAsYikpLG88dC5VYi0xJiYobihnW21dLnksMCxjLHUrNDgwLDE2KSxuKGdbbV0uZiwwLGwsaCsyMjQsOCksbihnW21dLmVhLDAsZixkKzIyNCw4KSkscj04KnMqdC5CLGc9dC5zYSxtPXQudGErMTYqYSsxNipzKnQuUix2PXQucWEscD10LnJhKzgqYStyLGI9dC5IYSx5PXQuSWErOCphK3Iscj0wOzE2PnI7KytyKW4oZyxtK3IqdC5SLGMsdSszMipyLDE2KTtmb3Iocj0wOzg+cjsrK3Ipbih2LHArcip0LkIsbCxoKzMyKnIsOCksbihiLHkrcip0LkIsZixkKzMyKnIsOCl9fWZ1bmN0aW9uIEJyKHQsbixpLGEsbyxzLGMsdSxsKXt2YXIgaD1bMF0sZj1bMF0sZD0wLHA9bnVsbCE9bD9sLmtkOjAsZz1udWxsIT1sP2w6bmV3IG5yO2lmKG51bGw9PXR8fDEyPmkpcmV0dXJuIDc7Zy5kYXRhPXQsZy53PW4sZy5oYT1pLG49W25dLGk9W2ldLGcuZ2I9W2cuZ2JdO3Q6e3ZhciBtPW4sYj1pLHk9Zy5nYjtpZihlKG51bGwhPXQpLGUobnVsbCE9YiksZShudWxsIT15KSx5WzBdPTAsMTI8PWJbMF0mJiFyKHQsbVswXSwiUklGRiIpKXtpZihyKHQsbVswXSs4LCJXRUJQIikpe3k9MzticmVhayB0fXZhciB3PWoodCxtWzBdKzQpO2lmKDEyPnd8fDQyOTQ5NjcyODY8dyl7eT0zO2JyZWFrIHR9aWYocCYmdz5iWzBdLTgpe3k9NzticmVhayB0fXlbMF09dyxtWzBdKz0xMixiWzBdLT0xMn15PTB9aWYoMCE9eSlyZXR1cm4geTtmb3Iodz0wPGcuZ2JbMF0saT1pWzBdOzspe3Q6e3ZhciBMPXQ7Yj1uLHk9aTt2YXIgQT1oLHg9ZixTPW09WzBdO2lmKChrPWQ9W2RdKVswXT0wLDg+eVswXSl5PTc7ZWxzZXtpZighcihMLGJbMF0sIlZQOFgiKSl7aWYoMTAhPWooTCxiWzBdKzQpKXt5PTM7YnJlYWsgdH1pZigxOD55WzBdKXt5PTc7YnJlYWsgdH12YXIgXz1qKEwsYlswXSs4KSxQPTErQyhMLGJbMF0rMTIpO2lmKDIxNDc0ODM2NDg8PVAqKEw9MStDKEwsYlswXSsxNSkpKXt5PTM7YnJlYWsgdH1udWxsIT1TJiYoU1swXT1fKSxudWxsIT1BJiYoQVswXT1QKSxudWxsIT14JiYoeFswXT1MKSxiWzBdKz0xOCx5WzBdLT0xOCxrWzBdPTF9eT0wfX1pZihkPWRbMF0sbT1tWzBdLDAhPXkpcmV0dXJuIHk7aWYoYj0hISgyJm0pLCF3JiZkKXJldHVybiAzO2lmKG51bGwhPXMmJihzWzBdPSEhKDE2Jm0pKSxudWxsIT1jJiYoY1swXT1iKSxudWxsIT11JiYodVswXT0wKSxjPWhbMF0sbT1mWzBdLGQmJmImJm51bGw9PWwpe3k9MDticmVha31pZig0Pmkpe3k9NzticmVha31pZih3JiZkfHwhdyYmIWQmJiFyKHQsblswXSwiQUxQSCIpKXtpPVtpXSxnLm5hPVtnLm5hXSxnLlA9W2cuUF0sZy5TYT1bZy5TYV07dDp7Xz10LHk9bix3PWk7dmFyIGs9Zy5nYjtBPWcubmEseD1nLlAsUz1nLlNhO1A9MjIsZShudWxsIT1fKSxlKG51bGwhPXcpLEw9eVswXTt2YXIgRj13WzBdO2ZvcihlKG51bGwhPUEpLGUobnVsbCE9UyksQVswXT1udWxsLHhbMF09bnVsbCxTWzBdPTA7Oyl7aWYoeVswXT1MLHdbMF09Riw4PkYpe3k9NzticmVhayB0fXZhciBJPWooXyxMKzQpO2lmKDQyOTQ5NjcyODY8SSl7eT0zO2JyZWFrIHR9dmFyIE89OCtJKzEmLTI7aWYoUCs9TywwPGsmJlA+ayl7eT0zO2JyZWFrIHR9aWYoIXIoXyxMLCJWUDggIil8fCFyKF8sTCwiVlA4TCIpKXt5PTA7YnJlYWsgdH1pZihGWzBdPE8pe3k9NzticmVhayB0fXIoXyxMLCJBTFBIIil8fChBWzBdPV8seFswXT1MKzgsU1swXT1JKSxMKz1PLEYtPU99fWlmKGk9aVswXSxnLm5hPWcubmFbMF0sZy5QPWcuUFswXSxnLlNhPWcuU2FbMF0sMCE9eSlicmVha31pPVtpXSxnLkphPVtnLkphXSxnLnhhPVtnLnhhXTt0OmlmKGs9dCx5PW4sdz1pLEE9Zy5nYlswXSx4PWcuSmEsUz1nLnhhLF89eVswXSxMPSFyKGssXywiVlA4ICIpLFA9IXIoayxfLCJWUDhMIiksZShudWxsIT1rKSxlKG51bGwhPXcpLGUobnVsbCE9eCksZShudWxsIT1TKSw4PndbMF0peT03O2Vsc2V7aWYoTHx8UCl7aWYoaz1qKGssXys0KSwxMjw9QSYmaz5BLTEyKXt5PTM7YnJlYWsgdH1pZihwJiZrPndbMF0tOCl7eT03O2JyZWFrIHR9eFswXT1rLHlbMF0rPTgsd1swXS09OCxTWzBdPVB9ZWxzZSBTWzBdPTU8PXdbMF0mJjQ3PT1rW18rMF0mJiEoa1tfKzRdPj41KSx4WzBdPXdbMF07eT0wfWlmKGk9aVswXSxnLkphPWcuSmFbMF0sZy54YT1nLnhhWzBdLG49blswXSwwIT15KWJyZWFrO2lmKDQyOTQ5NjcyODY8Zy5KYSlyZXR1cm4gMztpZihudWxsPT11fHxifHwodVswXT1nLnhhPzI6MSksYz1bY10sbT1bbV0sZy54YSl7aWYoNT5pKXt5PTc7YnJlYWt9dT1jLHA9bSxiPXMsbnVsbD09dHx8NT5pP3Q9MDo1PD1pJiY0Nz09dFtuKzBdJiYhKHRbbis0XT4+NSk/KHc9WzBdLGs9WzBdLEE9WzBdLHYoeD1uZXcgTix0LG4saSksZ3QoeCx3LGssQSk/KG51bGwhPXUmJih1WzBdPXdbMF0pLG51bGwhPXAmJihwWzBdPWtbMF0pLG51bGwhPWImJihiWzBdPUFbMF0pLHQ9MSk6dD0wKTp0PTB9ZWxzZXtpZigxMD5pKXt5PTc7YnJlYWt9dT1tLG51bGw9PXR8fDEwPml8fCFYdCh0LG4rMyxpLTMpP3Q9MDoocD10W24rMF18dFtuKzFdPDw4fHRbbisyXTw8MTYsYj0xNjM4MyYodFtuKzddPDw4fHRbbis2XSksdD0xNjM4MyYodFtuKzldPDw4fHRbbis4XSksMSZwfHwzPChwPj4xJjcpfHwhKHA+PjQmMSl8fHA+PjU+PWcuSmF8fCFifHwhdD90PTA6KGMmJihjWzBdPWIpLHUmJih1WzBdPXQpLHQ9MSkpfWlmKCF0KXJldHVybiAzO2lmKGM9Y1swXSxtPW1bMF0sZCYmKGhbMF0hPWN8fGZbMF0hPW0pKXJldHVybiAzO251bGwhPWwmJihsWzBdPWcsbC5vZmZzZXQ9bi1sLncsZSg0Mjk0OTY3Mjg2Pm4tbC53KSxlKGwub2Zmc2V0PT1sLmhhLWkpKTticmVha31yZXR1cm4gMD09eXx8Nz09eSYmZCYmbnVsbD09bD8obnVsbCE9cyYmKHNbMF18PW51bGwhPWcubmEmJjA8Zy5uYS5sZW5ndGgpLG51bGwhPWEmJihhWzBdPWMpLG51bGwhPW8mJihvWzBdPW0pLDApOnl9ZnVuY3Rpb24gTXIodCxlLHIpe3ZhciBuPWUud2lkdGgsaT1lLmhlaWdodCxhPTAsbz0wLHM9bixjPWk7aWYoZS5EYT1udWxsIT10JiYwPHQuRGEsZS5EYSYmKHM9dC5jZCxjPXQuYmQsYT10LnYsbz10LmosMTE+cnx8KGEmPS0yLG8mPS0yKSwwPmF8fDA+b3x8MD49c3x8MD49Y3x8YStzPm58fG8rYz5pKSlyZXR1cm4gMDtpZihlLnY9YSxlLmo9byxlLnZhPWErcyxlLm89bytjLGUuVT1zLGUuVD1jLGUuZGE9bnVsbCE9dCYmMDx0LmRhLGUuZGEpe2lmKCFFKHMsYyxyPVt0LmliXSxhPVt0LmhiXSkpcmV0dXJuIDA7ZS5pYj1yWzBdLGUuaGI9YVswXX1yZXR1cm4gZS5vYj1udWxsIT10JiZ0Lm9iLGUuS2I9bnVsbD09dHx8IXQuU2QsZS5kYSYmKGUub2I9ZS5pYjwzKm4vNCYmZS5oYjwzKmkvNCxlLktiPTApLDF9ZnVuY3Rpb24gRXIodCl7aWYobnVsbD09dClyZXR1cm4gMjtpZigxMT50LlMpe3ZhciBlPXQuZi5SR0JBO2UuZmIrPSh0LmhlaWdodC0xKSplLkEsZS5BPS1lLkF9ZWxzZSBlPXQuZi5rYix0PXQuaGVpZ2h0LGUuTys9KHQtMSkqZS5mYSxlLmZhPS1lLmZhLGUuTis9KHQtMT4+MSkqZS5BYixlLkFiPS1lLkFiLGUuVys9KHQtMT4+MSkqZS5EYixlLkRiPS1lLkRiLG51bGwhPWUuRiYmKGUuSis9KHQtMSkqZS5sYixlLmxiPS1lLmxiKTtyZXR1cm4gMH1mdW5jdGlvbiBxcih0LGUscixuKXtpZihudWxsPT1ufHwwPj10fHwwPj1lKXJldHVybiAyO2lmKG51bGwhPXIpe2lmKHIuRGEpe3ZhciBpPXIuY2Qsbz1yLmJkLHM9LTImci52LGM9LTImci5qO2lmKDA+c3x8MD5jfHwwPj1pfHwwPj1vfHxzK2k+dHx8YytvPmUpcmV0dXJuIDI7dD1pLGU9b31pZihyLmRhKXtpZighRSh0LGUsaT1bci5pYl0sbz1bci5oYl0pKXJldHVybiAyO3Q9aVswXSxlPW9bMF19fW4ud2lkdGg9dCxuLmhlaWdodD1lO3Q6e3ZhciB1PW4ud2lkdGgsbD1uLmhlaWdodDtpZih0PW4uUywwPj11fHwwPj1sfHwhKHQ+PUVuJiYxMz50KSl0PTI7ZWxzZXtpZigwPj1uLlJkJiZudWxsPT1uLnNkKXtzPW89aT1lPTA7dmFyIGg9KGM9dSp6aVt0XSkqbDtpZigxMT50fHwobz0obCsxKS8yKihlPSh1KzEpLzIpLDEyPT10JiYocz0oaT11KSpsKSksbnVsbD09KGw9YShoKzIqbytzKSkpe3Q9MTticmVhayB0fW4uc2Q9bCwxMT50PygodT1uLmYuUkdCQSkuZWI9bCx1LmZiPTAsdS5BPWMsdS5zaXplPWgpOigodT1uLmYua2IpLnk9bCx1Lk89MCx1LmZhPWMsdS5GZD1oLHUuZj1sLHUuTj0wK2gsdS5BYj1lLHUuQ2Q9byx1LmVhPWwsdS5XPTAraCtvLHUuRGI9ZSx1LkVkPW8sMTI9PXQmJih1LkY9bCx1Lko9MCtoKzIqbyksdS5UYz1zLHUubGI9aSl9aWYoZT0xLGk9bi5TLG89bi53aWR0aCxzPW4uaGVpZ2h0LGk+PUVuJiYxMz5pKWlmKDExPmkpdD1uLmYuUkdCQSxlJj0oYz1NYXRoLmFicyh0LkEpKSoocy0xKStvPD10LnNpemUsZSY9Yz49byp6aVtpXSxlJj1udWxsIT10LmViO2Vsc2V7dD1uLmYua2IsYz0obysxKS8yLGg9KHMrMSkvMix1PU1hdGguYWJzKHQuZmEpO2w9TWF0aC5hYnModC5BYik7dmFyIGY9TWF0aC5hYnModC5EYiksZD1NYXRoLmFicyh0LmxiKSxwPWQqKHMtMSkrbztlJj11KihzLTEpK288PXQuRmQsZSY9bCooaC0xKStjPD10LkNkLGU9KGUmPWYqKGgtMSkrYzw9dC5FZCkmdT49byZsPj1jJmY+PWMsZSY9bnVsbCE9dC55LGUmPW51bGwhPXQuZixlJj1udWxsIT10LmVhLDEyPT1pJiYoZSY9ZD49byxlJj1wPD10LlRjLGUmPW51bGwhPXQuRil9ZWxzZSBlPTA7dD1lPzA6Mn19cmV0dXJuIDAhPXR8fG51bGwhPXImJnIuZmQmJih0PUVyKG4pKSx0fXZhciBEcj02NCxScj1bMCwxLDMsNywxNSwzMSw2MywxMjcsMjU1LDUxMSwxMDIzLDIwNDcsNDA5NSw4MTkxLDE2MzgzLDMyNzY3LDY1NTM1LDEzMTA3MSwyNjIxNDMsNTI0Mjg3LDEwNDg1NzUsMjA5NzE1MSw0MTk0MzAzLDgzODg2MDcsMTY3NzcyMTVdLFRyPTI0LFVyPTMyLHpyPTgsSHI9WzAsMCwxLDEsMiwyLDIsMiwzLDMsMywzLDMsMywzLDMsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw0LDQsNCw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNSw1LDUsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw2LDYsNiw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDcsNyw3LDddO1IoIlByZWRpY3RvcjAiLCJQcmVkaWN0b3JBZGQwIiksdC5QcmVkaWN0b3IwPWZ1bmN0aW9uKCl7cmV0dXJuIDQyNzgxOTAwODB9LHQuUHJlZGljdG9yMT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sdC5QcmVkaWN0b3IyPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZVtyKzBdfSx0LlByZWRpY3RvcjM9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBlW3IrMV19LHQuUHJlZGljdG9yND1mdW5jdGlvbih0LGUscil7cmV0dXJuIGVbci0xXX0sdC5QcmVkaWN0b3I1PWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gVShVKHQsZVtyKzFdKSxlW3IrMF0pfSx0LlByZWRpY3RvcjY9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBVKHQsZVtyLTFdKX0sdC5QcmVkaWN0b3I3PWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gVSh0LGVbciswXSl9LHQuUHJlZGljdG9yOD1mdW5jdGlvbih0LGUscil7cmV0dXJuIFUoZVtyLTFdLGVbciswXSl9LHQuUHJlZGljdG9yOT1mdW5jdGlvbih0LGUscil7cmV0dXJuIFUoZVtyKzBdLGVbcisxXSl9LHQuUHJlZGljdG9yMTA9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBVKFUodCxlW3ItMV0pLFUoZVtyKzBdLGVbcisxXSkpfSx0LlByZWRpY3RvcjExPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1lW3IrMF07cmV0dXJuIDA+PVcobj4+MjQmMjU1LHQ+PjI0JjI1NSwoZT1lW3ItMV0pPj4yNCYyNTUpK1cobj4+MTYmMjU1LHQ+PjE2JjI1NSxlPj4xNiYyNTUpK1cobj4+OCYyNTUsdD4+OCYyNTUsZT4+OCYyNTUpK1coMjU1Jm4sMjU1JnQsMjU1JmUpP246dH0sdC5QcmVkaWN0b3IxMj1mdW5jdGlvbih0LGUscil7dmFyIG49ZVtyKzBdO3JldHVybih6KCh0Pj4yNCYyNTUpKyhuPj4yNCYyNTUpLSgoZT1lW3ItMV0pPj4yNCYyNTUpKTw8MjR8eigodD4+MTYmMjU1KSsobj4+MTYmMjU1KS0oZT4+MTYmMjU1KSk8PDE2fHooKHQ+PjgmMjU1KSsobj4+OCYyNTUpLShlPj44JjI1NSkpPDw4fHooKDI1NSZ0KSsoMjU1Jm4pLSgyNTUmZSkpKT4+PjB9LHQuUHJlZGljdG9yMTM9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPWVbci0xXTtyZXR1cm4oSCgodD1VKHQsZVtyKzBdKSk+PjI0JjI1NSxuPj4yNCYyNTUpPDwyNHxIKHQ+PjE2JjI1NSxuPj4xNiYyNTUpPDwxNnxIKHQ+PjgmMjU1LG4+PjgmMjU1KTw8OHxIKHQ+PjAmMjU1LG4+PjAmMjU1KSk+Pj4wfTt2YXIgV3I9dC5QcmVkaWN0b3JBZGQwO3QuUHJlZGljdG9yQWRkMT1WLFIoIlByZWRpY3RvcjIiLCJQcmVkaWN0b3JBZGQyIiksUigiUHJlZGljdG9yMyIsIlByZWRpY3RvckFkZDMiKSxSKCJQcmVkaWN0b3I0IiwiUHJlZGljdG9yQWRkNCIpLFIoIlByZWRpY3RvcjUiLCJQcmVkaWN0b3JBZGQ1IiksUigiUHJlZGljdG9yNiIsIlByZWRpY3RvckFkZDYiKSxSKCJQcmVkaWN0b3I3IiwiUHJlZGljdG9yQWRkNyIpLFIoIlByZWRpY3RvcjgiLCJQcmVkaWN0b3JBZGQ4IiksUigiUHJlZGljdG9yOSIsIlByZWRpY3RvckFkZDkiKSxSKCJQcmVkaWN0b3IxMCIsIlByZWRpY3RvckFkZDEwIiksUigiUHJlZGljdG9yMTEiLCJQcmVkaWN0b3JBZGQxMSIpLFIoIlByZWRpY3RvcjEyIiwiUHJlZGljdG9yQWRkMTIiKSxSKCJQcmVkaWN0b3IxMyIsIlByZWRpY3RvckFkZDEzIik7dmFyIFZyPXQuUHJlZGljdG9yQWRkMjtYKCJDb2xvckluZGV4SW52ZXJzZVRyYW5zZm9ybSIsIk1hcEFSR0IiLCIzMmIiLChmdW5jdGlvbih0KXtyZXR1cm4gdD4+OCYyNTV9KSwoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSksWCgiVlA4TENvbG9ySW5kZXhJbnZlcnNlVHJhbnNmb3JtQWxwaGEiLCJNYXBBbHBoYSIsIjhiIiwoZnVuY3Rpb24odCl7cmV0dXJuIHR9KSwoZnVuY3Rpb24odCl7cmV0dXJuIHQ+PjgmMjU1fSkpO3ZhciBHcixZcj10LkNvbG9ySW5kZXhJbnZlcnNlVHJhbnNmb3JtLEpyPXQuTWFwQVJHQixYcj10LlZQOExDb2xvckluZGV4SW52ZXJzZVRyYW5zZm9ybUFscGhhLEtyPXQuTWFwQWxwaGEsWnI9dC5WUDhMUHJlZGljdG9yc0FkZD1bXTtaci5sZW5ndGg9MTYsKHQuVlA4TFByZWRpY3RvcnM9W10pLmxlbmd0aD0xNiwodC5WUDhMUHJlZGljdG9yc0FkZF9DPVtdKS5sZW5ndGg9MTYsKHQuVlA4TFByZWRpY3RvcnNfQz1bXSkubGVuZ3RoPTE2O3ZhciAkcixRcix0bixlbixybixubixhbixvbixzbixjbix1bixsbixobixmbixkbixwbixnbixtbix2bixibix5bix3bixObixMbixBbix4bixTbixfbixQbj1hKDUxMSksa249YSgyMDQxKSxGbj1hKDIyNSksSW49YSg3NjcpLENuPTAsam49a24sT249Rm4sQm49SW4sTW49UG4sRW49MCxxbj0xLERuPTIsUm49MyxUbj00LFVuPTUsem49NixIbj03LFduPTgsVm49OSxHbj0xMCxZbj1bMiwzLDddLEpuPVszLDMsMTFdLFhuPVsyODAsMjU2LDI1NiwyNTYsNDBdLEtuPVswLDEsMSwxLDBdLFpuPVsxNywxOCwwLDEsMiwzLDQsNSwxNiw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1XSwkbj1bMjQsNywyMywyNSw0MCw2LDM5LDQxLDIyLDI2LDM4LDQyLDU2LDUsNTUsNTcsMjEsMjcsNTQsNTgsMzcsNDMsNzIsNCw3MSw3MywyMCwyOCw1Myw1OSw3MCw3NCwzNiw0NCw4OCw2OSw3NSw1Miw2MCwzLDg3LDg5LDE5LDI5LDg2LDkwLDM1LDQ1LDY4LDc2LDg1LDkxLDUxLDYxLDEwNCwyLDEwMywxMDUsMTgsMzAsMTAyLDEwNiwzNCw0Niw4NCw5Miw2Nyw3NywxMDEsMTA3LDUwLDYyLDEyMCwxLDExOSwxMjEsODMsOTMsMTcsMzEsMTAwLDEwOCw2Niw3OCwxMTgsMTIyLDMzLDQ3LDExNywxMjMsNDksNjMsOTksMTA5LDgyLDk0LDAsMTE2LDEyNCw2NSw3OSwxNiwzMiw5OCwxMTAsNDgsMTE1LDEyNSw4MSw5NSw2NCwxMTQsMTI2LDk3LDExMSw4MCwxMTMsMTI3LDk2LDExMl0sUW49WzI5NTQsMjk1NiwyOTU4LDI5NjIsMjk3MCwyOTg2LDMwMTgsMzA4MiwzMjEyLDM0NjgsMzk4MCw1MDA0XSx0aT04LGVpPVs0LDUsNiw3LDgsOSwxMCwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxNywxOCwxOSwyMCwyMCwyMSwyMSwyMiwyMiwyMywyMywyNCwyNSwyNSwyNiwyNywyOCwyOSwzMCwzMSwzMiwzMywzNCwzNSwzNiwzNywzNywzOCwzOSw0MCw0MSw0Miw0Myw0NCw0NSw0Niw0Niw0Nyw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1Nyw1OCw1OSw2MCw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw3Myw3NCw3NSw3Niw3Niw3Nyw3OCw3OSw4MCw4MSw4Miw4Myw4NCw4NSw4Niw4Nyw4OCw4OSw5MSw5Myw5NSw5Niw5OCwxMDAsMTAxLDEwMiwxMDQsMTA2LDEwOCwxMTAsMTEyLDExNCwxMTYsMTE4LDEyMiwxMjQsMTI2LDEyOCwxMzAsMTMyLDEzNCwxMzYsMTM4LDE0MCwxNDMsMTQ1LDE0OCwxNTEsMTU0LDE1N10scmk9WzQsNSw2LDcsOCw5LDEwLDExLDEyLDEzLDE0LDE1LDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxLDMyLDMzLDM0LDM1LDM2LDM3LDM4LDM5LDQwLDQxLDQyLDQzLDQ0LDQ1LDQ2LDQ3LDQ4LDQ5LDUwLDUxLDUyLDUzLDU0LDU1LDU2LDU3LDU4LDYwLDYyLDY0LDY2LDY4LDcwLDcyLDc0LDc2LDc4LDgwLDgyLDg0LDg2LDg4LDkwLDkyLDk0LDk2LDk4LDEwMCwxMDIsMTA0LDEwNiwxMDgsMTEwLDExMiwxMTQsMTE2LDExOSwxMjIsMTI1LDEyOCwxMzEsMTM0LDEzNywxNDAsMTQzLDE0NiwxNDksMTUyLDE1NSwxNTgsMTYxLDE2NCwxNjcsMTcwLDE3MywxNzcsMTgxLDE4NSwxODksMTkzLDE5NywyMDEsMjA1LDIwOSwyMTMsMjE3LDIyMSwyMjUsMjI5LDIzNCwyMzksMjQ1LDI0OSwyNTQsMjU5LDI2NCwyNjksMjc0LDI3OSwyODRdLG5pPW51bGwsaWk9W1sxNzMsMTQ4LDE0MCwwXSxbMTc2LDE1NSwxNDAsMTM1LDBdLFsxODAsMTU3LDE0MSwxMzQsMTMwLDBdLFsyNTQsMjU0LDI0MywyMzAsMTk2LDE3NywxNTMsMTQwLDEzMywxMzAsMTI5LDBdXSxhaT1bMCwxLDQsOCw1LDIsMyw2LDksMTIsMTMsMTAsNywxMSwxNCwxNV0sb2k9Wy0wLDEsLTEsMiwtMiwzLDQsNiwtMyw1LC00LC01LC02LDcsLTcsOCwtOCwtOV0sc2k9W1tbWzEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF1dLFtbMjUzLDEzNiwyNTQsMjU1LDIyOCwyMTksMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzE4OSwxMjksMjQyLDI1NSwyMjcsMjEzLDI1NSwyMTksMTI4LDEyOCwxMjhdLFsxMDYsMTI2LDIyNywyNTIsMjE0LDIwOSwyNTUsMjU1LDEyOCwxMjgsMTI4XV0sW1sxLDk4LDI0OCwyNTUsMjM2LDIyNiwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbMTgxLDEzMywyMzgsMjU0LDIyMSwyMzQsMjU1LDE1NCwxMjgsMTI4LDEyOF0sWzc4LDEzNCwyMDIsMjQ3LDE5OCwxODAsMjU1LDIxOSwxMjgsMTI4LDEyOF1dLFtbMSwxODUsMjQ5LDI1NSwyNDMsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxODQsMTUwLDI0NywyNTUsMjM2LDIyNCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbNzcsMTEwLDIxNiwyNTUsMjM2LDIzMCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1sxLDEwMSwyNTEsMjU1LDI0MSwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzE3MCwxMzksMjQxLDI1MiwyMzYsMjA5LDI1NSwyNTUsMTI4LDEyOCwxMjhdLFszNywxMTYsMTk2LDI0MywyMjgsMjU1LDI1NSwyNTUsMTI4LDEyOCwxMjhdXSxbWzEsMjA0LDI1NCwyNTUsMjQ1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMjA3LDE2MCwyNTAsMjU1LDIzOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzEwMiwxMDMsMjMxLDI1NSwyMTEsMTcxLDEyOCwxMjgsMTI4LDEyOCwxMjhdXSxbWzEsMTUyLDI1MiwyNTUsMjQwLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTc3LDEzNSwyNDMsMjU1LDIzNCwyMjUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzgwLDEyOSwyMTEsMjU1LDE5NCwyMjQsMTI4LDEyOCwxMjgsMTI4LDEyOF1dLFtbMSwxLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMjQ2LDEsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV1dLFtbWzE5OCwzNSwyMzcsMjIzLDE5MywxODcsMTYyLDE2MCwxNDUsMTU1LDYyXSxbMTMxLDQ1LDE5OCwyMjEsMTcyLDE3NiwyMjAsMTU3LDI1MiwyMjEsMV0sWzY4LDQ3LDE0NiwyMDgsMTQ5LDE2NywyMjEsMTYyLDI1NSwyMjMsMTI4XV0sW1sxLDE0OSwyNDEsMjU1LDIyMSwyMjQsMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzE4NCwxNDEsMjM0LDI1MywyMjIsMjIwLDI1NSwxOTksMTI4LDEyOCwxMjhdLFs4MSw5OSwxODEsMjQyLDE3NiwxOTAsMjQ5LDIwMiwyNTUsMjU1LDEyOF1dLFtbMSwxMjksMjMyLDI1MywyMTQsMTk3LDI0MiwxOTYsMjU1LDI1NSwxMjhdLFs5OSwxMjEsMjEwLDI1MCwyMDEsMTk4LDI1NSwyMDIsMTI4LDEyOCwxMjhdLFsyMyw5MSwxNjMsMjQyLDE3MCwxODcsMjQ3LDIxMCwyNTUsMjU1LDEyOF1dLFtbMSwyMDAsMjQ2LDI1NSwyMzQsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxMDksMTc4LDI0MSwyNTUsMjMxLDI0NSwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbNDQsMTMwLDIwMSwyNTMsMjA1LDE5MiwyNTUsMjU1LDEyOCwxMjgsMTI4XV0sW1sxLDEzMiwyMzksMjUxLDIxOSwyMDksMjU1LDE2NSwxMjgsMTI4LDEyOF0sWzk0LDEzNiwyMjUsMjUxLDIxOCwxOTAsMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzIyLDEwMCwxNzQsMjQ1LDE4NiwxNjEsMjU1LDE5OSwxMjgsMTI4LDEyOF1dLFtbMSwxODIsMjQ5LDI1NSwyMzIsMjM1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxMjQsMTQzLDI0MSwyNTUsMjI3LDIzNCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMzUsNzcsMTgxLDI1MSwxOTMsMjExLDI1NSwyMDUsMTI4LDEyOCwxMjhdXSxbWzEsMTU3LDI0NywyNTUsMjM2LDIzMSwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbMTIxLDE0MSwyMzUsMjU1LDIyNSwyMjcsMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzQ1LDk5LDE4OCwyNTEsMTk1LDIxNywyNTUsMjI0LDEyOCwxMjgsMTI4XV0sW1sxLDEsMjUxLDI1NSwyMTMsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyMDMsMSwyNDgsMjU1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzEzNywxLDE3NywyNTUsMjI0LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4XV1dLFtbWzI1Myw5LDI0OCwyNTEsMjA3LDIwOCwyNTUsMTkyLDEyOCwxMjgsMTI4XSxbMTc1LDEzLDIyNCwyNDMsMTkzLDE4NSwyNDksMTk4LDI1NSwyNTUsMTI4XSxbNzMsMTcsMTcxLDIyMSwxNjEsMTc5LDIzNiwxNjcsMjU1LDIzNCwxMjhdXSxbWzEsOTUsMjQ3LDI1MywyMTIsMTgzLDI1NSwyNTUsMTI4LDEyOCwxMjhdLFsyMzksOTAsMjQ0LDI1MCwyMTEsMjA5LDI1NSwyNTUsMTI4LDEyOCwxMjhdLFsxNTUsNzcsMTk1LDI0OCwxODgsMTk1LDI1NSwyNTUsMTI4LDEyOCwxMjhdXSxbWzEsMjQsMjM5LDI1MSwyMTgsMjE5LDI1NSwyMDUsMTI4LDEyOCwxMjhdLFsyMDEsNTEsMjE5LDI1NSwxOTYsMTg2LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFs2OSw0NiwxOTAsMjM5LDIwMSwyMTgsMjU1LDIyOCwxMjgsMTI4LDEyOF1dLFtbMSwxOTEsMjUxLDI1NSwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyMjMsMTY1LDI0OSwyNTUsMjEzLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTQxLDEyNCwyNDgsMjU1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF1dLFtbMSwxNiwyNDgsMjU1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzE5MCwzNiwyMzAsMjU1LDIzNiwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzE0OSwxLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1sxLDIyNiwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzI0NywxOTIsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyNDAsMTI4LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1sxLDEzNCwyNTIsMjU1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzIxMyw2MiwyNTAsMjU1LDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzU1LDkzLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV0sW1sxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XSxbMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdXV0sW1tbMjAyLDI0LDIxMywyMzUsMTg2LDE5MSwyMjAsMTYwLDI0MCwxNzUsMjU1XSxbMTI2LDM4LDE4MiwyMzIsMTY5LDE4NCwyMjgsMTc0LDI1NSwxODcsMTI4XSxbNjEsNDYsMTM4LDIxOSwxNTEsMTc4LDI0MCwxNzAsMjU1LDIxNiwxMjhdXSxbWzEsMTEyLDIzMCwyNTAsMTk5LDE5MSwyNDcsMTU5LDI1NSwyNTUsMTI4XSxbMTY2LDEwOSwyMjgsMjUyLDIxMSwyMTUsMjU1LDE3NCwxMjgsMTI4LDEyOF0sWzM5LDc3LDE2MiwyMzIsMTcyLDE4MCwyNDUsMTc4LDI1NSwyNTUsMTI4XV0sW1sxLDUyLDIyMCwyNDYsMTk4LDE5OSwyNDksMjIwLDI1NSwyNTUsMTI4XSxbMTI0LDc0LDE5MSwyNDMsMTgzLDE5MywyNTAsMjIxLDI1NSwyNTUsMTI4XSxbMjQsNzEsMTMwLDIxOSwxNTQsMTcwLDI0MywxODIsMjU1LDI1NSwxMjhdXSxbWzEsMTgyLDIyNSwyNDksMjE5LDI0MCwyNTUsMjI0LDEyOCwxMjgsMTI4XSxbMTQ5LDE1MCwyMjYsMjUyLDIxNiwyMDUsMjU1LDE3MSwxMjgsMTI4LDEyOF0sWzI4LDEwOCwxNzAsMjQyLDE4MywxOTQsMjU0LDIyMywyNTUsMjU1LDEyOF1dLFtbMSw4MSwyMzAsMjUyLDIwNCwyMDMsMjU1LDE5MiwxMjgsMTI4LDEyOF0sWzEyMywxMDIsMjA5LDI0NywxODgsMTk2LDI1NSwyMzMsMTI4LDEyOCwxMjhdLFsyMCw5NSwxNTMsMjQzLDE2NCwxNzMsMjU1LDIwMywxMjgsMTI4LDEyOF1dLFtbMSwyMjIsMjQ4LDI1NSwyMTYsMjEzLDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsxNjgsMTc1LDI0NiwyNTIsMjM1LDIwNSwyNTUsMjU1LDEyOCwxMjgsMTI4XSxbNDcsMTE2LDIxNSwyNTUsMjExLDIxMiwyNTUsMjU1LDEyOCwxMjgsMTI4XV0sW1sxLDEyMSwyMzYsMjUzLDIxMiwyMTQsMjU1LDI1NSwxMjgsMTI4LDEyOF0sWzE0MSw4NCwyMTMsMjUyLDIwMSwyMDIsMjU1LDIxOSwxMjgsMTI4LDEyOF0sWzQyLDgwLDE2MCwyNDAsMTYyLDE4NSwyNTUsMjA1LDEyOCwxMjgsMTI4XV0sW1sxLDEsMjU1LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjhdLFsyNDQsMSwyNTUsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOF0sWzIzOCwxLDI1NSwxMjgsMTI4LDEyOCwxMjgsMTI4LDEyOCwxMjgsMTI4XV1dXSxjaT1bW1syMzEsMTIwLDQ4LDg5LDExNSwxMTMsMTIwLDE1MiwxMTJdLFsxNTIsMTc5LDY0LDEyNiwxNzAsMTE4LDQ2LDcwLDk1XSxbMTc1LDY5LDE0Myw4MCw4NSw4Miw3MiwxNTUsMTAzXSxbNTYsNTgsMTAsMTcxLDIxOCwxODksMTcsMTMsMTUyXSxbMTE0LDI2LDE3LDE2Myw0NCwxOTUsMjEsMTAsMTczXSxbMTIxLDI0LDgwLDE5NSwyNiw2Miw0NCw2NCw4NV0sWzE0NCw3MSwxMCwzOCwxNzEsMjEzLDE0NCwzNCwyNl0sWzE3MCw0Niw1NSwxOSwxMzYsMTYwLDMzLDIwNiw3MV0sWzYzLDIwLDgsMTE0LDExNCwyMDgsMTIsOSwyMjZdLFs4MSw0MCwxMSw5NiwxODIsODQsMjksMTYsMzZdXSxbWzEzNCwxODMsODksMTM3LDk4LDEwMSwxMDYsMTY1LDE0OF0sWzcyLDE4NywxMDAsMTMwLDE1NywxMTEsMzIsNzUsODBdLFs2NiwxMDIsMTY3LDk5LDc0LDYyLDQwLDIzNCwxMjhdLFs0MSw1Myw5LDE3OCwyNDEsMTQxLDI2LDgsMTA3XSxbNzQsNDMsMjYsMTQ2LDczLDE2Niw0OSwyMywxNTddLFs2NSwzOCwxMDUsMTYwLDUxLDUyLDMxLDExNSwxMjhdLFsxMDQsNzksMTIsMjcsMjE3LDI1NSw4NywxNyw3XSxbODcsNjgsNzEsNDQsMTE0LDUxLDE1LDE4NiwyM10sWzQ3LDQxLDE0LDExMCwxODIsMTgzLDIxLDE3LDE5NF0sWzY2LDQ1LDI1LDEwMiwxOTcsMTg5LDIzLDE4LDIyXV0sW1s4OCw4OCwxNDcsMTUwLDQyLDQ2LDQ1LDE5NiwyMDVdLFs0Myw5NywxODMsMTE3LDg1LDM4LDM1LDE3OSw2MV0sWzM5LDUzLDIwMCw4NywyNiwyMSw0MywyMzIsMTcxXSxbNTYsMzQsNTEsMTA0LDExNCwxMDIsMjksOTMsNzddLFszOSwyOCw4NSwxNzEsNTgsMTY1LDkwLDk4LDY0XSxbMzQsMjIsMTE2LDIwNiwyMywzNCw0MywxNjYsNzNdLFsxMDcsNTQsMzIsMjYsNTEsMSw4MSw0MywzMV0sWzY4LDI1LDEwNiwyMiw2NCwxNzEsMzYsMjI1LDExNF0sWzM0LDE5LDIxLDEwMiwxMzIsMTg4LDE2LDc2LDEyNF0sWzYyLDE4LDc4LDk1LDg1LDU3LDUwLDQ4LDUxXV0sW1sxOTMsMTAxLDM1LDE1OSwyMTUsMTExLDg5LDQ2LDExMV0sWzYwLDE0OCwzMSwxNzIsMjE5LDIyOCwyMSwxOCwxMTFdLFsxMTIsMTEzLDc3LDg1LDE3OSwyNTUsMzgsMTIwLDExNF0sWzQwLDQyLDEsMTk2LDI0NSwyMDksMTAsMjUsMTA5XSxbODgsNDMsMjksMTQwLDE2NiwyMTMsMzcsNDMsMTU0XSxbNjEsNjMsMzAsMTU1LDY3LDQ1LDY4LDEsMjA5XSxbMTAwLDgwLDgsNDMsMTU0LDEsNTEsMjYsNzFdLFsxNDIsNzgsNzgsMTYsMjU1LDEyOCwzNCwxOTcsMTcxXSxbNDEsNDAsNSwxMDIsMjExLDE4Myw0LDEsMjIxXSxbNTEsNTAsMTcsMTY4LDIwOSwxOTIsMjMsMjUsODJdXSxbWzEzOCwzMSwzNiwxNzEsMjcsMTY2LDM4LDQ0LDIyOV0sWzY3LDg3LDU4LDE2OSw4MiwxMTUsMjYsNTksMTc5XSxbNjMsNTksOTAsMTgwLDU5LDE2Niw5Myw3MywxNTRdLFs0MCw0MCwyMSwxMTYsMTQzLDIwOSwzNCwzOSwxNzVdLFs0NywxNSwxNiwxODMsMzQsMjIzLDQ5LDQ1LDE4M10sWzQ2LDE3LDMzLDE4Myw2LDk4LDE1LDMyLDE4M10sWzU3LDQ2LDIyLDI0LDEyOCwxLDU0LDE3LDM3XSxbNjUsMzIsNzMsMTE1LDI4LDEyOCwyMywxMjgsMjA1XSxbNDAsMyw5LDExNSw1MSwxOTIsMTgsNiwyMjNdLFs4NywzNyw5LDExNSw1OSw3Nyw2NCwyMSw0N11dLFtbMTA0LDU1LDQ0LDIxOCw5LDU0LDUzLDEzMCwyMjZdLFs2NCw5MCw3MCwyMDUsNDAsNDEsMjMsMjYsNTddLFs1NCw1NywxMTIsMTg0LDUsNDEsMzgsMTY2LDIxM10sWzMwLDM0LDI2LDEzMywxNTIsMTE2LDEwLDMyLDEzNF0sWzM5LDE5LDUzLDIyMSwyNiwxMTQsMzIsNzMsMjU1XSxbMzEsOSw2NSwyMzQsMiwxNSwxLDExOCw3M10sWzc1LDMyLDEyLDUxLDE5MiwyNTUsMTYwLDQzLDUxXSxbODgsMzEsMzUsNjcsMTAyLDg1LDU1LDE4Niw4NV0sWzU2LDIxLDIzLDExMSw1OSwyMDUsNDUsMzcsMTkyXSxbNTUsMzgsNzAsMTI0LDczLDEwMiwxLDM0LDk4XV0sW1sxMjUsOTgsNDIsODgsMTA0LDg1LDExNywxNzUsODJdLFs5NSw4NCw1Myw4OSwxMjgsMTAwLDExMywxMDEsNDVdLFs3NSw3OSwxMjMsNDcsNTEsMTI4LDgxLDE3MSwxXSxbNTcsMTcsNSw3MSwxMDIsNTcsNTMsNDEsNDldLFszOCwzMywxMywxMjEsNTcsNzMsMjYsMSw4NV0sWzQxLDEwLDY3LDEzOCw3NywxMTAsOTAsNDcsMTE0XSxbMTE1LDIxLDIsMTAsMTAyLDI1NSwxNjYsMjMsNl0sWzEwMSwyOSwxNiwxMCw4NSwxMjgsMTAxLDE5NiwyNl0sWzU3LDE4LDEwLDEwMiwxMDIsMjEzLDM0LDIwLDQzXSxbMTE3LDIwLDE1LDM2LDE2MywxMjgsNjgsMSwyNl1dLFtbMTAyLDYxLDcxLDM3LDM0LDUzLDMxLDI0MywxOTJdLFs2OSw2MCw3MSwzOCw3MywxMTksMjgsMjIyLDM3XSxbNjgsNDUsMTI4LDM0LDEsNDcsMTEsMjQ1LDE3MV0sWzYyLDE3LDE5LDcwLDE0Niw4NSw1NSw2Miw3MF0sWzM3LDQzLDM3LDE1NCwxMDAsMTYzLDg1LDE2MCwxXSxbNjMsOSw5MiwxMzYsMjgsNjQsMzIsMjAxLDg1XSxbNzUsMTUsOSw5LDY0LDI1NSwxODQsMTE5LDE2XSxbODYsNiwyOCw1LDY0LDI1NSwyNSwyNDgsMV0sWzU2LDgsMTcsMTMyLDEzNywyNTUsNTUsMTE2LDEyOF0sWzU4LDE1LDIwLDgyLDEzNSw1NywyNiwxMjEsNDBdXSxbWzE2NCw1MCwzMSwxMzcsMTU0LDEzMywyNSwzNSwyMThdLFs1MSwxMDMsNDQsMTMxLDEzMSwxMjMsMzEsNiwxNThdLFs4Niw0MCw2NCwxMzUsMTQ4LDIyNCw0NSwxODMsMTI4XSxbMjIsMjYsMTcsMTMxLDI0MCwxNTQsMTQsMSwyMDldLFs0NSwxNiwyMSw5MSw2NCwyMjIsNywxLDE5N10sWzU2LDIxLDM5LDE1NSw2MCwxMzgsMjMsMTAyLDIxM10sWzgzLDEyLDEzLDU0LDE5MiwyNTUsNjgsNDcsMjhdLFs4NSwyNiw4NSw4NSwxMjgsMTI4LDMyLDE0NiwxNzFdLFsxOCwxMSw3LDYzLDE0NCwxNzEsNCw0LDI0Nl0sWzM1LDI3LDEwLDE0NiwxNzQsMTcxLDEyLDI2LDEyOF1dLFtbMTkwLDgwLDM1LDk5LDE4MCw4MCwxMjYsNTQsNDVdLFs4NSwxMjYsNDcsODcsMTc2LDUxLDQxLDIwLDMyXSxbMTAxLDc1LDEyOCwxMzksMTE4LDE0NiwxMTYsMTI4LDg1XSxbNTYsNDEsMTUsMTc2LDIzNiw4NSwzNyw5LDYyXSxbNzEsMzAsMTcsMTE5LDExOCwyNTUsMTcsMTgsMTM4XSxbMTAxLDM4LDYwLDEzOCw1NSw3MCw0MywyNiwxNDJdLFsxNDYsMzYsMTksMzAsMTcxLDI1NSw5NywyNywyMF0sWzEzOCw0NSw2MSw2MiwyMTksMSw4MSwxODgsNjRdLFszMiw0MSwyMCwxMTcsMTUxLDE0MiwyMCwyMSwxNjNdLFsxMTIsMTksMTIsNjEsMTk1LDEyOCw0OCw0LDI0XV1dLHVpPVtbW1syNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzE3NiwyNDYsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMjMsMjQxLDI1MiwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ5LDI1MywyNTMsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI0NCwyNTIsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzIzNCwyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTMsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjQ2LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjM5LDI1MywyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNDgsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTEsMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1MywyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MSwyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTQsMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU0LDI1MywyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUwLDI1NSwyNTQsMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dXSxbW1syMTcsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjI1LDI1MiwyNDEsMjUzLDI1NSwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NV0sWzIzNCwyNTAsMjQxLDI1MCwyNTMsMjU1LDI1MywyNTQsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMjMsMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjM4LDI1MywyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI0OCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI0OSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ3LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTMsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTIsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU0LDI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUwLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dXSxbW1sxODYsMjUxLDI1MCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjM0LDI1MSwyNDQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MSwyNTEsMjQzLDI1MywyNTQsMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTMsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyMzYsMjUzLDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUxLDI1MywyNTMsMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTQsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dXSxbW1syNDgsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUwLDI1NCwyNTIsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI0OCwyNTQsMjQ5LDI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTMsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNDYsMjUzLDI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUyLDI1NCwyNTEsMjU0LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1NCwyNTIsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI0OCwyNTQsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTMsMjU1LDI1NCwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjUxLDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjQ1LDI1MSwyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1MywyNTMsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTEsMjUzLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTIsMjUzLDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dLFtbMjU1LDI1MiwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI0OSwyNTUsMjU0LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTUsMjU1LDI1NCwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XV0sW1syNTUsMjU1LDI1MywyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjUwLDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV0sWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdXSxbWzI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTVdLFsyNTQsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1XSxbMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NSwyNTUsMjU1LDI1NV1dXV0sbGk9WzAsMSwyLDMsNiw0LDUsNiw2LDYsNiw2LDYsNiw2LDcsMF0saGk9W10sZmk9W10sZGk9W10scGk9MSxnaT0yLG1pPVtdLHZpPVtdO3ZyKCJVcHNhbXBsZVJnYkxpbmVQYWlyIixBciwzKSx2cigiVXBzYW1wbGVCZ3JMaW5lUGFpciIseHIsMyksdnIoIlVwc2FtcGxlUmdiYUxpbmVQYWlyIixGciw0KSx2cigiVXBzYW1wbGVCZ3JhTGluZVBhaXIiLGtyLDQpLHZyKCJVcHNhbXBsZUFyZ2JMaW5lUGFpciIsUHIsNCksdnIoIlVwc2FtcGxlUmdiYTQ0NDRMaW5lUGFpciIsX3IsMiksdnIoIlVwc2FtcGxlUmdiNTY1TGluZVBhaXIiLFNyLDIpO3ZhciBiaT10LlVwc2FtcGxlUmdiTGluZVBhaXIseWk9dC5VcHNhbXBsZUJnckxpbmVQYWlyLHdpPXQuVXBzYW1wbGVSZ2JhTGluZVBhaXIsTmk9dC5VcHNhbXBsZUJncmFMaW5lUGFpcixMaT10LlVwc2FtcGxlQXJnYkxpbmVQYWlyLEFpPXQuVXBzYW1wbGVSZ2JhNDQ0NExpbmVQYWlyLHhpPXQuVXBzYW1wbGVSZ2I1NjVMaW5lUGFpcixTaT0xNixfaT0xPDxTaS0xLFBpPS0yMjcsa2k9NDgyLEZpPTYsSWk9KDI1Njw8RmkpLTEsQ2k9MCxqaT1hKDI1NiksT2k9YSgyNTYpLEJpPWEoMjU2KSxNaT1hKDI1NiksRWk9YShraS1QaSkscWk9YShraS1QaSk7SXIoIll1dlRvUmdiUm93IixBciwzKSxJcigiWXV2VG9CZ3JSb3ciLHhyLDMpLElyKCJZdXZUb1JnYmFSb3ciLEZyLDQpLElyKCJZdXZUb0JncmFSb3ciLGtyLDQpLElyKCJZdXZUb0FyZ2JSb3ciLFByLDQpLElyKCJZdXZUb1JnYmE0NDQ0Um93IixfciwyKSxJcigiWXV2VG9SZ2I1NjVSb3ciLFNyLDIpO3ZhciBEaT1bMCw0LDgsMTIsMTI4LDEzMiwxMzYsMTQwLDI1NiwyNjAsMjY0LDI2OCwzODQsMzg4LDM5MiwzOTZdLFJpPVswLDIsOF0sVGk9WzgsNyw2LDQsNCwyLDIsMiwxLDEsMSwxXSxVaT0xO3RoaXMuV2ViUERlY29kZVJHQkE9ZnVuY3Rpb24odCxyLG4saSxhKXt2YXIgbz1xbixzPW5ldyBycixjPW5ldyBvdDtzLmJhPWMsYy5TPW8sYy53aWR0aD1bYy53aWR0aF0sYy5oZWlnaHQ9W2MuaGVpZ2h0XTt2YXIgdT1jLndpZHRoLGw9Yy5oZWlnaHQsaD1uZXcgc3Q7aWYobnVsbD09aHx8bnVsbD09dCl2YXIgZj0yO2Vsc2UgZShudWxsIT1oKSxmPUJyKHQscixuLGgud2lkdGgsaC5oZWlnaHQsaC5QZCxoLlFkLGguZm9ybWF0LG51bGwpO2lmKDAhPWY/dT0wOihudWxsIT11JiYodVswXT1oLndpZHRoWzBdKSxudWxsIT1sJiYobFswXT1oLmhlaWdodFswXSksdT0xKSx1KXtjLndpZHRoPWMud2lkdGhbMF0sYy5oZWlnaHQ9Yy5oZWlnaHRbMF0sbnVsbCE9aSYmKGlbMF09Yy53aWR0aCksbnVsbCE9YSYmKGFbMF09Yy5oZWlnaHQpO3Q6e2lmKGk9bmV3IEd0LChhPW5ldyBucikuZGF0YT10LGEudz1yLGEuaGE9bixhLmtkPTEscj1bMF0sZShudWxsIT1hKSwoMD09KHQ9QnIoYS5kYXRhLGEudyxhLmhhLG51bGwsbnVsbCxudWxsLHIsbnVsbCxhKSl8fDc9PXQpJiZyWzBdJiYodD00KSwwPT0ocj10KSl7aWYoZShudWxsIT1zKSxpLmRhdGE9YS5kYXRhLGkudz1hLncrYS5vZmZzZXQsaS5oYT1hLmhhLWEub2Zmc2V0LGkucHV0PWR0LGkuYWM9ZnQsaS5iYz1wdCxpLm1hPXMsYS54YSl7aWYobnVsbD09KHQ9a3QoKSkpe3M9MTticmVhayB0fWlmKGZ1bmN0aW9uKHQscil7dmFyIG49WzBdLGk9WzBdLGE9WzBdO2U6Zm9yKDs7KXtpZihudWxsPT10KXJldHVybiAwO2lmKG51bGw9PXIpcmV0dXJuIHQuYT0yLDA7aWYodC5sPXIsdC5hPTAsdih0Lm0sci5kYXRhLHIudyxyLmhhKSwhZ3QodC5tLG4saSxhKSl7dC5hPTM7YnJlYWsgZX1pZih0LnhiPWdpLHIud2lkdGg9blswXSxyLmhlaWdodD1pWzBdLCFGdChuWzBdLGlbMF0sMSx0LG51bGwpKWJyZWFrIGU7cmV0dXJuIDF9cmV0dXJuIGUoMCE9dC5hKSwwfSh0LGkpKXtpZihpPTA9PShyPXFyKGkud2lkdGgsaS5oZWlnaHQscy5PYSxzLmJhKSkpe2U6e2k9dDtyOmZvcig7Oyl7aWYobnVsbD09aSl7aT0wO2JyZWFrIGV9aWYoZShudWxsIT1pLnMueWMpLGUobnVsbCE9aS5zLllhKSxlKDA8aS5zLldiKSxlKG51bGwhPShuPWkubCkpLGUobnVsbCE9KGE9bi5tYSkpLDAhPWkueGIpe2lmKGkuY2E9YS5iYSxpLnRiPWEudGIsZShudWxsIT1pLmNhKSwhTXIoYS5PYSxuLFJuKSl7aS5hPTI7YnJlYWsgcn1pZighSXQoaSxuLndpZHRoKSlicmVhayByO2lmKG4uZGEpYnJlYWsgcjtpZigobi5kYXx8bnQoaS5jYS5TKSkmJm1yKCksMTE+aS5jYS5TfHwoYWxlcnQoInRvZG86V2ViUEluaXRDb252ZXJ0QVJHQlRvWVVWIiksbnVsbCE9aS5jYS5mLmtiLkYmJm1yKCkpLGkuUGImJjA8aS5zLnVhJiZudWxsPT1pLnMudmIuWCYmIU8oaS5zLnZiLGkucy5XYS5YYSkpe2kuYT0xO2JyZWFrIHJ9aS54Yj0wfWlmKCFfdChpLGkuVixpLkJhLGkuYyxpLmksbi5vLEx0KSlicmVhayByO2EuRGM9aS5NYSxpPTE7YnJlYWsgZX1lKDAhPWkuYSksaT0wfWk9IWl9aSYmKHI9dC5hKX1lbHNlIHI9dC5hfWVsc2V7aWYobnVsbD09KHQ9bmV3IFl0KSl7cz0xO2JyZWFrIHR9aWYodC5GYT1hLm5hLHQuUD1hLlAsdC5xYz1hLlNhLEt0KHQsaSkpe2lmKDA9PShyPXFyKGkud2lkdGgsaS5oZWlnaHQscy5PYSxzLmJhKSkpe2lmKHQuQWE9MCxuPXMuT2EsZShudWxsIT0oYT10KSksbnVsbCE9bil7aWYoMDwodT0wPih1PW4uTWQpPzA6MTAwPHU/MjU1OjI1NSp1LzEwMCkpe2ZvcihsPWg9MDs0Pmw7KytsKTEyPihmPWEucGJbbF0pLmxjJiYoZi5pYT11KlRpWzA+Zi5sYz8wOmYubGNdPj4zKSxofD1mLmlhO2gmJihhbGVydCgidG9kbzpWUDhJbml0UmFuZG9tIiksYS5pYT0xKX1hLkdhPW4uSWQsMTAwPGEuR2E/YS5HYT0xMDA6MD5hLkdhJiYoYS5HYT0wKX1RdCh0LGkpfHwocj10LmEpfX1lbHNlIHI9dC5hfTA9PXImJm51bGwhPXMuT2EmJnMuT2EuZmQmJihyPUVyKHMuYmEpKX1zPXJ9bz0wIT1zP251bGw6MTE+bz9jLmYuUkdCQS5lYjpjLmYua2IueX1lbHNlIG89bnVsbDtyZXR1cm4gb307dmFyIHppPVszLDQsMyw0LDQsMiwyLDQsNCw0LDIsMSwxXX07ZnVuY3Rpb24gdSh0LGUpe2Zvcih2YXIgcj0iIixuPTA7bjw0O24rKylyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbZSsrXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gbCh0LGUpe3JldHVybih0W2UrMF08PDB8dFtlKzFdPDw4fHRbZSsyXTw8MTYpPj4+MH1mdW5jdGlvbiBoKHQsZSl7cmV0dXJuKHRbZSswXTw8MHx0W2UrMV08PDh8dFtlKzJdPDwxNnx0W2UrM108PDI0KT4+PjB9bmV3IGM7dmFyIGY9WzBdLGQ9WzBdLHA9W10sZz1uZXcgYyxtPXQsdj1mdW5jdGlvbih0LGUpe3ZhciByPXt9LG49MCxpPSExLGE9MCxvPTA7aWYoci5mcmFtZXM9W10sIQovKiogQGxpY2Vuc2UKICAgICAqIENvcHlyaWdodCAoYykgMjAxNyBEb21pbmlrIEhvbWJlcmdlcgogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KICAgIGh0dHBzOi8vd2VicGpzLmFwcHNwb3QuY29tCiAgICBXZWJQUmlmZlBhcnNlciBkb21pbmlraGxiZ0BnbWFpbC5jb20KICAgICovCmZ1bmN0aW9uKHQsZSxyLG4pe2Zvcih2YXIgaT0wO2k8bjtpKyspaWYodFtlK2ldIT1yLmNoYXJDb2RlQXQoaSkpcmV0dXJuITA7cmV0dXJuITF9KHQsZSwiUklGRiIsNCkpe3ZhciBzLGM7aCh0LGUrPTQpO2ZvcihlKz04O2U8dC5sZW5ndGg7KXt2YXIgZj11KHQsZSksZD1oKHQsZSs9NCk7ZSs9NDt2YXIgcD1kKygxJmQpO3N3aXRjaChmKXtjYXNlIlZQOCAiOmNhc2UiVlA4TCI6dm9pZCAwPT09ci5mcmFtZXNbbl0mJihyLmZyYW1lc1tuXT17fSk7KHY9ci5mcmFtZXNbbl0pLnNyY19vZmY9aT9vOmUtOCx2LnNyY19zaXplPWErZCs4LG4rKyxpJiYoaT0hMSxhPTAsbz0wKTticmVhaztjYXNlIlZQOFgiOih2PXIuaGVhZGVyPXt9KS5mZWF0dXJlX2ZsYWdzPXRbZV07dmFyIGc9ZSs0O3YuY2FudmFzX3dpZHRoPTErbCh0LGcpO2crPTM7di5jYW52YXNfaGVpZ2h0PTErbCh0LGcpO2crPTM7YnJlYWs7Y2FzZSJBTFBIIjppPSEwLGE9cCs4LG89ZS04O2JyZWFrO2Nhc2UiQU5JTSI6KHY9ci5oZWFkZXIpLmJnY29sb3I9aCh0LGUpO2c9ZSs0O3YubG9vcF9jb3VudD0ocz10KVsoYz1nKSswXTw8MHxzW2MrMV08PDg7Zys9MjticmVhaztjYXNlIkFOTUYiOnZhciBtLHY7KHY9ci5mcmFtZXNbbl09e30pLm9mZnNldF94PTIqbCh0LGUpLGUrPTMsdi5vZmZzZXRfeT0yKmwodCxlKSxlKz0zLHYud2lkdGg9MStsKHQsZSksZSs9Myx2LmhlaWdodD0xK2wodCxlKSxlKz0zLHYuZHVyYXRpb249bCh0LGUpLGUrPTMsbT10W2UrK10sdi5kaXNwb3NlPTEmbSx2LmJsZW5kPW0+PjEmMX0iQU5NRiIhPWYmJihlKz1wKX1yZXR1cm4gcn19KG0sMCk7di5yZXNwb25zZT1tLHYucmdiYW91dHB1dD0hMCx2LmRhdGF1cmw9ITE7dmFyIGI9di5oZWFkZXI/di5oZWFkZXI6bnVsbCx5PXYuZnJhbWVzP3YuZnJhbWVzOm51bGw7aWYoYil7Yi5sb29wX2NvdW50ZXI9Yi5sb29wX2NvdW50LGY9W2IuY2FudmFzX2hlaWdodF0sZD1bYi5jYW52YXNfd2lkdGhdO2Zvcih2YXIgdz0wO3c8eS5sZW5ndGgmJjAhPXlbd10uYmxlbmQ7dysrKTt9dmFyIE49eVswXSxMPWcuV2ViUERlY29kZVJHQkEobSxOLnNyY19vZmYsTi5zcmNfc2l6ZSxkLGYpO04ucmdiYT1MLE4uaW1nd2lkdGg9ZFswXSxOLmltZ2hlaWdodD1mWzBdO2Zvcih2YXIgQT0wO0E8ZFswXSpmWzBdKjQ7QSsrKXBbQV09TFtBXTtyZXR1cm4gdGhpcy53aWR0aD1kLHRoaXMuaGVpZ2h0PWYsdGhpcy5kYXRhPXAsdGhpc30hZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0scj1mdW5jdGlvbihlLHIsaSx1KXt2YXIgbD00LGg9bztzd2l0Y2godSl7Y2FzZSB0LmltYWdlX2NvbXByZXNzaW9uLkZBU1Q6bD0xLGg9YTticmVhaztjYXNlIHQuaW1hZ2VfY29tcHJlc3Npb24uTUVESVVNOmw9NixoPXM7YnJlYWs7Y2FzZSB0LmltYWdlX2NvbXByZXNzaW9uLlNMT1c6bD05LGg9Y312YXIgZj1fZShlPW4oZSxyLGksaCkse2xldmVsOmx9KTtyZXR1cm4gdC5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhmKX0sbj1mdW5jdGlvbih0LGUscixuKXtmb3IodmFyIGksYSxvLHM9dC5sZW5ndGgvZSxjPW5ldyBVaW50OEFycmF5KHQubGVuZ3RoK3MpLHU9bCgpLGY9MDtmPHM7Zis9MSl7aWYobz1mKmUsaT10LnN1YmFycmF5KG8sbytlKSxuKWMuc2V0KG4oaSxyLGEpLG8rZik7ZWxzZXtmb3IodmFyIGQscD11Lmxlbmd0aCxnPVtdO2Q8cDtkKz0xKWdbZF09dVtkXShpLHIsYSk7dmFyIG09aChnLmNvbmNhdCgpKTtjLnNldChnW21dLG8rZil9YT1pfXJldHVybiBjfSxpPWZ1bmN0aW9uKHQpe3ZhciBlPUFycmF5LmFwcGx5KFtdLHQpO3JldHVybiBlLnVuc2hpZnQoMCksZX0sYT1mdW5jdGlvbih0LGUpe3ZhciByLG49W10saT10Lmxlbmd0aDtuWzBdPTE7Zm9yKHZhciBhPTA7YTxpO2ErPTEpcj10W2EtZV18fDAsblthKzFdPXRbYV0tcisyNTYmMjU1O3JldHVybiBufSxvPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpPVtdLGE9dC5sZW5ndGg7aVswXT0yO2Zvcih2YXIgbz0wO288YTtvKz0xKW49ciYmcltvXXx8MCxpW28rMV09dFtvXS1uKzI1NiYyNTU7cmV0dXJuIGl9LHM9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksYT1bXSxvPXQubGVuZ3RoO2FbMF09Mztmb3IodmFyIHM9MDtzPG87cys9MSluPXRbcy1lXXx8MCxpPXImJnJbc118fDAsYVtzKzFdPXRbc10rMjU2LShuK2k+Pj4xKSYyNTU7cmV0dXJuIGF9LGM9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksYSxvLHM9W10sYz10Lmxlbmd0aDtzWzBdPTQ7Zm9yKHZhciBsPTA7bDxjO2wrPTEpbj10W2wtZV18fDAsaT1yJiZyW2xdfHwwLGE9ciYmcltsLWVdfHwwLG89dShuLGksYSksc1tsKzFdPXRbbF0tbysyNTYmMjU1O3JldHVybiBzfSx1PWZ1bmN0aW9uKHQsZSxyKXtpZih0PT09ZSYmZT09PXIpcmV0dXJuIHQ7dmFyIG49TWF0aC5hYnMoZS1yKSxpPU1hdGguYWJzKHQtciksYT1NYXRoLmFicyh0K2Utci1yKTtyZXR1cm4gbjw9aSYmbjw9YT90Omk8PWE/ZTpyfSxsPWZ1bmN0aW9uKCl7cmV0dXJuW2ksYSxvLHMsY119LGg9ZnVuY3Rpb24odCl7dmFyIGU9dC5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlZHVjZSgoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCtNYXRoLmFicyhlKX0pLDApfSkpO3JldHVybiBlLmluZGV4T2YoTWF0aC5taW4uYXBwbHkobnVsbCxlKSl9O3QucHJvY2Vzc1BORz1mdW5jdGlvbihuLGksYSxvKXt2YXIgcyxjLHUsbCxoLGYsZCxwLGcsbSx2LGIseSx3LE4sTD10aGlzLmRlY29kZS5GTEFURV9ERUNPREUsQT0iIjtpZih0aGlzLl9fYWRkaW1hZ2VfXy5pc0FycmF5QnVmZmVyKG4pJiYobj1uZXcgVWludDhBcnJheShuKSksdGhpcy5fX2FkZGltYWdlX18uaXNBcnJheUJ1ZmZlclZpZXcobikpe2lmKG49KHU9bmV3IE9lKG4pKS5pbWdEYXRhLGM9dS5iaXRzLHM9dS5jb2xvclNwYWNlLGg9dS5jb2xvcnMsLTEhPT1bNCw2XS5pbmRleE9mKHUuY29sb3JUeXBlKSl7aWYoOD09PXUuYml0cyl7Zz0ocD0zMj09dS5waXhlbEJpdGxlbmd0aD9uZXcgVWludDMyQXJyYXkodS5kZWNvZGVQaXhlbHMoKS5idWZmZXIpOjE2PT11LnBpeGVsQml0bGVuZ3RoP25ldyBVaW50MTZBcnJheSh1LmRlY29kZVBpeGVscygpLmJ1ZmZlcik6bmV3IFVpbnQ4QXJyYXkodS5kZWNvZGVQaXhlbHMoKS5idWZmZXIpKS5sZW5ndGgsdj1uZXcgVWludDhBcnJheShnKnUuY29sb3JzKSxtPW5ldyBVaW50OEFycmF5KGcpO3ZhciB4LFM9dS5waXhlbEJpdGxlbmd0aC11LmJpdHM7Zm9yKHc9MCxOPTA7dzxnO3crKyl7Zm9yKHk9cFt3XSx4PTA7eDxTOyl2W04rK109eT4+PngmMjU1LHgrPXUuYml0czttW3ddPXk+Pj54JjI1NX19aWYoMTY9PT11LmJpdHMpe2c9KHA9bmV3IFVpbnQzMkFycmF5KHUuZGVjb2RlUGl4ZWxzKCkuYnVmZmVyKSkubGVuZ3RoLHY9bmV3IFVpbnQ4QXJyYXkoZyooMzIvdS5waXhlbEJpdGxlbmd0aCkqdS5jb2xvcnMpLG09bmV3IFVpbnQ4QXJyYXkoZyooMzIvdS5waXhlbEJpdGxlbmd0aCkpLGI9dS5jb2xvcnM+MSx3PTAsTj0wO2Zvcih2YXIgXz0wO3c8ZzspeT1wW3crK10sdltOKytdPXk+Pj4wJjI1NSxiJiYodltOKytdPXk+Pj4xNiYyNTUseT1wW3crK10sdltOKytdPXk+Pj4wJjI1NSksbVtfKytdPXk+Pj4xNiYyNTU7Yz04fW8hPT10LmltYWdlX2NvbXByZXNzaW9uLk5PTkUmJmUoKT8obj1yKHYsdS53aWR0aCp1LmNvbG9ycyx1LmNvbG9ycyxvKSxkPXIobSx1LndpZHRoLDEsbykpOihuPXYsZD1tLEw9dm9pZCAwKX1pZigzPT09dS5jb2xvclR5cGUmJihzPXRoaXMuY29sb3Jfc3BhY2VzLklOREVYRUQsZj11LnBhbGV0dGUsdS50cmFuc3BhcmVuY3kuaW5kZXhlZCkpe3ZhciBQPXUudHJhbnNwYXJlbmN5LmluZGV4ZWQsaz0wO2Zvcih3PTAsZz1QLmxlbmd0aDt3PGc7Kyt3KWsrPVBbd107aWYoKGsvPTI1NSk9PT1nLTEmJi0xIT09UC5pbmRleE9mKDApKWw9W1AuaW5kZXhPZigwKV07ZWxzZSBpZihrIT09Zyl7Zm9yKHA9dS5kZWNvZGVQaXhlbHMoKSxtPW5ldyBVaW50OEFycmF5KHAubGVuZ3RoKSx3PTAsZz1wLmxlbmd0aDt3PGc7dysrKW1bd109UFtwW3ddXTtkPXIobSx1LndpZHRoLDEpfX12YXIgRj1mdW5jdGlvbihlKXt2YXIgcjtzd2l0Y2goZSl7Y2FzZSB0LmltYWdlX2NvbXByZXNzaW9uLkZBU1Q6cj0xMTticmVhaztjYXNlIHQuaW1hZ2VfY29tcHJlc3Npb24uTUVESVVNOnI9MTM7YnJlYWs7Y2FzZSB0LmltYWdlX2NvbXByZXNzaW9uLlNMT1c6cj0xNDticmVhaztkZWZhdWx0OnI9MTJ9cmV0dXJuIHJ9KG8pO3JldHVybiBMPT09dGhpcy5kZWNvZGUuRkxBVEVfREVDT0RFJiYoQT0iL1ByZWRpY3RvciAiK0YrIiAiKSxBKz0iL0NvbG9ycyAiK2grIiAvQml0c1BlckNvbXBvbmVudCAiK2MrIiAvQ29sdW1ucyAiK3Uud2lkdGgsKHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXIobil8fHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3KG4pKSYmKG49dGhpcy5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhuKSksKGQmJnRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXIoZCl8fHRoaXMuX19hZGRpbWFnZV9fLmlzQXJyYXlCdWZmZXJWaWV3KGQpKSYmKGQ9dGhpcy5fX2FkZGltYWdlX18uYXJyYXlCdWZmZXJUb0JpbmFyeVN0cmluZyhkKSkse2FsaWFzOmEsZGF0YTpuLGluZGV4OmksZmlsdGVyOkwsZGVjb2RlUGFyYW1ldGVyczpBLHRyYW5zcGFyZW5jeTpsLHBhbGV0dGU6ZixzTWFzazpkLHByZWRpY3RvcjpGLHdpZHRoOnUud2lkdGgsaGVpZ2h0OnUuaGVpZ2h0LGJpdHNQZXJDb21wb25lbnQ6Yyxjb2xvclNwYWNlOnN9fX19KE0uQVBJKSxmdW5jdGlvbih0KXt0LnByb2Nlc3NHSUY4OUE9ZnVuY3Rpb24oZSxyLG4saSl7dmFyIGE9bmV3IEJlKGUpLG89YS53aWR0aCxzPWEuaGVpZ2h0LGM9W107YS5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKDAsYyk7dmFyIHU9e2RhdGE6Yyx3aWR0aDpvLGhlaWdodDpzfSxsPW5ldyBFZSgxMDApLmVuY29kZSh1LDEwMCk7cmV0dXJuIHQucHJvY2Vzc0pQRUcuY2FsbCh0aGlzLGwscixuLGkpfSx0LnByb2Nlc3NHSUY4N0E9dC5wcm9jZXNzR0lGODlBfShNLkFQSSkscWUucHJvdG90eXBlLnBhcnNlSGVhZGVyPWZ1bmN0aW9uKCl7aWYodGhpcy5maWxlU2l6ZT10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5yZXNlcnZlZD10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5vZmZzZXQ9dGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsITApLHRoaXMucG9zKz00LHRoaXMuaGVhZGVyU2l6ZT10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy53aWR0aD10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5oZWlnaHQ9dGhpcy5kYXRhdi5nZXRJbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5wbGFuZXM9dGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsITApLHRoaXMucG9zKz0yLHRoaXMuYml0UFA9dGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsITApLHRoaXMucG9zKz0yLHRoaXMuY29tcHJlc3M9dGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsITApLHRoaXMucG9zKz00LHRoaXMucmF3U2l6ZT10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5ocj10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy52cj10aGlzLmRhdGF2LmdldFVpbnQzMih0aGlzLnBvcywhMCksdGhpcy5wb3MrPTQsdGhpcy5jb2xvcnM9dGhpcy5kYXRhdi5nZXRVaW50MzIodGhpcy5wb3MsITApLHRoaXMucG9zKz00LHRoaXMuaW1wb3J0YW50Q29sb3JzPXRoaXMuZGF0YXYuZ2V0VWludDMyKHRoaXMucG9zLCEwKSx0aGlzLnBvcys9NCwxNj09PXRoaXMuYml0UFAmJnRoaXMuaXNfd2l0aF9hbHBoYSYmKHRoaXMuYml0UFA9MTUpLHRoaXMuYml0UFA8MTUpe3ZhciB0PTA9PT10aGlzLmNvbG9ycz8xPDx0aGlzLmJpdFBQOnRoaXMuY29sb3JzO3RoaXMucGFsZXR0ZT1uZXcgQXJyYXkodCk7Zm9yKHZhciBlPTA7ZTx0O2UrKyl7dmFyIHI9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxuPXRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywhMCksaT10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLGE9dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKTt0aGlzLnBhbGV0dGVbZV09e3JlZDppLGdyZWVuOm4sYmx1ZTpyLHF1YWQ6YX19fXRoaXMuaGVpZ2h0PDAmJih0aGlzLmhlaWdodCo9LTEsdGhpcy5ib3R0b21fdXA9ITEpfSxxZS5wcm90b3R5cGUucGFyc2VCR1I9ZnVuY3Rpb24oKXt0aGlzLnBvcz10aGlzLm9mZnNldDt0cnl7dmFyIHQ9ImJpdCIrdGhpcy5iaXRQUCxlPXRoaXMud2lkdGgqdGhpcy5oZWlnaHQqNDt0aGlzLmRhdGE9bmV3IFVpbnQ4QXJyYXkoZSksdGhpc1t0XSgpfWNhdGNoKHQpe2kubG9nKCJiaXQgZGVjb2RlIGVycm9yOiIrdCl9fSxxZS5wcm90b3R5cGUuYml0MT1mdW5jdGlvbigpe3ZhciB0LGU9TWF0aC5jZWlsKHRoaXMud2lkdGgvOCkscj1lJTQ7Zm9yKHQ9dGhpcy5oZWlnaHQtMTt0Pj0wO3QtLSl7Zm9yKHZhciBuPXRoaXMuYm90dG9tX3VwP3Q6dGhpcy5oZWlnaHQtMS10LGk9MDtpPGU7aSsrKWZvcih2YXIgYT10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLG89bip0aGlzLndpZHRoKjQrOCppKjQscz0wO3M8OCYmOCppK3M8dGhpcy53aWR0aDtzKyspe3ZhciBjPXRoaXMucGFsZXR0ZVthPj43LXMmMV07dGhpcy5kYXRhW28rNCpzXT1jLmJsdWUsdGhpcy5kYXRhW28rNCpzKzFdPWMuZ3JlZW4sdGhpcy5kYXRhW28rNCpzKzJdPWMucmVkLHRoaXMuZGF0YVtvKzQqcyszXT0yNTV9MCE9PXImJih0aGlzLnBvcys9NC1yKX19LHFlLnByb3RvdHlwZS5iaXQ0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PU1hdGguY2VpbCh0aGlzLndpZHRoLzIpLGU9dCU0LHI9dGhpcy5oZWlnaHQtMTtyPj0wO3ItLSl7Zm9yKHZhciBuPXRoaXMuYm90dG9tX3VwP3I6dGhpcy5oZWlnaHQtMS1yLGk9MDtpPHQ7aSsrKXt2YXIgYT10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLG89bip0aGlzLndpZHRoKjQrMippKjQscz1hPj40LGM9MTUmYSx1PXRoaXMucGFsZXR0ZVtzXTtpZih0aGlzLmRhdGFbb109dS5ibHVlLHRoaXMuZGF0YVtvKzFdPXUuZ3JlZW4sdGhpcy5kYXRhW28rMl09dS5yZWQsdGhpcy5kYXRhW28rM109MjU1LDIqaSsxPj10aGlzLndpZHRoKWJyZWFrO3U9dGhpcy5wYWxldHRlW2NdLHRoaXMuZGF0YVtvKzRdPXUuYmx1ZSx0aGlzLmRhdGFbbys0KzFdPXUuZ3JlZW4sdGhpcy5kYXRhW28rNCsyXT11LnJlZCx0aGlzLmRhdGFbbys0KzNdPTI1NX0wIT09ZSYmKHRoaXMucG9zKz00LWUpfX0scWUucHJvdG90eXBlLmJpdDg9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy53aWR0aCU0LGU9dGhpcy5oZWlnaHQtMTtlPj0wO2UtLSl7Zm9yKHZhciByPXRoaXMuYm90dG9tX3VwP2U6dGhpcy5oZWlnaHQtMS1lLG49MDtuPHRoaXMud2lkdGg7bisrKXt2YXIgaT10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLGE9cip0aGlzLndpZHRoKjQrNCpuO2lmKGk8dGhpcy5wYWxldHRlLmxlbmd0aCl7dmFyIG89dGhpcy5wYWxldHRlW2ldO3RoaXMuZGF0YVthXT1vLnJlZCx0aGlzLmRhdGFbYSsxXT1vLmdyZWVuLHRoaXMuZGF0YVthKzJdPW8uYmx1ZSx0aGlzLmRhdGFbYSszXT0yNTV9ZWxzZSB0aGlzLmRhdGFbYV09MjU1LHRoaXMuZGF0YVthKzFdPTI1NSx0aGlzLmRhdGFbYSsyXT0yNTUsdGhpcy5kYXRhW2ErM109MjU1fTAhPT10JiYodGhpcy5wb3MrPTQtdCl9fSxxZS5wcm90b3R5cGUuYml0MTU9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy53aWR0aCUzLGU9cGFyc2VJbnQoIjExMTExIiwyKSxyPXRoaXMuaGVpZ2h0LTE7cj49MDtyLS0pe2Zvcih2YXIgbj10aGlzLmJvdHRvbV91cD9yOnRoaXMuaGVpZ2h0LTEtcixpPTA7aTx0aGlzLndpZHRoO2krKyl7dmFyIGE9dGhpcy5kYXRhdi5nZXRVaW50MTYodGhpcy5wb3MsITApO3RoaXMucG9zKz0yO3ZhciBvPShhJmUpL2UqMjU1fDAscz0oYT4+NSZlKS9lKjI1NXwwLGM9KGE+PjEwJmUpL2UqMjU1fDAsdT1hPj4xNT8yNTU6MCxsPW4qdGhpcy53aWR0aCo0KzQqaTt0aGlzLmRhdGFbbF09Yyx0aGlzLmRhdGFbbCsxXT1zLHRoaXMuZGF0YVtsKzJdPW8sdGhpcy5kYXRhW2wrM109dX10aGlzLnBvcys9dH19LHFlLnByb3RvdHlwZS5iaXQxNj1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLndpZHRoJTMsZT1wYXJzZUludCgiMTExMTEiLDIpLHI9cGFyc2VJbnQoIjExMTExMSIsMiksbj10aGlzLmhlaWdodC0xO24+PTA7bi0tKXtmb3IodmFyIGk9dGhpcy5ib3R0b21fdXA/bjp0aGlzLmhlaWdodC0xLW4sYT0wO2E8dGhpcy53aWR0aDthKyspe3ZhciBvPXRoaXMuZGF0YXYuZ2V0VWludDE2KHRoaXMucG9zLCEwKTt0aGlzLnBvcys9Mjt2YXIgcz0obyZlKS9lKjI1NXwwLGM9KG8+PjUmcikvcioyNTV8MCx1PShvPj4xMSkvZSoyNTV8MCxsPWkqdGhpcy53aWR0aCo0KzQqYTt0aGlzLmRhdGFbbF09dSx0aGlzLmRhdGFbbCsxXT1jLHRoaXMuZGF0YVtsKzJdPXMsdGhpcy5kYXRhW2wrM109MjU1fXRoaXMucG9zKz10fX0scWUucHJvdG90eXBlLmJpdDI0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuaGVpZ2h0LTE7dD49MDt0LS0pe2Zvcih2YXIgZT10aGlzLmJvdHRvbV91cD90OnRoaXMuaGVpZ2h0LTEtdCxyPTA7cjx0aGlzLndpZHRoO3IrKyl7dmFyIG49dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxpPXRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywhMCksYT10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLG89ZSp0aGlzLndpZHRoKjQrNCpyO3RoaXMuZGF0YVtvXT1hLHRoaXMuZGF0YVtvKzFdPWksdGhpcy5kYXRhW28rMl09bix0aGlzLmRhdGFbbyszXT0yNTV9dGhpcy5wb3MrPXRoaXMud2lkdGglNH19LHFlLnByb3RvdHlwZS5iaXQzMj1mdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmhlaWdodC0xO3Q+PTA7dC0tKWZvcih2YXIgZT10aGlzLmJvdHRvbV91cD90OnRoaXMuaGVpZ2h0LTEtdCxyPTA7cjx0aGlzLndpZHRoO3IrKyl7dmFyIG49dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxpPXRoaXMuZGF0YXYuZ2V0VWludDgodGhpcy5wb3MrKywhMCksYT10aGlzLmRhdGF2LmdldFVpbnQ4KHRoaXMucG9zKyssITApLG89dGhpcy5kYXRhdi5nZXRVaW50OCh0aGlzLnBvcysrLCEwKSxzPWUqdGhpcy53aWR0aCo0KzQqcjt0aGlzLmRhdGFbc109YSx0aGlzLmRhdGFbcysxXT1pLHRoaXMuZGF0YVtzKzJdPW4sdGhpcy5kYXRhW3MrM109b319LHFlLnByb3RvdHlwZS5nZXREYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sCi8qKgogICAqIEBsaWNlbnNlCiAgICogQ29weXJpZ2h0IChjKSAyMDE4IEFyYXMgQWJiYXNpCiAgICoKICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAgICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAgICovCmZ1bmN0aW9uKHQpe3QucHJvY2Vzc0JNUD1mdW5jdGlvbihlLHIsbixpKXt2YXIgYT1uZXcgcWUoZSwhMSksbz1hLndpZHRoLHM9YS5oZWlnaHQsYz17ZGF0YTphLmdldERhdGEoKSx3aWR0aDpvLGhlaWdodDpzfSx1PW5ldyBFZSgxMDApLmVuY29kZShjLDEwMCk7cmV0dXJuIHQucHJvY2Vzc0pQRUcuY2FsbCh0aGlzLHUscixuLGkpfX0oTS5BUEkpLERlLnByb3RvdHlwZS5nZXREYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sCi8qKgogICAqIEBsaWNlbnNlCiAgICogQ29weXJpZ2h0IChjKSAyMDE5IEFyYXMgQWJiYXNpCiAgICoKICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAgICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAgICovCmZ1bmN0aW9uKHQpe3QucHJvY2Vzc1dFQlA9ZnVuY3Rpb24oZSxyLG4saSl7dmFyIGE9bmV3IERlKGUsITEpLG89YS53aWR0aCxzPWEuaGVpZ2h0LGM9e2RhdGE6YS5nZXREYXRhKCksd2lkdGg6byxoZWlnaHQ6c30sdT1uZXcgRWUoMTAwKS5lbmNvZGUoYywxMDApO3JldHVybiB0LnByb2Nlc3NKUEVHLmNhbGwodGhpcyx1LHIsbixpKX19KE0uQVBJKSwKLyoqCiAgICogQGxpY2Vuc2UKICAgKgogICAqIENvcHlyaWdodCAoYykgMjAyMSBBbnR0aSBQYWxvbGEsIGh0dHBzOi8vZ2l0aHViLmNvbS9QYW50dXJhCiAgICoKICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcKICAgKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKICAgKiAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCiAgICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAogICAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwogICAqIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0bwogICAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKICAgKgogICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlCiAgICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCiAgICoKICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwKICAgKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKICAgKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORAogICAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUKICAgKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OCiAgICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OCiAgICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCiAgICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KICAgKi8KZnVuY3Rpb24odCl7dC5wcm9jZXNzUkdCQT1mdW5jdGlvbih0LGUscil7Zm9yKHZhciBuPXQuZGF0YSxpPW4ubGVuZ3RoLGE9bmV3IFVpbnQ4QXJyYXkoaS80KjMpLG89bmV3IFVpbnQ4QXJyYXkoaS80KSxzPTAsYz0wLHU9MDt1PGk7dSs9NCl7dmFyIGw9blt1XSxoPW5bdSsxXSxmPW5bdSsyXSxkPW5bdSszXTthW3MrK109bCxhW3MrK109aCxhW3MrK109ZixvW2MrK109ZH12YXIgcD10aGlzLl9fYWRkaW1hZ2VfXy5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nKGEpO3JldHVybnthbHBoYTp0aGlzLl9fYWRkaW1hZ2VfXy5hcnJheUJ1ZmZlclRvQmluYXJ5U3RyaW5nKG8pLGRhdGE6cCxpbmRleDplLGFsaWFzOnIsY29sb3JTcGFjZToiRGV2aWNlUkdCIixiaXRzUGVyQ29tcG9uZW50Ojgsd2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHR9fX0oTS5BUEkpLAovKioKICAgKiBAbGljZW5zZQogICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4KICAgKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UKICAgKi8KZnVuY3Rpb24odCl7dC5zZXRMYW5ndWFnZT1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dGhpcy5pbnRlcm5hbC5sYW5ndWFnZVNldHRpbmdzJiYodGhpcy5pbnRlcm5hbC5sYW5ndWFnZVNldHRpbmdzPXt9LHRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5pc1N1YnNjcmliZWQ9ITEpLHZvaWQgMCE9PXthZjoiQWZyaWthYW5zIixzcToiQWxiYW5pYW4iLGFyOiJBcmFiaWMgKFN0YW5kYXJkKSIsImFyLURaIjoiQXJhYmljIChBbGdlcmlhKSIsImFyLUJIIjoiQXJhYmljIChCYWhyYWluKSIsImFyLUVHIjoiQXJhYmljIChFZ3lwdCkiLCJhci1JUSI6IkFyYWJpYyAoSXJhcSkiLCJhci1KTyI6IkFyYWJpYyAoSm9yZGFuKSIsImFyLUtXIjoiQXJhYmljIChLdXdhaXQpIiwiYXItTEIiOiJBcmFiaWMgKExlYmFub24pIiwiYXItTFkiOiJBcmFiaWMgKExpYnlhKSIsImFyLU1BIjoiQXJhYmljIChNb3JvY2NvKSIsImFyLU9NIjoiQXJhYmljIChPbWFuKSIsImFyLVFBIjoiQXJhYmljIChRYXRhcikiLCJhci1TQSI6IkFyYWJpYyAoU2F1ZGkgQXJhYmlhKSIsImFyLVNZIjoiQXJhYmljIChTeXJpYSkiLCJhci1UTiI6IkFyYWJpYyAoVHVuaXNpYSkiLCJhci1BRSI6IkFyYWJpYyAoVS5BLkUuKSIsImFyLVlFIjoiQXJhYmljIChZZW1lbikiLGFuOiJBcmFnb25lc2UiLGh5OiJBcm1lbmlhbiIsYXM6IkFzc2FtZXNlIixhc3Q6IkFzdHVyaWFuIixhejoiQXplcmJhaWphbmkiLGV1OiJCYXNxdWUiLGJlOiJCZWxhcnVzaWFuIixibjoiQmVuZ2FsaSIsYnM6IkJvc25pYW4iLGJyOiJCcmV0b24iLGJnOiJCdWxnYXJpYW4iLG15OiJCdXJtZXNlIixjYToiQ2F0YWxhbiIsY2g6IkNoYW1vcnJvIixjZToiQ2hlY2hlbiIsemg6IkNoaW5lc2UiLCJ6aC1ISyI6IkNoaW5lc2UgKEhvbmcgS29uZykiLCJ6aC1DTiI6IkNoaW5lc2UgKFBSQykiLCJ6aC1TRyI6IkNoaW5lc2UgKFNpbmdhcG9yZSkiLCJ6aC1UVyI6IkNoaW5lc2UgKFRhaXdhbikiLGN2OiJDaHV2YXNoIixjbzoiQ29yc2ljYW4iLGNyOiJDcmVlIixocjoiQ3JvYXRpYW4iLGNzOiJDemVjaCIsZGE6IkRhbmlzaCIsbmw6IkR1dGNoIChTdGFuZGFyZCkiLCJubC1CRSI6IkR1dGNoIChCZWxnaWFuKSIsZW46IkVuZ2xpc2giLCJlbi1BVSI6IkVuZ2xpc2ggKEF1c3RyYWxpYSkiLCJlbi1CWiI6IkVuZ2xpc2ggKEJlbGl6ZSkiLCJlbi1DQSI6IkVuZ2xpc2ggKENhbmFkYSkiLCJlbi1JRSI6IkVuZ2xpc2ggKElyZWxhbmQpIiwiZW4tSk0iOiJFbmdsaXNoIChKYW1haWNhKSIsImVuLU5aIjoiRW5nbGlzaCAoTmV3IFplYWxhbmQpIiwiZW4tUEgiOiJFbmdsaXNoIChQaGlsaXBwaW5lcykiLCJlbi1aQSI6IkVuZ2xpc2ggKFNvdXRoIEFmcmljYSkiLCJlbi1UVCI6IkVuZ2xpc2ggKFRyaW5pZGFkICYgVG9iYWdvKSIsImVuLUdCIjoiRW5nbGlzaCAoVW5pdGVkIEtpbmdkb20pIiwiZW4tVVMiOiJFbmdsaXNoIChVbml0ZWQgU3RhdGVzKSIsImVuLVpXIjoiRW5nbGlzaCAoWmltYmFid2UpIixlbzoiRXNwZXJhbnRvIixldDoiRXN0b25pYW4iLGZvOiJGYWVyb2VzZSIsZmo6IkZpamlhbiIsZmk6IkZpbm5pc2giLGZyOiJGcmVuY2ggKFN0YW5kYXJkKSIsImZyLUJFIjoiRnJlbmNoIChCZWxnaXVtKSIsImZyLUNBIjoiRnJlbmNoIChDYW5hZGEpIiwiZnItRlIiOiJGcmVuY2ggKEZyYW5jZSkiLCJmci1MVSI6IkZyZW5jaCAoTHV4ZW1ib3VyZykiLCJmci1NQyI6IkZyZW5jaCAoTW9uYWNvKSIsImZyLUNIIjoiRnJlbmNoIChTd2l0emVybGFuZCkiLGZ5OiJGcmlzaWFuIixmdXI6IkZyaXVsaWFuIixnZDoiR2FlbGljIChTY290cykiLCJnZC1JRSI6IkdhZWxpYyAoSXJpc2gpIixnbDoiR2FsYWNpYW4iLGthOiJHZW9yZ2lhbiIsZGU6Ikdlcm1hbiAoU3RhbmRhcmQpIiwiZGUtQVQiOiJHZXJtYW4gKEF1c3RyaWEpIiwiZGUtREUiOiJHZXJtYW4gKEdlcm1hbnkpIiwiZGUtTEkiOiJHZXJtYW4gKExpZWNodGVuc3RlaW4pIiwiZGUtTFUiOiJHZXJtYW4gKEx1eGVtYm91cmcpIiwiZGUtQ0giOiJHZXJtYW4gKFN3aXR6ZXJsYW5kKSIsZWw6IkdyZWVrIixndToiR3VqdXJhdGkiLGh0OiJIYWl0aWFuIixoZToiSGVicmV3IixoaToiSGluZGkiLGh1OiJIdW5nYXJpYW4iLGlzOiJJY2VsYW5kaWMiLGlkOiJJbmRvbmVzaWFuIixpdToiSW51a3RpdHV0IixnYToiSXJpc2giLGl0OiJJdGFsaWFuIChTdGFuZGFyZCkiLCJpdC1DSCI6Ikl0YWxpYW4gKFN3aXR6ZXJsYW5kKSIsamE6IkphcGFuZXNlIixrbjoiS2FubmFkYSIsa3M6Ikthc2htaXJpIixrazoiS2F6YWtoIixrbToiS2htZXIiLGt5OiJLaXJnaGl6Iix0bGg6IktsaW5nb24iLGtvOiJLb3JlYW4iLCJrby1LUCI6IktvcmVhbiAoTm9ydGggS29yZWEpIiwia28tS1IiOiJLb3JlYW4gKFNvdXRoIEtvcmVhKSIsbGE6IkxhdGluIixsdjoiTGF0dmlhbiIsbHQ6IkxpdGh1YW5pYW4iLGxiOiJMdXhlbWJvdXJnaXNoIixtazoiTm9ydGggTWFjZWRvbmlhIixtczoiTWFsYXkiLG1sOiJNYWxheWFsYW0iLG10OiJNYWx0ZXNlIixtaToiTWFvcmkiLG1yOiJNYXJhdGhpIixtbzoiTW9sZGF2aWFuIixudjoiTmF2YWpvIixuZzoiTmRvbmdhIixuZToiTmVwYWxpIixubzoiTm9yd2VnaWFuIixuYjoiTm9yd2VnaWFuIChCb2ttYWwpIixubjoiTm9yd2VnaWFuIChOeW5vcnNrKSIsb2M6Ik9jY2l0YW4iLG9yOiJPcml5YSIsb206Ik9yb21vIixmYToiUGVyc2lhbiIsImZhLUlSIjoiUGVyc2lhbi9JcmFuIixwbDoiUG9saXNoIixwdDoiUG9ydHVndWVzZSIsInB0LUJSIjoiUG9ydHVndWVzZSAoQnJhemlsKSIscGE6IlB1bmphYmkiLCJwYS1JTiI6IlB1bmphYmkgKEluZGlhKSIsInBhLVBLIjoiUHVuamFiaSAoUGFraXN0YW4pIixxdToiUXVlY2h1YSIscm06IlJoYWV0by1Sb21hbmljIixybzoiUm9tYW5pYW4iLCJyby1NTyI6IlJvbWFuaWFuIChNb2xkYXZpYSkiLHJ1OiJSdXNzaWFuIiwicnUtTU8iOiJSdXNzaWFuIChNb2xkYXZpYSkiLHN6OiJTYW1pIChMYXBwaXNoKSIsc2c6IlNhbmdvIixzYToiU2Fuc2tyaXQiLHNjOiJTYXJkaW5pYW4iLHNkOiJTaW5kaGkiLHNpOiJTaW5naGFsZXNlIixzcjoiU2VyYmlhbiIsc2s6IlNsb3ZhayIsc2w6IlNsb3ZlbmlhbiIsc286IlNvbWFuaSIsc2I6IlNvcmJpYW4iLGVzOiJTcGFuaXNoIiwiZXMtQVIiOiJTcGFuaXNoIChBcmdlbnRpbmEpIiwiZXMtQk8iOiJTcGFuaXNoIChCb2xpdmlhKSIsImVzLUNMIjoiU3BhbmlzaCAoQ2hpbGUpIiwiZXMtQ08iOiJTcGFuaXNoIChDb2xvbWJpYSkiLCJlcy1DUiI6IlNwYW5pc2ggKENvc3RhIFJpY2EpIiwiZXMtRE8iOiJTcGFuaXNoIChEb21pbmljYW4gUmVwdWJsaWMpIiwiZXMtRUMiOiJTcGFuaXNoIChFY3VhZG9yKSIsImVzLVNWIjoiU3BhbmlzaCAoRWwgU2FsdmFkb3IpIiwiZXMtR1QiOiJTcGFuaXNoIChHdWF0ZW1hbGEpIiwiZXMtSE4iOiJTcGFuaXNoIChIb25kdXJhcykiLCJlcy1NWCI6IlNwYW5pc2ggKE1leGljbykiLCJlcy1OSSI6IlNwYW5pc2ggKE5pY2FyYWd1YSkiLCJlcy1QQSI6IlNwYW5pc2ggKFBhbmFtYSkiLCJlcy1QWSI6IlNwYW5pc2ggKFBhcmFndWF5KSIsImVzLVBFIjoiU3BhbmlzaCAoUGVydSkiLCJlcy1QUiI6IlNwYW5pc2ggKFB1ZXJ0byBSaWNvKSIsImVzLUVTIjoiU3BhbmlzaCAoU3BhaW4pIiwiZXMtVVkiOiJTcGFuaXNoIChVcnVndWF5KSIsImVzLVZFIjoiU3BhbmlzaCAoVmVuZXp1ZWxhKSIsc3g6IlN1dHUiLHN3OiJTd2FoaWxpIixzdjoiU3dlZGlzaCIsInN2LUZJIjoiU3dlZGlzaCAoRmlubGFuZCkiLCJzdi1TViI6IlN3ZWRpc2ggKFN3ZWRlbikiLHRhOiJUYW1pbCIsdHQ6IlRhdGFyIix0ZToiVGVsdWdhIix0aDoiVGhhaSIsdGlnOiJUaWdyZSIsdHM6IlRzb25nYSIsdG46IlRzd2FuYSIsdHI6IlR1cmtpc2giLHRrOiJUdXJrbWVuIix1azoiVWtyYWluaWFuIixoc2I6IlVwcGVyIFNvcmJpYW4iLHVyOiJVcmR1Iix2ZToiVmVuZGEiLHZpOiJWaWV0bmFtZXNlIix2bzoiVm9sYXB1ayIsd2E6IldhbGxvb24iLGN5OiJXZWxzaCIseGg6Ilhob3NhIixqaToiWWlkZGlzaCIsenU6Ilp1bHUifVt0XSYmKHRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5sYW5ndWFnZUNvZGU9dCwhMT09PXRoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5pc1N1YnNjcmliZWQmJih0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInB1dENhdGFsb2ciLChmdW5jdGlvbigpe3RoaXMuaW50ZXJuYWwud3JpdGUoIi9MYW5nICgiK3RoaXMuaW50ZXJuYWwubGFuZ3VhZ2VTZXR0aW5ncy5sYW5ndWFnZUNvZGUrIikiKX0pKSx0aGlzLmludGVybmFsLmxhbmd1YWdlU2V0dGluZ3MuaXNTdWJzY3JpYmVkPSEwKSksdGhpc319KE0uQVBJKSxrZT1NLkFQSSxGZT1rZS5nZXRDaGFyV2lkdGhzQXJyYXk9ZnVuY3Rpb24odCxyKXt2YXIgbixpLGE9KHI9cnx8e30pLmZvbnR8fHRoaXMuaW50ZXJuYWwuZ2V0Rm9udCgpLG89ci5mb250U2l6ZXx8dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLHM9ci5jaGFyU3BhY2V8fHRoaXMuaW50ZXJuYWwuZ2V0Q2hhclNwYWNlKCksYz1yLndpZHRocz9yLndpZHRoczphLm1ldGFkYXRhLlVuaWNvZGUud2lkdGhzLHU9Yy5mb2Y/Yy5mb2Y6MSxsPXIua2VybmluZz9yLmtlcm5pbmc6YS5tZXRhZGF0YS5Vbmljb2RlLmtlcm5pbmcsaD1sLmZvZj9sLmZvZjoxLGY9ITEhPT1yLmRvS2VybmluZyxkPTAscD10Lmxlbmd0aCxnPTAsbT1jWzBdfHx1LHY9W107Zm9yKG49MDtuPHA7bisrKWk9dC5jaGFyQ29kZUF0KG4pLCJmdW5jdGlvbiI9PXR5cGVvZiBhLm1ldGFkYXRhLndpZHRoT2ZTdHJpbmc/di5wdXNoKChhLm1ldGFkYXRhLndpZHRoT2ZHbHlwaChhLm1ldGFkYXRhLmNoYXJhY3RlclRvR2x5cGgoaSkpK3MqKDFlMy9vKXx8MCkvMWUzKTooZD1mJiYib2JqZWN0Ij09PWUobFtpXSkmJiFpc05hTihwYXJzZUludChsW2ldW2ddLDEwKSk/bFtpXVtnXS9oOjAsdi5wdXNoKChjW2ldfHxtKS91K2QpKSxnPWk7cmV0dXJuIHZ9LEllPWtlLmdldFN0cmluZ1VuaXRXaWR0aD1mdW5jdGlvbih0LGUpe3ZhciByPShlPWV8fHt9KS5mb250U2l6ZXx8dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLG49ZS5mb250fHx0aGlzLmludGVybmFsLmdldEZvbnQoKSxpPWUuY2hhclNwYWNlfHx0aGlzLmludGVybmFsLmdldENoYXJTcGFjZSgpO3JldHVybiBrZS5wcm9jZXNzQXJhYmljJiYodD1rZS5wcm9jZXNzQXJhYmljKHQpKSwiZnVuY3Rpb24iPT10eXBlb2Ygbi5tZXRhZGF0YS53aWR0aE9mU3RyaW5nP24ubWV0YWRhdGEud2lkdGhPZlN0cmluZyh0LHIsaSkvcjpGZS5hcHBseSh0aGlzLGFyZ3VtZW50cykucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9KSwwKX0sQ2U9ZnVuY3Rpb24odCxlLHIsbil7Zm9yKHZhciBpPVtdLGE9MCxvPXQubGVuZ3RoLHM9MDthIT09byYmcytlW2FdPHI7KXMrPWVbYV0sYSsrO2kucHVzaCh0LnNsaWNlKDAsYSkpO3ZhciBjPWE7Zm9yKHM9MDthIT09bzspcytlW2FdPm4mJihpLnB1c2godC5zbGljZShjLGEpKSxzPTAsYz1hKSxzKz1lW2FdLGErKztyZXR1cm4gYyE9PWEmJmkucHVzaCh0LnNsaWNlKGMsYSkpLGl9LGplPWZ1bmN0aW9uKHQsZSxyKXtyfHwocj17fSk7dmFyIG4saSxhLG8scyxjLHUsbD1bXSxoPVtsXSxmPXIudGV4dEluZGVudHx8MCxkPTAscD0wLGc9dC5zcGxpdCgiICIpLG09RmUuYXBwbHkodGhpcyxbIiAiLHJdKVswXTtpZihjPS0xPT09ci5saW5lSW5kZW50P2dbMF0ubGVuZ3RoKzI6ci5saW5lSW5kZW50fHwwKXt2YXIgdj1BcnJheShjKS5qb2luKCIgIiksYj1bXTtnLm1hcCgoZnVuY3Rpb24odCl7KHQ9dC5zcGxpdCgvXHMqXG4vKSkubGVuZ3RoPjE/Yj1iLmNvbmNhdCh0Lm1hcCgoZnVuY3Rpb24odCxlKXtyZXR1cm4oZSYmdC5sZW5ndGg/IlxuIjoiIikrdH0pKSk6Yi5wdXNoKHRbMF0pfSkpLGc9YixjPUllLmFwcGx5KHRoaXMsW3Yscl0pfWZvcihhPTAsbz1nLmxlbmd0aDthPG87YSsrKXt2YXIgeT0wO2lmKG49Z1thXSxjJiYiXG4iPT1uWzBdJiYobj1uLnN1YnN0cigxKSx5PTEpLGYrZCsocD0oaT1GZS5hcHBseSh0aGlzLFtuLHJdKSkucmVkdWNlKChmdW5jdGlvbih0LGUpe3JldHVybiB0K2V9KSwwKSk+ZXx8eSl7aWYocD5lKXtmb3Iocz1DZS5hcHBseSh0aGlzLFtuLGksZS0oZitkKSxlXSksbC5wdXNoKHMuc2hpZnQoKSksbD1bcy5wb3AoKV07cy5sZW5ndGg7KWgucHVzaChbcy5zaGlmdCgpXSk7cD1pLnNsaWNlKG4ubGVuZ3RoLShsWzBdP2xbMF0ubGVuZ3RoOjApKS5yZWR1Y2UoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZX0pLDApfWVsc2UgbD1bbl07aC5wdXNoKGwpLGY9cCtjLGQ9bX1lbHNlIGwucHVzaChuKSxmKz1kK3AsZD1tfXJldHVybiB1PWM/ZnVuY3Rpb24odCxlKXtyZXR1cm4oZT92OiIiKSt0LmpvaW4oIiAiKX06ZnVuY3Rpb24odCl7cmV0dXJuIHQuam9pbigiICIpfSxoLm1hcCh1KX0sa2Uuc3BsaXRUZXh0VG9TaXplPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpPShyPXJ8fHt9KS5mb250U2l6ZXx8dGhpcy5pbnRlcm5hbC5nZXRGb250U2l6ZSgpLGE9ZnVuY3Rpb24odCl7aWYodC53aWR0aHMmJnQua2VybmluZylyZXR1cm57d2lkdGhzOnQud2lkdGhzLGtlcm5pbmc6dC5rZXJuaW5nfTt2YXIgZT10aGlzLmludGVybmFsLmdldEZvbnQodC5mb250TmFtZSx0LmZvbnRTdHlsZSk7cmV0dXJuIGUubWV0YWRhdGEuVW5pY29kZT97d2lkdGhzOmUubWV0YWRhdGEuVW5pY29kZS53aWR0aHN8fHswOjF9LGtlcm5pbmc6ZS5tZXRhZGF0YS5Vbmljb2RlLmtlcm5pbmd8fHt9fTp7Zm9udDplLm1ldGFkYXRhLGZvbnRTaXplOnRoaXMuaW50ZXJuYWwuZ2V0Rm9udFNpemUoKSxjaGFyU3BhY2U6dGhpcy5pbnRlcm5hbC5nZXRDaGFyU3BhY2UoKX19LmNhbGwodGhpcyxyKTtuPUFycmF5LmlzQXJyYXkodCk/dDpTdHJpbmcodCkuc3BsaXQoL1xyP1xuLyk7dmFyIG89MSp0aGlzLmludGVybmFsLnNjYWxlRmFjdG9yKmUvaTthLnRleHRJbmRlbnQ9ci50ZXh0SW5kZW50PzEqci50ZXh0SW5kZW50KnRoaXMuaW50ZXJuYWwuc2NhbGVGYWN0b3IvaTowLGEubGluZUluZGVudD1yLmxpbmVJbmRlbnQ7dmFyIHMsYyx1PVtdO2ZvcihzPTAsYz1uLmxlbmd0aDtzPGM7cysrKXU9dS5jb25jYXQoamUuYXBwbHkodGhpcyxbbltzXSxvLGFdKSk7cmV0dXJuIHV9LGZ1bmN0aW9uKHQpe3QuX19mb250bWV0cmljc19fPXQuX19mb250bWV0cmljc19ffHx7fTtmb3IodmFyIHI9ImtsbW5vcHFyc3R1dnd4eXoiLG49e30saT17fSxhPTA7YTxyLmxlbmd0aDthKyspbltyW2FdXT0iMDEyMzQ1Njc4OWFiY2RlZiJbYV0saVsiMDEyMzQ1Njc4OWFiY2RlZiJbYV1dPXJbYV07dmFyIG89ZnVuY3Rpb24odCl7cmV0dXJuIjB4IitwYXJzZUludCh0LDEwKS50b1N0cmluZygxNil9LHM9dC5fX2ZvbnRtZXRyaWNzX18uY29tcHJlc3M9ZnVuY3Rpb24odCl7dmFyIHIsbixhLGMsdT1bInsiXTtmb3IodmFyIGwgaW4gdCl7aWYocj10W2xdLGlzTmFOKHBhcnNlSW50KGwsMTApKT9uPSInIitsKyInIjoobD1wYXJzZUludChsLDEwKSxuPShuPW8obCkuc2xpY2UoMikpLnNsaWNlKDAsLTEpK2lbbi5zbGljZSgtMSldKSwibnVtYmVyIj09dHlwZW9mIHIpcjwwPyhhPW8ocikuc2xpY2UoMyksYz0iLSIpOihhPW8ocikuc2xpY2UoMiksYz0iIiksYT1jK2Euc2xpY2UoMCwtMSkraVthLnNsaWNlKC0xKV07ZWxzZXtpZigib2JqZWN0IiE9PWUocikpdGhyb3cgbmV3IEVycm9yKCJEb24ndCBrbm93IHdoYXQgdG8gZG8gd2l0aCB2YWx1ZSB0eXBlICIrZShyKSsiLiIpO2E9cyhyKX11LnB1c2gobithKX1yZXR1cm4gdS5wdXNoKCJ9IiksdS5qb2luKCIiKX0sYz10Ll9fZm9udG1ldHJpY3NfXy51bmNvbXByZXNzPWZ1bmN0aW9uKHQpe2lmKCJzdHJpbmciIT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoIkludmFsaWQgYXJndW1lbnQgcGFzc2VkIHRvIHVuY29tcHJlc3MuIik7Zm9yKHZhciBlLHIsaSxhLG89e30scz0xLGM9byx1PVtdLGw9IiIsaD0iIixmPXQubGVuZ3RoLTEsZD0xO2Q8ZjtkKz0xKSInIj09KGE9dFtkXSk/ZT8oaT1lLmpvaW4oIiIpLGU9dm9pZCAwKTplPVtdOmU/ZS5wdXNoKGEpOiJ7Ij09YT8odS5wdXNoKFtjLGldKSxjPXt9LGk9dm9pZCAwKToifSI9PWE/KChyPXUucG9wKCkpWzBdW3JbMV1dPWMsaT12b2lkIDAsYz1yWzBdKToiLSI9PWE/cz0tMTp2b2lkIDA9PT1pP24uaGFzT3duUHJvcGVydHkoYSk/KGwrPW5bYV0saT1wYXJzZUludChsLDE2KSpzLHM9MSxsPSIiKTpsKz1hOm4uaGFzT3duUHJvcGVydHkoYSk/KGgrPW5bYV0sY1tpXT1wYXJzZUludChoLDE2KSpzLHM9MSxpPXZvaWQgMCxoPSIiKTpoKz1hO3JldHVybiBvfSx1PXtjb2RlUGFnZXM6WyJXaW5BbnNpRW5jb2RpbmciXSxXaW5BbnNpRW5jb2Rpbmc6YygiezE5bThuMjAxbjlxMjAxbzlyMjAxczlsMjAxdDltMjAxdThtMjAxdzluMjAxeDlvMjAxeThvMjAyazhxMjAybDhyMjAybTlwMjAycThwMjBhdzhrMjAzazh0MjAzdDh2MjAzdTl2MmNxOHMyMTJtOXQxNW04dzE1bjl3MmR3OXMxNms4dTE2bDl1MTdzOXoxN3g4eTE3eTl5fSIpfSxsPXtVbmljb2RlOntDb3VyaWVyOnUsIkNvdXJpZXItQm9sZCI6dSwiQ291cmllci1Cb2xkT2JsaXF1ZSI6dSwiQ291cmllci1PYmxpcXVlIjp1LEhlbHZldGljYTp1LCJIZWx2ZXRpY2EtQm9sZCI6dSwiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjp1LCJIZWx2ZXRpY2EtT2JsaXF1ZSI6dSwiVGltZXMtUm9tYW4iOnUsIlRpbWVzLUJvbGQiOnUsIlRpbWVzLUJvbGRJdGFsaWMiOnUsIlRpbWVzLUl0YWxpYyI6dX19LGg9e1VuaWNvZGU6eyJDb3VyaWVyLU9ibGlxdWUiOmMoInsnd2lkdGhzJ3trM3cnZm9mJzZvfSdrZXJuaW5nJ3snZm9mJy02b319IiksIlRpbWVzLUJvbGRJdGFsaWMiOmMoInsnd2lkdGhzJ3trM28ycTR5Y3gycjIwMW4zbTIwMW82bzIwMXMybDIwMXQybDIwMXUybDIwMXczbTIwMXgzbTIwMXkzbTJrMXQybDJyMjAybTJuMm4zbTJvM20ycDVuMjAycTZvMnIxdzJzMmwydDJsMnUzbTJ2M3QydzF0MngybDJ5MXQyejF3M2szbTNsM20zbTNtM24zbTNvM20zcDNtM3EzbTNyM20zczNtMjAzdDJsMjAzdTJsM3YybDN3M3QzeDN0M3kzdDN6M200azVuNGw0bTRtNG00bjRtNG80czRwNG00cTRtNHI0czRzNHk0dDJyNHUzbTR2NG00dzN4NHg1dDR5NHM0ejRzNWszeDVsNHM1bTRtNW4zcjVvM3g1cDRzNXE0bTVyNXQ1czRtNXQzeDV1M3g1djJsNXcxdzV4Mmw1eTN0NXozbTZrMmw2bDNtNm0zbTZuMnc2bzNtNnAydzZxMmw2cjNtNnMzcjZ0MXc2dTF3NnYzbTZ3MXc2eDR5NnkzcjZ6M203azNtN2wzbTdtMnI3bjJyN28xdzdwM3I3cTJ3N3I0bTdzM203dDJ3N3Uycjd2Mm43dzFxN3gybjd5M3QyMDJsM21jbDRtYWwycmFtM21hbjNtYW8zbWFwM21hcjNtYXMybGF0NHVhdTF1YXYzbWF3M3dheTR1YXoybGJrMnNibDN0J2ZvZic2b2JvMmxicDN0YnEzbWJyMXRiczJsYnUxeWJ2M21iejNtY2s0bTIwMmszbWNtNG1jbjRtY280bWNwNG1jcTV5Y3I0bWNzNG1jdDRtY3U0bWN2NG1jdzJyMm0zcmN5MnJjejJyZGw0c2RtNHNkbjRzZG80c2RwNHNkcTRzZHM0c2R0NHNkdTRzZHY0c2R3NHNkejNtZWszbWVsM21lbTNtZW4zbWVvM21lcDNtZXE0c2VyMndlczJ3ZXQyd2V1MndldjJ3ZXcxd2V4MXdleTF3ZXoxd2ZsM3JmbTNtZm4zbWZvM21mcDNtZnEzbWZyM3RmczNtZnQzcmZ1M3JmdjNyZnczcmZ6MncyMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzbTN1MmwxN3MzeDE5bTNtfSdrZXJuaW5nJ3tjbHs0cXU1a3Q1cXQ1cnMxN3NzNXRzfTIwMXN7MjAxc3N9MjAxdHtja3M0bHNjbXNjbnNjb3NjcHNjbHMyd3UyeXUyMDF0c30yMDF4ezJ3dTJ5dX0ya3syMDF0c30yd3s0cXg1a3g1b3U1cXg1cnMxN3N1NXR1fTJ4ezE3c3U1dHU1b3V9Mnl7NHF4NWt4NW91NXF4NXJzMTdzczV0c30nZm9mJy02b2ZuezE3c3c1dHc1b3U1cXc1cnN9N3R7Y2tzY2xzY21zY25zY29zY3BzNGxzfTN1ezE3c3U1dHU1b3M1cXN9M3Z7MTdzdTV0dTVvczVxc303cHsxN3N1NXR1fWNrezRxdTVrdDVxdDVyczE3c3M1dHN9NGx7NHF1NWt0NXF0NXJzMTdzczV0c31jbXs0cXU1a3Q1cXQ1cnMxN3NzNXRzfWNuezRxdTVrdDVxdDVyczE3c3M1dHN9Y297NHF1NWt0NXF0NXJzMTdzczV0c31jcHs0cXU1a3Q1cXQ1cnMxN3NzNXRzfTZsezRxdTVvdTVxdzVydDE3c3U1dHV9NXF7Y2t1Y2x1Y211Y251Y291Y3B1NGx1fTVye2NrdWNsdWNtdWNudWNvdWNwdTRsdX03cXtja3NjbHNjbXNjbnNjb3NjcHM0bHN9NnB7NHF1NW91NXF3NXJ0MTdzdzV0d31la3s0cXU1b3U1cXc1cnQxN3N1NXR1fWVsezRxdTVvdTVxdzVydDE3c3U1dHV9ZW17NHF1NW91NXF3NXJ0MTdzdTV0dX1lbns0cXU1b3U1cXc1cnQxN3N1NXR1fWVvezRxdTVvdTVxdzVydDE3c3U1dHV9ZXB7NHF1NW91NXF3NXJ0MTdzdTV0dX1lc3sxN3NzNXRzNXFzNHF1fWV0ezRxdTVvdTVxdzVydDE3c3c1dHd9ZXV7NHF1NW91NXF3NXJ0MTdzczV0c31ldnsxN3NzNXRzNXFzNHF1fTZ6ezE3c3c1dHc1b3U1cXc1cnN9Zm17MTdzdzV0dzVvdTVxdzVyc303bnsyMDF0c31mb3sxN3N3NXR3NW91NXF3NXJzfWZwezE3c3c1dHc1b3U1cXc1cnN9ZnF7MTdzdzV0dzVvdTVxdzVyc303cntja3NjbHNjbXNjbnNjb3NjcHM0bHN9ZnN7MTdzdzV0dzVvdTVxdzVyc31mdHsxN3N1NXR1fWZ1ezE3c3U1dHV9ZnZ7MTdzdTV0dX1md3sxN3N1NXR1fWZ6e2Nrc2Nsc2Ntc2Nuc2Nvc2NwczRsc319fSIpLCJIZWx2ZXRpY2EtQm9sZCI6Yygieyd3aWR0aHMne2szczJxNHNjeDF3MjAxbjNyMjAxbzZvMjAxczF3MjAxdDF3MjAxdTF3MjAxdzNtMjAxeDNtMjAxeTNtMmsxdzJsMmwyMDJtMm4ybjNyMm8zcjJwNXQyMDJxNm8ycjFzMnMybDJ0MmwydTJyMnYzdTJ3MXcyeDJsMnkxdzJ6MXczazNyM2wzcjNtM3IzbjNyM28zcjNwM3IzcTNyM3IzcjNzM3IyMDN0MmwyMDN1MmwzdjJsM3czdTN4M3UzeTN1M3ozeDRrNmw0bDRzNG00czRuNHM0bzRzNHA0bTRxM3g0cjR5NHM0czR0MXc0dTNyNHY0czR3M3g0eDVuNHk0czR6NHk1azRtNWw0eTVtNHM1bjRtNW8zeDVwNHM1cTRtNXI1eTVzNG01dDRtNXUzeDV2Mmw1dzF3NXgybDV5M3U1ejNyNmsybDZsM3I2bTN4Nm4zcjZvM3g2cDNyNnEybDZyM3g2czN4NnQxdzZ1MXc2djNyNncxdzZ4NXQ2eTN4NnozeDdrM3g3bDN4N20ycjduM3I3bzJsN3AzeDdxM3I3cjR5N3Mzcjd0M3I3dTNtN3Yycjd3MXc3eDJyN3kzdTIwMmwzcmNsNHNhbDJsYW0zcmFuM3JhbzNyYXAzcmFyM3JhczJsYXQ0dGF1MnBhdjNyYXczdWF5NHRhejJsYmsyc2JsM3UnZm9mJzZvYm8ybGJwM3hicTNyYnIxd2JzMmxidTJvYnYzcmJ6M3hjazRzMjAyazNyY200c2NuNHNjbzRzY3A0c2NxNm9jcjRzY3M0bWN0NG1jdTRtY3Y0bWN3MXcybTJ6Y3kxd2N6MXdkbDRzZG00eWRuNHlkbzR5ZHA0eWRxNHlkczR5ZHQ0c2R1NHNkdjRzZHc0c2R6M3hlazNyZWwzcmVtM3JlbjNyZW8zcmVwM3JlcTV0ZXIzcmVzM3JldDNyZXUzcmV2M3JldzF3ZXgxd2V5MXdlejF3ZmwzeGZtM3hmbjN4Zm8zeGZwM3hmcTN4ZnIzdWZzM3hmdDN4ZnUzeGZ2M3hmdzN4ZnozcjIwM2s2bzIxMm02bzJkdzJsMmNxMmwzdDNyM3UybDE3czRtMTltM3J9J2tlcm5pbmcne2NsezRxczVrdTVvdDVxczE3c3Y1dHZ9MjAxdHsyd3c0d3kyeXd9MjAxd3sya3N9MjAxeHsyd3c0d3kyeXd9Mmt7MjAxdHMyMDF4c30yd3s3cXM0cXU1a3c1b3M1cXc1cnMxN3N1NXR1N3RzZnpzfTJ4ezVvdzVxc30yeXs3cXM0cXU1a3c1b3M1cXc1cnMxN3N1NXR1N3RzZnpzfSdmb2YnLTZvN3B7MTdzdTV0dTVvdH1ja3s0cXM1a3U1b3Q1cXMxN3N2NXR2fTRsezRxczVrdTVvdDVxczE3c3Y1dHZ9Y217NHFzNWt1NW90NXFzMTdzdjV0dn1jbns0cXM1a3U1b3Q1cXMxN3N2NXR2fWNvezRxczVrdTVvdDVxczE3c3Y1dHZ9Y3B7NHFzNWt1NW90NXFzMTdzdjV0dn02bHsxN3N0NXR0NW9zfTE3c3sya3djbHZjbXZjbnZjb3ZjcHY0bHY0d3dja3Z9NW97Mmt1Y2x0Y210Y250Y290Y3B0NGx0NHd0Y2t0fTVxezJrc2Nsc2Ntc2Nuc2Nvc2NwczRsczR3dmNrc301cnsya3M0d3N9NXR7Mmt3Y2x2Y212Y252Y292Y3B2NGx2NHd3Y2t2fWVvezE3c3Q1dHQ1b3N9ZnV7MTdzdTV0dTVvdH02cHsxN3NzNXRzfWVrezE3c3Q1dHQ1b3N9ZWx7MTdzdDV0dDVvc31lbXsxN3N0NXR0NW9zfWVuezE3c3Q1dHQ1b3N9Nm97MjAxdHN9ZXB7MTdzdDV0dDVvc31lc3sxN3NzNXRzfWV0ezE3c3M1dHN9ZXV7MTdzczV0c31ldnsxN3NzNXRzfTZ6ezE3c3U1dHU1b3M1cXR9Zm17MTdzdTV0dTVvczVxdH1mbnsxN3N1NXR1NW9zNXF0fWZvezE3c3U1dHU1b3M1cXR9ZnB7MTdzdTV0dTVvczVxdH1mcXsxN3N1NXR1NW9zNXF0fWZzezE3c3U1dHU1b3M1cXR9ZnR7MTdzdTV0dTVvdH03bXs1b3N9ZnZ7MTdzdTV0dTVvdH1md3sxN3N1NXR1NW90fX19IiksQ291cmllcjpjKCJ7J3dpZHRocyd7azN3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fSIpLCJDb3VyaWVyLUJvbGRPYmxpcXVlIjpjKCJ7J3dpZHRocyd7azN3J2ZvZic2b30na2VybmluZyd7J2ZvZictNm99fSIpLCJUaW1lcy1Cb2xkIjpjKCJ7J3dpZHRocyd7azNxMnE1bmN4MnIyMDFuM20yMDFvNm8yMDFzMmwyMDF0MmwyMDF1MmwyMDF3M20yMDF4M20yMDF5M20yazF0MmwybDIwMm0ybjJuM20ybzNtMnA2bzIwMnE2bzJyMXcyczJsMnQybDJ1M20ydjN0MncxdDJ4MmwyeTF0MnoxdzNrM20zbDNtM20zbTNuM20zbzNtM3AzbTNxM20zcjNtM3MzbTIwM3QybDIwM3UybDN2MmwzdzN0M3gzdDN5M3QzejNtNGs1eDRsNHM0bTRtNG40czRvNHM0cDRtNHEzeDRyNHk0czR5NHQycjR1M200djR5NHc0bTR4NXk0eTRzNHo0eTVrM3g1bDR5NW00czVuM3I1bzRtNXA0czVxNHM1cjZvNXM0czV0NHM1dTRtNXYybDV3MXc1eDJsNXkzdTV6M202azJsNmwzbTZtM3I2bjJ3Nm8zcjZwMnc2cTJsNnIzbTZzM3I2dDF3NnUybDZ2M3I2dzF3Nng1bjZ5M3I2ejNtN2szcjdsM3I3bTJ3N24ycjdvMmw3cDNyN3EzbTdyNHM3czNtN3QzbTd1Mnc3djJyN3cxcTd4MnI3eTNvMjAybDNtY2w0c2FsMmxhbTNtYW4zbWFvM21hcDNtYXIzbWFzMmxhdDR1YXUxeWF2M21hdzN0YXk0dWF6MmxiazJzYmwzdCdmb2YnNm9ibzJsYnAzcmJyMXRiczJsYnUybGJ2M21iejNtY2s0czIwMmszbWNtNHNjbjRzY280c2NwNHNjcTZvY3I0c2NzNG1jdDRtY3U0bWN2NG1jdzJyMm0zcmN5MnJjejJyZGw0c2RtNHlkbjR5ZG80eWRwNHlkcTR5ZHM0eWR0NHNkdTRzZHY0c2R3NHNkejNyZWszbWVsM21lbTNtZW4zbWVvM21lcDNtZXE0c2VyMndlczJ3ZXQyd2V1MndldjJ3ZXcxd2V4MXdleTF3ZXoxd2ZsM3JmbTNtZm4zbWZvM21mcDNtZnEzbWZyM3RmczNtZnQzcmZ1M3JmdjNyZnczcmZ6M20yMDNrNm8yMTJtNm8yZHcybDJjcTJsM3QzbTN1MmwxN3M0czE5bTNtfSdrZXJuaW5nJ3tjbHs0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fTIwMXR7Y2tzNGxzY21zY25zY29zY3BzY2xzNHd2fTJrezIwMXRzfTJ3ezRxdTVrdTdtdTVvczVxeDVydTE3c3U1dHV9Mnh7MTdzdTV0dTVvdTVxc30yeXs0cXY1a3Y3bXU1b3Q1cXo1cnUxN3N1NXR1fSdmb2YnLTZvN3R7Y2tzY2xzY21zY25zY29zY3BzNGxzfTN1ezE3c3U1dHU1b3M1cXV9M3Z7MTdzdTV0dTVvczVxdX1mdXsxN3N1NXR1NW91NXF1fTdwezE3c3U1dHU1b3U1cXV9Y2t7NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn00bHs0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fWNtezRxdDVrczVvdDVxeTVydzE3c3Y1dHZ9Y257NHF0NWtzNW90NXF5NXJ3MTdzdjV0dn1jb3s0cXQ1a3M1b3Q1cXk1cncxN3N2NXR2fWNwezRxdDVrczVvdDVxeTVydzE3c3Y1dHZ9Nmx7MTdzdDV0dDVvdTVxdX0xN3N7Y2t1Y2x1Y211Y251Y291Y3B1NGx1NHd1fTVve2NrdWNsdWNtdWNudWNvdWNwdTRsdTR3dX01cXtja3pjbHpjbXpjbnpjb3pjcHo0bHo0d3V9NXJ7Y2t4Y2x4Y214Y254Y294Y3B4NGx4NHd1fTV0e2NrdWNsdWNtdWNudWNvdWNwdTRsdTR3dX03cXtja3VjbHVjbXVjbnVjb3VjcHU0bHV9NnB7MTdzdzV0dzVvdTVxdX1la3sxN3N0NXR0NXF1fWVsezE3c3Q1dHQ1b3U1cXV9ZW17MTdzdDV0dDVxdX1lbnsxN3N0NXR0NXF1fWVvezE3c3Q1dHQ1cXV9ZXB7MTdzdDV0dDVvdTVxdX1lc3sxN3NzNXRzNXF1fWV0ezE3c3c1dHc1b3U1cXV9ZXV7MTdzdzV0dzVvdTVxdX1ldnsxN3NzNXRzNXF1fTZ6ezE3c3c1dHc1b3U1cXU1cnN9Zm17MTdzdzV0dzVvdTVxdTVyc31mbnsxN3N3NXR3NW91NXF1NXJzfWZvezE3c3c1dHc1b3U1cXU1cnN9ZnB7MTdzdzV0dzVvdTVxdTVyc31mcXsxN3N3NXR3NW91NXF1NXJzfTdye2NrdGNsdGNtdGNudGNvdGNwdDRsdDVvc31mc3sxN3N3NXR3NW91NXF1NXJzfWZ0ezE3c3U1dHU1b3U1cXV9N217NW9zfWZ2ezE3c3U1dHU1b3U1cXV9Znd7MTdzdTV0dTVvdTVxdX1mentja3NjbHNjbXNjbnNjb3NjcHM0bHN9fX0iKSxTeW1ib2w6Yygieyd3aWR0aHMne2szdWF3NHIxOW0zbTJrMXQybDJsMjAybTJ5Mm4zbTJwNW4yMDJxNm8zazNtMnMybDJ0MmwydjNyMncxdDNtM20yeTF0Mnoxd2JrMnNibDNyJ2ZvZic2bzNuM20zbzNtM3AzbTNxM20zcjNtM3MzbTN0M20zdTF3M3YxdzN3M3IzeDNyM3kzcjN6MndicDN0M2wzbTV2Mmw1eDJsNXozbTJxNHlmcjNyN3Yzazd3MW83eDNrfSdrZXJuaW5nJ3snZm9mJy02b319IiksSGVsdmV0aWNhOmMoInsnd2lkdGhzJ3trM3AycTRtY3gxdzIwMW4zcjIwMW82bzIwMXMxcTIwMXQxcTIwMXUxcTIwMXcybDIwMXgybDIwMXkybDJrMXcybDF3MjAybTJuMm4zcjJvM3IycDV0MjAycTZvMnIxbjJzMmwydDJsMnUycjJ2M3UydzF3MngybDJ5MXcyejF3M2szcjNsM3IzbTNyM24zcjNvM3IzcDNyM3EzcjNyM3IzczNyMjAzdDJsMjAzdTJsM3YxdzN3M3UzeDN1M3kzdTN6M3I0azZwNGw0bTRtNG00bjRzNG80czRwNG00cTN4NHI0eTRzNHM0dDF3NHUzbTR2NG00dzNyNHg1bjR5NHM0ejR5NWs0bTVsNHk1bTRzNW40bTVvM3g1cDRzNXE0bTVyNXk1czRtNXQ0bTV1M3g1djF3NXcxdzV4MXc1eTJ6NXozcjZrMmw2bDNyNm0zcjZuM202bzNyNnAzcjZxMXc2cjNyNnMzcjZ0MXE2dTFxNnYzbTZ3MXE2eDVuNnkzcjZ6M3I3azNyN2wzcjdtMmw3bjNtN28xdzdwM3I3cTNtN3I0czdzM203dDNtN3UzbTd2Mmw3dzF1N3gybDd5M3UyMDJsM3JjbDRtYWwybGFtM3JhbjNyYW8zcmFwM3JhcjNyYXMybGF0NHRhdTJwYXYzcmF3M3VheTR0YXoybGJrMnNibDN1J2ZvZic2b2JvMmxicDNyYnIxd2JzMmxidTJvYnYzcmJ6M3hjazRtMjAyazNyY200bWNuNG1jbzRtY3A0bWNxNm9jcjRzY3M0bWN0NG1jdTRtY3Y0bWN3MXcybTJuY3kxd2N6MXdkbDRzZG00eWRuNHlkbzR5ZHA0eWRxNHlkczR5ZHQ0c2R1NHNkdjRzZHc0c2R6M3hlazNyZWwzcmVtM3JlbjNyZW8zcmVwM3JlcTV0ZXIzbWVzM3JldDNyZXUzcmV2M3JldzF3ZXgxd2V5MXdlejF3ZmwzcmZtM3JmbjNyZm8zcmZwM3JmcTNyZnIzdWZzM3hmdDNyZnUzcmZ2M3JmdzNyZnozbTIwM2s2bzIxMm02bzJkdzJsMmNxMmwzdDNyM3UxdzE3czRtMTltM3J9J2tlcm5pbmcnezVxezR3dn1jbHs0cXM1a3c1b3c1cXMxN3N2NXR2fTIwMXR7Mnd1NHcxazJ5dX0yMDF4ezJ3dTR3eTJ5dX0xN3N7Mmt0Y2x1Y211Y251NG90Y3B1NGx1NHd5Y291Y2t1fTJ3ezdxczRxejVrMW0xN3N5NW93NXF4NXJzZnN1NXR5N3R1Znp1fTJ4ezE3c3k1dHk1b3k1cXN9Mnl7N3FzNHF6NWsxbTE3c3k1b3c1cXg1cnNmc3U1dHk3dHVmenV9J2ZvZictNm83cHsxN3N2NXR2NW93fWNrezRxczVrdzVvdzVxczE3c3Y1dHZ9NGx7NHFzNWt3NW93NXFzMTdzdjV0dn1jbXs0cXM1a3c1b3c1cXMxN3N2NXR2fWNuezRxczVrdzVvdzVxczE3c3Y1dHZ9Y297NHFzNWt3NW93NXFzMTdzdjV0dn1jcHs0cXM1a3c1b3c1cXMxN3N2NXR2fTZsezE3c3k1dHk1b3d9ZG97MTdzdDV0dH00ensxN3N0NXR0fTdze2ZzdH1kbXsxN3N0NXR0fWRuezE3c3Q1dHR9NW97Y2t3Y2x3Y213Y253Y293Y3B3NGx3NHd2fWRwezE3c3Q1dHR9ZHF7MTdzdDV0dH03dHs1b3d9ZHN7MTdzdDV0dH01dHsya3RjbHVjbXVjbnU0b3RjcHU0bHU0d3ljb3Vja3V9ZnV7MTdzdjV0djVvd302cHsxN3N5NXR5NW93NXFzfWVrezE3c3k1dHk1b3d9ZWx7MTdzeTV0eTVvd31lbXsxN3N5NXR5NW93fWVuezV0eX1lb3sxN3N5NXR5NW93fWVwezE3c3k1dHk1b3d9ZXN7MTdzeTV0eTVxc31ldHsxN3N5NXR5NW93NXFzfWV1ezE3c3k1dHk1b3c1cXN9ZXZ7MTdzeTV0eTVvdzVxc302ensxN3N5NXR5NW93NXFzfWZtezE3c3k1dHk1b3c1cXN9Zm57MTdzeTV0eTVvdzVxc31mb3sxN3N5NXR5NW93NXFzfWZwezE3c3k1dHk1cXN9ZnF7MTdzeTV0eTVvdzVxc303cns1b3d9ZnN7MTdzeTV0eTVvdzVxc31mdHsxN3N2NXR2NW93fTdtezVvd31mdnsxN3N2NXR2NW93fWZ3ezE3c3Y1dHY1b3d9fX0iKSwiSGVsdmV0aWNhLUJvbGRPYmxpcXVlIjpjKCJ7J3dpZHRocyd7azNzMnE0c2N4MXcyMDFuM3IyMDFvNm8yMDFzMXcyMDF0MXcyMDF1MXcyMDF3M20yMDF4M20yMDF5M20yazF3MmwybDIwMm0ybjJuM3IybzNyMnA1dDIwMnE2bzJyMXMyczJsMnQybDJ1MnIydjN1MncxdzJ4MmwyeTF3MnoxdzNrM3IzbDNyM20zcjNuM3IzbzNyM3AzcjNxM3IzcjNyM3MzcjIwM3QybDIwM3UybDN2MmwzdzN1M3gzdTN5M3UzejN4NGs2bDRsNHM0bTRzNG40czRvNHM0cDRtNHEzeDRyNHk0czRzNHQxdzR1M3I0djRzNHczeDR4NW40eTRzNHo0eTVrNG01bDR5NW00czVuNG01bzN4NXA0czVxNG01cjV5NXM0bTV0NG01dTN4NXYybDV3MXc1eDJsNXkzdTV6M3I2azJsNmwzcjZtM3g2bjNyNm8zeDZwM3I2cTJsNnIzeDZzM3g2dDF3NnUxdzZ2M3I2dzF3Nng1dDZ5M3g2ejN4N2szeDdsM3g3bTJyN24zcjdvMmw3cDN4N3EzcjdyNHk3czNyN3Qzcjd1M203djJyN3cxdzd4MnI3eTN1MjAybDNyY2w0c2FsMmxhbTNyYW4zcmFvM3JhcDNyYXIzcmFzMmxhdDR0YXUycGF2M3JhdzN1YXk0dGF6MmxiazJzYmwzdSdmb2YnNm9ibzJsYnAzeGJxM3JicjF3YnMybGJ1Mm9idjNyYnozeGNrNHMyMDJrM3JjbTRzY240c2NvNHNjcDRzY3E2b2NyNHNjczRtY3Q0bWN1NG1jdjRtY3cxdzJtMnpjeTF3Y3oxd2RsNHNkbTR5ZG40eWRvNHlkcDR5ZHE0eWRzNHlkdDRzZHU0c2R2NHNkdzRzZHozeGVrM3JlbDNyZW0zcmVuM3JlbzNyZXAzcmVxNXRlcjNyZXMzcmV0M3JldTNyZXYzcmV3MXdleDF3ZXkxd2V6MXdmbDN4Zm0zeGZuM3hmbzN4ZnAzeGZxM3hmcjN1ZnMzeGZ0M3hmdTN4ZnYzeGZ3M3hmejNyMjAzazZvMjEybTZvMmR3MmwyY3EybDN0M3IzdTJsMTdzNG0xOW0zcn0na2VybmluZyd7Y2x7NHFzNWt1NW90NXFzMTdzdjV0dn0yMDF0ezJ3dzR3eTJ5d30yMDF3ezJrc30yMDF4ezJ3dzR3eTJ5d30ya3syMDF0czIwMXhzfTJ3ezdxczRxdTVrdzVvczVxdzVyczE3c3U1dHU3dHNmenN9Mnh7NW93NXFzfTJ5ezdxczRxdTVrdzVvczVxdzVyczE3c3U1dHU3dHNmenN9J2ZvZictNm83cHsxN3N1NXR1NW90fWNrezRxczVrdTVvdDVxczE3c3Y1dHZ9NGx7NHFzNWt1NW90NXFzMTdzdjV0dn1jbXs0cXM1a3U1b3Q1cXMxN3N2NXR2fWNuezRxczVrdTVvdDVxczE3c3Y1dHZ9Y297NHFzNWt1NW90NXFzMTdzdjV0dn1jcHs0cXM1a3U1b3Q1cXMxN3N2NXR2fTZsezE3c3Q1dHQ1b3N9MTdzezJrd2NsdmNtdmNudmNvdmNwdjRsdjR3d2Nrdn01b3sya3VjbHRjbXRjbnRjb3RjcHQ0bHQ0d3Rja3R9NXF7MmtzY2xzY21zY25zY29zY3BzNGxzNHd2Y2tzfTVyezJrczR3c301dHsya3djbHZjbXZjbnZjb3ZjcHY0bHY0d3dja3Z9ZW97MTdzdDV0dDVvc31mdXsxN3N1NXR1NW90fTZwezE3c3M1dHN9ZWt7MTdzdDV0dDVvc31lbHsxN3N0NXR0NW9zfWVtezE3c3Q1dHQ1b3N9ZW57MTdzdDV0dDVvc302b3syMDF0c31lcHsxN3N0NXR0NW9zfWVzezE3c3M1dHN9ZXR7MTdzczV0c31ldXsxN3NzNXRzfWV2ezE3c3M1dHN9Nnp7MTdzdTV0dTVvczVxdH1mbXsxN3N1NXR1NW9zNXF0fWZuezE3c3U1dHU1b3M1cXR9Zm97MTdzdTV0dTVvczVxdH1mcHsxN3N1NXR1NW9zNXF0fWZxezE3c3U1dHU1b3M1cXR9ZnN7MTdzdTV0dTVvczVxdH1mdHsxN3N1NXR1NW90fTdtezVvc31mdnsxN3N1NXR1NW90fWZ3ezE3c3U1dHU1b3R9fX0iKSxaYXBmRGluZ2JhdHM6Yygieyd3aWR0aHMne2s0dTJrMXcnZm9mJzZvfSdrZXJuaW5nJ3snZm9mJy02b319IiksIkNvdXJpZXItQm9sZCI6Yygieyd3aWR0aHMne2szdydmb2YnNm99J2tlcm5pbmcneydmb2YnLTZvfX0iKSwiVGltZXMtSXRhbGljIjpjKCJ7J3dpZHRocyd7azNuMnE0eWN4MmwyMDFuM20yMDFvNXQyMDFzMmwyMDF0MmwyMDF1MmwyMDF3M3IyMDF4M3IyMDF5M3IyazF0MmwybDIwMm0ybjJuM20ybzNtMnA1bjIwMnE1dDJyMXAyczJsMnQybDJ1M20ydjRuMncxdDJ4MmwyeTF0MnoxdzNrM20zbDNtM20zbTNuM20zbzNtM3AzbTNxM20zcjNtM3MzbTIwM3QybDIwM3UybDN2MmwzdzRuM3g0bjN5NG4zejNtNGs1dzRsM3g0bTN4NG40bTRvNHM0cDN4NHEzeDRyNHM0czRzNHQybDR1Mnc0djRtNHczcjR4NW40eTRtNHo0czVrM3g1bDRzNW0zeDVuM201bzNyNXA0czVxM3g1cjVuNXMzeDV0M3I1dTNyNXYycjV3MXc1eDJyNXkydTV6M202azJsNmwzbTZtM202bjJ3Nm8zbTZwMnc2cTF3NnIzbTZzM202dDF3NnUxdzZ2Mnc2dzF3Nng0czZ5M202ejNtN2szbTdsM203bTJyN24ycjdvMXc3cDNtN3EydzdyNG03czJ3N3Qydzd1MnI3djJzN3cxdjd4MnM3eTNxMjAybDNtY2wzeGFsMnJhbTNtYW4zbWFvM21hcDNtYXIzbWFzMmxhdDR3YXUxdmF2M21hdzRuYXk0d2F6MmxiazJzYmw0bidmb2YnNm9ibzJsYnAzbWJxM29icjF0YnMybGJ1MXpidjNtYnozbWNrM3gyMDJrM21jbTN4Y24zeGNvM3hjcDN4Y3E1dGNyNG1jczN4Y3QzeGN1M3hjdjN4Y3cybDJtMnVjeTJsY3oybGRsNG1kbTRzZG40c2RvNHNkcDRzZHE0c2RzNHNkdDRzZHU0c2R2NHNkdzRzZHozbWVrM21lbDNtZW0zbWVuM21lbzNtZXAzbWVxNG1lcjJ3ZXMyd2V0MndldTJ3ZXYyd2V3MXdleDF3ZXkxd2V6MXdmbDNtZm0zbWZuM21mbzNtZnAzbWZxM21mcjRuZnMzbWZ0M21mdTNtZnYzbWZ3M21mejJ3MjAzazZvMjEybTZtMmR3MmwyY3EybDN0M20zdTJsMTdzM3IxOW0zbX0na2VybmluZyd7Y2x7NWt0NHF3fTIwMXN7MjAxc3d9MjAxdHsyMDF0dzJ3eTJ5eTZxLXR9MjAxeHsyd3kyeXl9Mmt7MjAxdHd9Mnd7N3FzNHF5N3JzNWt5N213NW9zNXF4NXJ1MTdzdTV0dX0yeHsxN3NzNXRzNW9zfTJ5ezdxczRxeTdyczVreTdtdzVvczVxeDVydTE3c3U1dHV9J2ZvZictNm82dHsxN3NzNXRzNXFzfTd0ezVvc30zdns1cXN9N3B7MTdzdTV0dTVxc31ja3s1a3Q0cXd9NGx7NWt0NHF3fWNtezVrdDRxd31jbns1a3Q0cXd9Y297NWt0NHF3fWNwezVrdDRxd302bHs0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fTE3c3sya3N9NXF7Y2t2Y2x2Y212Y252Y292Y3B2NGx2fTVye2NrdWNsdWNtdWNudWNvdWNwdTRsdX01dHsya3N9NnB7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1la3s0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fWVsezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZW17NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1lbns0cXM1a3M1b3U1cXc1cnUxN3N1NXR1fWVvezRxczVrczVvdTVxdzVydTE3c3U1dHV9ZXB7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1lc3s1a3M1cXM0cXN9ZXR7NHFzNWtzNW91NXF3NXJ1MTdzdTV0dX1ldXs0cXM1a3M1cXc1cnUxN3N1NXR1fWV2ezVrczVxczRxc31leHsxN3NzNXRzNXFzfTZ6ezRxdjVrczVvdTVxdzVydTE3c3U1dHV9Zm17NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX1mbns0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fWZvezRxdjVrczVvdTVxdzVydTE3c3U1dHV9ZnB7NHF2NWtzNW91NXF3NXJ1MTdzdTV0dX1mcXs0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fTdyezVvc31mc3s0cXY1a3M1b3U1cXc1cnUxN3N1NXR1fWZ0ezE3c3U1dHU1cXN9ZnV7MTdzdTV0dTVxc31mdnsxN3N1NXR1NXFzfWZ3ezE3c3U1dHU1cXN9fX0iKSwiVGltZXMtUm9tYW4iOmMoInsnd2lkdGhzJ3trM24ycTR5Y3gybDIwMW4zbTIwMW82bzIwMXMybDIwMXQybDIwMXUybDIwMXcydzIwMXgydzIwMXkydzJrMXQybDJsMjAybTJuMm4zbTJvM20ycDVuMjAycTZvMnIxbTJzMmwydDJsMnUzbTJ2M3MydzF0MngybDJ5MXQyejF3M2szbTNsM20zbTNtM24zbTNvM20zcDNtM3EzbTNyM20zczNtMjAzdDJsMjAzdTJsM3YxdzN3M3MzeDNzM3kzczN6Mnc0azV3NGw0czRtNG00bjRtNG80czRwM3g0cTNyNHI0czRzNHM0dDJsNHUycjR2NHM0dzN4NHg1dDR5NHM0ejRzNWszcjVsNHM1bTRtNW4zcjVvM3g1cDRzNXE0czVyNXk1czRzNXQ0czV1M3g1djJsNXcxdzV4Mmw1eTJ6NXozbTZrMmw2bDJ3Nm0zbTZuMnc2bzNtNnAydzZxMmw2cjNtNnMzbTZ0MXc2dTF3NnYzbTZ3MXc2eDR5NnkzbTZ6M203azNtN2wzbTdtMmw3bjJyN28xdzdwM203cTNtN3I0czdzM203dDNtN3Uydzd2M2s3dzFvN3gzazd5M3EyMDJsM21jbDRzYWwybGFtM21hbjNtYW8zbWFwM21hcjNtYXMybGF0NHdhdTF2YXYzbWF3M3NheTR3YXoybGJrMnNibDNzJ2ZvZic2b2JvMmxicDNtYnEyeGJyMXRiczJsYnUxemJ2M21iejJ3Y2s0czIwMmszbWNtNHNjbjRzY280c2NwNHNjcTV0Y3I0bWNzM3hjdDN4Y3UzeGN2M3hjdzJsMm0ydGN5MmxjejJsZGw0c2RtNHNkbjRzZG80c2RwNHNkcTRzZHM0c2R0NHNkdTRzZHY0c2R3NHNkejNtZWsyd2VsMndlbTJ3ZW4yd2VvMndlcDJ3ZXE0bWVyMndlczJ3ZXQyd2V1MndldjJ3ZXcxd2V4MXdleTF3ZXoxd2ZsM21mbTNtZm4zbWZvM21mcDNtZnEzbWZyM3NmczNtZnQzbWZ1M21mdjNtZnczbWZ6M20yMDNrNm8yMTJtNm0yZHcybDJjcTJsM3QzbTN1MXcxN3M0czE5bTNtfSdrZXJuaW5nJ3tjbHs0cXM1a3UxN3N3NW91NXF5NXJ3MjAxc3M1dHcyMDF3c30yMDFzezIwMXNzfTIwMXR7Y2t3NGx3Y213Y253Y293Y3B3Y2x3NHd1MjAxdHN9Mmt7MjAxdHN9Mnd7NHFzNWt3NW9zNXF4NXJ1MTdzeDV0eH0yeHsxN3N3NXR3NW91NXF1fTJ5ezRxczVrdzVvczVxeDVydTE3c3g1dHh9J2ZvZictNm83dHtja3VjbHVjbXVjbnVjb3VjcHU0bHU1b3M1cnN9M3V7MTdzdTV0dTVxc30zdnsxN3N1NXR1NXFzfTdwezE3c3c1dHc1cXN9Y2t7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9NGx7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y217NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y257NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y297NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Y3B7NHFzNWt1MTdzdzVvdTVxeTVydzIwMXNzNXR3MjAxd3N9Nmx7MTdzdTV0dTVvczVxdzVyc30xN3N7Mmt0Y2x2Y212Y252Y292Y3B2NGx2NHd1Y2t2fTVve2Nrd2Nsd2Ntd2Nud2Nvd2NwdzRsdzR3dX01cXtja3ljbHljbXljbnljb3ljcHk0bHk0d3U1bXN9NXJ7Y2t0Y2x0Y210Y250Y290Y3B0NGx0NHdzfTV0ezJrdGNsdmNtdmNudmNvdmNwdjRsdjR3dWNrdn03cXtja3NjbHNjbXNjbnNjb3NjcHM0bHN9NnB7MTdzdTV0dTVxdzVyc31la3s1cXM1cnN9ZWx7MTdzdTV0dTVvczVxdzVyc31lbXsxN3N1NXR1NW9zNXFzNXJzfWVuezE3c3U1cXM1cnN9ZW97NXFzNXJzfWVwezE3c3U1dHU1b3M1cXc1cnN9ZXN7NXFzfWV0ezE3c3U1dHU1cXc1cnN9ZXV7MTdzdTV0dTVxczVyc31ldns1cXN9Nnp7MTdzdjV0djVvczVxeDVyc31mbXs1b3M1cXQ1cnN9Zm57MTdzdjV0djVvczVxeDVyc31mb3sxN3N2NXR2NW9zNXF4NXJzfWZwezVvczVxdDVyc31mcXs1b3M1cXQ1cnN9N3J7Y2t1Y2x1Y211Y251Y291Y3B1NGx1NW9zfWZzezE3c3Y1dHY1b3M1cXg1cnN9ZnR7MTdzczV0czVxc31mdXsxN3N3NXR3NXFzfWZ2ezE3c3c1dHc1cXN9Znd7MTdzczV0czVxc31mentja3VjbHVjbXVjbnVjb3VjcHU0bHU1b3M1cnN9fX0iKSwiSGVsdmV0aWNhLU9ibGlxdWUiOmMoInsnd2lkdGhzJ3trM3AycTRtY3gxdzIwMW4zcjIwMW82bzIwMXMxcTIwMXQxcTIwMXUxcTIwMXcybDIwMXgybDIwMXkybDJrMXcybDF3MjAybTJuMm4zcjJvM3IycDV0MjAycTZvMnIxbjJzMmwydDJsMnUycjJ2M3UydzF3MngybDJ5MXcyejF3M2szcjNsM3IzbTNyM24zcjNvM3IzcDNyM3EzcjNyM3IzczNyMjAzdDJsMjAzdTJsM3YxdzN3M3UzeDN1M3kzdTN6M3I0azZwNGw0bTRtNG00bjRzNG80czRwNG00cTN4NHI0eTRzNHM0dDF3NHUzbTR2NG00dzNyNHg1bjR5NHM0ejR5NWs0bTVsNHk1bTRzNW40bTVvM3g1cDRzNXE0bTVyNXk1czRtNXQ0bTV1M3g1djF3NXcxdzV4MXc1eTJ6NXozcjZrMmw2bDNyNm0zcjZuM202bzNyNnAzcjZxMXc2cjNyNnMzcjZ0MXE2dTFxNnYzbTZ3MXE2eDVuNnkzcjZ6M3I3azNyN2wzcjdtMmw3bjNtN28xdzdwM3I3cTNtN3I0czdzM203dDNtN3UzbTd2Mmw3dzF1N3gybDd5M3UyMDJsM3JjbDRtYWwybGFtM3JhbjNyYW8zcmFwM3JhcjNyYXMybGF0NHRhdTJwYXYzcmF3M3VheTR0YXoybGJrMnNibDN1J2ZvZic2b2JvMmxicDNyYnIxd2JzMmxidTJvYnYzcmJ6M3hjazRtMjAyazNyY200bWNuNG1jbzRtY3A0bWNxNm9jcjRzY3M0bWN0NG1jdTRtY3Y0bWN3MXcybTJuY3kxd2N6MXdkbDRzZG00eWRuNHlkbzR5ZHA0eWRxNHlkczR5ZHQ0c2R1NHNkdjRzZHc0c2R6M3hlazNyZWwzcmVtM3JlbjNyZW8zcmVwM3JlcTV0ZXIzbWVzM3JldDNyZXUzcmV2M3JldzF3ZXgxd2V5MXdlejF3ZmwzcmZtM3JmbjNyZm8zcmZwM3JmcTNyZnIzdWZzM3hmdDNyZnUzcmZ2M3JmdzNyZnozbTIwM2s2bzIxMm02bzJkdzJsMmNxMmwzdDNyM3UxdzE3czRtMTltM3J9J2tlcm5pbmcnezVxezR3dn1jbHs0cXM1a3c1b3c1cXMxN3N2NXR2fTIwMXR7Mnd1NHcxazJ5dX0yMDF4ezJ3dTR3eTJ5dX0xN3N7Mmt0Y2x1Y211Y251NG90Y3B1NGx1NHd5Y291Y2t1fTJ3ezdxczRxejVrMW0xN3N5NW93NXF4NXJzZnN1NXR5N3R1Znp1fTJ4ezE3c3k1dHk1b3k1cXN9Mnl7N3FzNHF6NWsxbTE3c3k1b3c1cXg1cnNmc3U1dHk3dHVmenV9J2ZvZictNm83cHsxN3N2NXR2NW93fWNrezRxczVrdzVvdzVxczE3c3Y1dHZ9NGx7NHFzNWt3NW93NXFzMTdzdjV0dn1jbXs0cXM1a3c1b3c1cXMxN3N2NXR2fWNuezRxczVrdzVvdzVxczE3c3Y1dHZ9Y297NHFzNWt3NW93NXFzMTdzdjV0dn1jcHs0cXM1a3c1b3c1cXMxN3N2NXR2fTZsezE3c3k1dHk1b3d9ZG97MTdzdDV0dH00ensxN3N0NXR0fTdze2ZzdH1kbXsxN3N0NXR0fWRuezE3c3Q1dHR9NW97Y2t3Y2x3Y213Y253Y293Y3B3NGx3NHd2fWRwezE3c3Q1dHR9ZHF7MTdzdDV0dH03dHs1b3d9ZHN7MTdzdDV0dH01dHsya3RjbHVjbXVjbnU0b3RjcHU0bHU0d3ljb3Vja3V9ZnV7MTdzdjV0djVvd302cHsxN3N5NXR5NW93NXFzfWVrezE3c3k1dHk1b3d9ZWx7MTdzeTV0eTVvd31lbXsxN3N5NXR5NW93fWVuezV0eX1lb3sxN3N5NXR5NW93fWVwezE3c3k1dHk1b3d9ZXN7MTdzeTV0eTVxc31ldHsxN3N5NXR5NW93NXFzfWV1ezE3c3k1dHk1b3c1cXN9ZXZ7MTdzeTV0eTVvdzVxc302ensxN3N5NXR5NW93NXFzfWZtezE3c3k1dHk1b3c1cXN9Zm57MTdzeTV0eTVvdzVxc31mb3sxN3N5NXR5NW93NXFzfWZwezE3c3k1dHk1cXN9ZnF7MTdzeTV0eTVvdzVxc303cns1b3d9ZnN7MTdzeTV0eTVvdzVxc31mdHsxN3N2NXR2NW93fTdtezVvd31mdnsxN3N2NXR2NW93fWZ3ezE3c3Y1dHY1b3d9fX0iKX19O3QuZXZlbnRzLnB1c2goWyJhZGRGb250IixmdW5jdGlvbih0KXt2YXIgZT10LmZvbnQscj1oLlVuaWNvZGVbZS5wb3N0U2NyaXB0TmFtZV07ciYmKGUubWV0YWRhdGEuVW5pY29kZT17fSxlLm1ldGFkYXRhLlVuaWNvZGUud2lkdGhzPXIud2lkdGhzLGUubWV0YWRhdGEuVW5pY29kZS5rZXJuaW5nPXIua2VybmluZyk7dmFyIG49bC5Vbmljb2RlW2UucG9zdFNjcmlwdE5hbWVdO24mJihlLm1ldGFkYXRhLlVuaWNvZGUuZW5jb2Rpbmc9bixlLmVuY29kaW5nPW4uY29kZVBhZ2VzWzBdKX1dKX0oTS5BUEkpLAovKioKICAgKiBAbGljZW5zZQogICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4KICAgKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UKICAgKi8KZnVuY3Rpb24odCl7dmFyIGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLHI9bmV3IFVpbnQ4QXJyYXkoZSksbj0wO248ZTtuKyspcltuXT10LmNoYXJDb2RlQXQobik7cmV0dXJuIHJ9O3QuQVBJLmV2ZW50cy5wdXNoKFsiYWRkRm9udCIsZnVuY3Rpb24ocil7dmFyIG49dm9pZCAwLGk9ci5mb250LGE9ci5pbnN0YW5jZTtpZighaS5pc1N0YW5kYXJkRm9udCl7aWYodm9pZCAwPT09YSl0aHJvdyBuZXcgRXJyb3IoIkZvbnQgZG9lcyBub3QgZXhpc3QgaW4gdkZTLCBpbXBvcnQgZm9udHMgb3IgcmVtb3ZlIGRlY2xhcmF0aW9uIGRvYy5hZGRGb250KCciK2kucG9zdFNjcmlwdE5hbWUrIicpLiIpO2lmKCJzdHJpbmciIT10eXBlb2Yobj0hMT09PWEuZXhpc3RzRmlsZUluVkZTKGkucG9zdFNjcmlwdE5hbWUpP2EubG9hZEZpbGUoaS5wb3N0U2NyaXB0TmFtZSk6YS5nZXRGaWxlRnJvbVZGUyhpLnBvc3RTY3JpcHROYW1lKSkpdGhyb3cgbmV3IEVycm9yKCJGb250IGlzIG5vdCBzdG9yZWQgYXMgc3RyaW5nLWRhdGEgaW4gdkZTLCBpbXBvcnQgZm9udHMgb3IgcmVtb3ZlIGRlY2xhcmF0aW9uIGRvYy5hZGRGb250KCciK2kucG9zdFNjcmlwdE5hbWUrIicpLiIpOyFmdW5jdGlvbihyLG4pe249L15ceDAwXHgwMVx4MDBceDAwLy50ZXN0KG4pP2Uobik6ZShjKG4pKSxyLm1ldGFkYXRhPXQuQVBJLlRURkZvbnQub3BlbihuKSxyLm1ldGFkYXRhLlVuaWNvZGU9ci5tZXRhZGF0YS5Vbmljb2RlfHx7ZW5jb2Rpbmc6e30sa2VybmluZzp7fSx3aWR0aHM6W119LHIubWV0YWRhdGEuZ2x5SWRzVXNlZD1bMF19KGksbil9fV0pfShNKSxmdW5jdGlvbihuKXtmdW5jdGlvbiBhKCl7cmV0dXJuKHIuY2Fudmc/UHJvbWlzZS5yZXNvbHZlKHIuY2FudmcpOiJvYmplY3QiPT09KHZvaWQgMD09PXQ/InVuZGVmaW5lZCI6ZSh0KSkmJiJ1bmRlZmluZWQiIT10eXBlb2YgbW9kdWxlP25ldyBQcm9taXNlKChmdW5jdGlvbih0LGUpe3RyeXt0KHJlcXVpcmUoImNhbnZnIikpfWNhdGNoKHQpe2UodCl9fSkpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/bmV3IFByb21pc2UoKGZ1bmN0aW9uKHQsZSl7dHJ5e3JlcXVpcmUoWyJjYW52ZyJdLHQpfWNhdGNoKHQpe2UodCl9fSkpOlByb21pc2UucmVqZWN0KG5ldyBFcnJvcigiQ291bGQgbm90IGxvYWQgY2FudmciKSkpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCJDb3VsZCBub3QgbG9hZCBjYW52ZzogIit0KSl9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQuZGVmYXVsdD90LmRlZmF1bHQ6dH0pKX1uLmFkZFN2Z0FzSW1hZ2U9ZnVuY3Rpb24odCxlLHIsbixvLHMsYyx1KXtpZihpc05hTihlKXx8aXNOYU4ocikpdGhyb3cgaS5lcnJvcigianNQREYuYWRkU3ZnQXNJbWFnZTogSW52YWxpZCBjb29yZGluYXRlcyIsYXJndW1lbnRzKSxuZXcgRXJyb3IoIkludmFsaWQgY29vcmRpbmF0ZXMgcGFzc2VkIHRvIGpzUERGLmFkZFN2Z0FzSW1hZ2UiKTtpZihpc05hTihuKXx8aXNOYU4obykpdGhyb3cgaS5lcnJvcigianNQREYuYWRkU3ZnQXNJbWFnZTogSW52YWxpZCBtZWFzdXJlbWVudHMiLGFyZ3VtZW50cyksbmV3IEVycm9yKCJJbnZhbGlkIG1lYXN1cmVtZW50cyAod2lkdGggYW5kL29yIGhlaWdodCkgcGFzc2VkIHRvIGpzUERGLmFkZFN2Z0FzSW1hZ2UiKTt2YXIgbD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJjYW52YXMiKTtsLndpZHRoPW4sbC5oZWlnaHQ9bzt2YXIgaD1sLmdldENvbnRleHQoIjJkIik7aC5maWxsU3R5bGU9IiNmZmYiLGguZmlsbFJlY3QoMCwwLGwud2lkdGgsbC5oZWlnaHQpO3ZhciBmPXtpZ25vcmVNb3VzZTohMCxpZ25vcmVBbmltYXRpb246ITAsaWdub3JlRGltZW5zaW9uczohMH0sZD10aGlzO3JldHVybiBhKCkudGhlbigoZnVuY3Rpb24oZSl7cmV0dXJuIGUuZnJvbVN0cmluZyhoLHQsZil9KSwoZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCJDb3VsZCBub3QgbG9hZCBjYW52Zy4iKSl9KSkudGhlbigoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVuZGVyKGYpfSkpLnRoZW4oKGZ1bmN0aW9uKCl7ZC5hZGRJbWFnZShsLnRvRGF0YVVSTCgiaW1hZ2UvanBlZyIsMSksZSxyLG4sbyxjLHUpfSkpfX0oTS5BUEkpLAovKioKICAgKiBAbGljZW5zZQogICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICogQ29weXJpZ2h0IChjKSAyMDEzIEVkdWFyZG8gTWVuZXplcyBkZSBNb3JhaXMsIGVkdWFyZG8ubW9yYWlzQHVzcC5icgogICAqCiAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nCiAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCiAgICogIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwogICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8KICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8KICAgKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICoKICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZQogICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgogICAqCiAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsCiAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCiAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQKICAgKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFCiAgICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTgogICAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTgogICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgogICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICovCmZ1bmN0aW9uKHQpe3QucHV0VG90YWxQYWdlcz1mdW5jdGlvbih0KXt2YXIgZSxyPTA7cGFyc2VJbnQodGhpcy5pbnRlcm5hbC5nZXRGb250KCkuaWQuc3Vic3RyKDEpLDEwKTwxNT8oZT1uZXcgUmVnRXhwKHQsImciKSxyPXRoaXMuaW50ZXJuYWwuZ2V0TnVtYmVyT2ZQYWdlcygpKTooZT1uZXcgUmVnRXhwKHRoaXMucGRmRXNjYXBlMTYodCx0aGlzLmludGVybmFsLmdldEZvbnQoKSksImciKSxyPXRoaXMucGRmRXNjYXBlMTYodGhpcy5pbnRlcm5hbC5nZXROdW1iZXJPZlBhZ2VzKCkrIiIsdGhpcy5pbnRlcm5hbC5nZXRGb250KCkpKTtmb3IodmFyIG49MTtuPD10aGlzLmludGVybmFsLmdldE51bWJlck9mUGFnZXMoKTtuKyspZm9yKHZhciBpPTA7aTx0aGlzLmludGVybmFsLnBhZ2VzW25dLmxlbmd0aDtpKyspdGhpcy5pbnRlcm5hbC5wYWdlc1tuXVtpXT10aGlzLmludGVybmFsLnBhZ2VzW25dW2ldLnJlcGxhY2UoZSxyKTtyZXR1cm4gdGhpc319KE0uQVBJKSxmdW5jdGlvbih0KXt0LnZpZXdlclByZWZlcmVuY2VzPWZ1bmN0aW9uKHQscil7dmFyIG47dD10fHx7fSxyPXJ8fCExO3ZhciBpLGEsbyxzPXtIaWRlVG9vbGJhcjp7ZGVmYXVsdFZhbHVlOiExLHZhbHVlOiExLHR5cGU6ImJvb2xlYW4iLGV4cGxpY2l0U2V0OiExLHZhbHVlU2V0OlshMCwhMV0scGRmVmVyc2lvbjoxLjN9LEhpZGVNZW51YmFyOntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sSGlkZVdpbmRvd1VJOntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sRml0V2luZG93OntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sQ2VudGVyV2luZG93OntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuM30sRGlzcGxheURvY1RpdGxlOntkZWZhdWx0VmFsdWU6ITEsdmFsdWU6ITEsdHlwZToiYm9vbGVhbiIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyEwLCExXSxwZGZWZXJzaW9uOjEuNH0sTm9uRnVsbFNjcmVlblBhZ2VNb2RlOntkZWZhdWx0VmFsdWU6IlVzZU5vbmUiLHZhbHVlOiJVc2VOb25lIix0eXBlOiJuYW1lIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbIlVzZU5vbmUiLCJVc2VPdXRsaW5lcyIsIlVzZVRodW1icyIsIlVzZU9DIl0scGRmVmVyc2lvbjoxLjN9LERpcmVjdGlvbjp7ZGVmYXVsdFZhbHVlOiJMMlIiLHZhbHVlOiJMMlIiLHR5cGU6Im5hbWUiLGV4cGxpY2l0U2V0OiExLHZhbHVlU2V0OlsiTDJSIiwiUjJMIl0scGRmVmVyc2lvbjoxLjN9LFZpZXdBcmVhOntkZWZhdWx0VmFsdWU6IkNyb3BCb3giLHZhbHVlOiJDcm9wQm94Iix0eXBlOiJuYW1lIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbIk1lZGlhQm94IiwiQ3JvcEJveCIsIlRyaW1Cb3giLCJCbGVlZEJveCIsIkFydEJveCJdLHBkZlZlcnNpb246MS40fSxWaWV3Q2xpcDp7ZGVmYXVsdFZhbHVlOiJDcm9wQm94Iix2YWx1ZToiQ3JvcEJveCIsdHlwZToibmFtZSIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyJNZWRpYUJveCIsIkNyb3BCb3giLCJUcmltQm94IiwiQmxlZWRCb3giLCJBcnRCb3giXSxwZGZWZXJzaW9uOjEuNH0sUHJpbnRBcmVhOntkZWZhdWx0VmFsdWU6IkNyb3BCb3giLHZhbHVlOiJDcm9wQm94Iix0eXBlOiJuYW1lIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbIk1lZGlhQm94IiwiQ3JvcEJveCIsIlRyaW1Cb3giLCJCbGVlZEJveCIsIkFydEJveCJdLHBkZlZlcnNpb246MS40fSxQcmludENsaXA6e2RlZmF1bHRWYWx1ZToiQ3JvcEJveCIsdmFsdWU6IkNyb3BCb3giLHR5cGU6Im5hbWUiLGV4cGxpY2l0U2V0OiExLHZhbHVlU2V0OlsiTWVkaWFCb3giLCJDcm9wQm94IiwiVHJpbUJveCIsIkJsZWVkQm94IiwiQXJ0Qm94Il0scGRmVmVyc2lvbjoxLjR9LFByaW50U2NhbGluZzp7ZGVmYXVsdFZhbHVlOiJBcHBEZWZhdWx0Iix2YWx1ZToiQXBwRGVmYXVsdCIsdHlwZToibmFtZSIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyJBcHBEZWZhdWx0IiwiTm9uZSJdLHBkZlZlcnNpb246MS42fSxEdXBsZXg6e2RlZmF1bHRWYWx1ZToiIix2YWx1ZToibm9uZSIsdHlwZToibmFtZSIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6WyJTaW1wbGV4IiwiRHVwbGV4RmxpcFNob3J0RWRnZSIsIkR1cGxleEZsaXBMb25nRWRnZSIsIm5vbmUiXSxwZGZWZXJzaW9uOjEuN30sUGlja1RyYXlCeVBERlNpemU6e2RlZmF1bHRWYWx1ZTohMSx2YWx1ZTohMSx0eXBlOiJib29sZWFuIixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpbITAsITFdLHBkZlZlcnNpb246MS43fSxQcmludFBhZ2VSYW5nZTp7ZGVmYXVsdFZhbHVlOiIiLHZhbHVlOiIiLHR5cGU6ImFycmF5IixleHBsaWNpdFNldDohMSx2YWx1ZVNldDpudWxsLHBkZlZlcnNpb246MS43fSxOdW1Db3BpZXM6e2RlZmF1bHRWYWx1ZToxLHZhbHVlOjEsdHlwZToiaW50ZWdlciIsZXhwbGljaXRTZXQ6ITEsdmFsdWVTZXQ6bnVsbCxwZGZWZXJzaW9uOjEuN319LGM9T2JqZWN0LmtleXMocyksdT1bXSxsPTAsaD0wLGY9MDtmdW5jdGlvbiBkKHQsZSl7dmFyIHIsbj0hMTtmb3Iocj0wO3I8dC5sZW5ndGg7cis9MSl0W3JdPT09ZSYmKG49ITApO3JldHVybiBufWlmKHZvaWQgMD09PXRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMmJih0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzPXt9LHRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMuY29uZmlndXJhdGlvbj1KU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHMpKSx0aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZD0hMSksbj10aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmNvbmZpZ3VyYXRpb24sInJlc2V0Ij09PXR8fCEwPT09cil7dmFyIHA9Yy5sZW5ndGg7Zm9yKGY9MDtmPHA7Zis9MSluW2NbZl1dLnZhbHVlPW5bY1tmXV0uZGVmYXVsdFZhbHVlLG5bY1tmXV0uZXhwbGljaXRTZXQ9ITF9aWYoIm9iamVjdCI9PT1lKHQpKWZvcihhIGluIHQpaWYobz10W2FdLGQoYyxhKSYmdm9pZCAwIT09byl7aWYoImJvb2xlYW4iPT09blthXS50eXBlJiYiYm9vbGVhbiI9PXR5cGVvZiBvKW5bYV0udmFsdWU9bztlbHNlIGlmKCJuYW1lIj09PW5bYV0udHlwZSYmZChuW2FdLnZhbHVlU2V0LG8pKW5bYV0udmFsdWU9bztlbHNlIGlmKCJpbnRlZ2VyIj09PW5bYV0udHlwZSYmTnVtYmVyLmlzSW50ZWdlcihvKSluW2FdLnZhbHVlPW87ZWxzZSBpZigiYXJyYXkiPT09blthXS50eXBlKXtmb3IobD0wO2w8by5sZW5ndGg7bCs9MSlpZihpPSEwLDE9PT1vW2xdLmxlbmd0aCYmIm51bWJlciI9PXR5cGVvZiBvW2xdWzBdKXUucHVzaChTdHJpbmcob1tsXS0xKSk7ZWxzZSBpZihvW2xdLmxlbmd0aD4xKXtmb3IoaD0wO2g8b1tsXS5sZW5ndGg7aCs9MSkibnVtYmVyIiE9dHlwZW9mIG9bbF1baF0mJihpPSExKTshMD09PWkmJnUucHVzaChbb1tsXVswXS0xLG9bbF1bMV0tMV0uam9pbigiICIpKX1uW2FdLnZhbHVlPSJbIit1LmpvaW4oIiAiKSsiXSJ9ZWxzZSBuW2FdLnZhbHVlPW5bYV0uZGVmYXVsdFZhbHVlO25bYV0uZXhwbGljaXRTZXQ9ITB9cmV0dXJuITE9PT10aGlzLmludGVybmFsLnZpZXdlcnByZWZlcmVuY2VzLmlzU3Vic2NyaWJlZCYmKHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicHV0Q2F0YWxvZyIsKGZ1bmN0aW9uKCl7dmFyIHQsZT1bXTtmb3IodCBpbiBuKSEwPT09blt0XS5leHBsaWNpdFNldCYmKCJuYW1lIj09PW5bdF0udHlwZT9lLnB1c2goIi8iK3QrIiAvIituW3RdLnZhbHVlKTplLnB1c2goIi8iK3QrIiAiK25bdF0udmFsdWUpKTswIT09ZS5sZW5ndGgmJnRoaXMuaW50ZXJuYWwud3JpdGUoIi9WaWV3ZXJQcmVmZXJlbmNlc1xuPDxcbiIrZS5qb2luKCJcbiIpKyJcbj4+Iil9KSksdGhpcy5pbnRlcm5hbC52aWV3ZXJwcmVmZXJlbmNlcy5pc1N1YnNjcmliZWQ9ITApLHRoaXMuaW50ZXJuYWwudmlld2VycHJlZmVyZW5jZXMuY29uZmlndXJhdGlvbj1uLHRoaXN9fShNLkFQSSksCi8qKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PQogICAqIEBsaWNlbnNlCiAgICoganNQREYgWE1QIG1ldGFkYXRhIHBsdWdpbgogICAqIENvcHlyaWdodCAoYykgMjAxNiBKdXNzaSBVdHVuZW4sIHUtanVzc2lAc3VvbWkyNC5maQogICAqCiAgICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nCiAgICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCiAgICogIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwogICAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKICAgKiBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8KICAgKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8KICAgKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6CiAgICoKICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZQogICAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgogICAqCiAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsCiAgICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCiAgICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQKICAgKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFCiAgICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTgogICAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTgogICAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgogICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09CiAgICovCmZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7dmFyIHQ9JzxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6anNwZGY9IicrdGhpcy5pbnRlcm5hbC5fX21ldGFkYXRhX18ubmFtZXNwYWNldXJpKyciPjxqc3BkZjptZXRhZGF0YT4nLGU9dW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KCc8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIj4nKSkscj11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodCkpLG49dW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaW50ZXJuYWwuX19tZXRhZGF0YV9fLm1ldGFkYXRhKSksaT11bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoIjwvanNwZGY6bWV0YWRhdGE+PC9yZGY6RGVzY3JpcHRpb24+PC9yZGY6UkRGPiIpKSxhPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCgiPC94OnhtcG1ldGE+IikpLG89ci5sZW5ndGgrbi5sZW5ndGgraS5sZW5ndGgrZS5sZW5ndGgrYS5sZW5ndGg7dGhpcy5pbnRlcm5hbC5fX21ldGFkYXRhX18ubWV0YWRhdGFfb2JqZWN0X251bWJlcj10aGlzLmludGVybmFsLm5ld09iamVjdCgpLHRoaXMuaW50ZXJuYWwud3JpdGUoIjw8IC9UeXBlIC9NZXRhZGF0YSAvU3VidHlwZSAvWE1MIC9MZW5ndGggIitvKyIgPj4iKSx0aGlzLmludGVybmFsLndyaXRlKCJzdHJlYW0iKSx0aGlzLmludGVybmFsLndyaXRlKGUrcituK2krYSksdGhpcy5pbnRlcm5hbC53cml0ZSgiZW5kc3RyZWFtIiksdGhpcy5pbnRlcm5hbC53cml0ZSgiZW5kb2JqIil9LHI9ZnVuY3Rpb24oKXt0aGlzLmludGVybmFsLl9fbWV0YWRhdGFfXy5tZXRhZGF0YV9vYmplY3RfbnVtYmVyJiZ0aGlzLmludGVybmFsLndyaXRlKCIvTWV0YWRhdGEgIit0aGlzLmludGVybmFsLl9fbWV0YWRhdGFfXy5tZXRhZGF0YV9vYmplY3RfbnVtYmVyKyIgMCBSIil9O3QuYWRkTWV0YWRhdGE9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5pbnRlcm5hbC5fX21ldGFkYXRhX18mJih0aGlzLmludGVybmFsLl9fbWV0YWRhdGFfXz17bWV0YWRhdGE6dCxuYW1lc3BhY2V1cmk6bnx8Imh0dHA6Ly9qc3BkZi5kZWZhdWx0Lm5hbWVzcGFjZXVyaS8ifSx0aGlzLmludGVybmFsLmV2ZW50cy5zdWJzY3JpYmUoInB1dENhdGFsb2ciLHIpLHRoaXMuaW50ZXJuYWwuZXZlbnRzLnN1YnNjcmliZSgicG9zdFB1dFJlc291cmNlcyIsZSkpLHRoaXN9fShNLkFQSSksZnVuY3Rpb24odCl7dmFyIGU9dC5BUEkscj1lLnBkZkVzY2FwZTE2PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLG49ZS5tZXRhZGF0YS5Vbmljb2RlLndpZHRocyxpPVsiIiwiMCIsIjAwIiwiMDAwIiwiMDAwMCJdLGE9WyIiXSxvPTAscz10Lmxlbmd0aDtvPHM7KytvKXtpZihyPWUubWV0YWRhdGEuY2hhcmFjdGVyVG9HbHlwaCh0LmNoYXJDb2RlQXQobykpLGUubWV0YWRhdGEuZ2x5SWRzVXNlZC5wdXNoKHIpLGUubWV0YWRhdGEudG9Vbmljb2RlW3JdPXQuY2hhckNvZGVBdChvKSwtMT09bi5pbmRleE9mKHIpJiYobi5wdXNoKHIpLG4ucHVzaChbcGFyc2VJbnQoZS5tZXRhZGF0YS53aWR0aE9mR2x5cGgociksMTApXSkpLCIwIj09cilyZXR1cm4gYS5qb2luKCIiKTtyPXIudG9TdHJpbmcoMTYpLGEucHVzaChpWzQtci5sZW5ndGhdLHIpfXJldHVybiBhLmpvaW4oIiIpfSxuPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpLGEsbyxzO2ZvcihhPSIvQ0lESW5pdCAvUHJvY1NldCBmaW5kcmVzb3VyY2UgYmVnaW5cbjEyIGRpY3QgYmVnaW5cbmJlZ2luY21hcFxuL0NJRFN5c3RlbUluZm8gPDxcbiAgL1JlZ2lzdHJ5IChBZG9iZSlcbiAgL09yZGVyaW5nIChVQ1MpXG4gIC9TdXBwbGVtZW50IDBcbj4+IGRlZlxuL0NNYXBOYW1lIC9BZG9iZS1JZGVudGl0eS1VQ1MgZGVmXG4vQ01hcFR5cGUgMiBkZWZcbjEgYmVnaW5jb2Rlc3BhY2VyYW5nZVxuPDAwMDA+PGZmZmY+XG5lbmRjb2Rlc3BhY2VyYW5nZSIsbj1bXSxvPTAscz0ocj1PYmplY3Qua2V5cyh0KS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9KSkpLmxlbmd0aDtvPHM7bysrKWU9cltvXSxuLmxlbmd0aD49MTAwJiYoYSs9IlxuIituLmxlbmd0aCsiIGJlZ2luYmZjaGFyXG4iK24uam9pbigiXG4iKSsiXG5lbmRiZmNoYXIiLG49W10pLHZvaWQgMCE9PXRbZV0mJm51bGwhPT10W2VdJiYiZnVuY3Rpb24iPT10eXBlb2YgdFtlXS50b1N0cmluZyYmKGk9KCIwMDAwIit0W2VdLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpLGU9KCIwMDAwIisoK2UpLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpLG4ucHVzaCgiPCIrZSsiPjwiK2krIj4iKSk7cmV0dXJuIG4ubGVuZ3RoJiYoYSs9IlxuIituLmxlbmd0aCsiIGJlZ2luYmZjaGFyXG4iK24uam9pbigiXG4iKSsiXG5lbmRiZmNoYXJcbiIpLGErPSJlbmRjbWFwXG5DTWFwTmFtZSBjdXJyZW50ZGljdCAvQ01hcCBkZWZpbmVyZXNvdXJjZSBwb3BcbmVuZFxuZW5kIn07ZS5ldmVudHMucHVzaChbInB1dEZvbnQiLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXt2YXIgcj1lLmZvbnQsaT1lLm91dCxhPWUubmV3T2JqZWN0LG89ZS5wdXRTdHJlYW07aWYoci5tZXRhZGF0YSBpbnN0YW5jZW9mIHQuQVBJLlRURkZvbnQmJiJJZGVudGl0eS1IIj09PXIuZW5jb2Rpbmcpe2Zvcih2YXIgcz1yLm1ldGFkYXRhLlVuaWNvZGUud2lkdGhzLGM9ci5tZXRhZGF0YS5zdWJzZXQuZW5jb2RlKHIubWV0YWRhdGEuZ2x5SWRzVXNlZCwxKSx1PSIiLGw9MDtsPGMubGVuZ3RoO2wrKyl1Kz1TdHJpbmcuZnJvbUNoYXJDb2RlKGNbbF0pO3ZhciBoPWEoKTtvKHtkYXRhOnUsYWRkTGVuZ3RoMTohMCxvYmplY3RJZDpofSksaSgiZW5kb2JqIik7dmFyIGY9YSgpO28oe2RhdGE6bihyLm1ldGFkYXRhLnRvVW5pY29kZSksYWRkTGVuZ3RoMTohMCxvYmplY3RJZDpmfSksaSgiZW5kb2JqIik7dmFyIGQ9YSgpO2koIjw8IiksaSgiL1R5cGUgL0ZvbnREZXNjcmlwdG9yIiksaSgiL0ZvbnROYW1lIC8iK0Yoci5mb250TmFtZSkpLGkoIi9Gb250RmlsZTIgIitoKyIgMCBSIiksaSgiL0ZvbnRCQm94ICIrdC5BUEkuUERGT2JqZWN0LmNvbnZlcnQoci5tZXRhZGF0YS5iYm94KSksaSgiL0ZsYWdzICIrci5tZXRhZGF0YS5mbGFncyksaSgiL1N0ZW1WICIrci5tZXRhZGF0YS5zdGVtViksaSgiL0l0YWxpY0FuZ2xlICIrci5tZXRhZGF0YS5pdGFsaWNBbmdsZSksaSgiL0FzY2VudCAiK3IubWV0YWRhdGEuYXNjZW5kZXIpLGkoIi9EZXNjZW50ICIrci5tZXRhZGF0YS5kZWNlbmRlciksaSgiL0NhcEhlaWdodCAiK3IubWV0YWRhdGEuY2FwSGVpZ2h0KSxpKCI+PiIpLGkoImVuZG9iaiIpO3ZhciBwPWEoKTtpKCI8PCIpLGkoIi9UeXBlIC9Gb250IiksaSgiL0Jhc2VGb250IC8iK0Yoci5mb250TmFtZSkpLGkoIi9Gb250RGVzY3JpcHRvciAiK2QrIiAwIFIiKSxpKCIvVyAiK3QuQVBJLlBERk9iamVjdC5jb252ZXJ0KHMpKSxpKCIvQ0lEVG9HSURNYXAgL0lkZW50aXR5IiksaSgiL0RXIDEwMDAiKSxpKCIvU3VidHlwZSAvQ0lERm9udFR5cGUyIiksaSgiL0NJRFN5c3RlbUluZm8iKSxpKCI8PCIpLGkoIi9TdXBwbGVtZW50IDAiKSxpKCIvUmVnaXN0cnkgKEFkb2JlKSIpLGkoIi9PcmRlcmluZyAoIityLmVuY29kaW5nKyIpIiksaSgiPj4iKSxpKCI+PiIpLGkoImVuZG9iaiIpLHIub2JqZWN0TnVtYmVyPWEoKSxpKCI8PCIpLGkoIi9UeXBlIC9Gb250IiksaSgiL1N1YnR5cGUgL1R5cGUwIiksaSgiL1RvVW5pY29kZSAiK2YrIiAwIFIiKSxpKCIvQmFzZUZvbnQgLyIrRihyLmZvbnROYW1lKSksaSgiL0VuY29kaW5nIC8iK3IuZW5jb2RpbmcpLGkoIi9EZXNjZW5kYW50Rm9udHMgWyIrcCsiIDAgUl0iKSxpKCI+PiIpLGkoImVuZG9iaiIpLHIuaXNBbHJlYWR5UHV0dGVkPSEwfX0oZSl9XSk7ZS5ldmVudHMucHVzaChbInB1dEZvbnQiLGZ1bmN0aW9uKGUpeyFmdW5jdGlvbihlKXt2YXIgcj1lLmZvbnQsaT1lLm91dCxhPWUubmV3T2JqZWN0LG89ZS5wdXRTdHJlYW07aWYoci5tZXRhZGF0YSBpbnN0YW5jZW9mIHQuQVBJLlRURkZvbnQmJiJXaW5BbnNpRW5jb2RpbmciPT09ci5lbmNvZGluZyl7Zm9yKHZhciBzPXIubWV0YWRhdGEucmF3RGF0YSxjPSIiLHU9MDt1PHMubGVuZ3RoO3UrKyljKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHNbdV0pO3ZhciBsPWEoKTtvKHtkYXRhOmMsYWRkTGVuZ3RoMTohMCxvYmplY3RJZDpsfSksaSgiZW5kb2JqIik7dmFyIGg9YSgpO28oe2RhdGE6bihyLm1ldGFkYXRhLnRvVW5pY29kZSksYWRkTGVuZ3RoMTohMCxvYmplY3RJZDpofSksaSgiZW5kb2JqIik7dmFyIGY9YSgpO2koIjw8IiksaSgiL0Rlc2NlbnQgIityLm1ldGFkYXRhLmRlY2VuZGVyKSxpKCIvQ2FwSGVpZ2h0ICIrci5tZXRhZGF0YS5jYXBIZWlnaHQpLGkoIi9TdGVtViAiK3IubWV0YWRhdGEuc3RlbVYpLGkoIi9UeXBlIC9Gb250RGVzY3JpcHRvciIpLGkoIi9Gb250RmlsZTIgIitsKyIgMCBSIiksaSgiL0ZsYWdzIDk2IiksaSgiL0ZvbnRCQm94ICIrdC5BUEkuUERGT2JqZWN0LmNvbnZlcnQoci5tZXRhZGF0YS5iYm94KSksaSgiL0ZvbnROYW1lIC8iK0Yoci5mb250TmFtZSkpLGkoIi9JdGFsaWNBbmdsZSAiK3IubWV0YWRhdGEuaXRhbGljQW5nbGUpLGkoIi9Bc2NlbnQgIityLm1ldGFkYXRhLmFzY2VuZGVyKSxpKCI+PiIpLGkoImVuZG9iaiIpLHIub2JqZWN0TnVtYmVyPWEoKTtmb3IodmFyIGQ9MDtkPHIubWV0YWRhdGEuaG10eC53aWR0aHMubGVuZ3RoO2QrKylyLm1ldGFkYXRhLmhtdHgud2lkdGhzW2RdPXBhcnNlSW50KHIubWV0YWRhdGEuaG10eC53aWR0aHNbZF0qKDFlMy9yLm1ldGFkYXRhLmhlYWQudW5pdHNQZXJFbSkpO2koIjw8L1N1YnR5cGUvVHJ1ZVR5cGUvVHlwZS9Gb250L1RvVW5pY29kZSAiK2grIiAwIFIvQmFzZUZvbnQvIitGKHIuZm9udE5hbWUpKyIvRm9udERlc2NyaXB0b3IgIitmKyIgMCBSL0VuY29kaW5nLyIrci5lbmNvZGluZysiIC9GaXJzdENoYXIgMjkgL0xhc3RDaGFyIDI1NSAvV2lkdGhzICIrdC5BUEkuUERGT2JqZWN0LmNvbnZlcnQoci5tZXRhZGF0YS5obXR4LndpZHRocykrIj4+IiksaSgiZW5kb2JqIiksci5pc0FscmVhZHlQdXR0ZWQ9ITB9fShlKX1dKTt2YXIgaT1mdW5jdGlvbih0KXt2YXIgZSxuPXQudGV4dHx8IiIsaT10LngsYT10Lnksbz10Lm9wdGlvbnN8fHt9LHM9dC5tdXRleHx8e30sYz1zLnBkZkVzY2FwZSx1PXMuYWN0aXZlRm9udEtleSxsPXMuZm9udHMsaD11LGY9IiIsZD0wLHA9IiIsZz1sW2hdLmVuY29kaW5nO2lmKCJJZGVudGl0eS1IIiE9PWxbaF0uZW5jb2RpbmcpcmV0dXJue3RleHQ6bix4OmkseTphLG9wdGlvbnM6byxtdXRleDpzfTtmb3IocD1uLGg9dSxBcnJheS5pc0FycmF5KG4pJiYocD1uWzBdKSxkPTA7ZDxwLmxlbmd0aDtkKz0xKWxbaF0ubWV0YWRhdGEuaGFzT3duUHJvcGVydHkoImNtYXAiKSYmKGU9bFtoXS5tZXRhZGF0YS5jbWFwLnVuaWNvZGUuY29kZU1hcFtwW2RdLmNoYXJDb2RlQXQoMCldKSxlfHxwW2RdLmNoYXJDb2RlQXQoMCk8MjU2JiZsW2hdLm1ldGFkYXRhLmhhc093blByb3BlcnR5KCJVbmljb2RlIik/Zis9cFtkXTpmKz0iIjt2YXIgbT0iIjtyZXR1cm4gcGFyc2VJbnQoaC5zbGljZSgxKSk8MTR8fCJXaW5BbnNpRW5jb2RpbmciPT09Zz9tPWMoZixoKS5zcGxpdCgiIikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KX0pKS5qb2luKCIiKToiSWRlbnRpdHktSCI9PT1nJiYobT1yKGYsbFtoXSkpLHMuaXNIZXg9ITAse3RleHQ6bSx4OmkseTphLG9wdGlvbnM6byxtdXRleDpzfX07ZS5ldmVudHMucHVzaChbInBvc3RQcm9jZXNzVGV4dCIsZnVuY3Rpb24odCl7dmFyIGU9dC50ZXh0fHwiIixyPVtdLG49e3RleHQ6ZSx4OnQueCx5OnQueSxvcHRpb25zOnQub3B0aW9ucyxtdXRleDp0Lm11dGV4fTtpZihBcnJheS5pc0FycmF5KGUpKXt2YXIgYT0wO2ZvcihhPTA7YTxlLmxlbmd0aDthKz0xKUFycmF5LmlzQXJyYXkoZVthXSkmJjM9PT1lW2FdLmxlbmd0aD9yLnB1c2goW2koT2JqZWN0LmFzc2lnbih7fSxuLHt0ZXh0OmVbYV1bMF19KSkudGV4dCxlW2FdWzFdLGVbYV1bMl1dKTpyLnB1c2goaShPYmplY3QuYXNzaWduKHt9LG4se3RleHQ6ZVthXX0pKS50ZXh0KTt0LnRleHQ9cn1lbHNlIHQudGV4dD1pKE9iamVjdC5hc3NpZ24oe30sbix7dGV4dDplfSkpLnRleHR9XSl9KE0pLAovKioKICAgKiBAbGljZW5zZQogICAqIGpzUERGIHZpcnR1YWwgRmlsZVN5c3RlbSBmdW5jdGlvbmFsaXR5CiAgICoKICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuCiAgICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlCiAgICovCmZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PXRoaXMuaW50ZXJuYWwudkZTJiYodGhpcy5pbnRlcm5hbC52RlM9e30pLCEwfTt0LmV4aXN0c0ZpbGVJblZGUz1mdW5jdGlvbih0KXtyZXR1cm4gZS5jYWxsKHRoaXMpLHZvaWQgMCE9PXRoaXMuaW50ZXJuYWwudkZTW3RdfSx0LmFkZEZpbGVUb1ZGUz1mdW5jdGlvbih0LHIpe3JldHVybiBlLmNhbGwodGhpcyksdGhpcy5pbnRlcm5hbC52RlNbdF09cix0aGlzfSx0LmdldEZpbGVGcm9tVkZTPWZ1bmN0aW9uKHQpe3JldHVybiBlLmNhbGwodGhpcyksdm9pZCAwIT09dGhpcy5pbnRlcm5hbC52RlNbdF0/dGhpcy5pbnRlcm5hbC52RlNbdF06bnVsbH19KE0uQVBJKSwKLyoqCiAgICogQGxpY2Vuc2UKICAgKiBVbmljb2RlIEJpZGkgRW5naW5lIGJhc2VkIG9uIHRoZSB3b3JrIG9mIEFsZXggU2hlbnNpcyAoQGFzdGhlbnNpcykKICAgKiBNSVQgTGljZW5zZQogICAqLwpmdW5jdGlvbih0KXt0Ll9fYmlkaUVuZ2luZV9fPXQucHJvdG90eXBlLl9fYmlkaUVuZ2luZV9fPWZ1bmN0aW9uKHQpe3ZhciByLG4saSxhLG8scyxjLHU9ZSxsPVtbMCwzLDAsMSwwLDAsMF0sWzAsMywwLDEsMiwyLDBdLFswLDMsMCwxNywyLDAsMV0sWzAsMyw1LDUsNCwxLDBdLFswLDMsMjEsMjEsNCwwLDFdLFswLDMsNSw1LDQsMiwwXV0saD1bWzIsMCwxLDEsMCwxLDBdLFsyLDAsMSwxLDAsMiwwXSxbMiwwLDIsMSwzLDIsMF0sWzIsMCwyLDMzLDMsMSwxXV0sZj17TDowLFI6MSxFTjoyLEFOOjMsTjo0LEI6NSxTOjZ9LGQ9ezA6MCw1OjEsNjoyLDc6MywzMjo0LDI1MTo1LDI1NDo2LDI1NTo3fSxwPVsiKCIsIikiLCIoIiwiPCIsIj4iLCI8IiwiWyIsIl0iLCJbIiwieyIsIn0iLCJ7IiwiwqsiLCLCuyIsIsKrIiwi4oC5Iiwi4oC6Iiwi4oC5Iiwi4oGFIiwi4oGGIiwi4oGFIiwi4oG9Iiwi4oG+Iiwi4oG9Iiwi4oKNIiwi4oKOIiwi4oKNIiwi4omkIiwi4omlIiwi4omkIiwi4oypIiwi4oyqIiwi4oypIiwi77mZIiwi77maIiwi77mZIiwi77mbIiwi77mcIiwi77mbIiwi77mdIiwi77meIiwi77mdIiwi77mkIiwi77mlIiwi77mkIl0sZz1uZXcgUmVnRXhwKC9eKFsxLTR8OV18MVswLTldfDJbMC05XXwzWzAxNjhdfDRbMDQ1ODldfDVbMDEyXXw3Wzc4XXwxNTl8MTZbMC05XXwxN1swLTJdfDIxWzU2OV18MjJbMDM0ODldfDI1MCkkLyksbT0hMSx2PTA7dGhpcy5fX2JpZGlFbmdpbmVfXz17fTt2YXIgYj1mdW5jdGlvbih0KXt2YXIgZT10LmNoYXJDb2RlQXQoKSxyPWU+Pjgsbj1kW3JdO3JldHVybiB2b2lkIDAhPT1uP3VbMjU2Km4rKDI1NSZlKV06MjUyPT09cnx8MjUzPT09cj8iQUwiOmcudGVzdChyKT8iTCI6OD09PXI/IlIiOiJOIn0seT1mdW5jdGlvbih0KXtmb3IodmFyIGUscj0wO3I8dC5sZW5ndGg7cisrKXtpZigiTCI9PT0oZT1iKHQuY2hhckF0KHIpKSkpcmV0dXJuITE7aWYoIlIiPT09ZSlyZXR1cm4hMH1yZXR1cm4hMX0sdz1mdW5jdGlvbih0LGUsbyxzKXt2YXIgYyx1LGwsaCxmPWVbc107c3dpdGNoKGYpe2Nhc2UiTCI6Y2FzZSJSIjptPSExO2JyZWFrO2Nhc2UiTiI6Y2FzZSJBTiI6YnJlYWs7Y2FzZSJFTiI6bSYmKGY9IkFOIik7YnJlYWs7Y2FzZSJBTCI6bT0hMCxmPSJSIjticmVhaztjYXNlIldTIjpmPSJOIjticmVhaztjYXNlIkNTIjpzPDF8fHMrMT49ZS5sZW5ndGh8fCJFTiIhPT0oYz1vW3MtMV0pJiYiQU4iIT09Y3x8IkVOIiE9PSh1PWVbcysxXSkmJiJBTiIhPT11P2Y9Ik4iOm0mJih1PSJBTiIpLGY9dT09PWM/dToiTiI7YnJlYWs7Y2FzZSJFUyI6Zj0iRU4iPT09KGM9cz4wP29bcy0xXToiQiIpJiZzKzE8ZS5sZW5ndGgmJiJFTiI9PT1lW3MrMV0/IkVOIjoiTiI7YnJlYWs7Y2FzZSJFVCI6aWYocz4wJiYiRU4iPT09b1tzLTFdKXtmPSJFTiI7YnJlYWt9aWYobSl7Zj0iTiI7YnJlYWt9Zm9yKGw9cysxLGg9ZS5sZW5ndGg7bDxoJiYiRVQiPT09ZVtsXTspbCsrO2Y9bDxoJiYiRU4iPT09ZVtsXT8iRU4iOiJOIjticmVhaztjYXNlIk5TTSI6aWYoaSYmIWEpe2ZvcihoPWUubGVuZ3RoLGw9cysxO2w8aCYmIk5TTSI9PT1lW2xdOylsKys7aWYobDxoKXt2YXIgZD10W3NdLHA9ZD49MTQyNSYmZDw9MjMwM3x8NjQyODY9PT1kO2lmKGM9ZVtsXSxwJiYoIlIiPT09Y3x8IkFMIj09PWMpKXtmPSJSIjticmVha319fWY9czwxfHwiQiI9PT0oYz1lW3MtMV0pPyJOIjpvW3MtMV07YnJlYWs7Y2FzZSJCIjptPSExLHI9ITAsZj12O2JyZWFrO2Nhc2UiUyI6bj0hMCxmPSJOIjticmVhaztjYXNlIkxSRSI6Y2FzZSJSTEUiOmNhc2UiTFJPIjpjYXNlIlJMTyI6Y2FzZSJQREYiOm09ITE7YnJlYWs7Y2FzZSJCTiI6Zj0iTiJ9cmV0dXJuIGZ9LE49ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQuc3BsaXQoIiIpO3JldHVybiByJiZMKG4scix7aGlMZXZlbDp2fSksbi5yZXZlcnNlKCksZSYmZS5yZXZlcnNlKCksbi5qb2luKCIiKX0sTD1mdW5jdGlvbih0LGUsaSl7dmFyIGEsbyxzLGMsdSxkPS0xLHA9dC5sZW5ndGgsZz0wLHk9W10sTj12P2g6bCxMPVtdO2ZvcihtPSExLHI9ITEsbj0hMSxvPTA7bzxwO28rKylMW29dPWIodFtvXSk7Zm9yKHM9MDtzPHA7cysrKXtpZih1PWcseVtzXT13KHQsTCx5LHMpLGE9MjQwJihnPU5bdV1bZlt5W3NdXV0pLGcmPTE1LGVbc109Yz1OW2ddWzVdLGE+MClpZigxNj09PWEpe2ZvcihvPWQ7bzxzO28rKyllW29dPTE7ZD0tMX1lbHNlIGQ9LTE7aWYoTltnXVs2XSktMT09PWQmJihkPXMpO2Vsc2UgaWYoZD4tMSl7Zm9yKG89ZDtvPHM7bysrKWVbb109YztkPS0xfSJCIj09PUxbc10mJihlW3NdPTApLGkuaGlMZXZlbHw9Y31uJiZmdW5jdGlvbih0LGUscil7Zm9yKHZhciBuPTA7bjxyO24rKylpZigiUyI9PT10W25dKXtlW25dPXY7Zm9yKHZhciBpPW4tMTtpPj0wJiYiV1MiPT09dFtpXTtpLS0pZVtpXT12fX0oTCxlLHApfSxBPWZ1bmN0aW9uKHQsZSxuLGksYSl7aWYoIShhLmhpTGV2ZWw8dCkpe2lmKDE9PT10JiYxPT09diYmIXIpcmV0dXJuIGUucmV2ZXJzZSgpLHZvaWQobiYmbi5yZXZlcnNlKCkpO2Zvcih2YXIgbyxzLGMsdSxsPWUubGVuZ3RoLGg9MDtoPGw7KXtpZihpW2hdPj10KXtmb3IoYz1oKzE7YzxsJiZpW2NdPj10OyljKys7Zm9yKHU9aCxzPWMtMTt1PHM7dSsrLHMtLSlvPWVbdV0sZVt1XT1lW3NdLGVbc109byxuJiYobz1uW3VdLG5bdV09bltzXSxuW3NdPW8pO2g9Y31oKyt9fX0seD1mdW5jdGlvbih0LGUscil7dmFyIG49dC5zcGxpdCgiIiksaT17aGlMZXZlbDp2fTtyZXR1cm4gcnx8KHI9W10pLEwobixyLGkpLGZ1bmN0aW9uKHQsZSxyKXtpZigwIT09ci5oaUxldmVsJiZjKWZvcih2YXIgbixpPTA7aTx0Lmxlbmd0aDtpKyspMT09PWVbaV0mJihuPXAuaW5kZXhPZih0W2ldKSk+PTAmJih0W2ldPXBbbisxXSl9KG4scixpKSxBKDIsbixlLHIsaSksQSgxLG4sZSxyLGkpLG4uam9pbigiIil9O3JldHVybiB0aGlzLl9fYmlkaUVuZ2luZV9fLmRvQmlkaVJlb3JkZXI9ZnVuY3Rpb24odCxlLHIpe2lmKGZ1bmN0aW9uKHQsZSl7aWYoZSlmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyllW3JdPXI7dm9pZCAwPT09YSYmKGE9eSh0KSksdm9pZCAwPT09cyYmKHM9eSh0KSl9KHQsZSksaXx8IW98fHMpaWYoaSYmbyYmYV5zKXY9YT8xOjAsdD1OKHQsZSxyKTtlbHNlIGlmKCFpJiZvJiZzKXY9YT8xOjAsdD14KHQsZSxyKSx0PU4odCxlKTtlbHNlIGlmKCFpfHxhfHxvfHxzKXtpZihpJiYhbyYmYV5zKXQ9Tih0LGUpLGE/KHY9MCx0PXgodCxlLHIpKToodj0xLHQ9eCh0LGUsciksdD1OKHQsZSkpO2Vsc2UgaWYoaSYmYSYmIW8mJnMpdj0xLHQ9eCh0LGUsciksdD1OKHQsZSk7ZWxzZSBpZighaSYmIW8mJmFecyl7dmFyIG49YzthPyh2PTEsdD14KHQsZSxyKSx2PTAsYz0hMSx0PXgodCxlLHIpLGM9bik6KHY9MCx0PXgodCxlLHIpLHQ9Tih0LGUpLHY9MSxjPSExLHQ9eCh0LGUsciksYz1uLHQ9Tih0LGUpKX19ZWxzZSB2PTAsdD14KHQsZSxyKTtlbHNlIHY9YT8xOjAsdD14KHQsZSxyKTtyZXR1cm4gdH0sdGhpcy5fX2JpZGlFbmdpbmVfXy5zZXRPcHRpb25zPWZ1bmN0aW9uKHQpe3QmJihpPXQuaXNJbnB1dFZpc3VhbCxvPXQuaXNPdXRwdXRWaXN1YWwsYT10LmlzSW5wdXRSdGwscz10LmlzT3V0cHV0UnRsLGM9dC5pc1N5bW1ldHJpY1N3YXBwaW5nKX0sdGhpcy5fX2JpZGlFbmdpbmVfXy5zZXRPcHRpb25zKHQpLHRoaXMuX19iaWRpRW5naW5lX199O3ZhciBlPVsiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiUyIsIkIiLCJTIiwiV1MiLCJCIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkIiLCJCIiwiQiIsIlMiLCJXUyIsIk4iLCJOIiwiRVQiLCJFVCIsIkVUIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJFUyIsIkNTIiwiRVMiLCJDUyIsIkNTIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJDUyIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIk4iLCJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJDUyIsIk4iLCJFVCIsIkVUIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIk4iLCJMIiwiTiIsIk4iLCJCTiIsIk4iLCJOIiwiRVQiLCJFVCIsIkVOIiwiRU4iLCJOIiwiTCIsIk4iLCJOIiwiTiIsIkVOIiwiTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiRVQiLCJOIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiUiIsIk5TTSIsIlIiLCJOU00iLCJOU00iLCJSIiwiTlNNIiwiTlNNIiwiUiIsIk5TTSIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJSIiwiUiIsIlIiLCJSIiwiUiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiTiIsIk4iLCJBTCIsIkVUIiwiRVQiLCJBTCIsIkNTIiwiQUwiLCJOIiwiTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIkFMIiwiQUwiLCJOIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJBTiIsIkFOIiwiQU4iLCJFVCIsIkFOIiwiQU4iLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQU4iLCJOIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiQUwiLCJBTCIsIk5TTSIsIk5TTSIsIk4iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIkFMIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTiIsIkFMIiwiQUwiLCJOU00iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOIiwiTiIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJBTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIlIiLCJSIiwiTiIsIk4iLCJOIiwiTiIsIlIiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIldTIiwiV1MiLCJXUyIsIldTIiwiV1MiLCJXUyIsIldTIiwiV1MiLCJXUyIsIldTIiwiV1MiLCJCTiIsIkJOIiwiQk4iLCJMIiwiUiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIldTIiwiQiIsIkxSRSIsIlJMRSIsIlBERiIsIkxSTyIsIlJMTyIsIkNTIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkNTIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJXUyIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJOIiwiTFJJIiwiUkxJIiwiRlNJIiwiUERJIiwiQk4iLCJCTiIsIkJOIiwiQk4iLCJCTiIsIkJOIiwiRU4iLCJMIiwiTiIsIk4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFUyIsIkVTIiwiTiIsIk4iLCJOIiwiTCIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRVMiLCJFUyIsIk4iLCJOIiwiTiIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJFVCIsIkVUIiwiRVQiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk5TTSIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiUiIsIk5TTSIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJFUyIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJOIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJOIiwiUiIsIk4iLCJSIiwiUiIsIk4iLCJSIiwiUiIsIk4iLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiUiIsIlIiLCJSIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOU00iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTlNNIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJDUyIsIk4iLCJDUyIsIk4iLCJOIiwiQ1MiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJFVCIsIk4iLCJOIiwiRVMiLCJFUyIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIk4iLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJBTCIsIkFMIiwiQUwiLCJOIiwiTiIsIkJOIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIkVUIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJFUyIsIkNTIiwiRVMiLCJDUyIsIkNTIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJFTiIsIkVOIiwiRU4iLCJDUyIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJMIiwiTCIsIkwiLCJMIiwiTCIsIkwiLCJOIiwiTiIsIkwiLCJMIiwiTCIsIkwiLCJMIiwiTCIsIk4iLCJOIiwiTCIsIkwiLCJMIiwiTiIsIk4iLCJOIiwiRVQiLCJFVCIsIk4iLCJOIiwiTiIsIkVUIiwiRVQiLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIiwiTiIsIk4iLCJOIl0scj1uZXcgdC5fX2JpZGlFbmdpbmVfXyh7aXNJbnB1dFZpc3VhbDohMH0pO3QuQVBJLmV2ZW50cy5wdXNoKFsicG9zdFByb2Nlc3NUZXh0IixmdW5jdGlvbih0KXt2YXIgZT10LnRleHQsbj0odC54LHQueSx0Lm9wdGlvbnN8fHt9KSxpPSh0Lm11dGV4LG4ubGFuZyxbXSk7aWYobi5pc0lucHV0VmlzdWFsPSJib29sZWFuIiE9dHlwZW9mIG4uaXNJbnB1dFZpc3VhbHx8bi5pc0lucHV0VmlzdWFsLHIuc2V0T3B0aW9ucyhuKSwiW29iamVjdCBBcnJheV0iPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKXt2YXIgYT0wO2ZvcihpPVtdLGE9MDthPGUubGVuZ3RoO2ErPTEpIltvYmplY3QgQXJyYXldIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlW2FdKT9pLnB1c2goW3IuZG9CaWRpUmVvcmRlcihlW2FdWzBdKSxlW2FdWzFdLGVbYV1bMl1dKTppLnB1c2goW3IuZG9CaWRpUmVvcmRlcihlW2FdKV0pO3QudGV4dD1pfWVsc2UgdC50ZXh0PXIuZG9CaWRpUmVvcmRlcihlKTtyLnNldE9wdGlvbnMoe2lzSW5wdXRWaXN1YWw6ITB9KX1dKX0oTSksTS5BUEkuVFRGRm9udD1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU7aWYodGhpcy5yYXdEYXRhPXQsZT10aGlzLmNvbnRlbnRzPW5ldyBUZSh0KSx0aGlzLmNvbnRlbnRzLnBvcz00LCJ0dGNmIj09PWUucmVhZFN0cmluZyg0KSl0aHJvdyBuZXcgRXJyb3IoIlRUQ0Ygbm90IHN1cHBvcnRlZC4iKTtlLnBvcz0wLHRoaXMucGFyc2UoKSx0aGlzLnN1YnNldD1uZXcgYXIodGhpcyksdGhpcy5yZWdpc3RlclRURigpfXJldHVybiB0Lm9wZW49ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyB0KGUpfSx0LnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmRpcmVjdG9yeT1uZXcgVWUodGhpcy5jb250ZW50cyksdGhpcy5oZWFkPW5ldyBXZSh0aGlzKSx0aGlzLm5hbWU9bmV3IFplKHRoaXMpLHRoaXMuY21hcD1uZXcgR2UodGhpcyksdGhpcy50b1VuaWNvZGU9e30sdGhpcy5oaGVhPW5ldyBZZSh0aGlzKSx0aGlzLm1heHA9bmV3ICRlKHRoaXMpLHRoaXMuaG10eD1uZXcgUWUodGhpcyksdGhpcy5wb3N0PW5ldyBYZSh0aGlzKSx0aGlzLm9zMj1uZXcgSmUodGhpcyksdGhpcy5sb2NhPW5ldyBpcih0aGlzKSx0aGlzLmdseWY9bmV3IGVyKHRoaXMpLHRoaXMuYXNjZW5kZXI9dGhpcy5vczIuZXhpc3RzJiZ0aGlzLm9zMi5hc2NlbmRlcnx8dGhpcy5oaGVhLmFzY2VuZGVyLHRoaXMuZGVjZW5kZXI9dGhpcy5vczIuZXhpc3RzJiZ0aGlzLm9zMi5kZWNlbmRlcnx8dGhpcy5oaGVhLmRlY2VuZGVyLHRoaXMubGluZUdhcD10aGlzLm9zMi5leGlzdHMmJnRoaXMub3MyLmxpbmVHYXB8fHRoaXMuaGhlYS5saW5lR2FwLHRoaXMuYmJveD1bdGhpcy5oZWFkLnhNaW4sdGhpcy5oZWFkLnlNaW4sdGhpcy5oZWFkLnhNYXgsdGhpcy5oZWFkLnlNYXhdfSx0LnByb3RvdHlwZS5yZWdpc3RlclRURj1mdW5jdGlvbigpe3ZhciB0LGUscixuLGk7aWYodGhpcy5zY2FsZUZhY3Rvcj0xZTMvdGhpcy5oZWFkLnVuaXRzUGVyRW0sdGhpcy5iYm94PWZ1bmN0aW9uKCl7dmFyIGUscixuLGk7Zm9yKGk9W10sZT0wLHI9KG49dGhpcy5iYm94KS5sZW5ndGg7ZTxyO2UrKyl0PW5bZV0saS5wdXNoKE1hdGgucm91bmQodCp0aGlzLnNjYWxlRmFjdG9yKSk7cmV0dXJuIGl9LmNhbGwodGhpcyksdGhpcy5zdGVtVj0wLHRoaXMucG9zdC5leGlzdHM/KHI9MjU1JihuPXRoaXMucG9zdC5pdGFsaWNfYW5nbGUpLDAhPSgzMjc2OCYoZT1uPj4xNikpJiYoZT0tKDErKDY1NTM1XmUpKSksdGhpcy5pdGFsaWNBbmdsZT0rKGUrIi4iK3IpKTp0aGlzLml0YWxpY0FuZ2xlPTAsdGhpcy5hc2NlbmRlcj1NYXRoLnJvdW5kKHRoaXMuYXNjZW5kZXIqdGhpcy5zY2FsZUZhY3RvciksdGhpcy5kZWNlbmRlcj1NYXRoLnJvdW5kKHRoaXMuZGVjZW5kZXIqdGhpcy5zY2FsZUZhY3RvciksdGhpcy5saW5lR2FwPU1hdGgucm91bmQodGhpcy5saW5lR2FwKnRoaXMuc2NhbGVGYWN0b3IpLHRoaXMuY2FwSGVpZ2h0PXRoaXMub3MyLmV4aXN0cyYmdGhpcy5vczIuY2FwSGVpZ2h0fHx0aGlzLmFzY2VuZGVyLHRoaXMueEhlaWdodD10aGlzLm9zMi5leGlzdHMmJnRoaXMub3MyLnhIZWlnaHR8fDAsdGhpcy5mYW1pbHlDbGFzcz0odGhpcy5vczIuZXhpc3RzJiZ0aGlzLm9zMi5mYW1pbHlDbGFzc3x8MCk+PjgsdGhpcy5pc1NlcmlmPTE9PT0oaT10aGlzLmZhbWlseUNsYXNzKXx8Mj09PWl8fDM9PT1pfHw0PT09aXx8NT09PWl8fDc9PT1pLHRoaXMuaXNTY3JpcHQ9MTA9PT10aGlzLmZhbWlseUNsYXNzLHRoaXMuZmxhZ3M9MCx0aGlzLnBvc3QuaXNGaXhlZFBpdGNoJiYodGhpcy5mbGFnc3w9MSksdGhpcy5pc1NlcmlmJiYodGhpcy5mbGFnc3w9MiksdGhpcy5pc1NjcmlwdCYmKHRoaXMuZmxhZ3N8PTgpLDAhPT10aGlzLml0YWxpY0FuZ2xlJiYodGhpcy5mbGFnc3w9NjQpLHRoaXMuZmxhZ3N8PTMyLCF0aGlzLmNtYXAudW5pY29kZSl0aHJvdyBuZXcgRXJyb3IoIk5vIHVuaWNvZGUgY21hcCBmb3IgZm9udCIpfSx0LnByb3RvdHlwZS5jaGFyYWN0ZXJUb0dseXBoPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybihudWxsIT0oZT10aGlzLmNtYXAudW5pY29kZSk/ZS5jb2RlTWFwW3RdOnZvaWQgMCl8fDB9LHQucHJvdG90eXBlLndpZHRoT2ZHbHlwaD1mdW5jdGlvbih0KXt2YXIgZTtyZXR1cm4gZT0xZTMvdGhpcy5oZWFkLnVuaXRzUGVyRW0sdGhpcy5obXR4LmZvckdseXBoKHQpLmFkdmFuY2UqZX0sdC5wcm90b3R5cGUud2lkdGhPZlN0cmluZz1mdW5jdGlvbih0LGUscil7dmFyIG4saSxhLG87Zm9yKGE9MCxpPTAsbz0odD0iIit0KS5sZW5ndGg7MDw9bz9pPG86aT5vO2k9MDw9bz8rK2k6LS1pKW49dC5jaGFyQ29kZUF0KGkpLGErPXRoaXMud2lkdGhPZkdseXBoKHRoaXMuY2hhcmFjdGVyVG9HbHlwaChuKSkrciooMWUzL2UpfHwwO3JldHVybiBhKihlLzFlMyl9LHQucHJvdG90eXBlLmxpbmVIZWlnaHQ9ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gbnVsbD09ZSYmKGU9ITEpLHI9ZT90aGlzLmxpbmVHYXA6MCwodGhpcy5hc2NlbmRlcityLXRoaXMuZGVjZW5kZXIpLzFlMyp0fSx0fSgpO3ZhciBSZSxUZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dGhpcy5kYXRhPW51bGwhPXQ/dDpbXSx0aGlzLnBvcz0wLHRoaXMubGVuZ3RoPXRoaXMuZGF0YS5sZW5ndGh9cmV0dXJuIHQucHJvdG90eXBlLnJlYWRCeXRlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXX0sdC5wcm90b3R5cGUud3JpdGVCeXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRhdGFbdGhpcy5wb3MrK109dH0sdC5wcm90b3R5cGUucmVhZFVJbnQzMj1mdW5jdGlvbigpe3JldHVybiAxNjc3NzIxNip0aGlzLnJlYWRCeXRlKCkrKHRoaXMucmVhZEJ5dGUoKTw8MTYpKyh0aGlzLnJlYWRCeXRlKCk8PDgpK3RoaXMucmVhZEJ5dGUoKX0sdC5wcm90b3R5cGUud3JpdGVVSW50MzI9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMud3JpdGVCeXRlKHQ+Pj4yNCYyNTUpLHRoaXMud3JpdGVCeXRlKHQ+PjE2JjI1NSksdGhpcy53cml0ZUJ5dGUodD4+OCYyNTUpLHRoaXMud3JpdGVCeXRlKDI1NSZ0KX0sdC5wcm90b3R5cGUucmVhZEludDMyPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuKHQ9dGhpcy5yZWFkVUludDMyKCkpPj0yMTQ3NDgzNjQ4P3QtNDI5NDk2NzI5Njp0fSx0LnByb3RvdHlwZS53cml0ZUludDMyPWZ1bmN0aW9uKHQpe3JldHVybiB0PDAmJih0Kz00Mjk0OTY3Mjk2KSx0aGlzLndyaXRlVUludDMyKHQpfSx0LnByb3RvdHlwZS5yZWFkVUludDE2PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZEJ5dGUoKTw8OHx0aGlzLnJlYWRCeXRlKCl9LHQucHJvdG90eXBlLndyaXRlVUludDE2PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLndyaXRlQnl0ZSh0Pj44JjI1NSksdGhpcy53cml0ZUJ5dGUoMjU1JnQpfSx0LnByb3RvdHlwZS5yZWFkSW50MTY9ZnVuY3Rpb24oKXt2YXIgdDtyZXR1cm4odD10aGlzLnJlYWRVSW50MTYoKSk+PTMyNzY4P3QtNjU1MzY6dH0sdC5wcm90b3R5cGUud3JpdGVJbnQxNj1mdW5jdGlvbih0KXtyZXR1cm4gdDwwJiYodCs9NjU1MzYpLHRoaXMud3JpdGVVSW50MTYodCl9LHQucHJvdG90eXBlLnJlYWRTdHJpbmc9ZnVuY3Rpb24odCl7dmFyIGUscjtmb3Iocj1bXSxlPTA7MDw9dD9lPHQ6ZT50O2U9MDw9dD8rK2U6LS1lKXJbZV09U3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRCeXRlKCkpO3JldHVybiByLmpvaW4oIiIpfSx0LnByb3RvdHlwZS53cml0ZVN0cmluZz1mdW5jdGlvbih0KXt2YXIgZSxyLG47Zm9yKG49W10sZT0wLHI9dC5sZW5ndGg7MDw9cj9lPHI6ZT5yO2U9MDw9cj8rK2U6LS1lKW4ucHVzaCh0aGlzLndyaXRlQnl0ZSh0LmNoYXJDb2RlQXQoZSkpKTtyZXR1cm4gbn0sdC5wcm90b3R5cGUucmVhZFNob3J0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmVhZEludDE2KCl9LHQucHJvdG90eXBlLndyaXRlU2hvcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMud3JpdGVJbnQxNih0KX0sdC5wcm90b3R5cGUucmVhZExvbmdMb25nPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saSxhLG8scztyZXR1cm4gdD10aGlzLnJlYWRCeXRlKCksZT10aGlzLnJlYWRCeXRlKCkscj10aGlzLnJlYWRCeXRlKCksbj10aGlzLnJlYWRCeXRlKCksaT10aGlzLnJlYWRCeXRlKCksYT10aGlzLnJlYWRCeXRlKCksbz10aGlzLnJlYWRCeXRlKCkscz10aGlzLnJlYWRCeXRlKCksMTI4JnQ/LTEqKDcyMDU3NTk0MDM3OTI3OTQwKigyNTVedCkrMjgxNDc0OTc2NzEwNjU2KigyNTVeZSkrMTA5OTUxMTYyNzc3NiooMjU1XnIpKzQyOTQ5NjcyOTYqKDI1NV5uKSsxNjc3NzIxNiooMjU1XmkpKzY1NTM2KigyNTVeYSkrMjU2KigyNTVebykrKDI1NV5zKSsxKTo3MjA1NzU5NDAzNzkyNzk0MCp0KzI4MTQ3NDk3NjcxMDY1NiplKzEwOTk1MTE2Mjc3NzYqcis0Mjk0OTY3Mjk2Km4rMTY3NzcyMTYqaSs2NTUzNiphKzI1NipvK3N9LHQucHJvdG90eXBlLndyaXRlTG9uZ0xvbmc9ZnVuY3Rpb24odCl7dmFyIGUscjtyZXR1cm4gZT1NYXRoLmZsb29yKHQvNDI5NDk2NzI5Nikscj00Mjk0OTY3Mjk1JnQsdGhpcy53cml0ZUJ5dGUoZT4+MjQmMjU1KSx0aGlzLndyaXRlQnl0ZShlPj4xNiYyNTUpLHRoaXMud3JpdGVCeXRlKGU+PjgmMjU1KSx0aGlzLndyaXRlQnl0ZSgyNTUmZSksdGhpcy53cml0ZUJ5dGUocj4+MjQmMjU1KSx0aGlzLndyaXRlQnl0ZShyPj4xNiYyNTUpLHRoaXMud3JpdGVCeXRlKHI+PjgmMjU1KSx0aGlzLndyaXRlQnl0ZSgyNTUmcil9LHQucHJvdG90eXBlLnJlYWRJbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZWFkSW50MzIoKX0sdC5wcm90b3R5cGUud3JpdGVJbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMud3JpdGVJbnQzMih0KX0sdC5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXt2YXIgZSxyO2ZvcihlPVtdLHI9MDswPD10P3I8dDpyPnQ7cj0wPD10PysrcjotLXIpZS5wdXNoKHRoaXMucmVhZEJ5dGUoKSk7cmV0dXJuIGV9LHQucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpO2ZvcihpPVtdLHI9MCxuPXQubGVuZ3RoO3I8bjtyKyspZT10W3JdLGkucHVzaCh0aGlzLndyaXRlQnl0ZShlKSk7cmV0dXJuIGl9LHR9KCksVWU9ZnVuY3Rpb24oKXt2YXIgdDtmdW5jdGlvbiBlKHQpe3ZhciBlLHIsbjtmb3IodGhpcy5zY2FsYXJUeXBlPXQucmVhZEludCgpLHRoaXMudGFibGVDb3VudD10LnJlYWRTaG9ydCgpLHRoaXMuc2VhcmNoUmFuZ2U9dC5yZWFkU2hvcnQoKSx0aGlzLmVudHJ5U2VsZWN0b3I9dC5yZWFkU2hvcnQoKSx0aGlzLnJhbmdlU2hpZnQ9dC5yZWFkU2hvcnQoKSx0aGlzLnRhYmxlcz17fSxyPTAsbj10aGlzLnRhYmxlQ291bnQ7MDw9bj9yPG46cj5uO3I9MDw9bj8rK3I6LS1yKWU9e3RhZzp0LnJlYWRTdHJpbmcoNCksY2hlY2tzdW06dC5yZWFkSW50KCksb2Zmc2V0OnQucmVhZEludCgpLGxlbmd0aDp0LnJlYWRJbnQoKX0sdGhpcy50YWJsZXNbZS50YWddPWV9cmV0dXJuIGUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihlKXt2YXIgcixuLGksYSxvLHMsYyx1LGwsaCxmLGQscDtmb3IocCBpbiBmPU9iamVjdC5rZXlzKGUpLmxlbmd0aCxzPU1hdGgubG9nKDIpLGw9MTYqTWF0aC5mbG9vcihNYXRoLmxvZyhmKS9zKSxhPU1hdGguZmxvb3IobC9zKSx1PTE2KmYtbCwobj1uZXcgVGUpLndyaXRlSW50KHRoaXMuc2NhbGFyVHlwZSksbi53cml0ZVNob3J0KGYpLG4ud3JpdGVTaG9ydChsKSxuLndyaXRlU2hvcnQoYSksbi53cml0ZVNob3J0KHUpLGk9MTYqZixjPW4ucG9zK2ksbz1udWxsLGQ9W10sZSlmb3IoaD1lW3BdLG4ud3JpdGVTdHJpbmcocCksbi53cml0ZUludCh0KGgpKSxuLndyaXRlSW50KGMpLG4ud3JpdGVJbnQoaC5sZW5ndGgpLGQ9ZC5jb25jYXQoaCksImhlYWQiPT09cCYmKG89YyksYys9aC5sZW5ndGg7YyU0OylkLnB1c2goMCksYysrO3JldHVybiBuLndyaXRlKGQpLHI9Mjk4MTE0NjU1NC10KG4uZGF0YSksbi5wb3M9bys4LG4ud3JpdGVVSW50MzIociksbi5kYXRhfSx0PWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpO2Zvcih0PXRyLmNhbGwodCk7dC5sZW5ndGglNDspdC5wdXNoKDApO2ZvcihuPW5ldyBUZSh0KSxyPTAsZT0wLGk9dC5sZW5ndGg7ZTxpO2U9ZSs9NClyKz1uLnJlYWRVSW50MzIoKTtyZXR1cm4gNDI5NDk2NzI5NSZyfSxlfSgpLHplPXt9Lmhhc093blByb3BlcnR5LEhlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByIGluIGUpemUuY2FsbChlLHIpJiYodFtyXT1lW3JdKTtmdW5jdGlvbiBuKCl7dGhpcy5jb25zdHJ1Y3Rvcj10fXJldHVybiBuLnByb3RvdHlwZT1lLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgbix0Ll9fc3VwZXJfXz1lLnByb3RvdHlwZSx0fSxXZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSGUoZSx0KSxlLnByb3RvdHlwZS50YWc9ImhlYWQiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHQpe3JldHVybiB0LnBvcz10aGlzLm9mZnNldCx0aGlzLnZlcnNpb249dC5yZWFkSW50KCksdGhpcy5yZXZpc2lvbj10LnJlYWRJbnQoKSx0aGlzLmNoZWNrU3VtQWRqdXN0bWVudD10LnJlYWRJbnQoKSx0aGlzLm1hZ2ljTnVtYmVyPXQucmVhZEludCgpLHRoaXMuZmxhZ3M9dC5yZWFkU2hvcnQoKSx0aGlzLnVuaXRzUGVyRW09dC5yZWFkU2hvcnQoKSx0aGlzLmNyZWF0ZWQ9dC5yZWFkTG9uZ0xvbmcoKSx0aGlzLm1vZGlmaWVkPXQucmVhZExvbmdMb25nKCksdGhpcy54TWluPXQucmVhZFNob3J0KCksdGhpcy55TWluPXQucmVhZFNob3J0KCksdGhpcy54TWF4PXQucmVhZFNob3J0KCksdGhpcy55TWF4PXQucmVhZFNob3J0KCksdGhpcy5tYWNTdHlsZT10LnJlYWRTaG9ydCgpLHRoaXMubG93ZXN0UmVjUFBFTT10LnJlYWRTaG9ydCgpLHRoaXMuZm9udERpcmVjdGlvbkhpbnQ9dC5yZWFkU2hvcnQoKSx0aGlzLmluZGV4VG9Mb2NGb3JtYXQ9dC5yZWFkU2hvcnQoKSx0aGlzLmdseXBoRGF0YUZvcm1hdD10LnJlYWRTaG9ydCgpfSxlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuKGU9bmV3IFRlKS53cml0ZUludCh0aGlzLnZlcnNpb24pLGUud3JpdGVJbnQodGhpcy5yZXZpc2lvbiksZS53cml0ZUludCh0aGlzLmNoZWNrU3VtQWRqdXN0bWVudCksZS53cml0ZUludCh0aGlzLm1hZ2ljTnVtYmVyKSxlLndyaXRlU2hvcnQodGhpcy5mbGFncyksZS53cml0ZVNob3J0KHRoaXMudW5pdHNQZXJFbSksZS53cml0ZUxvbmdMb25nKHRoaXMuY3JlYXRlZCksZS53cml0ZUxvbmdMb25nKHRoaXMubW9kaWZpZWQpLGUud3JpdGVTaG9ydCh0aGlzLnhNaW4pLGUud3JpdGVTaG9ydCh0aGlzLnlNaW4pLGUud3JpdGVTaG9ydCh0aGlzLnhNYXgpLGUud3JpdGVTaG9ydCh0aGlzLnlNYXgpLGUud3JpdGVTaG9ydCh0aGlzLm1hY1N0eWxlKSxlLndyaXRlU2hvcnQodGhpcy5sb3dlc3RSZWNQUEVNKSxlLndyaXRlU2hvcnQodGhpcy5mb250RGlyZWN0aW9uSGludCksZS53cml0ZVNob3J0KHQpLGUud3JpdGVTaG9ydCh0aGlzLmdseXBoRGF0YUZvcm1hdCksZS5kYXRhfSxlfShSZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7dmFyIGU7dGhpcy5maWxlPXQsZT10aGlzLmZpbGUuZGlyZWN0b3J5LnRhYmxlc1t0aGlzLnRhZ10sdGhpcy5leGlzdHM9ISFlLGUmJih0aGlzLm9mZnNldD1lLm9mZnNldCx0aGlzLmxlbmd0aD1lLmxlbmd0aCx0aGlzLnBhcnNlKHRoaXMuZmlsZS5jb250ZW50cykpfXJldHVybiB0LnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbigpe30sdC5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKCl7fSx0LnByb3RvdHlwZS5yYXc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGlzdHM/KHRoaXMuZmlsZS5jb250ZW50cy5wb3M9dGhpcy5vZmZzZXQsdGhpcy5maWxlLmNvbnRlbnRzLnJlYWQodGhpcy5sZW5ndGgpKTpudWxsfSx0fSgpKSxWZT1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlKXt2YXIgcixuLGksYSxvLHMsYyx1LGwsaCxmLGQscCxnLG0sdixiO3N3aXRjaCh0aGlzLnBsYXRmb3JtSUQ9dC5yZWFkVUludDE2KCksdGhpcy5lbmNvZGluZ0lEPXQucmVhZFNob3J0KCksdGhpcy5vZmZzZXQ9ZSt0LnJlYWRJbnQoKSxsPXQucG9zLHQucG9zPXRoaXMub2Zmc2V0LHRoaXMuZm9ybWF0PXQucmVhZFVJbnQxNigpLHRoaXMubGVuZ3RoPXQucmVhZFVJbnQxNigpLHRoaXMubGFuZ3VhZ2U9dC5yZWFkVUludDE2KCksdGhpcy5pc1VuaWNvZGU9Mz09PXRoaXMucGxhdGZvcm1JRCYmMT09PXRoaXMuZW5jb2RpbmdJRCYmND09PXRoaXMuZm9ybWF0fHwwPT09dGhpcy5wbGF0Zm9ybUlEJiY0PT09dGhpcy5mb3JtYXQsdGhpcy5jb2RlTWFwPXt9LHRoaXMuZm9ybWF0KXtjYXNlIDA6Zm9yKHM9MDtzPDI1NjsrK3MpdGhpcy5jb2RlTWFwW3NdPXQucmVhZEJ5dGUoKTticmVhaztjYXNlIDQ6Zm9yKGY9dC5yZWFkVUludDE2KCksaD1mLzIsdC5wb3MrPTYsaT1mdW5jdGlvbigpe3ZhciBlLHI7Zm9yKHI9W10scz1lPTA7MDw9aD9lPGg6ZT5oO3M9MDw9aD8rK2U6LS1lKXIucHVzaCh0LnJlYWRVSW50MTYoKSk7cmV0dXJuIHJ9KCksdC5wb3MrPTIscD1mdW5jdGlvbigpe3ZhciBlLHI7Zm9yKHI9W10scz1lPTA7MDw9aD9lPGg6ZT5oO3M9MDw9aD8rK2U6LS1lKXIucHVzaCh0LnJlYWRVSW50MTYoKSk7cmV0dXJuIHJ9KCksYz1mdW5jdGlvbigpe3ZhciBlLHI7Zm9yKHI9W10scz1lPTA7MDw9aD9lPGg6ZT5oO3M9MDw9aD8rK2U6LS1lKXIucHVzaCh0LnJlYWRVSW50MTYoKSk7cmV0dXJuIHJ9KCksdT1mdW5jdGlvbigpe3ZhciBlLHI7Zm9yKHI9W10scz1lPTA7MDw9aD9lPGg6ZT5oO3M9MDw9aD8rK2U6LS1lKXIucHVzaCh0LnJlYWRVSW50MTYoKSk7cmV0dXJuIHJ9KCksbj0odGhpcy5sZW5ndGgtdC5wb3MrdGhpcy5vZmZzZXQpLzIsbz1mdW5jdGlvbigpe3ZhciBlLHI7Zm9yKHI9W10scz1lPTA7MDw9bj9lPG46ZT5uO3M9MDw9bj8rK2U6LS1lKXIucHVzaCh0LnJlYWRVSW50MTYoKSk7cmV0dXJuIHJ9KCkscz1tPTAsYj1pLmxlbmd0aDttPGI7cz0rK20pZm9yKGc9aVtzXSxyPXY9ZD1wW3NdO2Q8PWc/djw9Zzp2Pj1nO3I9ZDw9Zz8rK3Y6LS12KTA9PT11W3NdP2E9citjW3NdOjAhPT0oYT1vW3Vbc10vMisoci1kKS0oaC1zKV18fDApJiYoYSs9Y1tzXSksdGhpcy5jb2RlTWFwW3JdPTY1NTM1JmF9dC5wb3M9bH1yZXR1cm4gdC5lbmNvZGU9ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksYSxvLHMsYyx1LGwsaCxmLGQscCxnLG0sdixiLHksdyxOLEwsQSx4LFMsXyxQLGssRixJLEMsaixPLEIsTSxFLHEsRCxSLFQsVSx6LEgsVyxWLEcsWTtzd2l0Y2goRj1uZXcgVGUsYT1PYmplY3Qua2V5cyh0KS5zb3J0KChmdW5jdGlvbih0LGUpe3JldHVybiB0LWV9KSksZSl7Y2FzZSJtYWNyb21hbiI6Zm9yKHA9MCxnPWZ1bmN0aW9uKCl7dmFyIHQ9W107Zm9yKGQ9MDtkPDI1NjsrK2QpdC5wdXNoKDApO3JldHVybiB0fSgpLHY9ezA6MH0saT17fSxJPTAsQj1hLmxlbmd0aDtJPEI7SSsrKW51bGw9PXZbVz10W249YVtJXV1dJiYodltXXT0rK3ApLGlbbl09e29sZDp0W25dLG5ldzp2W3Rbbl1dfSxnW25dPXZbdFtuXV07cmV0dXJuIEYud3JpdGVVSW50MTYoMSksRi53cml0ZVVJbnQxNigwKSxGLndyaXRlVUludDMyKDEyKSxGLndyaXRlVUludDE2KDApLEYud3JpdGVVSW50MTYoMjYyKSxGLndyaXRlVUludDE2KDApLEYud3JpdGUoZykse2NoYXJNYXA6aSxzdWJ0YWJsZTpGLmRhdGEsbWF4R2x5cGhJRDpwKzF9O2Nhc2UidW5pY29kZSI6Zm9yKFA9W10sbD1bXSxiPTAsdj17fSxyPXt9LG09Yz1udWxsLEM9MCxNPWEubGVuZ3RoO0M8TTtDKyspbnVsbD09dlt3PXRbbj1hW0NdXV0mJih2W3ddPSsrYikscltuXT17b2xkOncsbmV3OnZbd119LG89dlt3XS1uLG51bGwhPW0mJm89PT1jfHwobSYmbC5wdXNoKG0pLFAucHVzaChuKSxjPW8pLG09bjtmb3IobSYmbC5wdXNoKG0pLGwucHVzaCg2NTUzNSksUC5wdXNoKDY1NTM1KSxTPTIqKHg9UC5sZW5ndGgpLEE9MipNYXRoLnBvdyhNYXRoLmxvZyh4KS9NYXRoLkxOMiwyKSxoPU1hdGgubG9nKEEvMikvTWF0aC5MTjIsTD0yKngtQSxzPVtdLE49W10sZj1bXSxkPWo9MCxFPVAubGVuZ3RoO2o8RTtkPSsrail7aWYoXz1QW2RdLHU9bFtkXSw2NTUzNT09PV8pe3MucHVzaCgwKSxOLnB1c2goMCk7YnJlYWt9aWYoXy0oaz1yW19dLm5ldyk+PTMyNzY4KWZvcihzLnB1c2goMCksTi5wdXNoKDIqKGYubGVuZ3RoK3gtZCkpLG49Tz1fO188PXU/Tzw9dTpPPj11O249Xzw9dT8rK086LS1PKWYucHVzaChyW25dLm5ldyk7ZWxzZSBzLnB1c2goay1fKSxOLnB1c2goMCl9Zm9yKEYud3JpdGVVSW50MTYoMyksRi53cml0ZVVJbnQxNigxKSxGLndyaXRlVUludDMyKDEyKSxGLndyaXRlVUludDE2KDQpLEYud3JpdGVVSW50MTYoMTYrOCp4KzIqZi5sZW5ndGgpLEYud3JpdGVVSW50MTYoMCksRi53cml0ZVVJbnQxNihTKSxGLndyaXRlVUludDE2KEEpLEYud3JpdGVVSW50MTYoaCksRi53cml0ZVVJbnQxNihMKSx6PTAscT1sLmxlbmd0aDt6PHE7eisrKW49bFt6XSxGLndyaXRlVUludDE2KG4pO2ZvcihGLndyaXRlVUludDE2KDApLEg9MCxEPVAubGVuZ3RoO0g8RDtIKyspbj1QW0hdLEYud3JpdGVVSW50MTYobik7Zm9yKFY9MCxSPXMubGVuZ3RoO1Y8UjtWKyspbz1zW1ZdLEYud3JpdGVVSW50MTYobyk7Zm9yKEc9MCxUPU4ubGVuZ3RoO0c8VDtHKyspeT1OW0ddLEYud3JpdGVVSW50MTYoeSk7Zm9yKFk9MCxVPWYubGVuZ3RoO1k8VTtZKyspcD1mW1ldLEYud3JpdGVVSW50MTYocCk7cmV0dXJue2NoYXJNYXA6cixzdWJ0YWJsZTpGLmRhdGEsbWF4R2x5cGhJRDpiKzF9fX0sdH0oKSxHZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSGUoZSx0KSxlLnByb3RvdHlwZS50YWc9ImNtYXAiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbjtmb3IodC5wb3M9dGhpcy5vZmZzZXQsdGhpcy52ZXJzaW9uPXQucmVhZFVJbnQxNigpLG49dC5yZWFkVUludDE2KCksdGhpcy50YWJsZXM9W10sdGhpcy51bmljb2RlPW51bGwscj0wOzA8PW4/cjxuOnI+bjtyPTA8PW4/KytyOi0tcillPW5ldyBWZSh0LHRoaXMub2Zmc2V0KSx0aGlzLnRhYmxlcy5wdXNoKGUpLGUuaXNVbmljb2RlJiZudWxsPT10aGlzLnVuaWNvZGUmJih0aGlzLnVuaWNvZGU9ZSk7cmV0dXJuITB9LGUuZW5jb2RlPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbjtyZXR1cm4gbnVsbD09ZSYmKGU9Im1hY3JvbWFuIikscj1WZS5lbmNvZGUodCxlKSwobj1uZXcgVGUpLndyaXRlVUludDE2KDApLG4ud3JpdGVVSW50MTYoMSksci50YWJsZT1uLmRhdGEuY29uY2F0KHIuc3VidGFibGUpLHJ9LGV9KFJlKSxZZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSGUoZSx0KSxlLnByb3RvdHlwZS50YWc9ImhoZWEiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHQpe3JldHVybiB0LnBvcz10aGlzLm9mZnNldCx0aGlzLnZlcnNpb249dC5yZWFkSW50KCksdGhpcy5hc2NlbmRlcj10LnJlYWRTaG9ydCgpLHRoaXMuZGVjZW5kZXI9dC5yZWFkU2hvcnQoKSx0aGlzLmxpbmVHYXA9dC5yZWFkU2hvcnQoKSx0aGlzLmFkdmFuY2VXaWR0aE1heD10LnJlYWRTaG9ydCgpLHRoaXMubWluTGVmdFNpZGVCZWFyaW5nPXQucmVhZFNob3J0KCksdGhpcy5taW5SaWdodFNpZGVCZWFyaW5nPXQucmVhZFNob3J0KCksdGhpcy54TWF4RXh0ZW50PXQucmVhZFNob3J0KCksdGhpcy5jYXJldFNsb3BlUmlzZT10LnJlYWRTaG9ydCgpLHRoaXMuY2FyZXRTbG9wZVJ1bj10LnJlYWRTaG9ydCgpLHRoaXMuY2FyZXRPZmZzZXQ9dC5yZWFkU2hvcnQoKSx0LnBvcys9OCx0aGlzLm1ldHJpY0RhdGFGb3JtYXQ9dC5yZWFkU2hvcnQoKSx0aGlzLm51bWJlck9mTWV0cmljcz10LnJlYWRVSW50MTYoKX0sZX0oUmUpLEplPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBIZShlLHQpLGUucHJvdG90eXBlLnRhZz0iT1MvMiIsZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24odCl7aWYodC5wb3M9dGhpcy5vZmZzZXQsdGhpcy52ZXJzaW9uPXQucmVhZFVJbnQxNigpLHRoaXMuYXZlcmFnZUNoYXJXaWR0aD10LnJlYWRTaG9ydCgpLHRoaXMud2VpZ2h0Q2xhc3M9dC5yZWFkVUludDE2KCksdGhpcy53aWR0aENsYXNzPXQucmVhZFVJbnQxNigpLHRoaXMudHlwZT10LnJlYWRTaG9ydCgpLHRoaXMueVN1YnNjcmlwdFhTaXplPXQucmVhZFNob3J0KCksdGhpcy55U3Vic2NyaXB0WVNpemU9dC5yZWFkU2hvcnQoKSx0aGlzLnlTdWJzY3JpcHRYT2Zmc2V0PXQucmVhZFNob3J0KCksdGhpcy55U3Vic2NyaXB0WU9mZnNldD10LnJlYWRTaG9ydCgpLHRoaXMueVN1cGVyc2NyaXB0WFNpemU9dC5yZWFkU2hvcnQoKSx0aGlzLnlTdXBlcnNjcmlwdFlTaXplPXQucmVhZFNob3J0KCksdGhpcy55U3VwZXJzY3JpcHRYT2Zmc2V0PXQucmVhZFNob3J0KCksdGhpcy55U3VwZXJzY3JpcHRZT2Zmc2V0PXQucmVhZFNob3J0KCksdGhpcy55U3RyaWtlb3V0U2l6ZT10LnJlYWRTaG9ydCgpLHRoaXMueVN0cmlrZW91dFBvc2l0aW9uPXQucmVhZFNob3J0KCksdGhpcy5mYW1pbHlDbGFzcz10LnJlYWRTaG9ydCgpLHRoaXMucGFub3NlPWZ1bmN0aW9uKCl7dmFyIGUscjtmb3Iocj1bXSxlPTA7ZTwxMDsrK2Upci5wdXNoKHQucmVhZEJ5dGUoKSk7cmV0dXJuIHJ9KCksdGhpcy5jaGFyUmFuZ2U9ZnVuY3Rpb24oKXt2YXIgZSxyO2ZvcihyPVtdLGU9MDtlPDQ7KytlKXIucHVzaCh0LnJlYWRJbnQoKSk7cmV0dXJuIHJ9KCksdGhpcy52ZW5kb3JJRD10LnJlYWRTdHJpbmcoNCksdGhpcy5zZWxlY3Rpb249dC5yZWFkU2hvcnQoKSx0aGlzLmZpcnN0Q2hhckluZGV4PXQucmVhZFNob3J0KCksdGhpcy5sYXN0Q2hhckluZGV4PXQucmVhZFNob3J0KCksdGhpcy52ZXJzaW9uPjAmJih0aGlzLmFzY2VudD10LnJlYWRTaG9ydCgpLHRoaXMuZGVzY2VudD10LnJlYWRTaG9ydCgpLHRoaXMubGluZUdhcD10LnJlYWRTaG9ydCgpLHRoaXMud2luQXNjZW50PXQucmVhZFNob3J0KCksdGhpcy53aW5EZXNjZW50PXQucmVhZFNob3J0KCksdGhpcy5jb2RlUGFnZVJhbmdlPWZ1bmN0aW9uKCl7dmFyIGUscjtmb3Iocj1bXSxlPTA7ZTwyO2U9KytlKXIucHVzaCh0LnJlYWRJbnQoKSk7cmV0dXJuIHJ9KCksdGhpcy52ZXJzaW9uPjEpKXJldHVybiB0aGlzLnhIZWlnaHQ9dC5yZWFkU2hvcnQoKSx0aGlzLmNhcEhlaWdodD10LnJlYWRTaG9ydCgpLHRoaXMuZGVmYXVsdENoYXI9dC5yZWFkU2hvcnQoKSx0aGlzLmJyZWFrQ2hhcj10LnJlYWRTaG9ydCgpLHRoaXMubWF4Q29udGV4dD10LnJlYWRTaG9ydCgpfSxlfShSZSksWGU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEhlKGUsdCksZS5wcm90b3R5cGUudGFnPSJwb3N0IixlLnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbih0KXt2YXIgZSxyLG47c3dpdGNoKHQucG9zPXRoaXMub2Zmc2V0LHRoaXMuZm9ybWF0PXQucmVhZEludCgpLHRoaXMuaXRhbGljQW5nbGU9dC5yZWFkSW50KCksdGhpcy51bmRlcmxpbmVQb3NpdGlvbj10LnJlYWRTaG9ydCgpLHRoaXMudW5kZXJsaW5lVGhpY2tuZXNzPXQucmVhZFNob3J0KCksdGhpcy5pc0ZpeGVkUGl0Y2g9dC5yZWFkSW50KCksdGhpcy5taW5NZW1UeXBlNDI9dC5yZWFkSW50KCksdGhpcy5tYXhNZW1UeXBlNDI9dC5yZWFkSW50KCksdGhpcy5taW5NZW1UeXBlMT10LnJlYWRJbnQoKSx0aGlzLm1heE1lbVR5cGUxPXQucmVhZEludCgpLHRoaXMuZm9ybWF0KXtjYXNlIDY1NTM2OmJyZWFrO2Nhc2UgMTMxMDcyOnZhciBpO2ZvcihyPXQucmVhZFVJbnQxNigpLHRoaXMuZ2x5cGhOYW1lSW5kZXg9W10saT0wOzA8PXI/aTxyOmk+cjtpPTA8PXI/KytpOi0taSl0aGlzLmdseXBoTmFtZUluZGV4LnB1c2godC5yZWFkVUludDE2KCkpO2Zvcih0aGlzLm5hbWVzPVtdLG49W107dC5wb3M8dGhpcy5vZmZzZXQrdGhpcy5sZW5ndGg7KWU9dC5yZWFkQnl0ZSgpLG4ucHVzaCh0aGlzLm5hbWVzLnB1c2godC5yZWFkU3RyaW5nKGUpKSk7cmV0dXJuIG47Y2FzZSAxNTE1NTI6cmV0dXJuIHI9dC5yZWFkVUludDE2KCksdGhpcy5vZmZzZXRzPXQucmVhZChyKTtjYXNlIDE5NjYwODpicmVhaztjYXNlIDI2MjE0NDpyZXR1cm4gdGhpcy5tYXA9ZnVuY3Rpb24oKXt2YXIgZSxyLG47Zm9yKG49W10saT1lPTAscj10aGlzLmZpbGUubWF4cC5udW1HbHlwaHM7MDw9cj9lPHI6ZT5yO2k9MDw9cj8rK2U6LS1lKW4ucHVzaCh0LnJlYWRVSW50MzIoKSk7cmV0dXJuIG59LmNhbGwodGhpcyl9fSxlfShSZSksS2U9ZnVuY3Rpb24odCxlKXt0aGlzLnJhdz10LHRoaXMubGVuZ3RoPXQubGVuZ3RoLHRoaXMucGxhdGZvcm1JRD1lLnBsYXRmb3JtSUQsdGhpcy5lbmNvZGluZ0lEPWUuZW5jb2RpbmdJRCx0aGlzLmxhbmd1YWdlSUQ9ZS5sYW5ndWFnZUlEfSxaZT1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSGUoZSx0KSxlLnByb3RvdHlwZS50YWc9Im5hbWUiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpLGEsbyxzLGMsdSxsLGg7Zm9yKHQucG9zPXRoaXMub2Zmc2V0LHQucmVhZFNob3J0KCksZT10LnJlYWRTaG9ydCgpLG89dC5yZWFkU2hvcnQoKSxyPVtdLGk9MDswPD1lP2k8ZTppPmU7aT0wPD1lPysraTotLWkpci5wdXNoKHtwbGF0Zm9ybUlEOnQucmVhZFNob3J0KCksZW5jb2RpbmdJRDp0LnJlYWRTaG9ydCgpLGxhbmd1YWdlSUQ6dC5yZWFkU2hvcnQoKSxuYW1lSUQ6dC5yZWFkU2hvcnQoKSxsZW5ndGg6dC5yZWFkU2hvcnQoKSxvZmZzZXQ6dGhpcy5vZmZzZXQrbyt0LnJlYWRTaG9ydCgpfSk7Zm9yKHM9e30saT11PTAsbD1yLmxlbmd0aDt1PGw7aT0rK3Upbj1yW2ldLHQucG9zPW4ub2Zmc2V0LGM9dC5yZWFkU3RyaW5nKG4ubGVuZ3RoKSxhPW5ldyBLZShjLG4pLG51bGw9PXNbaD1uLm5hbWVJRF0mJihzW2hdPVtdKSxzW24ubmFtZUlEXS5wdXNoKGEpO3RoaXMuc3RyaW5ncz1zLHRoaXMuY29weXJpZ2h0PXNbMF0sdGhpcy5mb250RmFtaWx5PXNbMV0sdGhpcy5mb250U3ViZmFtaWx5PXNbMl0sdGhpcy51bmlxdWVTdWJmYW1pbHk9c1szXSx0aGlzLmZvbnROYW1lPXNbNF0sdGhpcy52ZXJzaW9uPXNbNV07dHJ5e3RoaXMucG9zdHNjcmlwdE5hbWU9c1s2XVswXS5yYXcucmVwbGFjZSgvW1x4MDAtXHgxOVx4ODAtXHhmZl0vZywiIil9Y2F0Y2godCl7dGhpcy5wb3N0c2NyaXB0TmFtZT1zWzRdWzBdLnJhdy5yZXBsYWNlKC9bXHgwMC1ceDE5XHg4MC1ceGZmXS9nLCIiKX1yZXR1cm4gdGhpcy50cmFkZW1hcms9c1s3XSx0aGlzLm1hbnVmYWN0dXJlcj1zWzhdLHRoaXMuZGVzaWduZXI9c1s5XSx0aGlzLmRlc2NyaXB0aW9uPXNbMTBdLHRoaXMudmVuZG9yVXJsPXNbMTFdLHRoaXMuZGVzaWduZXJVcmw9c1sxMl0sdGhpcy5saWNlbnNlPXNbMTNdLHRoaXMubGljZW5zZVVybD1zWzE0XSx0aGlzLnByZWZlcnJlZEZhbWlseT1zWzE1XSx0aGlzLnByZWZlcnJlZFN1YmZhbWlseT1zWzE3XSx0aGlzLmNvbXBhdGlibGVGdWxsPXNbMThdLHRoaXMuc2FtcGxlVGV4dD1zWzE5XX0sZX0oUmUpLCRlPWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gZS5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpfXJldHVybiBIZShlLHQpLGUucHJvdG90eXBlLnRhZz0ibWF4cCIsZS5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQucG9zPXRoaXMub2Zmc2V0LHRoaXMudmVyc2lvbj10LnJlYWRJbnQoKSx0aGlzLm51bUdseXBocz10LnJlYWRVSW50MTYoKSx0aGlzLm1heFBvaW50cz10LnJlYWRVSW50MTYoKSx0aGlzLm1heENvbnRvdXJzPXQucmVhZFVJbnQxNigpLHRoaXMubWF4Q29tcG9zaXRlUG9pbnRzPXQucmVhZFVJbnQxNigpLHRoaXMubWF4Q29tcG9uZW50Q29udG91cnM9dC5yZWFkVUludDE2KCksdGhpcy5tYXhab25lcz10LnJlYWRVSW50MTYoKSx0aGlzLm1heFR3aWxpZ2h0UG9pbnRzPXQucmVhZFVJbnQxNigpLHRoaXMubWF4U3RvcmFnZT10LnJlYWRVSW50MTYoKSx0aGlzLm1heEZ1bmN0aW9uRGVmcz10LnJlYWRVSW50MTYoKSx0aGlzLm1heEluc3RydWN0aW9uRGVmcz10LnJlYWRVSW50MTYoKSx0aGlzLm1heFN0YWNrRWxlbWVudHM9dC5yZWFkVUludDE2KCksdGhpcy5tYXhTaXplT2ZJbnN0cnVjdGlvbnM9dC5yZWFkVUludDE2KCksdGhpcy5tYXhDb21wb25lbnRFbGVtZW50cz10LnJlYWRVSW50MTYoKSx0aGlzLm1heENvbXBvbmVudERlcHRoPXQucmVhZFVJbnQxNigpfSxlfShSZSksUWU9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSgpe3JldHVybiBlLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIEhlKGUsdCksZS5wcm90b3R5cGUudGFnPSJobXR4IixlLnByb3RvdHlwZS5wYXJzZT1mdW5jdGlvbih0KXt2YXIgZSxyLG4saSxhLG8scztmb3IodC5wb3M9dGhpcy5vZmZzZXQsdGhpcy5tZXRyaWNzPVtdLGU9MCxvPXRoaXMuZmlsZS5oaGVhLm51bWJlck9mTWV0cmljczswPD1vP2U8bzplPm87ZT0wPD1vPysrZTotLWUpdGhpcy5tZXRyaWNzLnB1c2goe2FkdmFuY2U6dC5yZWFkVUludDE2KCksbHNiOnQucmVhZEludDE2KCl9KTtmb3Iobj10aGlzLmZpbGUubWF4cC5udW1HbHlwaHMtdGhpcy5maWxlLmhoZWEubnVtYmVyT2ZNZXRyaWNzLHRoaXMubGVmdFNpZGVCZWFyaW5ncz1mdW5jdGlvbigpe3ZhciByLGk7Zm9yKGk9W10sZT1yPTA7MDw9bj9yPG46cj5uO2U9MDw9bj8rK3I6LS1yKWkucHVzaCh0LnJlYWRJbnQxNigpKTtyZXR1cm4gaX0oKSx0aGlzLndpZHRocz1mdW5jdGlvbigpe3ZhciB0LGUscixuO2ZvcihuPVtdLHQ9MCxlPShyPXRoaXMubWV0cmljcykubGVuZ3RoO3Q8ZTt0KyspaT1yW3RdLG4ucHVzaChpLmFkdmFuY2UpO3JldHVybiBufS5jYWxsKHRoaXMpLHI9dGhpcy53aWR0aHNbdGhpcy53aWR0aHMubGVuZ3RoLTFdLHM9W10sZT1hPTA7MDw9bj9hPG46YT5uO2U9MDw9bj8rK2E6LS1hKXMucHVzaCh0aGlzLndpZHRocy5wdXNoKHIpKTtyZXR1cm4gc30sZS5wcm90b3R5cGUuZm9yR2x5cGg9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW4gdGhpcy5tZXRyaWNzP3RoaXMubWV0cmljc1t0XTp7YWR2YW5jZTp0aGlzLm1ldHJpY3NbdGhpcy5tZXRyaWNzLmxlbmd0aC0xXS5hZHZhbmNlLGxzYjp0aGlzLmxlZnRTaWRlQmVhcmluZ3NbdC10aGlzLm1ldHJpY3MubGVuZ3RoXX19LGV9KFJlKSx0cj1bXS5zbGljZSxlcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSGUoZSx0KSxlLnByb3RvdHlwZS50YWc9ImdseWYiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FjaGU9e319LGUucHJvdG90eXBlLmdseXBoRm9yPWZ1bmN0aW9uKHQpe3ZhciBlLHIsbixpLGEsbyxzLGMsdSxsO3JldHVybiB0IGluIHRoaXMuY2FjaGU/dGhpcy5jYWNoZVt0XTooaT10aGlzLmZpbGUubG9jYSxlPXRoaXMuZmlsZS5jb250ZW50cyxyPWkuaW5kZXhPZih0KSwwPT09KG49aS5sZW5ndGhPZih0KSk/dGhpcy5jYWNoZVt0XT1udWxsOihlLnBvcz10aGlzLm9mZnNldCtyLGE9KG89bmV3IFRlKGUucmVhZChuKSkpLnJlYWRTaG9ydCgpLGM9by5yZWFkU2hvcnQoKSxsPW8ucmVhZFNob3J0KCkscz1vLnJlYWRTaG9ydCgpLHU9by5yZWFkU2hvcnQoKSx0aGlzLmNhY2hlW3RdPS0xPT09YT9uZXcgbnIobyxjLGwscyx1KTpuZXcgcnIobyxhLGMsbCxzLHUpLHRoaXMuY2FjaGVbdF0pKX0sZS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpLGEsbyxzO2ZvcihhPVtdLGk9W10sbz0wLHM9ZS5sZW5ndGg7bzxzO28rKyluPXRbZVtvXV0saS5wdXNoKGEubGVuZ3RoKSxuJiYoYT1hLmNvbmNhdChuLmVuY29kZShyKSkpO3JldHVybiBpLnB1c2goYS5sZW5ndGgpLHt0YWJsZTphLG9mZnNldHM6aX19LGV9KFJlKSxycj1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxlLHIsbixpLGEpe3RoaXMucmF3PXQsdGhpcy5udW1iZXJPZkNvbnRvdXJzPWUsdGhpcy54TWluPXIsdGhpcy55TWluPW4sdGhpcy54TWF4PWksdGhpcy55TWF4PWEsdGhpcy5jb21wb3VuZD0hMX1yZXR1cm4gdC5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmF3LmRhdGF9LHR9KCksbnI9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQsZSxyLG4saSl7dmFyIGEsbztmb3IodGhpcy5yYXc9dCx0aGlzLnhNaW49ZSx0aGlzLnlNaW49cix0aGlzLnhNYXg9bix0aGlzLnlNYXg9aSx0aGlzLmNvbXBvdW5kPSEwLHRoaXMuZ2x5cGhJRHM9W10sdGhpcy5nbHlwaE9mZnNldHM9W10sYT10aGlzLnJhdztvPWEucmVhZFNob3J0KCksdGhpcy5nbHlwaE9mZnNldHMucHVzaChhLnBvcyksdGhpcy5nbHlwaElEcy5wdXNoKGEucmVhZFVJbnQxNigpKSwzMiZvOylhLnBvcys9MSZvPzQ6MiwxMjgmbz9hLnBvcys9ODo2NCZvP2EucG9zKz00OjgmbyYmKGEucG9zKz0yKX1yZXR1cm4gMSw4LDMyLDY0LDEyOCx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oKXt2YXIgdCxlLHI7Zm9yKGU9bmV3IFRlKHRyLmNhbGwodGhpcy5yYXcuZGF0YSkpLHQ9MCxyPXRoaXMuZ2x5cGhJRHMubGVuZ3RoO3Q8cjsrK3QpZS5wb3M9dGhpcy5nbHlwaE9mZnNldHNbdF07cmV0dXJuIGUuZGF0YX0sdH0oKSxpcj1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKCl7cmV0dXJuIGUuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gSGUoZSx0KSxlLnByb3RvdHlwZS50YWc9ImxvY2EiLGUucHJvdG90eXBlLnBhcnNlPWZ1bmN0aW9uKHQpe3ZhciBlLHI7cmV0dXJuIHQucG9zPXRoaXMub2Zmc2V0LGU9dGhpcy5maWxlLmhlYWQuaW5kZXhUb0xvY0Zvcm1hdCx0aGlzLm9mZnNldHM9MD09PWU/ZnVuY3Rpb24oKXt2YXIgZSxuO2ZvcihuPVtdLHI9MCxlPXRoaXMubGVuZ3RoO3I8ZTtyKz0yKW4ucHVzaCgyKnQucmVhZFVJbnQxNigpKTtyZXR1cm4gbn0uY2FsbCh0aGlzKTpmdW5jdGlvbigpe3ZhciBlLG47Zm9yKG49W10scj0wLGU9dGhpcy5sZW5ndGg7cjxlO3IrPTQpbi5wdXNoKHQucmVhZFVJbnQzMigpKTtyZXR1cm4gbn0uY2FsbCh0aGlzKX0sZS5wcm90b3R5cGUuaW5kZXhPZj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vZmZzZXRzW3RdfSxlLnByb3RvdHlwZS5sZW5ndGhPZj1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vZmZzZXRzW3QrMV0tdGhpcy5vZmZzZXRzW3RdfSxlLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9bmV3IFVpbnQzMkFycmF5KHRoaXMub2Zmc2V0cy5sZW5ndGgpLG49MCxpPTAsYT0wO2E8ci5sZW5ndGg7KythKWlmKHJbYV09bixpPGUubGVuZ3RoJiZlW2ldPT1hKXsrK2ksclthXT1uO3ZhciBvPXRoaXMub2Zmc2V0c1thXSxzPXRoaXMub2Zmc2V0c1thKzFdLW87cz4wJiYobis9cyl9Zm9yKHZhciBjPW5ldyBBcnJheSg0KnIubGVuZ3RoKSx1PTA7dTxyLmxlbmd0aDsrK3UpY1s0KnUrM109MjU1JnJbdV0sY1s0KnUrMl09KDY1MjgwJnJbdV0pPj44LGNbNCp1KzFdPSgxNjcxMTY4MCZyW3VdKT4+MTYsY1s0KnVdPSg0Mjc4MTkwMDgwJnJbdV0pPj4yNDtyZXR1cm4gY30sZX0oUmUpLGFyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0KXt0aGlzLmZvbnQ9dCx0aGlzLnN1YnNldD17fSx0aGlzLnVuaWNvZGVzPXt9LHRoaXMubmV4dD0zM31yZXR1cm4gdC5wcm90b3R5cGUuZ2VuZXJhdGVDbWFwPWZ1bmN0aW9uKCl7dmFyIHQsZSxyLG4saTtmb3IoZSBpbiBuPXRoaXMuZm9udC5jbWFwLnRhYmxlc1swXS5jb2RlTWFwLHQ9e30saT10aGlzLnN1YnNldClyPWlbZV0sdFtlXT1uW3JdO3JldHVybiB0fSx0LnByb3RvdHlwZS5nbHlwaHNGb3I9ZnVuY3Rpb24odCl7dmFyIGUscixuLGksYSxvLHM7Zm9yKG49e30sYT0wLG89dC5sZW5ndGg7YTxvO2ErKyluW2k9dFthXV09dGhpcy5mb250LmdseWYuZ2x5cGhGb3IoaSk7Zm9yKGkgaW4gZT1bXSxuKShudWxsIT0ocj1uW2ldKT9yLmNvbXBvdW5kOnZvaWQgMCkmJmUucHVzaC5hcHBseShlLHIuZ2x5cGhJRHMpO2lmKGUubGVuZ3RoPjApZm9yKGkgaW4gcz10aGlzLmdseXBoc0ZvcihlKSlyPXNbaV0sbltpXT1yO3JldHVybiBufSx0LnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24odCxlKXt2YXIgcixuLGksYSxvLHMsYyx1LGwsaCxmLGQscCxnLG07Zm9yKG4gaW4gcj1HZS5lbmNvZGUodGhpcy5nZW5lcmF0ZUNtYXAoKSwidW5pY29kZSIpLGE9dGhpcy5nbHlwaHNGb3IodCksZj17MDowfSxtPXIuY2hhck1hcClmWyhzPW1bbl0pLm9sZF09cy5uZXc7Zm9yKGQgaW4gaD1yLm1heEdseXBoSUQsYSlkIGluIGZ8fChmW2RdPWgrKyk7cmV0dXJuIHU9ZnVuY3Rpb24odCl7dmFyIGUscjtmb3IoZSBpbiByPXt9LHQpclt0W2VdXT1lO3JldHVybiByfShmKSxsPU9iamVjdC5rZXlzKHUpLnNvcnQoKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQtZX0pKSxwPWZ1bmN0aW9uKCl7dmFyIHQsZSxyO2ZvcihyPVtdLHQ9MCxlPWwubGVuZ3RoO3Q8ZTt0Kyspbz1sW3RdLHIucHVzaCh1W29dKTtyZXR1cm4gcn0oKSxpPXRoaXMuZm9udC5nbHlmLmVuY29kZShhLHAsZiksYz10aGlzLmZvbnQubG9jYS5lbmNvZGUoaS5vZmZzZXRzLHApLGc9e2NtYXA6dGhpcy5mb250LmNtYXAucmF3KCksZ2x5ZjppLnRhYmxlLGxvY2E6YyxobXR4OnRoaXMuZm9udC5obXR4LnJhdygpLGhoZWE6dGhpcy5mb250LmhoZWEucmF3KCksbWF4cDp0aGlzLmZvbnQubWF4cC5yYXcoKSxwb3N0OnRoaXMuZm9udC5wb3N0LnJhdygpLG5hbWU6dGhpcy5mb250Lm5hbWUucmF3KCksaGVhZDp0aGlzLmZvbnQuaGVhZC5lbmNvZGUoZSl9LHRoaXMuZm9udC5vczIuZXhpc3RzJiYoZ1siT1MvMiJdPXRoaXMuZm9udC5vczIucmF3KCkpLHRoaXMuZm9udC5kaXJlY3RvcnkuZW5jb2RlKGcpfSx0fSgpO00uQVBJLlBERk9iamVjdD1mdW5jdGlvbigpe3ZhciB0O2Z1bmN0aW9uIGUoKXt9cmV0dXJuIHQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4oQXJyYXkoZSsxKS5qb2luKCIwIikrdCkuc2xpY2UoLWUpfSxlLmNvbnZlcnQ9ZnVuY3Rpb24ocil7dmFyIG4saSxhLG87aWYoQXJyYXkuaXNBcnJheShyKSlyZXR1cm4iWyIrZnVuY3Rpb24oKXt2YXIgdCxpLGE7Zm9yKGE9W10sdD0wLGk9ci5sZW5ndGg7dDxpO3QrKyluPXJbdF0sYS5wdXNoKGUuY29udmVydChuKSk7cmV0dXJuIGF9KCkuam9pbigiICIpKyJdIjtpZigic3RyaW5nIj09dHlwZW9mIHIpcmV0dXJuIi8iK3I7aWYobnVsbCE9cj9yLmlzU3RyaW5nOnZvaWQgMClyZXR1cm4iKCIrcisiKSI7aWYociBpbnN0YW5jZW9mIERhdGUpcmV0dXJuIihEOiIrdChyLmdldFVUQ0Z1bGxZZWFyKCksNCkrdChyLmdldFVUQ01vbnRoKCksMikrdChyLmdldFVUQ0RhdGUoKSwyKSt0KHIuZ2V0VVRDSG91cnMoKSwyKSt0KHIuZ2V0VVRDTWludXRlcygpLDIpK3Qoci5nZXRVVENTZWNvbmRzKCksMikrIlopIjtpZigiW29iamVjdCBPYmplY3RdIj09PXt9LnRvU3RyaW5nLmNhbGwocikpe2ZvcihpIGluIGE9WyI8PCJdLHIpbz1yW2ldLGEucHVzaCgiLyIraSsiICIrZS5jb252ZXJ0KG8pKTtyZXR1cm4gYS5wdXNoKCI+PiIpLGEuam9pbigiXG4iKX1yZXR1cm4iIityfSxlfSgpLHQuQWNyb0Zvcm09eHQsdC5BY3JvRm9ybUFwcGVhcmFuY2U9THQsdC5BY3JvRm9ybUJ1dHRvbj1ndCx0LkFjcm9Gb3JtQ2hlY2tCb3g9eXQsdC5BY3JvRm9ybUNob2ljZUZpZWxkPWh0LHQuQWNyb0Zvcm1Db21ib0JveD1kdCx0LkFjcm9Gb3JtRWRpdEJveD1wdCx0LkFjcm9Gb3JtTGlzdEJveD1mdCx0LkFjcm9Gb3JtUGFzc3dvcmRGaWVsZD1OdCx0LkFjcm9Gb3JtUHVzaEJ1dHRvbj1tdCx0LkFjcm9Gb3JtUmFkaW9CdXR0b249dnQsdC5BY3JvRm9ybVRleHRGaWVsZD13dCx0LkdTdGF0ZT1DLHQuU2hhZGluZ1BhdHRlcm49Tyx0LlRpbGluZ1BhdHRlcm49Qix0LmRlZmF1bHQ9TSx0LmpzUERGPU0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIl9fZXNNb2R1bGUiLHt2YWx1ZTohMH0pfSkpOwovLyMgc291cmNlTWFwcGluZ1VSTD1qc3BkZi51bWQubWluLmpzLm1hcAo=";

      function loadJsPDF() {
        return new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = "data:text/javascript;base64," + jspdfBase64;
          script.onload = () => {
            console.log("jsPDF loaded");
            resolve(window.jspdf);
          };
          script.onerror = reject;
          document.head.appendChild(script);
        });
      }
    </script>

    <style>
      :root {
        --primary: #ff5722; /* Orange */
        --bg: #0a0a0a;
        --surface: #1a1a1a;
        --text: #ffffff;
        --text-secondary: #a0a0a0;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue",
          sans-serif;
        background-color: var(--bg);
        color: var(--text);
        overflow-x: hidden;
      }

      /* Three.js Background */
      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        opacity: 0.6;
      }

      /* Layout */
      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4rem;
        backdrop-filter: blur(10px);
        padding: 1rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      h1,
      h2,
      h3 {
        font-weight: 700;
      }

      .logo {
        font-size: 1.5rem;
        color: var(--primary);
        text-transform: uppercase;
        letter-spacing: 2px;
      }

      /* Buttons */
      .btn {
        background: transparent;
        border: 1px solid var(--primary);
        color: var(--primary);
        padding: 0.8rem 1.5rem;
        cursor: pointer;
        font-family: inherit;
        font-weight: 600;
        text-transform: uppercase;
        transition: all 0.3s ease;
        clip-path: polygon(
          10px 0,
          100% 0,
          100% calc(100% - 10px),
          calc(100% - 10px) 100%,
          0 100%,
          0 10px
        );
      }

      .btn:hover {
        background: var(--primary);
        color: white;
        box-shadow: 0 0 20px rgba(255, 87, 34, 0.4);
      }

      .btn-small {
        padding: 0.5rem 1rem;
        font-size: 0.8rem;
      }

      /* Inputs */
      input,
      textarea {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: white;
        padding: 1rem;
        width: 100%;
        margin-bottom: 1rem;
        font-family: inherit;
        border-radius: 4px;
      }

      input:focus,
      textarea:focus {
        outline: none;
        border-color: var(--primary);
      }

      /* Sections */
      .section {
        background: rgba(26, 26, 26, 0.8);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.05);
        padding: 2rem;
        margin-bottom: 2rem;
        border-radius: 16px;
        display: none; /* Hidden by default */
      }

      .section.active {
        display: block;
        animation: fadeIn 0.5s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Newspaper Card */
      .newspaper-card {
        border-left: 4px solid var(--primary);
        padding-left: 2rem;
        margin-bottom: 2rem;
      }

      .newspaper-meta {
        color: var(--text-secondary);
        font-size: 0.9rem;
        margin-bottom: 1rem;
      }

      .newspaper-content {
        line-height: 1.6;
        margin-bottom: 2rem;
        white-space: pre-wrap;
      }

      /* Governance Grid */
      .proposals-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        gap: 1.5rem;
        margin-top: 1.5rem;
      }

      .proposal-card {
        background: rgba(0, 0, 0, 0.3);
        padding: 1.5rem;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.05);
      }

      .proposal-stats {
        display: flex;
        justify-content: space-between;
        margin: 1rem 0;
        font-size: 0.9rem;
      }

      .vote-actions {
        display: flex;
        gap: 0.5rem;
      }

      .status-badge {
        display: inline-block;
        padding: 0.25rem 0.5rem;
        border-radius: 4px;
        font-size: 0.7rem;
        text-transform: uppercase;
        background: rgba(255, 255, 255, 0.1);
      }

      .status-active {
        color: #4caf50;
        border: 1px solid #4caf50;
      }
      .status-ended {
        color: #f44336;
        border: 1px solid #f44336;
      }

      /* Mobile Optimization */
      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        header {
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 2rem;
          text-align: center;
        }

        h1 {
          font-size: 2.5rem !important;
        }

        .section {
          padding: 1.5rem;
        }

        /* Fix headers in sections */
        .section-header {
          flex-direction: column;
          align-items: flex-start !important;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .section-header h2 {
          margin-bottom: 0;
        }

        .section-header .btn {
          width: 100%;
          margin-top: 0;
        }

        .newspaper-card {
          padding-left: 1rem;
          border-left-width: 2px;
        }

        #issueTitle {
          font-size: 1.8rem !important;
        }

        .proposals-grid {
          grid-template-columns: 1fr;
        }

        .btn {
          width: 100%;
          display: block;
          margin-bottom: 0.5rem;
        }

        /* Adjust inputs for mobile */
        input,
        textarea {
          width: 100%;
        }

        /* Gift section mobile fix */
        #giftSection {
          flex-direction: column;
        }
      }

      /* Notification */
      #notification {
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 1rem 2rem;
        background: var(--surface);
        border-left: 4px solid var(--primary);
        color: white;
        border-radius: 4px;
        transform: translateX(150%);
        transition: transform 0.3s ease;
        z-index: 100;
      }

      #notification.show {
        transform: translateX(0);
      }
    </style>
  </head>
  <body>
    <!-- Three.js Background -->
    <div id="canvas-container"></div>

    <!-- Notification -->
    <div id="notification">Action Completed</div>

    <div class="container">
      <header>
        <div style="display: flex; align-items: center; gap: 1rem">
          <div class="logo">Vox Populi</div>
          <select
            id="networkSelect"
            class="btn btn-small"
            style="
              background: transparent;
              border: 1px solid var(--primary);
              color: var(--primary);
            "
          >
            <option value="0x1">Mainnet</option>
            <option value="0xaa36a7">Sepolia</option>
          </select>
        </div>
        <button id="connectBtn" class="btn">Connetti Wallet</button>
      </header>

      <!-- Welcome / Hero Section -->
      <div
        id="heroSection"
        class="section active"
        style="text-align: center; padding: 4rem 2rem"
      >
        <h1 style="font-size: 3.5rem; margin-bottom: 1rem">
          Il Giornale Decentralizzato
        </h1>
        <p
          style="
            color: var(--text-secondary);
            margin-bottom: 2rem;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
          "
        >
          Partecipa alla democrazia studentesca. Minta il tuo Soulbound Token,
          leggi le notizie verificate e vota per la verit.
        </p>
        <div style="display: flex; gap: 1rem; justify-content: center">
          <button id="mintBtn" class="btn">Abbonati (Mint)</button>
        </div>
      </div>

      <!-- Dashboard (Visible after login) -->
      <div id="dashboardSection" style="display: none">
        <!-- Current Issue Viewer -->
        <div class="section active">
          <div
            class="section-header"
            style="
              display: flex;
              justify-content: space-between;
              align-items: flex-start;
            "
          >
            <h2>Edizione Corrente</h2>
            <button id="downloadPdfBtn" class="btn btn-small">
              Scarica PDF
            </button>
          </div>
          <div class="newspaper-card" style="margin-top: 2rem">
            <div class="newspaper-meta">
              Pubblicato il: <span id="issueDate">...</span>
            </div>
            <h1 id="issueTitle" style="margin-bottom: 1rem; font-size: 2.5rem">
              Caricamento...
            </h1>
            <div id="issueContent" class="newspaper-content">
              Connetti il wallet per leggere le ultime notizie.
            </div>
          </div>
        </div>

        <!-- Governance / Voting -->
        <div class="section active">
          <div
            class="section-header"
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
            "
          >
            <h2>Governance</h2>
            <button id="refreshProposals" class="btn btn-small">
              Aggiorna
            </button>
          </div>
          <p style="color: var(--text-secondary)">
            Vota per le prossime modifiche al giornale.
          </p>

          <div
            style="
              margin-top: 1.5rem;
              padding: 1.5rem;
              background: rgba(255, 255, 255, 0.02);
              border-radius: 8px;
            "
          >
            <h3 style="margin-bottom: 1rem">Nuova Proposta</h3>
            <input type="text" id="propTitle" placeholder="Nuovo Titolo" />
            <textarea
              id="propContent"
              rows="3"
              placeholder="Nuovo Contenuto"
            ></textarea>
            <button id="proposeBtn" class="btn btn-small">
              Invia Proposta
            </button>
          </div>

          <div id="proposalsList" class="proposals-grid">
            <!-- Proposals will be injected here -->
          </div>

          <!-- Admin / Gift Section (Visible only to owner inside dashboard) -->
          <div
            id="giftContainer"
            style="
              margin-top: 3rem;
              padding-top: 2rem;
              border-top: 1px solid rgba(255, 255, 255, 0.1);
              display: none;
            "
          >
            <h3>Amministrazione</h3>
            <p style="font-size: 0.8rem; color: #888; margin-bottom: 1rem">
              Regala un abbonamento (Airdrop)
            </p>
            <div
              id="giftSection"
              style="display: flex; gap: 0.5rem; max-width: 500px"
            >
              <input
                type="text"
                id="giftAddress"
                placeholder="Indirizzo destinatario (0x...)"
                style="margin-bottom: 0"
              />
              <button id="giftBtn" class="btn btn-small">Regala</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ==========================================
      // CONFIGURATION
      // ==========================================
      const CONTRACT_ADDRESSES = {
        "0x1": "0x6462A6c527373a2EE3F1415503ae4BAB5acd5618", // Mainnet (Legacy/Placeholder)
        "0xaa36a7": "0xEd9EfF0E06DB8233EDCBEedb3bCee804A70A4BB7", // Sepolia
      };

      const ABI = [
        "function subscribe() public",
        "function airdrop(address to) public",
        "function balanceOf(address owner) view returns (uint256)",
        "function owner() view returns (address)",
        "function currentIssue() view returns (string headline, string content, uint256 timestamp)",
        "function proposals(uint256) view returns (string newHeadline, string newContent, uint256 votesPro, uint256 votesContra, uint256 endTime, bool executed, uint256 cycle)",
        "function vote(uint256 proposalId, bool support) public",
        "function executeProposal(uint256 proposalId) public",
        "function proposeUpdate(string _headline, string _content) public",
        "function reuseProposal(uint256 proposalId, string _headline, string _content) public",
      ];

      let provider, signer, contract;
      let userAddress;
      let currentChainId = "0x1"; // Default to Mainnet

      // ==========================================
      // THREE.JS BACKGROUND
      // ==========================================
      function initThree() {
        const container = document.getElementById("canvas-container");
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer({
          alpha: true,
          antialias: true,
        });

        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Particles
        const geometry = new THREE.BufferGeometry();
        const count = 2000;
        const positions = new Float32Array(count * 3);

        for (let i = 0; i < count * 3; i++) {
          positions[i] = (Math.random() - 0.5) * 20;
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );

        const material = new THREE.PointsMaterial({
          color: 0xff5722,
          size: 0.05,
          transparent: true,
          opacity: 0.8,
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // Connecting Lines (Mesh)
        const wireGeo = new THREE.IcosahedronGeometry(10, 1);
        const wireMat = new THREE.MeshBasicMaterial({
          color: 0xff5722,
          wireframe: true,
          transparent: true,
          opacity: 0.1,
        });
        const wireMesh = new THREE.Mesh(wireGeo, wireMat);
        scene.add(wireMesh);

        camera.position.z = 5;

        function animate() {
          requestAnimationFrame(animate);

          particles.rotation.y += 0.001;
          particles.rotation.x += 0.0005;

          wireMesh.rotation.x -= 0.001;
          wireMesh.rotation.y -= 0.001;

          renderer.render(scene, camera);
        }
        animate();

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      // ==========================================
      // UI HELPERS
      // ==========================================
      function showNotification(msg, type = "info") {
        const notif = document.getElementById("notification");
        notif.innerText = msg;
        notif.style.borderLeftColor = type === "error" ? "#f44336" : "#ff5722";
        notif.classList.add("show");
        setTimeout(() => notif.classList.remove("show"), 3000);
      }

      // ==========================================
      // BLOCKCHAIN LOGIC
      // ==========================================
      const NETWORKS = {
        "0x1": "Ethereum Mainnet",
        "0xaa36a7": "Sepolia Testnet",
      };

      // Initialize Network Selector
      const networkSelect = document.getElementById("networkSelect");

      // Listen for Network Selector Changes
      networkSelect.addEventListener("change", async (e) => {
        const targetChainId = e.target.value;
        // Don't reload immediately, handle gracefully
        try {
          await switchNetwork(targetChainId);
          // After successful switch, re-check connection
          if (userAddress) {
            await connectWallet();
          }
        } catch (err) {
          console.error(err);
        }
      });

      async function switchNetwork(chainId) {
        if (!window.ethereum) return;
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: chainId }],
          });
          // Wait a bit for the network to actually change in provider
          await new Promise((r) => setTimeout(r, 1000));
        } catch (switchError) {
          // This error code indicates that the chain has not been added to MetaMask.
          if (switchError.code === 4902) {
            showNotification(
              "Rete non trovata in MetaMask. Aggiungila manualmente.",
              "error"
            );
          } else {
            console.error(switchError);
            showNotification(
              "Errore cambio rete: " + switchError.message,
              "error"
            );
          }
        }
      }

      async function connectWallet() {
        if (userAddress) {
          // Disconnect logic
          userAddress = null;
          signer = null;
          contract = null;
          document.getElementById("connectBtn").innerText = "Connetti Wallet";
          document.getElementById("connectBtn").style.borderColor =
            "var(--primary)";
          document.getElementById("heroSection").style.display = "block";
          document.getElementById("dashboardSection").style.display = "none";
          showNotification("Disconnesso");
          return;
        }

        if (!window.ethereum) {
          alert("Per favore installa MetaMask!");
          return;
        }

        try {
          // Force MetaMask to show account picker
          await window.ethereum.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }],
          });

          provider = new ethers.BrowserProvider(window.ethereum);

          // Check Network Mismatch
          const network = await provider.getNetwork();
          const currentChainId = "0x" + network.chainId.toString(16);
          const selectedChainId = networkSelect.value;

          if (currentChainId !== selectedChainId) {
            // Try to switch automatically
            try {
              await switchNetwork(selectedChainId);
              // Re-init provider after switch (though listener handles reload usually)
              provider = new ethers.BrowserProvider(window.ethereum);
            } catch (e) {
              showNotification(
                `Network Mismatch! Selezionato: ${
                  NETWORKS[selectedChainId]
                }, Wallet: ${NETWORKS[currentChainId] || currentChainId}`,
                "error"
              );
              throw new Error("Network Mismatch. Please switch network.");
            }
          }

          signer = await provider.getSigner();
          userAddress = await signer.getAddress();

          document.getElementById("connectBtn").innerText =
            "Disconnetti (" +
            userAddress.substring(0, 4) +
            "..." +
            userAddress.substring(38) +
            ")";
          document.getElementById("connectBtn").style.borderColor = "#f44336"; // Red for disconnect

          // Init Contract
          const contractAddress = CONTRACT_ADDRESSES[currentChainId];
          if (!contractAddress) {
            showNotification(
              "Contratto non disponibile su questa rete.",
              "error"
            );
            throw new Error(
              "Contract address not found for chainId: " + currentChainId
            );
          }
          contract = new ethers.Contract(contractAddress, ABI, signer);

          // Check Balance and Ownership
          checkSubscription();
          checkOwner();
        } catch (err) {
          console.error(err);
          showNotification("Errore connessione: " + err.message, "error");
        }
      }

      async function checkOwner() {
        try {
          const owner = await contract.owner();
          if (owner.toLowerCase() === userAddress.toLowerCase()) {
            document.getElementById("giftContainer").style.display = "block";
          } else {
            document.getElementById("giftContainer").style.display = "none";
          }
        } catch (err) {
          console.error("Error checking owner", err);
        }
      }

      async function checkSubscription() {
        try {
          const balance = await contract.balanceOf(userAddress);
          if (balance > 0n) {
            document.getElementById("heroSection").style.display = "none";
            document.getElementById("dashboardSection").style.display = "block";
            loadDashboardData();
          } else {
            document.getElementById("heroSection").style.display = "block";
            document.getElementById("dashboardSection").style.display = "none";
          }
        } catch (err) {
          console.error(err);
          // If contract address is invalid, it might fail here.
          // For demo purposes, we show dashboard if it fails (assuming dev mode) or handle error
          if (CONTRACT_ADDRESS === "0xYourContractAddressHere") {
            showNotification(
              "Inserisci l'indirizzo del contratto nel codice!",
              "error"
            );
          }
        }
      }

      async function mint() {
        if (!contract) return connectWallet();
        try {
          const tx = await contract.subscribe();
          showNotification("Transazione inviata...");
          await tx.wait();
          showNotification("Abbonamento attivato!");
          checkSubscription();
        } catch (err) {
          console.error(err);
          showNotification("Errore Mint: " + err.message, "error");
        }
      }

      async function gift() {
        if (!contract) return connectWallet();
        const to = document.getElementById("giftAddress").value;
        if (!ethers.isAddress(to))
          return showNotification("Indirizzo non valido", "error");

        try {
          const tx = await contract.airdrop(to);
          showNotification("Regalo inviato...");
          await tx.wait();
          showNotification("Airdrop completato!");
        } catch (err) {
          console.error(err);
          showNotification(
            "Errore (Solo Owner pu regalare): " + err.message,
            "error"
          );
        }
      }

      async function loadDashboardData() {
        loadCurrentIssue();
        loadProposals();
      }

      async function loadCurrentIssue() {
        try {
          const issue = await contract.currentIssue();
          // issue is [headline, content, timestamp]
          document.getElementById("issueTitle").innerText = issue[0];
          document.getElementById("issueContent").innerText = issue[1];

          const date = new Date(Number(issue[2]) * 1000);
          document.getElementById("issueDate").innerText =
            date.toLocaleDateString() + " " + date.toLocaleTimeString();
        } catch (err) {
          console.error("Error loading issue", err);
        }
      }

      async function loadProposals() {
        const list = document.getElementById("proposalsList");
        list.innerHTML = "Caricamento...";

        try {
          let html = "";
          // Since we don't have a getProposalsLength, we'll try fetching first 10 or until error
          // In a real scenario, we'd add a length getter or event indexing
          let index = 0;
          let fails = 0;

          while (fails < 1 && index < 20) {
            // Safety limit
            try {
              const p = await contract.proposals(index);
              // p structure: [newHeadline, newContent, votesPro, votesContra, endTime, executed, cycle]

              const now = Math.floor(Date.now() / 1000);
              const endTime = Number(p[4]);
              // Use >= to allow execution exactly at expiration
              const isExpired = now >= endTime;

              // Calculate time remaining
              let timeLabel = "";
              // If NOT expired AND NOT executed
              if (!isExpired && !p[5]) {
                const diff = endTime - now;
                const hours = Math.floor(diff / 3600);
                const minutes = Math.floor((diff % 3600) / 60);
                // If less than 1 minute, show seconds or "Adesso"
                if (hours === 0 && minutes === 0) {
                  timeLabel = `<span style="color: var(--primary); font-weight: bold;">Scade: ADESSO</span>`;
                } else {
                  timeLabel = `<span style="color: var(--primary); font-weight: bold;">Scade tra: ${hours}h ${minutes}m</span>`;
                }
              } else {
                timeLabel = `<span style="font-size:0.8rem; color:#888;">Scaduta: ${new Date(
                  endTime * 1000
                ).toLocaleDateString()}</span>`;
              }

              const statusClass = p[5]
                ? "status-ended"
                : isExpired
                ? "status-ended"
                : "status-active";
              const statusText = p[5]
                ? "ESEGUITA"
                : isExpired
                ? "SCADUTA"
                : "ATTIVA";

              html += `
                            <div class="proposal-card">
                                <div style="display:flex; justify-content:space-between; align-items:center;">
                                    <span class="status-badge ${statusClass}">#${index} ${statusText}</span>
                                    ${timeLabel}
                                </div>
                                <h4 style="margin: 0.5rem 0; color: var(--primary);">${
                                  p[0]
                                }</h4>
                                <p style="font-size: 0.9rem; color: #ccc; height: 60px; overflow: hidden; text-overflow: ellipsis;">${p[1].substring(
                                  0,
                                  100
                                )}...</p>
                                
                                <div class="proposal-stats">
                                    <span style="color: #4caf50;">S: ${
                                      p[2]
                                    }</span>
                                    <span style="color: #f44336;">NO: ${
                                      p[3]
                                    }</span>
                                </div>

                                <div class="vote-actions">
                                    ${
                                      !isExpired && !p[5]
                                        ? `
                                        <button onclick="vote(${index}, true)" class="btn btn-small" style="flex:1; border-color:#4caf50; color:#4caf50;">S</button>
                                        <button onclick="vote(${index}, false)" class="btn btn-small" style="flex:1; border-color:#f44336; color:#f44336;">NO</button>
                                    `
                                        : ""
                                    }
                                    ${
                                      isExpired && !p[5]
                                        ? `
                                        <button onclick="execute(${index})" class="btn btn-small" style="width:100%;">ESEGUI</button>
                                    `
                                        : ""
                                    }
                                </div>
                            </div>
                        `;
              index++;
            } catch (e) {
              fails++; // Stop loop if we hit an error (likely out of bounds)
            }
          }

          list.innerHTML = html || "<p>Nessuna proposta trovata.</p>";
        } catch (err) {
          console.error(err);
          list.innerHTML = "Errore caricamento proposte.";
        }
      }

      async function createProposal() {
        const title = document.getElementById("propTitle").value;
        const content = document.getElementById("propContent").value;
        if (!title || !content)
          return showNotification("Compila tutti i campi", "error");

        try {
          // 1. Search for reusable proposal slot
          let reusableId = -1;
          let index = 0;
          let fails = 0;

          showNotification("Cercando slot libero...", "info");

          // Scan first 50 slots to find a reusable one
          while (fails < 1 && index < 50) {
            try {
              const p = await contract.proposals(index);
              // p: [newHeadline, newContent, votesPro, votesContra, endTime, executed, cycle]
              const now = Math.floor(Date.now() / 1000);
              const endTime = Number(p[4]);
              const isExecuted = p[5];

              // Check if reusable: Executed OR Expired
              if (isExecuted || now > endTime) {
                reusableId = index;
                break; // Found one!
              }
              index++;
            } catch (e) {
              fails++; // End of array reached
            }
          }

          let tx;
          if (reusableId !== -1) {
            console.log("Reusing proposal ID:", reusableId);
            tx = await contract.reuseProposal(reusableId, title, content);
            showNotification(`Riciclando slot #${reusableId}...`);
          } else {
            console.log("Creating new proposal");
            tx = await contract.proposeUpdate(title, content);
            showNotification("Creando nuova proposta...");
          }

          await tx.wait();
          showNotification("Proposta creata con successo!");
          loadProposals();

          // Clear inputs
          document.getElementById("propTitle").value = "";
          document.getElementById("propContent").value = "";
        } catch (err) {
          console.error(err);
          showNotification("Errore: " + err.message, "error");
        }
      }

      window.vote = async function (id, support) {
        try {
          const tx = await contract.vote(id, support);
          showNotification("Voto inviato...");
          await tx.wait();
          showNotification("Voto registrato!");
          loadProposals();
        } catch (err) {
          showNotification("Errore Voto: " + err.message, "error");
        }
      };

      window.execute = async function (id) {
        try {
          const tx = await contract.executeProposal(id);
          showNotification("Esecuzione inviata...");
          await tx.wait();
          showNotification("Proposta eseguita!");
          loadDashboardData(); // Refresh issue too
        } catch (err) {
          showNotification("Errore Esecuzione: " + err.message, "error");
        }
      };

      // ==========================================
      // PDF LOGIC
      // ==========================================
      async function generatePDF() {
        let jsPDF;
        try {
          const jspdfLib = await loadJsPDF();
          jsPDF = jspdfLib.jsPDF;
        } catch (e) {
          console.error("Error loading jsPDF", e);
          showNotification("Errore nel caricamento del modulo PDF", "error");
          return;
        }

        const doc = new jsPDF();

        const title = document.getElementById("issueTitle").innerText;
        const content = document.getElementById("issueContent").innerText;
        const date = document.getElementById("issueDate").innerText;
        const pageWidth = doc.internal.pageSize.width;
        const pageHeight = doc.internal.pageSize.height;
        const margin = 20;

        // 1. Background (Paper Texture imitation)
        doc.setFillColor(252, 247, 242); // Warm off-white newsprint color
        doc.rect(0, 0, pageWidth, pageHeight, "F");

        // 2. Border
        doc.setDrawColor(40);
        doc.setLineWidth(0.5);
        doc.rect(10, 10, pageWidth - 20, pageHeight - 20); // Outer
        doc.setLineWidth(0.2);
        doc.rect(12, 12, pageWidth - 24, pageHeight - 24); // Inner

        // 3. Header (Masthead)
        doc.setFont("times", "bold");
        doc.setFontSize(40);
        doc.setTextColor(20, 20, 20); // Almost black
        doc.text("VOX POPULI", pageWidth / 2, 35, { align: "center" });

        // Subtitle / Motto
        doc.setFontSize(10);
        doc.setFont("helvetica", "italic");
        doc.text(
          "notizie incensurabili dagli studenti per gli studenti",
          pageWidth / 2,
          42,
          { align: "center" }
        );

        // 4. Meta Bar (Date, Issue, Owner)
        doc.setFillColor(20, 20, 20);
        doc.rect(margin, 48, pageWidth - margin * 2, 8, "F");

        doc.setTextColor(255, 255, 255);
        doc.setFont("helvetica", "bold");
        doc.setFontSize(9);

        // Left: Date
        doc.text(date.toUpperCase(), margin + 5, 53);

        // Right: Owner (Truncated)
        const ownerText = `HOLDER: ${userAddress}`;
        doc.text(ownerText, pageWidth - margin - 5, 53, { align: "right" });

        // 5. Main Headline
        doc.setTextColor(255, 87, 34); // Brand Orange
        doc.setFont("times", "bold");
        doc.setFontSize(28); // Increased from 24

        // Auto-wrap title
        const splitTitle = doc.splitTextToSize(
          title.toUpperCase(),
          pageWidth - margin * 2
        );
        doc.text(splitTitle, pageWidth / 2, 75, { align: "center" });

        let yOffset = 75 + splitTitle.length * 12; // Increased spacing

        // Separator Line
        doc.setDrawColor(200);
        doc.setLineWidth(0.5);
        doc.line(margin, yOffset, pageWidth - margin, yOffset);

        yOffset += 15; // More breathing room

        // 6. Content (Two Balanced Columns)
        doc.setTextColor(20, 20, 20);
        doc.setFont("times", "normal");
        doc.setFontSize(14); // Increased from 11
        doc.setLineHeightFactor(1.5); // More readable line spacing

        const colWidth = (pageWidth - margin * 2 - 15) / 2; // Slightly more gap between columns
        const splitContent = doc.splitTextToSize(content, colWidth);

        // Balance columns: Split text evenly between the two columns
        // This fills the page width better than filling col 1 then col 2
        const midPoint = Math.ceil(splitContent.length / 2);

        let col1Lines = splitContent.slice(0, midPoint);
        let col2Lines = splitContent.slice(midPoint);

        // Draw Column 1
        doc.text(col1Lines, margin, yOffset, {
          align: "justify",
          maxWidth: colWidth,
        });

        // Draw Column 2
        // We draw it at the same Y offset
        doc.text(col2Lines, margin + colWidth + 15, yOffset, {
          align: "justify",
          maxWidth: colWidth,
        });

        // Vertical Divider (only if there is content in col 2)
        if (col2Lines.length > 0) {
          // Calculate height of the text block to draw the line correctly
          // approx line height for 14pt is ~7mm with 1.5 factor
          const blockHeight = col1Lines.length * 7;
          doc.setDrawColor(220);
          doc.setLineWidth(0.2);
          doc.line(
            pageWidth / 2,
            yOffset,
            pageWidth / 2,
            yOffset + blockHeight
          );
        }

        // 7. Footer Seal
        const footerY = pageHeight - 30;
        doc.setDrawColor(255, 87, 34);
        doc.setLineWidth(2);
        doc.circle(pageWidth - 30, footerY, 12);

        doc.setFontSize(6);
        doc.setTextColor(255, 87, 34);
        doc.text("OFFICIAL", pageWidth - 30, footerY - 2, { align: "center" });
        doc.text("COPY", pageWidth - 30, footerY + 4, { align: "center" });

        // Bottom Text
        doc.setFontSize(8);
        doc.setTextColor(150);
        const currentContractAddr = contract ? contract.target : "N/A";
        doc.text(
          `Smart Contract: ${currentContractAddr}`,
          pageWidth / 2,
          pageHeight - 15,
          { align: "center" }
        );

        doc.save("vox-populi-issue.pdf");
      }

      // ==========================================
      // EVENT LISTENERS
      // ==========================================
      document
        .getElementById("connectBtn")
        .addEventListener("click", connectWallet);
      document.getElementById("mintBtn").addEventListener("click", mint);
      document.getElementById("giftBtn").addEventListener("click", gift);
      document
        .getElementById("downloadPdfBtn")
        .addEventListener("click", generatePDF);
      document
        .getElementById("proposeBtn")
        .addEventListener("click", createProposal);
      document
        .getElementById("refreshProposals")
        .addEventListener("click", loadProposals);

      // Init
      initThree();

      // Listen for account and network changes
      if (window.ethereum) {
        window.ethereum.on("accountsChanged", (accounts) => {
          if (accounts.length === 0) {
            // Disconnected
            userAddress = null;
            window.location.reload();
          } else {
            // Account changed, just re-connect logic without full reload if possible,
            // or reload to be safe. Let's reload to ensure fresh state.
            window.location.reload();
          }
        });

        window.ethereum.on("chainChanged", (chainId) => {
          // Sync selector with external change
          if (networkSelect.value !== chainId) {
            networkSelect.value = chainId;
          }
          // Do NOT reload here if we are handling it in the switch logic
          // But MetaMask recommends reloading on chainChanged.
          // We will reload ONLY if we didn't initiate the switch manually via UI (hard to track)
          // or just reload to be safe.
          window.location.reload();
        });
      }
    </script>
  </body>
</html>
