{"language":"Solidity","settings":{"viaIR":true,"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"":["ast"],"*":["abi","metadata","devdoc","userdoc","storageLayout","evm.legacyAssembly","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","evm.gasEstimates","evm.assembly"]}},"remappings":[]},"sources":{"contracts/journalnft.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// =============================================================\n//                      LIBRARIES & UTILS\n// =============================================================\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor(address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    function toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n\n/**\n * @dev Base64 encoding/decoding.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes32 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return \"\";\n        string memory table = _TABLE;\n        string memory result = new string(4 * ((data.length + 2) / 3));\n        \n        bytes memory tableBytes = bytes(table);\n        bytes memory resultBytes = bytes(result);\n        \n        uint256 j = 0;\n        for (uint256 i = 0; i < data.length; i += 3) {\n            uint256 len = data.length - i;\n            uint8 b0 = uint8(data[i]);\n            uint8 b1 = len > 1 ? uint8(data[i + 1]) : 0;\n            uint8 b2 = len > 2 ? uint8(data[i + 2]) : 0;\n            \n            resultBytes[j++] = tableBytes[(b0 >> 2) & 0x3F];\n            resultBytes[j++] = tableBytes[((b0 & 0x3) << 4) | ((b1 >> 4) & 0xF)];\n            resultBytes[j++] = len > 1 ? tableBytes[((b1 & 0xF) << 2) | ((b2 >> 6) & 0x3)] : bytes1('=');\n            resultBytes[j++] = len > 2 ? tableBytes[b2 & 0x3F] : bytes1('=');\n        }\n        return string(resultBytes);\n    }\n}\n\n// =============================================================\n//                      ERC721 IMPLEMENTATION\n// =============================================================\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\nabstract contract ERC165 is IERC165 {\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n        return \"\";\n    }\n\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        _owners[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    // Hook che useremo per il Soulbound\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {}\n}\n\n// =============================================================\n//                      JOURNAL DAO\n// =============================================================\n\n/**\n * @title VoxPopuliVoxDei\n * @dev NFT Soulbound che rappresenta un giornale con notizie aggiornabili tramite voto.\n */\ncontract VoxPopuliVoxDei is ERC721, Ownable {\n    using Strings for uint256;\n\n    // Struttura per una notizia/articolo\n    struct NewsItem {\n        string headline;\n        string content;\n        uint256 timestamp;\n    }\n\n    // Struttura per una proposta di aggiornamento\n    struct Proposal {\n        string newHeadline;\n        string newContent;\n        uint256 votesPro;     // Sostituisce voteCount\n        uint256 votesContra;  // Nuovo contatore\n        uint256 endTime;\n        bool executed;\n        uint256 cycle;\n    }\n\n    // Stato del Giornale\n    NewsItem public currentIssue;\n    \n    // Gestione Proposte\n    Proposal[] public proposals;\n    mapping(uint256 => mapping(address => uint256)) public hasVoted;\n    uint256 public constant VOTING_DURATION = 1 days; // Mainnet: 1 giorno\n\n    // Gestione Proposte Attive (Logica StudentCommittee)\n    uint256[] private activeProposalIds;\n    mapping(uint256 => uint256) private activeProposalIndex;\n\n    // Counter per i Token ID (rappresenta anche la Total Supply dato che non c'è burn)\n    uint256 private _nextTokenId;\n\n    constructor() ERC721(\"Vox Populi\", \"VOX\") Ownable(msg.sender) {\n        // Imposta la prima notizia di default\n        currentIssue = NewsItem({\n            headline: unicode\"Il comitato studentesco rinasca dalle sue ceneri\",\n            content: unicode\"sin dalla sua fondazione, il comitato studentesco, il più importante organo di espressione della volontà studentesca è stato ILLEGALMENTE privato della sua autorità e della sua autonomia, il tutto all'oscuro degli studenti. le leggi violate dalla scuola sono molte, per menzionarle alcune: 1. comma 5 art 4 DPR 10-10-1996 n. 567 che impone al comitato di avere un regolamento per le essemblee e permette di averne uno interno che regoli la sua organizzazione. 2. l'art 4 DPR 10-10-1996 stabilisce che possano essere fondate asscociazioni studentesche extrascolastiche che possono svolgere una serie di attività e questo non è mai stato concesso, 3. gestione economica il comitato può finanziare attività coerenti allo studio con fondi scolastici allocati dal consiglio di istituto o tramite autofinanziamento ma il consiglio di istituto continua a negarci i nostri diritti.\",\n            timestamp: block.timestamp\n        });\n    }\n\n    // =============================================================\n    //                      MINTING (SOULBOUND)\n    // =============================================================\n\n    function subscribe() public {\n        require(balanceOf(msg.sender) == 0, \"Gia abbonato\");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(msg.sender, tokenId);\n    }\n\n    function airdrop(address to) public onlyOwner {\n        require(balanceOf(to) == 0, \"Gia abbonato\");\n        uint256 tokenId = _nextTokenId++;\n        _safeMint(to, tokenId);\n    }\n\n    /**\n     * @dev Blocca i trasferimenti per rendere il token Soulbound (SBT).\n     * Usa il hook _beforeTokenTransfer (compatibile con implementazione stile v4 sopra).\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 /*tokenId*/) internal virtual override {\n        // Se 'from' non è zero (non è un mint) e 'to' non è zero (non è un burn), allora è un trasferimento.\n        // Lo blocchiamo.\n        if (from != address(0) && to != address(0)) {\n            revert(\"VoxPopuliVoxDei: Questo NFT e' Soulbound e non puo' essere trasferito\");\n        }\n    }\n\n    // =============================================================\n    //                      GOVERNANCE (VOTO)\n    // =============================================================\n\n    /**\n     * @dev Crea una proposta per aggiornare la notizia del giorno.\n     */\n    /**\n     * @dev Crea una NUOVA proposta (append in coda).\n     */\n    function proposeUpdate(string memory _headline, string memory _content) public {\n        require(balanceOf(msg.sender) > 0, \"Devi essere un abbonato per proporre\");\n\n        uint256 proposalId = proposals.length;\n        proposals.push(Proposal({\n            newHeadline: _headline,\n            newContent: _content,\n            votesPro: 0,\n            votesContra: 0,\n            endTime: block.timestamp + VOTING_DURATION,\n            executed: false,\n            cycle: 1\n        }));\n\n        _addToActiveProposals(proposalId);\n    }\n\n    /**\n     * @dev Ricicla una vecchia proposta (Logica StudentCommittee).\n     * Risparmia gas evitando di espandere l'array.\n     */\n    function reuseProposal(uint256 proposalId, string memory _headline, string memory _content) public {\n        require(balanceOf(msg.sender) > 0, \"Devi essere un abbonato per proporre\");\n        require(proposalId < proposals.length, \"Proposta inesistente\");\n        \n        Proposal storage p = proposals[proposalId];\n        // Possiamo riciclare se eseguita O se scaduta\n        require(p.executed || block.timestamp > p.endTime, \"Proposta ancora attiva!\");\n\n        p.newHeadline = _headline;\n        p.newContent = _content;\n        p.votesPro = 0;\n        p.votesContra = 0;\n        p.endTime = block.timestamp + VOTING_DURATION;\n        p.executed = false;\n        p.cycle++; // Incrementa ciclo\n\n        _addToActiveProposals(proposalId);\n    }\n\n    function _addToActiveProposals(uint256 proposalId) internal {\n        activeProposalIndex[proposalId] = activeProposalIds.length;\n        activeProposalIds.push(proposalId);\n    }\n\n    function _removeFromActiveProposals(uint256 proposalId) internal {\n        uint256 index = activeProposalIndex[proposalId];\n        uint256 lastIndex = activeProposalIds.length - 1;\n\n        if (index != lastIndex) {\n            uint256 lastProposalId = activeProposalIds[lastIndex];\n            activeProposalIds[index] = lastProposalId;\n            activeProposalIndex[lastProposalId] = index;\n        }\n\n        activeProposalIds.pop();\n        delete activeProposalIndex[proposalId];\n    }\n\n    /**\n     * @dev Vota per una proposta attiva (Sì o No).\n     * @param support true per SÌ, false per NO.\n     */\n    function vote(uint256 proposalId, bool support) public {\n        require(balanceOf(msg.sender) > 0, \"Devi essere un abbonato per votare\");\n        require(proposalId < proposals.length, \"Proposta inesistente\");\n        Proposal storage p = proposals[proposalId];\n        \n        require(block.timestamp < p.endTime, \"Votazione conclusa\");\n        require(!p.executed, \"Gia eseguita\");\n        require(hasVoted[proposalId][msg.sender] != p.cycle, \"Hai gia votato\");\n\n        if (support) {\n            p.votesPro++;\n        } else {\n            p.votesContra++;\n        }\n        \n        hasVoted[proposalId][msg.sender] = p.cycle;\n    }\n\n    /**\n     * @dev Esegue la proposta se il tempo è scaduto e i SÌ vincono.\n     * Può essere chiamata da chiunque (public).\n     */\n    function executeProposal(uint256 proposalId) public {\n        require(proposalId < proposals.length, \"Proposta inesistente\");\n        Proposal storage p = proposals[proposalId];\n\n        require(!p.executed, \"Gia eseguita\");\n        require(block.timestamp >= p.endTime, \"Votazione ancora in corso\");\n        \n        // Verifica esito: Sì > No\n        if (p.votesPro > p.votesContra) {\n            _executeProposalLogic(proposalId);\n        } else {\n            // Se vince il NO o pareggio, la proposta viene marcata come \"eseguita\" (chiusa) ma senza effetti.\n            // Questo libera lo slot per il riciclo.\n            p.executed = true;\n            _removeFromActiveProposals(proposalId);\n        }\n    }\n\n    function _executeProposalLogic(uint256 proposalId) internal {\n        Proposal storage p = proposals[proposalId];\n        p.executed = true;\n\n        currentIssue = NewsItem({\n            headline: p.newHeadline,\n            content: p.newContent,\n            timestamp: block.timestamp\n        });\n\n        _removeFromActiveProposals(proposalId);\n    }\n\n    // =============================================================\n    //                      RENDER SVG (ON-CHAIN)\n    // =============================================================\n\n    /**\n     * @dev Converte un timestamp in una data leggibile \"YYYY-MM-DD\".\n     * Usiamo un algoritmo semplificato per risparmiare gas.\n     */\n    function _timestampToString(uint256 timestamp) internal pure returns (string memory) {\n        // Algoritmo di conversione (semplificato)\n        // Basato su: http://howardhinnant.github.io/date_algorithms.html\n        uint256 z = timestamp / 86400 + 719468;\n        uint256 era = (z >= 0 ? z : z - 146096) / 146097;\n        uint256 doe = z - era * 146097;\n        uint256 yoe = (doe - doe/1460 + doe/36524 - doe/146096) / 365;\n        uint256 y = yoe + era * 400;\n        uint256 doy = doe - (365*yoe + yoe/4 - yoe/100);\n        uint256 mp = (5*doy + 2)/153;\n        uint256 d = doy - (153*mp+2)/5 + 1;\n        uint256 m = mp < 10 ? mp + 3 : mp - 9;\n        uint256 year = y + (m <= 2 ? 1 : 0);\n\n        return string(abi.encodePacked(\n            Strings.toString(year), \"-\", \n            (m < 10 ? \"0\" : \"\"), Strings.toString(m), \"-\", \n            (d < 10 ? \"0\" : \"\"), Strings.toString(d)\n        ));\n    }\n\n    /**\n     * @dev Genera l'SVG raw in base allo stato attuale di 'currentIssue'.\n     */\n    function generateSVG() internal view returns (string memory) {\n        string memory dateStr = _timestampToString(currentIssue.timestamp);\n\n        return string(abi.encodePacked(\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"xMinYMin meet\" viewBox=\"0 0 350 650\">',\n            '<style>.base { fill: black; font-family: serif; font-size: 14px; } .head { fill: black; font-weight: bold; font-size: 24px; }</style>',\n            '<rect width=\"100%\" height=\"100%\" fill=\"#f0e6d2\" />', // Sfondo color carta\n            '<text x=\"50%\" y=\"40\" class=\"head\" dominant-baseline=\"middle\" text-anchor=\"middle\">Vox Populi</text>',\n            '<line x1=\"20\" y1=\"60\" x2=\"330\" y2=\"60\" stroke=\"black\" stroke-width=\"2\"/>',\n            \n            // Data dinamica\n            '<text x=\"50%\" y=\"80\" class=\"base\" text-anchor=\"middle\" font-style=\"italic\">', dateStr, '</text>',\n            \n            // Headline dinamica (multi-line, max 60 chars split in 2 lines of 30)\n            '<text x=\"50%\" y=\"130\" class=\"head\" text-anchor=\"middle\" font-size=\"20\">', \n            '<tspan x=\"50%\" dy=\"0\">', _substringSafe(currentIssue.headline, 0, 30), '</tspan>',\n            '<tspan x=\"50%\" dy=\"25\">', _substringSafe(currentIssue.headline, 30, 60), '</tspan>',\n            '</text>',\n            \n            // Content snippet (Multi-line centered)\n            '<text x=\"50%\" y=\"200\" class=\"base\" text-anchor=\"middle\">', \n            '<tspan x=\"50%\" dy=\"0\">', _substringSafe(currentIssue.content, 0, 50), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 50, 100), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 100, 150), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 150, 200), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 200, 250), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 250, 300), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 300, 350), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 350, 400), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 400, 450), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 450, 500), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 500, 550), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 550, 600), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 600, 650), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 650, 700), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 700, 750), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 750, 800), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 800, 850), '</tspan>',\n            '<tspan x=\"50%\" dy=\"20\">', _substringSafe(currentIssue.content, 850, 900), '</tspan>',\n            '</text>',\n            '<text x=\"50%\" y=\"630\" class=\"base\" font-size=\"10\" text-anchor=\"middle\">Verified by Ethereum</text>',\n            '</svg>'\n        ));\n    }\n\n    /**\n     * @dev Helper sicuro per estrarre sottostringhe senza errori out-of-bounds.\n     * Restituisce stringa vuota se startIndex è fuori range.\n     * Taglia a endIndex o fine stringa.\n     */\n    function _substringSafe(string memory str, uint256 startIndex, uint256 endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        if (startIndex >= strBytes.length) return \"\";\n        if (endIndex > strBytes.length) endIndex = strBytes.length;\n        return substring(str, startIndex, endIndex);\n    }\n\n    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n        bytes memory strBytes = bytes(str);\n        bytes memory result = new bytes(endIndex - startIndex);\n        for(uint i = startIndex; i < endIndex; i++) {\n            result[i - startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n\n    /**\n     * @dev Override di tokenURI per restituire il JSON Base64 con l'SVG aggiornato.\n     */\n    function tokenURI(uint256 /*tokenId*/) public view override returns (string memory) {\n        string memory svg = generateSVG();\n        string memory dateStr = _timestampToString(currentIssue.timestamp);\n        \n        string memory json = Base64.encode(bytes(string(abi.encodePacked(\n            '{\"name\": \"Journal #', dateStr, '\",',\n            '\"description\": \"Un giornale on-chain aggiornato dalla community.\",',\n            '\"attributes\": [',\n                '{\"trait_type\": \"Headline\", \"value\": \"', currentIssue.headline, '\"},',\n                '{\"trait_type\": \"Date\", \"value\": \"', dateStr, '\"}',\n            '],',\n            '\"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(svg)), '\"}'\n        ))));\n\n        return string(abi.encodePacked(\"data:application/json;base64,\", json));\n    }\n}\n"}}}